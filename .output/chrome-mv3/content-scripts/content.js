var content = (function() {
  "use strict";var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  function _mergeNamespaces(n, m) {
    for (var i = 0; i < m.length; i++) {
      const e = m[i];
      if (typeof e !== "string" && !Array.isArray(e)) {
        for (const k in e) {
          if (k !== "default" && !(k in n)) {
            const d = Object.getOwnPropertyDescriptor(e, k);
            if (d) {
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: () => e[k]
              });
            }
          }
        }
      }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
  }
  function defineContentScript(definition2) {
    return definition2;
  }
  var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
    LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
    LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
    LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
    LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
    return LogLevel2;
  })(LogLevel || {});
  var LogCategory = /* @__PURE__ */ ((LogCategory2) => {
    LogCategory2["STORAGE"] = "STORAGE";
    LogCategory2["SERVICE"] = "SERVICE";
    LogCategory2["UI"] = "UI";
    LogCategory2["NETWORK"] = "NETWORK";
    LogCategory2["BACKGROUND"] = "BACKGROUND";
    LogCategory2["CONTENT_SCRIPT"] = "CONTENT_SCRIPT";
    LogCategory2["PERFORMANCE"] = "PERFORMANCE";
    LogCategory2["ANALYTICS"] = "ANALYTICS";
    LogCategory2["MONITORING"] = "MONITORING";
    return LogCategory2;
  })(LogCategory || {});
  const _Logger = class _Logger {
    constructor() {
      __publicField(this, "minLevel", 0);
      __publicField(this, "enabledCategories", new Set(Object.values(LogCategory)));
      __publicField(this, "logHistory", []);
      __publicField(this, "maxHistorySize", 1e3);
    }
    static getInstance() {
      if (!_Logger.instance) {
        _Logger.instance = new _Logger();
      }
      return _Logger.instance;
    }
    /**
     * Set minimum log level (only logs at or above this level will be shown)
     */
    setMinLevel(level) {
      this.minLevel = level;
      this.info("ANALYTICS", "Log level changed", { newLevel: LogLevel[level] });
    }
    /**
     * Enable/disable specific log categories
     */
    setCategories(categories) {
      this.enabledCategories = new Set(categories);
      this.info("ANALYTICS", "Log categories updated", { categories: categories.map((c) => LogCategory[c]) });
    }
    /**
     * Get log history (useful for debugging)
     */
    getHistory(limit) {
      return limit ? this.logHistory.slice(-limit) : this.logHistory;
    }
    /**
     * Clear log history
     */
    clearHistory() {
      this.logHistory = [];
      console.log("[Uproot] Log history cleared");
    }
    /**
     * Main logging method
     */
    log(level, category, message, options = {}) {
      if (level < this.minLevel || !this.enabledCategories.has(category)) {
        return;
      }
      const levelName = LogLevel[level];
      const categoryName = LogCategory[category];
      const logEntry = {
        timestamp: Date.now(),
        level,
        category,
        message,
        data: options.data
      };
      this.logHistory.push(logEntry);
      if (this.logHistory.length > this.maxHistorySize) {
        this.logHistory.shift();
      }
      const prefix = `[Uproot][${levelName}][${categoryName}]`;
      const fullMessage = `${prefix} ${message}`;
      switch (level) {
        case 0:
          if (options.data) {
            console.debug(fullMessage, options.data);
          } else {
            console.debug(fullMessage);
          }
          break;
        case 1:
          if (options.data) {
            console.log(fullMessage, options.data);
          } else {
            console.log(fullMessage);
          }
          break;
        case 2:
          if (options.data) {
            console.warn(fullMessage, options.data);
          } else {
            console.warn(fullMessage);
          }
          break;
        case 3:
          if (options.data && options.error) {
            console.error(fullMessage, options.data, options.error);
          } else if (options.data) {
            console.error(fullMessage, options.data);
          } else if (options.error) {
            console.error(fullMessage, options.error);
          } else {
            console.error(fullMessage);
          }
          if (options.error) {
            console.error("Stack trace:", options.error.stack);
          }
          break;
      }
      if (options.duration !== void 0) {
        console.log(`${prefix} â±ï¸ Duration: ${options.duration.toFixed(2)}ms`);
      }
    }
    // Convenience methods
    debug(category, message, data) {
      this.log(0, category, message, { data });
    }
    info(category, message, data) {
      this.log(1, category, message, { data });
    }
    warn(category, message, data) {
      this.log(2, category, message, { data });
    }
    error(category, message, errorOrData, data) {
      const isErrorObject = errorOrData instanceof Error;
      const error = isErrorObject ? errorOrData : errorOrData?.error;
      const mergedData = isErrorObject ? data : { ...errorOrData, ...data };
      this.log(3, category, message, { error, data: mergedData });
    }
    /**
     * Performance tracking helper
     */
    startTimer(category, operation) {
      const startTime = performance.now();
      this.debug("PERFORMANCE", `â–¶ï¸ Started: ${operation}`, { category: LogCategory[category] });
      return () => {
        const duration = performance.now() - startTime;
        this.info("PERFORMANCE", `âœ… Completed: ${operation}`, { category: LogCategory[category], duration: `${duration.toFixed(2)}ms` });
      };
    }
    /**
     * Async operation wrapper with automatic logging
     */
    async trackAsync(category, operation, fn) {
      const startTime = performance.now();
      this.debug(category, `â–¶ï¸ Started: ${operation}`);
      try {
        const result2 = await fn();
        const duration = performance.now() - startTime;
        this.info(category, `âœ… Completed: ${operation}`, { duration: `${duration.toFixed(2)}ms` });
        return result2;
      } catch (error) {
        const duration = performance.now() - startTime;
        this.error(category, `âŒ Failed: ${operation}`, error, { duration: `${duration.toFixed(2)}ms` });
        throw error;
      }
    }
    /**
     * Log function entry/exit (for detailed tracing)
     */
    trace(category, functionName, args) {
      this.debug(category, `â†’ Entering: ${functionName}`, { args });
      return (returnValue) => {
        this.debug(category, `â† Exiting: ${functionName}`, { returnValue });
      };
    }
    /**
     * Log data changes (useful for state management)
     */
    logChange(category, entity, action, data) {
      const emojiMap = {
        create: "âž•",
        update: "âœï¸",
        delete: "ðŸ—‘ï¸",
        markAllRead: "âœ…",
        clear: "ðŸ§¹"
      };
      const emoji = emojiMap[action] || "ðŸ“";
      this.info(category, `${emoji} ${action.toUpperCase()}: ${entity}`, data);
    }
    /**
     * Log analytics events
     */
    logEvent(eventName, properties) {
      this.info("ANALYTICS", `ðŸ“Š Event: ${eventName}`, properties);
    }
    /**
     * Log user actions
     */
    logAction(action, details) {
      this.info("UI", `ðŸ‘† User Action: ${action}`, details);
    }
    /**
     * Log API calls
     */
    logApiCall(method, endpoint, status, duration) {
      const statusEmoji = status && status >= 200 && status < 300 ? "âœ…" : "âŒ";
      this.info("NETWORK", `${statusEmoji} ${method} ${endpoint}`, { status, duration: duration ? `${duration}ms` : void 0 });
    }
    /**
     * Export logs for debugging
     */
    exportLogs() {
      return JSON.stringify(this.logHistory, null, 2);
    }
    /**
     * Download logs as file (only works in DOM context, not in service worker)
     */
    downloadLogs() {
      if (typeof document === "undefined") {
        console.warn("[Uproot] downloadLogs() cannot be called in service worker context");
        return;
      }
      const logs = this.exportLogs();
      const blob = new Blob([logs], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `uproot-logs-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      this.info("ANALYTICS", "Logs downloaded");
    }
  };
  __publicField(_Logger, "instance");
  let Logger = _Logger;
  const logger$2 = Logger.getInstance();
  const log$1 = {
    debug: (category, message, data) => logger$2.debug(category, message, data),
    info: (category, message, data) => logger$2.info(category, message, data),
    warn: (category, message, data) => logger$2.warn(category, message, data),
    error: (category, message, errorOrData, data) => logger$2.error(category, message, errorOrData, data),
    // Specialized logging
    startTimer: (category, operation) => logger$2.startTimer(category, operation),
    trackAsync: (category, operation, fn) => logger$2.trackAsync(category, operation, fn),
    trace: (category, functionName, args) => logger$2.trace(category, functionName, args),
    change: (category, entity, action, data) => logger$2.logChange(category, entity, action, data),
    event: (eventName, properties) => logger$2.logEvent(eventName, properties),
    action: (action, details) => logger$2.logAction(action, details),
    apiCall: (method, endpoint, status, duration) => logger$2.logApiCall(method, endpoint, status, duration),
    // Utility
    setMinLevel: (level) => logger$2.setMinLevel(level),
    setCategories: (categories) => logger$2.setCategories(categories),
    getHistory: (limit) => logger$2.getHistory(limit),
    clearHistory: () => logger$2.clearHistory(),
    exportLogs: () => logger$2.exportLogs(),
    downloadLogs: () => logger$2.downloadLogs()
  };
  logger$2.info("ANALYTICS", "ðŸš€ Uproot LinkedIn Extension - Logging initialized", {
    version: "1.0.0",
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  });
  content;
  const DEFAULT_AUTOFILL_PROFILE = {
    firstName: "",
    lastName: "",
    fullName: "",
    email: "",
    phone: "",
    location: "",
    skills: [],
    createdAt: Date.now(),
    updatedAt: Date.now(),
    version: 1
  };
  const DEFAULT_QUESTION_BANK = {
    questions: []
  };
  const AUTOFILL_PROFILE_KEY = "uproot_autofill_profile";
  const QUESTION_BANK_KEY = "uproot_question_bank";
  content;
  const PROFESSIONAL_PROFILE_KEY = "uproot_professional_profile";
  const JOB_DESCRIPTIONS_KEY = "uproot_job_descriptions";
  const GENERATED_RESUMES_KEY = "uproot_generated_resumes";
  content;
  async function getProfessionalProfile() {
    return log$1.trackAsync(LogCategory.STORAGE, "getProfessionalProfile", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Fetching professional profile from storage");
        const result2 = await chrome.storage.local.get(PROFESSIONAL_PROFILE_KEY);
        const profile = result2[PROFESSIONAL_PROFILE_KEY];
        if (!profile) {
          log$1.info(LogCategory.STORAGE, "No profile found, returning empty profile structure");
          return {
            personalInfo: {
              fullName: "",
              email: ""
            },
            jobs: [],
            internships: [],
            volunteerWork: [],
            technicalSkills: [],
            softSkills: [],
            tools: [],
            certifications: [],
            languages: [],
            education: [],
            projects: [],
            publications: [],
            achievements: [],
            awards: [],
            createdAt: Date.now(),
            updatedAt: Date.now(),
            version: 1
          };
        }
        log$1.info(LogCategory.STORAGE, "Professional profile retrieved", {
          fullName: profile.personalInfo.fullName,
          jobsCount: profile.jobs.length,
          educationCount: profile.education.length
        });
        console.log("[Uproot] Retrieved professional profile");
        return profile;
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Error getting professional profile", { error });
        console.error("[Uproot] Error getting professional profile:", error);
        throw error;
      }
    });
  }
  async function saveProfessionalProfile(profile) {
    return log$1.trackAsync(LogCategory.STORAGE, "saveProfessionalProfile", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Saving professional profile", {
          fullName: profile.personalInfo.fullName,
          jobsCount: profile.jobs.length,
          educationCount: profile.education.length
        });
        const updatedProfile = {
          ...profile,
          updatedAt: Date.now()
        };
        await chrome.storage.local.set({ [PROFESSIONAL_PROFILE_KEY]: updatedProfile });
        log$1.change(LogCategory.STORAGE, "professionalProfile", "update", {
          fullName: profile.personalInfo.fullName,
          jobsCount: profile.jobs.length
        });
        console.log("[Uproot] Professional profile saved");
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Error saving professional profile", { error });
        console.error("[Uproot] Error saving professional profile:", error);
        throw error;
      }
    });
  }
  async function getProfileStats() {
    const profile = await getProfessionalProfile();
    let totalMonths = 0;
    profile.jobs.forEach((job) => {
      const startDate = new Date(job.startDate);
      const endDate = job.endDate ? new Date(job.endDate) : /* @__PURE__ */ new Date();
      const months = (endDate.getFullYear() - startDate.getFullYear()) * 12 + (endDate.getMonth() - startDate.getMonth());
      totalMonths += months;
    });
    const yearsOfExperience = Math.floor(totalMonths / 12);
    let completeness = 0;
    if (profile.personalInfo.fullName) completeness += 10;
    if (profile.personalInfo.email) completeness += 10;
    if (profile.personalInfo.professionalSummary) completeness += 10;
    if (profile.jobs.length > 0) completeness += 20;
    if (profile.technicalSkills.length > 0) completeness += 15;
    if (profile.education.length > 0) completeness += 15;
    if (profile.projects.length > 0) completeness += 10;
    if (profile.certifications.length > 0) completeness += 10;
    return {
      totalJobs: profile.jobs.length,
      totalInternships: profile.internships.length,
      totalVolunteerWork: profile.volunteerWork.length,
      totalProjects: profile.projects.length,
      totalSkills: profile.technicalSkills.length + profile.softSkills.length,
      totalCertifications: profile.certifications.length,
      yearsOfExperience,
      profileCompleteness: Math.min(100, completeness)
    };
  }
  content;
  function isContextInvalidatedError(error) {
    if (!error) return false;
    if (error.message) {
      const message = error.message.toLowerCase();
      if (message.includes("extension context invalidated") || message.includes("access to storage is not allowed") || message.includes("storage is not available") || message.includes("context invalidated")) {
        return true;
      }
    }
    const errorStr = String(error).toLowerCase();
    return errorStr.includes("extension context invalidated") || errorStr.includes("access to storage is not allowed") || errorStr.includes("storage is not available") || errorStr.includes("context invalidated");
  }
  content;
  async function getAutofillProfile() {
    return log$1.trackAsync(LogCategory.STORAGE, "getAutofillProfile", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Fetching autofill profile from storage");
        const result2 = await chrome.storage.local.get(AUTOFILL_PROFILE_KEY);
        const profile = result2[AUTOFILL_PROFILE_KEY] || DEFAULT_AUTOFILL_PROFILE;
        log$1.info(LogCategory.STORAGE, "Autofill profile retrieved", {
          hasData: !!profile.email,
          skillsCount: profile.skills?.length || 0
        });
        return profile;
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return DEFAULT_AUTOFILL_PROFILE;
        }
        log$1.error(LogCategory.STORAGE, "Error getting autofill profile", error);
        console.error("[Uproot] Error getting autofill profile:", error instanceof Error ? error.message : String(error), error);
        return DEFAULT_AUTOFILL_PROFILE;
      }
    });
  }
  async function getQuestionBank() {
    return log$1.trackAsync(LogCategory.STORAGE, "getQuestionBank", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Fetching question bank from storage");
        const result2 = await chrome.storage.local.get(QUESTION_BANK_KEY);
        const bank = result2[QUESTION_BANK_KEY] || DEFAULT_QUESTION_BANK;
        log$1.info(LogCategory.STORAGE, "Question bank retrieved", {
          questionCount: bank.questions?.length || 0
        });
        return bank;
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return DEFAULT_QUESTION_BANK;
        }
        log$1.error(LogCategory.STORAGE, "Error getting question bank", error);
        console.error("[Uproot] Error getting question bank:", error instanceof Error ? error.message : String(error), error);
        return DEFAULT_QUESTION_BANK;
      }
    });
  }
  async function saveQuestion(question, answer = "", jobId, keywords = []) {
    return log$1.trackAsync(LogCategory.STORAGE, "saveQuestion", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Saving question to bank", {
          questionLength: question.length,
          hasAnswer: !!answer,
          hasJobId: !!jobId
        });
        const bank = await getQuestionBank();
        const newQuestion = {
          id: `question-${Date.now()}`,
          question,
          answer,
          jobId,
          keywords,
          savedAt: Date.now(),
          updatedAt: Date.now(),
          usageCount: 0,
          wasEdited: false
        };
        bank.questions.unshift(newQuestion);
        await chrome.storage.local.set({ [QUESTION_BANK_KEY]: bank });
        log$1.change(LogCategory.STORAGE, "questionBank", "create", {
          id: newQuestion.id,
          questionPreview: question.substring(0, 50)
        });
        console.log("[Uproot] Question saved:", question.substring(0, 50) + "...");
        return newQuestion;
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          throw error;
        }
        log$1.error(LogCategory.STORAGE, "Error saving question", error);
        console.error("[Uproot] Error saving question:", error instanceof Error ? error.message : String(error), error);
        throw error;
      }
    });
  }
  content;
  const autofillStorage = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    getAutofillProfile,
    getQuestionBank,
    saveQuestion
  }, Symbol.toStringTag, { value: "Module" }));
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n) {
    if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  var react = { exports: {} };
  var react_production_min = {};
  /**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReact_production_min;
  function requireReact_production_min() {
    if (hasRequiredReact_production_min) return react_production_min;
    hasRequiredReact_production_min = 1;
    var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r2 = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
    function A(a) {
      if (null === a || "object" !== typeof a) return null;
      a = z && a[z] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C = Object.assign, D = {};
    function E(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
      if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E.prototype;
    function G(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    var H = G.prototype = new F();
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = true;
    var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
    function M(a, b, e) {
      var d, c = {}, k = null, h = null;
      if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (1 === g) c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
        c.children = f;
      }
      if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
      return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
    }
    function N(a, b) {
      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l;
    }
    function escape(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P = /\/+/g;
    function Q(a, b) {
      return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
    }
    function R(a, b, e, d, c) {
      var k = typeof a;
      if ("undefined" === k || "boolean" === k) a = null;
      var h = false;
      if (null === a) h = true;
      else switch (k) {
        case "string":
        case "number":
          h = true;
          break;
        case "object":
          switch (a.$$typeof) {
            case l:
            case n:
              h = true;
          }
      }
      if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
        return a2;
      })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
      h = 0;
      d = "" === d ? "." : d + ":";
      if (I(a)) for (var g = 0; g < a.length; g++) {
        k = a[g];
        var f = d + Q(k, g);
        h += R(k, b, e, f, c);
      }
      else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
      else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    function S(a, b, e) {
      if (null == a) return a;
      var d = [], c = 0;
      R(a, d, "", "", function(a2) {
        return b.call(e, a2, c++);
      });
      return d;
    }
    function T(a) {
      if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(b2) {
          if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
        }, function(b2) {
          if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
        });
        -1 === a._status && (a._status = 0, a._result = b);
      }
      if (1 === a._status) return a._result.default;
      throw a._result;
    }
    var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
    function X2() {
      throw Error("act(...) is not supported in production builds of React.");
    }
    react_production_min.Children = { map: S, forEach: function(a, b, e) {
      S(a, function() {
        b.apply(this, arguments);
      }, e);
    }, count: function(a) {
      var b = 0;
      S(a, function() {
        b++;
      });
      return b;
    }, toArray: function(a) {
      return S(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    react_production_min.Component = E;
    react_production_min.Fragment = p;
    react_production_min.Profiler = r2;
    react_production_min.PureComponent = G;
    react_production_min.StrictMode = q;
    react_production_min.Suspense = w;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    react_production_min.act = X2;
    react_production_min.cloneElement = function(a, b, e) {
      if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
      if (null != b) {
        void 0 !== b.ref && (k = b.ref, h = K.current);
        void 0 !== b.key && (c = "" + b.key);
        if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
        for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (1 === f) d.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
        d.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
    };
    react_production_min.createContext = function(a) {
      a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t, _context: a };
      return a.Consumer = a;
    };
    react_production_min.createElement = M;
    react_production_min.createFactory = function(a) {
      var b = M.bind(null, a);
      b.type = a;
      return b;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    react_production_min.isValidElement = O;
    react_production_min.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    react_production_min.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
    };
    react_production_min.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    react_production_min.unstable_act = X2;
    react_production_min.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    react_production_min.useContext = function(a) {
      return U.current.useContext(a);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    react_production_min.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    react_production_min.useId = function() {
      return U.current.useId();
    };
    react_production_min.useImperativeHandle = function(a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    react_production_min.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    react_production_min.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    react_production_min.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    react_production_min.useReducer = function(a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    react_production_min.useRef = function(a) {
      return U.current.useRef(a);
    };
    react_production_min.useState = function(a) {
      return U.current.useState(a);
    };
    react_production_min.useSyncExternalStore = function(a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    react_production_min.useTransition = function() {
      return U.current.useTransition();
    };
    react_production_min.version = "18.3.1";
    return react_production_min;
  }
  var hasRequiredReact;
  function requireReact() {
    if (hasRequiredReact) return react.exports;
    hasRequiredReact = 1;
    {
      react.exports = requireReact_production_min();
    }
    return react.exports;
  }
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactJsxRuntime_production_min;
  function requireReactJsxRuntime_production_min() {
    if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
    hasRequiredReactJsxRuntime_production_min = 1;
    var f = requireReact(), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
    function q(c, a, g) {
      var b, d = {}, e = null, h = null;
      void 0 !== g && (e = "" + g);
      void 0 !== a.key && (e = "" + a.key);
      void 0 !== a.ref && (h = a.ref);
      for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
      if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
      return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
    }
    reactJsxRuntime_production_min.Fragment = l;
    reactJsxRuntime_production_min.jsx = q;
    reactJsxRuntime_production_min.jsxs = q;
    return reactJsxRuntime_production_min;
  }
  var hasRequiredJsxRuntime;
  function requireJsxRuntime() {
    if (hasRequiredJsxRuntime) return jsxRuntime.exports;
    hasRequiredJsxRuntime = 1;
    {
      jsxRuntime.exports = requireReactJsxRuntime_production_min();
    }
    return jsxRuntime.exports;
  }
  var jsxRuntimeExports = requireJsxRuntime();
  var reactExports = requireReact();
  const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
  var client = {};
  var reactDom = { exports: {} };
  var reactDom_production_min = {};
  var scheduler = { exports: {} };
  var scheduler_production_min = {};
  /**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredScheduler_production_min;
  function requireScheduler_production_min() {
    if (hasRequiredScheduler_production_min) return scheduler_production_min;
    hasRequiredScheduler_production_min = 1;
    (function(exports$1) {
      function f(a, b) {
        var c = a.length;
        a.push(b);
        a: for (; 0 < c; ) {
          var d = c - 1 >>> 1, e = a[d];
          if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
          else break a;
        }
      }
      function h(a) {
        return 0 === a.length ? null : a[0];
      }
      function k(a) {
        if (0 === a.length) return null;
        var b = a[0], c = a.pop();
        if (c !== b) {
          a[0] = c;
          a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
            var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
            if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
            else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
            else break a;
          }
        }
        return b;
      }
      function g(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l = performance;
        exports$1.unstable_now = function() {
          return l.now();
        };
      } else {
        var p = Date, q = p.now();
        exports$1.unstable_now = function() {
          return p.now() - q;
        };
      }
      var r2 = [], t = [], u = 1, v = null, y = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a) {
        for (var b = h(t); null !== b; ) {
          if (null === b.callback) k(t);
          else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r2, b);
          else break;
          b = h(t);
        }
      }
      function H(a) {
        B = false;
        G(a);
        if (!A) if (null !== h(r2)) A = true, I(J);
        else {
          var b = h(t);
          null !== b && K(H, b.startTime - a);
        }
      }
      function J(a, b) {
        A = false;
        B && (B = false, E(L), L = -1);
        z = true;
        var c = y;
        try {
          G(b);
          for (v = h(r2); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
            var d = v.callback;
            if ("function" === typeof d) {
              v.callback = null;
              y = v.priorityLevel;
              var e = d(v.expirationTime <= b);
              b = exports$1.unstable_now();
              "function" === typeof e ? v.callback = e : v === h(r2) && k(r2);
              G(b);
            } else k(r2);
            v = h(r2);
          }
          if (null !== v) var w = true;
          else {
            var m = h(t);
            null !== m && K(H, m.startTime - b);
            w = false;
          }
          return w;
        } finally {
          v = null, y = c, z = false;
        }
      }
      var N = false, O = null, L = -1, P = 5, Q = -1;
      function M() {
        return exports$1.unstable_now() - Q < P ? false : true;
      }
      function R() {
        if (null !== O) {
          var a = exports$1.unstable_now();
          Q = a;
          var b = true;
          try {
            b = O(true, a);
          } finally {
            b ? S() : (N = false, O = null);
          }
        } else N = false;
      }
      var S;
      if ("function" === typeof F) S = function() {
        F(R);
      };
      else if ("undefined" !== typeof MessageChannel) {
        var T = new MessageChannel(), U = T.port2;
        T.port1.onmessage = R;
        S = function() {
          U.postMessage(null);
        };
      } else S = function() {
        D(R, 0);
      };
      function I(a) {
        O = a;
        N || (N = true, S());
      }
      function K(a, b) {
        L = D(function() {
          a(exports$1.unstable_now());
        }, b);
      }
      exports$1.unstable_IdlePriority = 5;
      exports$1.unstable_ImmediatePriority = 1;
      exports$1.unstable_LowPriority = 4;
      exports$1.unstable_NormalPriority = 3;
      exports$1.unstable_Profiling = null;
      exports$1.unstable_UserBlockingPriority = 2;
      exports$1.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports$1.unstable_continueExecution = function() {
        A || z || (A = true, I(J));
      };
      exports$1.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports$1.unstable_getCurrentPriorityLevel = function() {
        return y;
      };
      exports$1.unstable_getFirstCallbackNode = function() {
        return h(r2);
      };
      exports$1.unstable_next = function(a) {
        switch (y) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y;
        }
        var c = y;
        y = b;
        try {
          return a();
        } finally {
          y = c;
        }
      };
      exports$1.unstable_pauseExecution = function() {
      };
      exports$1.unstable_requestPaint = function() {
      };
      exports$1.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = y;
        y = a;
        try {
          return b();
        } finally {
          y = c;
        }
      };
      exports$1.unstable_scheduleCallback = function(a, b, c) {
        var d = exports$1.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, f(t, a), null === h(r2) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r2, a), A || z || (A = true, I(J)));
        return a;
      };
      exports$1.unstable_shouldYield = M;
      exports$1.unstable_wrapCallback = function(a) {
        var b = y;
        return function() {
          var c = y;
          y = b;
          try {
            return a.apply(this, arguments);
          } finally {
            y = c;
          }
        };
      };
    })(scheduler_production_min);
    return scheduler_production_min;
  }
  var hasRequiredScheduler;
  function requireScheduler() {
    if (hasRequiredScheduler) return scheduler.exports;
    hasRequiredScheduler = 1;
    {
      scheduler.exports = requireScheduler_production_min();
    }
    return scheduler.exports;
  }
  /**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactDom_production_min;
  function requireReactDom_production_min() {
    if (hasRequiredReactDom_production_min) return reactDom_production_min;
    hasRequiredReactDom_production_min = 1;
    var aa = requireReact(), ca = requireScheduler();
    function p(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set(), ea = {};
    function fa(a, b) {
      ha(a, b);
      ha(a + "Capture", b);
    }
    function ha(a, b) {
      ea[a] = b;
      for (a = 0; a < b.length; a++) da.add(b[a]);
    }
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a) {
      if (ja.call(ma, a)) return true;
      if (ja.call(la, a)) return false;
      if (ka.test(a)) return ma[a] = true;
      la[a] = true;
      return false;
    }
    function pa(a, b, c, d) {
      if (null !== c && 0 === c.type) return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d) return false;
          if (null !== c) return !c.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    function qa(a, b, c, d) {
      if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
      if (d) return false;
      if (null !== c) switch (c.type) {
        case 3:
          return !b;
        case 4:
          return false === b;
        case 5:
          return isNaN(b);
        case 6:
          return isNaN(b) || 1 > b;
      }
      return false;
    }
    function v(a, b, c, d, e, f, g) {
      this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
      this.attributeName = d;
      this.attributeNamespace = e;
      this.mustUseProperty = c;
      this.propertyName = a;
      this.type = b;
      this.sanitizeURL = f;
      this.removeEmptyString = g;
    }
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z[a] = new v(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      z[b] = new v(b, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z[a] = new v(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z[a] = new v(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      z[a] = new v(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z[a] = new v(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        ra,
        sa
      );
      z[b] = new v(b, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta(a, b, c, d) {
      var e = z.hasOwnProperty(b) ? z[b] : null;
      if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    var Ia = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka(a) {
      if (null === a || "object" !== typeof a) return null;
      a = Ja && a[Ja] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var A = Object.assign, La;
    function Ma(a) {
      if (void 0 === La) try {
        throw Error();
      } catch (c) {
        var b = c.stack.trim().match(/\n( *(at )?)/);
        La = b && b[1] || "";
      }
      return "\n" + La + a;
    }
    var Na = false;
    function Oa(a, b) {
      if (!a || Na) return "";
      Na = true;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b) if (b = function() {
          throw Error();
        }, Object.defineProperty(b.prototype, "props", { set: function() {
          throw Error();
        } }), "object" === typeof Reflect && Reflect.construct) {
          try {
            Reflect.construct(b, []);
          } catch (l) {
            var d = l;
          }
          Reflect.construct(a, [], b);
        } else {
          try {
            b.call();
          } catch (l) {
            d = l;
          }
          a.call(b.prototype);
        }
        else {
          try {
            throw Error();
          } catch (l) {
            d = l;
          }
          a();
        }
      } catch (l) {
        if (l && d && "string" === typeof l.stack) {
          for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
          for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
            if (1 !== g || 1 !== h) {
              do
                if (g--, h--, 0 > h || e[g] !== f[h]) {
                  var k = "\n" + e[g].replace(" at new ", " at ");
                  a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                  return k;
                }
              while (1 <= g && 0 <= h);
            }
            break;
          }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa(a.type, false), a;
        case 11:
          return a = Oa(a.type.render, false), a;
        case 1:
          return a = Oa(a.type, true), a;
        default:
          return "";
      }
    }
    function Qa(a) {
      if (null == a) return null;
      if ("function" === typeof a) return a.displayName || a.name || null;
      if ("string" === typeof a) return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a) switch (a.$$typeof) {
        case Ca:
          return (a.displayName || "Context") + ".Consumer";
        case Ba:
          return (a._context.displayName || "Context") + ".Provider";
        case Da:
          var b = a.render;
          a = a.displayName;
          a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          return a;
        case Ga:
          return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
        case Ha:
          b = a._payload;
          a = a._init;
          try {
            return Qa(a(b));
          } catch (c) {
          }
      }
      return null;
    }
    function Ra(a) {
      var b = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b.displayName || "Context") + ".Consumer";
        case 10:
          return (b._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b);
        case 8:
          return b === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b) return b.displayName || b.name || null;
          if ("string" === typeof b) return b;
      }
      return null;
    }
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta(a) {
      var b = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
    }
    function Ua(a) {
      var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
      if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
        var e = c.get, f = c.set;
        Object.defineProperty(a, b, { configurable: true, get: function() {
          return e.call(this);
        }, set: function(a2) {
          d = "" + a2;
          f.call(this, a2);
        } });
        Object.defineProperty(a, b, { enumerable: c.enumerable });
        return { getValue: function() {
          return d;
        }, setValue: function(a2) {
          d = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null;
          delete a[b];
        } };
      }
    }
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    function Wa(a) {
      if (!a) return false;
      var b = a._valueTracker;
      if (!b) return true;
      var c = b.getValue();
      var d = "";
      a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
      a = d;
      return a !== c ? (b.setValue(a), true) : false;
    }
    function Xa(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a) return null;
      try {
        return a.activeElement || a.body;
      } catch (b) {
        return a.body;
      }
    }
    function Ya(a, b) {
      var c = b.checked;
      return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
    }
    function Za(a, b) {
      var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
      c = Sa(null != b.value ? b.value : c);
      a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
    }
    function ab(a, b) {
      b = b.checked;
      null != b && ta(a, "checked", b, false);
    }
    function bb(a, b) {
      ab(a, b);
      var c = Sa(b.value), d = b.type;
      if (null != c) if ("number" === d) {
        if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
      } else a.value !== "" + c && (a.value = "" + c);
      else if ("submit" === d || "reset" === d) {
        a.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
      null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
    }
    function db(a, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
        b = "" + a._wrapperState.initialValue;
        c || b === a.value || (a.value = b);
        a.defaultValue = b;
      }
      c = a.name;
      "" !== c && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c && (a.name = c);
    }
    function cb(a, b, c) {
      if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
    }
    var eb = Array.isArray;
    function fb(a, b, c, d) {
      a = a.options;
      if (b) {
        b = {};
        for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
        for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
      } else {
        c = "" + Sa(c);
        b = null;
        for (e = 0; e < a.length; e++) {
          if (a[e].value === c) {
            a[e].selected = true;
            d && (a[e].defaultSelected = true);
            return;
          }
          null !== b || a[e].disabled || (b = a[e]);
        }
        null !== b && (b.selected = true);
      }
    }
    function gb(a, b) {
      if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
      return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function hb(a, b) {
      var c = b.value;
      if (null == c) {
        c = b.children;
        b = b.defaultValue;
        if (null != c) {
          if (null != b) throw Error(p(92));
          if (eb(c)) {
            if (1 < c.length) throw Error(p(93));
            c = c[0];
          }
          b = c;
        }
        null == b && (b = "");
        c = b;
      }
      a._wrapperState = { initialValue: Sa(c) };
    }
    function ib(a, b) {
      var c = Sa(b.value), d = Sa(b.defaultValue);
      null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
      null != d && (a.defaultValue = "" + d);
    }
    function jb(a) {
      var b = a.textContent;
      b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
    }
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a, b) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
    }
    var mb, nb = (function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b, c, d, e);
        });
      } : a;
    })(function(a, b) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
        for (; b.firstChild; ) a.appendChild(b.firstChild);
      }
    });
    function ob(a, b) {
      if (b) {
        var c = a.firstChild;
        if (c && c === a.lastChild && 3 === c.nodeType) {
          c.nodeValue = b;
          return;
        }
      }
      a.textContent = b;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1);
        pb[b] = pb[a];
      });
    });
    function rb(a, b, c) {
      return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
    }
    function sb(a, b) {
      a = a.style;
      for (var c in b) if (b.hasOwnProperty(c)) {
        var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
        "float" === c && (c = "cssFloat");
        d ? a.setProperty(c, e) : a[c] = e;
      }
    }
    var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a, b) {
      if (b) {
        if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
        if (null != b.dangerouslySetInnerHTML) {
          if (null != b.children) throw Error(p(60));
          if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
        }
        if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
      }
    }
    function vb(a, b) {
      if (-1 === a.indexOf("-")) return "string" === typeof b.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if ("function" !== typeof yb) throw Error(p(280));
        var b = a.stateNode;
        b && (b = Db(b), yb(a.stateNode, a.type, b));
      }
    }
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    function Fb() {
      if (zb) {
        var a = zb, b = Ab;
        Ab = zb = null;
        Bb(a);
        if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
      }
    }
    function Gb(a, b) {
      return a(b);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a, b, c) {
      if (Ib) return a(b, c);
      Ib = true;
      try {
        return Gb(a, b, c);
      } finally {
        if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
      }
    }
    function Kb(a, b) {
      var c = a.stateNode;
      if (null === c) return null;
      var d = Db(c);
      if (null === d) return null;
      c = d[b];
      a: switch (b) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
          a = !d;
          break a;
        default:
          a = false;
      }
      if (a) return null;
      if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
      return c;
    }
    var Lb = false;
    if (ia) try {
      var Mb = {};
      Object.defineProperty(Mb, "passive", { get: function() {
        Lb = true;
      } });
      window.addEventListener("test", Mb, Mb);
      window.removeEventListener("test", Mb, Mb);
    } catch (a) {
      Lb = false;
    }
    function Nb(a, b, c, d, e, f, g, h, k) {
      var l = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l);
      } catch (m) {
        this.onError(m);
      }
    }
    var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
      Ob = true;
      Pb = a;
    } };
    function Tb(a, b, c, d, e, f, g, h, k) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a, b, c, d, e, f, g, h, k) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l = Pb;
          Ob = false;
          Pb = null;
        } else throw Error(p(198));
        Qb || (Qb = true, Rb = l);
      }
    }
    function Vb(a) {
      var b = a, c = a;
      if (a.alternate) for (; b.return; ) b = b.return;
      else {
        a = b;
        do
          b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
        while (a);
      }
      return 3 === b.tag ? c : null;
    }
    function Wb(a) {
      if (13 === a.tag) {
        var b = a.memoizedState;
        null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
        if (null !== b) return b.dehydrated;
      }
      return null;
    }
    function Xb(a) {
      if (Vb(a) !== a) throw Error(p(188));
    }
    function Yb(a) {
      var b = a.alternate;
      if (!b) {
        b = Vb(a);
        if (null === b) throw Error(p(188));
        return b !== a ? null : a;
      }
      for (var c = a, d = b; ; ) {
        var e = c.return;
        if (null === e) break;
        var f = e.alternate;
        if (null === f) {
          d = e.return;
          if (null !== d) {
            c = d;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c) return Xb(e), a;
            if (f === d) return Xb(e), b;
            f = f.sibling;
          }
          throw Error(p(188));
        }
        if (c.return !== d.return) c = e, d = f;
        else {
          for (var g = false, h = e.child; h; ) {
            if (h === c) {
              g = true;
              c = e;
              d = f;
              break;
            }
            if (h === d) {
              g = true;
              d = e;
              c = f;
              break;
            }
            h = h.sibling;
          }
          if (!g) {
            for (h = f.child; h; ) {
              if (h === c) {
                g = true;
                c = f;
                d = e;
                break;
              }
              if (h === d) {
                g = true;
                d = f;
                c = e;
                break;
              }
              h = h.sibling;
            }
            if (!g) throw Error(p(189));
          }
        }
        if (c.alternate !== d) throw Error(p(190));
      }
      if (3 !== c.tag) throw Error(p(188));
      return c.stateNode.current === c ? a : b;
    }
    function Zb(a) {
      a = Yb(a);
      return null !== a ? $b(a) : null;
    }
    function $b(a) {
      if (5 === a.tag || 6 === a.tag) return a;
      for (a = a.child; null !== a; ) {
        var b = $b(a);
        if (null !== b) return b;
        a = a.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a) {
      if (lc && "function" === typeof lc.onCommitFiberRoot) try {
        lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
      } catch (b) {
      }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a) {
      a >>>= 0;
      return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc(a, b) {
      var c = a.pendingLanes;
      if (0 === c) return 0;
      var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
      if (0 !== g) {
        var h = g & ~e;
        0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
      } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
      if (0 === d) return 0;
      if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
      0 !== (d & 4) && (d |= c & 16);
      b = a.entangledLanes;
      if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
      return d;
    }
    function vc(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a, b) {
      for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
        var g = 31 - oc(f), h = 1 << g, k = e[g];
        if (-1 === k) {
          if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
        } else k <= b && (a.expiredLanes |= h);
        f &= ~h;
      }
    }
    function xc(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a;
    }
    function zc(a) {
      for (var b = [], c = 0; 31 > c; c++) b.push(a);
      return b;
    }
    function Ac(a, b, c) {
      a.pendingLanes |= b;
      536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
      a = a.eventTimes;
      b = 31 - oc(b);
      a[b] = c;
    }
    function Bc(a, b) {
      var c = a.pendingLanes & ~b;
      a.pendingLanes = b;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b;
      a.mutableReadLanes &= b;
      a.entangledLanes &= b;
      b = a.entanglements;
      var d = a.eventTimes;
      for (a = a.expirationTimes; 0 < c; ) {
        var e = 31 - oc(c), f = 1 << e;
        b[e] = 0;
        d[e] = -1;
        a[e] = -1;
        c &= ~f;
      }
    }
    function Cc(a, b) {
      var c = a.entangledLanes |= b;
      for (a = a.entanglements; c; ) {
        var d = 31 - oc(c), e = 1 << d;
        e & b | a[d] & b && (a[d] |= b);
        c &= ~e;
      }
    }
    var C = 0;
    function Dc(a) {
      a &= -a;
      return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b.pointerId);
      }
    }
    function Tc(a, b, c, d, e, f) {
      if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
      a.eventSystemFlags |= d;
      b = a.targetContainers;
      null !== e && -1 === b.indexOf(e) && b.push(e);
      return a;
    }
    function Uc(a, b, c, d, e) {
      switch (b) {
        case "focusin":
          return Lc = Tc(Lc, a, b, c, d, e), true;
        case "dragenter":
          return Mc = Tc(Mc, a, b, c, d, e), true;
        case "mouseover":
          return Nc = Tc(Nc, a, b, c, d, e), true;
        case "pointerover":
          var f = e.pointerId;
          Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
          return true;
        case "gotpointercapture":
          return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
      }
      return false;
    }
    function Vc(a) {
      var b = Wc(a.target);
      if (null !== b) {
        var c = Vb(b);
        if (null !== c) {
          if (b = c.tag, 13 === b) {
            if (b = Wb(c), null !== b) {
              a.blockedOn = b;
              Ic(a.priority, function() {
                Gc(c);
              });
              return;
            }
          } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc(a) {
      if (null !== a.blockedOn) return false;
      for (var b = a.targetContainers; 0 < b.length; ) {
        var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
        if (null === c) {
          c = a.nativeEvent;
          var d = new c.constructor(c.type, c);
          wb = d;
          c.target.dispatchEvent(d);
          wb = null;
        } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
        b.shift();
      }
      return true;
    }
    function Zc(a, b, c) {
      Xc(a) && c.delete(b);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a, b) {
      a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a) {
      function b(b2) {
        return ad(b2, a);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c = 1; c < Kc.length; c++) {
          var d = Kc[c];
          d.blockedOn === a && (d.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a);
      null !== Mc && ad(Mc, a);
      null !== Nc && ad(Nc, a);
      Oc.forEach(b);
      Pc.forEach(b);
      for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
      for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = true;
    function ed(a, b, c, d) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a, b, c, d);
      } finally {
        C = e, cd.transition = f;
      }
    }
    function gd(a, b, c, d) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a, b, c, d);
      } finally {
        C = e, cd.transition = f;
      }
    }
    function fd(a, b, c, d) {
      if (dd) {
        var e = Yc(a, b, c, d);
        if (null === e) hd(a, b, d, id, c), Sc(a, d);
        else if (Uc(e, a, b, c, d)) d.stopPropagation();
        else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
          for (; null !== e; ) {
            var f = Cb(e);
            null !== f && Ec(f);
            f = Yc(a, b, c, d);
            null === f && hd(a, b, d, id, c);
            if (f === e) break;
            e = f;
          }
          null !== e && d.stopPropagation();
        } else hd(a, b, d, null, c);
      }
    }
    var id = null;
    function Yc(a, b, c, d) {
      id = null;
      a = xb(d);
      a = Wc(a);
      if (null !== a) if (b = Vb(a), null === b) a = null;
      else if (c = b.tag, 13 === c) {
        a = Wb(b);
        if (null !== a) return a;
        a = null;
      } else if (3 === c) {
        if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
        a = null;
      } else b !== a && (a = null);
      id = a;
      return null;
    }
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md) return md;
      var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
      for (a = 0; a < c && b[a] === e[a]; a++) ;
      var g = c - a;
      for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
      return md = e.slice(a, 1 < d ? 1 - d : void 0);
    }
    function od(a) {
      var b = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a) {
      function b(b2, d, e, f, g) {
        this._reactName = b2;
        this._targetInst = e;
        this.type = d;
        this.nativeEvent = f;
        this.target = g;
        this.currentTarget = null;
        for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
        this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A(b.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      if ("movementX" in a) return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A({}, ud, { key: function(a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if ("Unidentified" !== b) return b;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
      return "keypress" === a.type ? od(a) : 0;
    }, keyCode: function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, which: function(a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
    function ge(a, b) {
      switch (a) {
        case "keyup":
          return -1 !== $d.indexOf(b.keyCode);
        case "keydown":
          return 229 !== b.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    var ie = false;
    function je(a, b) {
      switch (a) {
        case "compositionend":
          return he(b);
        case "keypress":
          if (32 !== b.which) return null;
          fe = true;
          return ee;
        case "textInput":
          return a = b.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke(a, b) {
      if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length) return b.char;
            if (b.which) return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b.locale ? null : b.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
    }
    function ne(a, b, c, d) {
      Eb(d);
      b = oe(b, "onChange");
      0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
    }
    var pe = null, qe = null;
    function re(a) {
      se(a, 0);
    }
    function te(a) {
      var b = ue(a);
      if (Wa(b)) return a;
    }
    function ve(a, b) {
      if ("change" === a) return b;
    }
    var we = false;
    if (ia) {
      var xe;
      if (ia) {
        var ye = "oninput" in document;
        if (!ye) {
          var ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a) {
      if ("value" === a.propertyName && te(qe)) {
        var b = [];
        ne(b, qe, a, xb(a));
        Jb(re, b);
      }
    }
    function Ce(a, b, c) {
      "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
    }
    function De(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
    }
    function Ee(a, b) {
      if ("click" === a) return te(b);
    }
    function Fe(a, b) {
      if ("input" === a || "change" === a) return te(b);
    }
    function Ge(a, b) {
      return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a, b) {
      if (He(a, b)) return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
      var c = Object.keys(a), d = Object.keys(b);
      if (c.length !== d.length) return false;
      for (d = 0; d < c.length; d++) {
        var e = c[d];
        if (!ja.call(b, e) || !He(a[e], b[e])) return false;
      }
      return true;
    }
    function Je(a) {
      for (; a && a.firstChild; ) a = a.firstChild;
      return a;
    }
    function Ke(a, b) {
      var c = Je(a);
      a = 0;
      for (var d; c; ) {
        if (3 === c.nodeType) {
          d = a + c.textContent.length;
          if (a <= b && d >= b) return { node: c, offset: b - a };
          a = d;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Je(c);
      }
    }
    function Le(a, b) {
      return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
    }
    function Me() {
      for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
        try {
          var c = "string" === typeof b.contentWindow.location.href;
        } catch (d) {
          c = false;
        }
        if (c) a = b.contentWindow;
        else break;
        b = Xa(a.document);
      }
      return b;
    }
    function Ne(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
    }
    function Oe(a) {
      var b = Me(), c = a.focusedElem, d = a.selectionRange;
      if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
        if (null !== d && Ne(c)) {
          if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
          else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e = c.textContent.length, f = Math.min(d.start, e);
            d = void 0 === d.end ? f : Math.min(d.end, e);
            !a.extend && f > d && (e = d, d = f, f = e);
            e = Ke(c, f);
            var g = Ke(
              c,
              d
            );
            e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
          }
        }
        b = [];
        for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c.focus && c.focus();
        for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
    function Ue(a, b, c) {
      var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
      Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
    }
    function Ve(a, b) {
      var c = {};
      c[a.toLowerCase()] = b.toLowerCase();
      c["Webkit" + a] = "webkit" + b;
      c["Moz" + a] = "moz" + b;
      return c;
    }
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a) {
      if (Xe[a]) return Xe[a];
      if (!We[a]) return a;
      var b = We[a], c;
      for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
      return a;
    }
    var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b) {
      df.set(a, b);
      fa(b, [a]);
    }
    for (var gf = 0; gf < ef.length; gf++) {
      var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b, c) {
      var d = a.type || "unknown-event";
      a.currentTarget = c;
      Ub(d, b, void 0, a);
      a.currentTarget = null;
    }
    function se(a, b) {
      b = 0 !== (b & 4);
      for (var c = 0; c < a.length; c++) {
        var d = a[c], e = d.event;
        d = d.listeners;
        a: {
          var f = void 0;
          if (b) for (var g = d.length - 1; 0 <= g; g--) {
            var h = d[g], k = h.instance, l = h.currentTarget;
            h = h.listener;
            if (k !== f && e.isPropagationStopped()) break a;
            nf(e, h, l);
            f = k;
          }
          else for (g = 0; g < d.length; g++) {
            h = d[g];
            k = h.instance;
            l = h.currentTarget;
            h = h.listener;
            if (k !== f && e.isPropagationStopped()) break a;
            nf(e, h, l);
            f = k;
          }
        }
      }
      if (Qb) throw a = Rb, Qb = false, Rb = null, a;
    }
    function D(a, b) {
      var c = b[of];
      void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
      var d = a + "__bubble";
      c.has(d) || (pf(b, a, 2, false), c.add(d));
    }
    function qf(a, b, c) {
      var d = 0;
      b && (d |= 4);
      pf(c, a, d, b);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = true;
        da.forEach(function(b2) {
          "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
        });
        var b = 9 === a.nodeType ? a : a.ownerDocument;
        null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
      }
    }
    function pf(a, b, c, d) {
      switch (jd(b)) {
        case 1:
          var e = ed;
          break;
        case 4:
          e = gd;
          break;
        default:
          e = fd;
      }
      c = e.bind(null, b, c, a);
      e = void 0;
      !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
      d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
    }
    function hd(a, b, c, d, e) {
      var f = d;
      if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
        if (null === d) return;
        var g = d.tag;
        if (3 === g || 4 === g) {
          var h = d.stateNode.containerInfo;
          if (h === e || 8 === h.nodeType && h.parentNode === e) break;
          if (4 === g) for (g = d.return; null !== g; ) {
            var k = g.tag;
            if (3 === k || 4 === k) {
              if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
            }
            g = g.return;
          }
          for (; null !== h; ) {
            g = Wc(h);
            if (null === g) return;
            k = g.tag;
            if (5 === k || 6 === k) {
              d = f = g;
              continue a;
            }
            h = h.parentNode;
          }
        }
        d = d.return;
      }
      Jb(function() {
        var d2 = f, e2 = xb(c), g2 = [];
        a: {
          var h2 = df.get(a);
          if (void 0 !== h2) {
            var k2 = td, n = a;
            switch (a) {
              case "keypress":
                if (0 === od(c)) break a;
              case "keydown":
              case "keyup":
                k2 = Rd;
                break;
              case "focusin":
                n = "focus";
                k2 = Fd;
                break;
              case "focusout":
                n = "blur";
                k2 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k2 = Fd;
                break;
              case "click":
                if (2 === c.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k2 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k2 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k2 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k2 = Hd;
                break;
              case cf:
                k2 = Xd;
                break;
              case "scroll":
                k2 = vd;
                break;
              case "wheel":
                k2 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k2 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k2 = Td;
            }
            var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
            t = [];
            for (var w = d2, u; null !== w; ) {
              u = w;
              var F = u.stateNode;
              5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
              if (J) break;
              w = w.return;
            }
            0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
          }
        }
        if (0 === (b & 7)) {
          a: {
            h2 = "mouseover" === a || "pointerover" === a;
            k2 = "mouseout" === a || "pointerout" === a;
            if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
            if (k2 || h2) {
              h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
              if (k2) {
                if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
              } else k2 = null, n = d2;
              if (k2 !== n) {
                t = Bd;
                F = "onMouseLeave";
                x = "onMouseEnter";
                w = "mouse";
                if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                J = null == k2 ? h2 : ue(k2);
                u = null == n ? h2 : ue(n);
                h2 = new t(F, w + "leave", k2, c, e2);
                h2.target = J;
                h2.relatedTarget = u;
                F = null;
                Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
                J = F;
                if (k2 && n) b: {
                  t = k2;
                  x = n;
                  w = 0;
                  for (u = t; u; u = vf(u)) w++;
                  u = 0;
                  for (F = x; F; F = vf(F)) u++;
                  for (; 0 < w - u; ) t = vf(t), w--;
                  for (; 0 < u - w; ) x = vf(x), u--;
                  for (; w--; ) {
                    if (t === x || null !== x && t === x.alternate) break b;
                    t = vf(t);
                    x = vf(x);
                  }
                  t = null;
                }
                else t = null;
                null !== k2 && wf(g2, h2, k2, t, false);
                null !== n && null !== J && wf(g2, J, n, t, true);
              }
            }
          }
          a: {
            h2 = d2 ? ue(d2) : window;
            k2 = h2.nodeName && h2.nodeName.toLowerCase();
            if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
            else if (me(h2)) if (we) na = Fe;
            else {
              na = De;
              var xa = Ce;
            }
            else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
            if (na && (na = na(a, d2))) {
              ne(g2, na, c, e2);
              break a;
            }
            xa && xa(a, h2, d2);
            "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
          }
          xa = d2 ? ue(d2) : window;
          switch (a) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g2, c, e2);
              break;
            case "selectionchange":
              if (Pe) break;
            case "keydown":
            case "keyup":
              Ue(g2, c, e2);
          }
          var $a;
          if (ae) b: {
            switch (a) {
              case "compositionstart":
                var ba = "onCompositionStart";
                break b;
              case "compositionend":
                ba = "onCompositionEnd";
                break b;
              case "compositionupdate":
                ba = "onCompositionUpdate";
                break b;
            }
            ba = void 0;
          }
          else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
          if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
        }
        se(g2, b);
      });
    }
    function tf(a, b, c) {
      return { instance: a, listener: b, currentTarget: c };
    }
    function oe(a, b) {
      for (var c = b + "Capture", d = []; null !== a; ) {
        var e = a, f = e.stateNode;
        5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
        a = a.return;
      }
      return d;
    }
    function vf(a) {
      if (null === a) return null;
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    function wf(a, b, c, d, e) {
      for (var f = b._reactName, g = []; null !== c && c !== d; ) {
        var h = c, k = h.alternate, l = h.stateNode;
        if (null !== k && k === d) break;
        5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
        c = c.return;
      }
      0 !== g.length && a.push({ event: b, listeners: g });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
    }
    function Af(a, b, c) {
      b = zf(b);
      if (zf(a) !== b && c) throw Error(p(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a, b) {
      return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Kf(a, b) {
      var c = b, d = 0;
      do {
        var e = c.nextSibling;
        a.removeChild(c);
        if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
          if (0 === d) {
            a.removeChild(e);
            bd(b);
            return;
          }
          d--;
        } else "$" !== c && "$?" !== c && "$!" !== c || d++;
        c = e;
      } while (c);
      bd(b);
    }
    function Lf(a) {
      for (; null != a; a = a.nextSibling) {
        var b = a.nodeType;
        if (1 === b || 3 === b) break;
        if (8 === b) {
          b = a.data;
          if ("$" === b || "$!" === b || "$?" === b) break;
          if ("/$" === b) return null;
        }
      }
      return a;
    }
    function Mf(a) {
      a = a.previousSibling;
      for (var b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("$" === c || "$!" === c || "$?" === c) {
            if (0 === b) return a;
            b--;
          } else "/$" === c && b++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b = a[Of];
      if (b) return b;
      for (var c = a.parentNode; c; ) {
        if (b = c[uf] || c[Of]) {
          c = b.alternate;
          if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
            if (c = a[Of]) return c;
            a = Mf(a);
          }
          return b;
        }
        a = c;
        c = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      a = a[Of] || a[uf];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    function ue(a) {
      if (5 === a.tag || 6 === a.tag) return a.stateNode;
      throw Error(p(33));
    }
    function Db(a) {
      return a[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    function E(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G(a, b) {
      Tf++;
      Sf[Tf] = a.current;
      a.current = b;
    }
    var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
    function Yf(a, b) {
      var c = a.type.contextTypes;
      if (!c) return Vf;
      var d = a.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f;
      for (f in c) e[f] = b[f];
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    function Zf(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    function $f() {
      E(Wf);
      E(H);
    }
    function ag(a, b, c) {
      if (H.current !== Vf) throw Error(p(168));
      G(H, b);
      G(Wf, c);
    }
    function bg(a, b, c) {
      var d = a.stateNode;
      b = b.childContextTypes;
      if ("function" !== typeof d.getChildContext) return c;
      d = d.getChildContext();
      for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
      return A({}, c, d);
    }
    function cg(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H.current;
      G(H, a);
      G(Wf, Wf.current);
      return true;
    }
    function dg(a, b, c) {
      var d = a.stateNode;
      if (!d) throw Error(p(169));
      c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
      G(Wf, c);
    }
    var eg = null, fg = false, gg = false;
    function hg(a) {
      null === eg ? eg = [a] : eg.push(a);
    }
    function ig(a) {
      fg = true;
      hg(a);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a = 0, b = C;
        try {
          var c = eg;
          for (C = 1; a < c.length; a++) {
            var d = c[a];
            do
              d = d(true);
            while (null !== d);
          }
          eg = null;
          fg = false;
        } catch (e) {
          throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
        } finally {
          C = b, gg = false;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a, b) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a;
      ng = b;
    }
    function ug(a, b, c) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a;
      var d = rg;
      a = sg;
      var e = 32 - oc(d) - 1;
      d &= ~(1 << e);
      c += 1;
      var f = 32 - oc(b) + e;
      if (30 < f) {
        var g = e - e % 5;
        f = (d & (1 << g) - 1).toString(32);
        d >>= g;
        e -= g;
        rg = 1 << 32 - oc(b) + e | c << e | d;
        sg = f + a;
      } else rg = 1 << f | c << e | d, sg = a;
    }
    function vg(a) {
      null !== a.return && (tg(a, 1), ug(a, 1, 0));
    }
    function wg(a) {
      for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I = false, zg = null;
    function Ag(a, b) {
      var c = Bg(5, null, null, 0);
      c.elementType = "DELETED";
      c.stateNode = b;
      c.return = a;
      b = a.deletions;
      null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
    }
    function Cg(a, b) {
      switch (a.tag) {
        case 5:
          var c = a.type;
          b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
          return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
        case 6:
          return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
        case 13:
          return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    function Eg(a) {
      if (I) {
        var b = yg;
        if (b) {
          var c = b;
          if (!Cg(a, b)) {
            if (Dg(a)) throw Error(p(418));
            b = Lf(c.nextSibling);
            var d = xg;
            b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
          }
        } else {
          if (Dg(a)) throw Error(p(418));
          a.flags = a.flags & -4097 | 2;
          I = false;
          xg = a;
        }
      }
    }
    function Fg(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
      xg = a;
    }
    function Gg(a) {
      if (a !== xg) return false;
      if (!I) return Fg(a), I = true, false;
      var b;
      (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
      if (b && (b = yg)) {
        if (Dg(a)) throw Hg(), Error(p(418));
        for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
      }
      Fg(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a) throw Error(p(317));
        a: {
          a = a.nextSibling;
          for (b = 0; a; ) {
            if (8 === a.nodeType) {
              var c = a.data;
              if ("/$" === c) {
                if (0 === b) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b--;
              } else "$" !== c && "$!" !== c && "$?" !== c || b++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a = yg; a; ) a = Lf(a.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I = false;
    }
    function Jg(a) {
      null === zg ? zg = [a] : zg.push(a);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b, c) {
      a = c.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c._owner) {
          c = c._owner;
          if (c) {
            if (1 !== c.tag) throw Error(p(309));
            var d = c.stateNode;
          }
          if (!d) throw Error(p(147, a));
          var e = d, f = "" + a;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
          b = function(a2) {
            var b2 = e.refs;
            null === a2 ? delete b2[f] : b2[f] = a2;
          };
          b._stringRef = f;
          return b;
        }
        if ("string" !== typeof a) throw Error(p(284));
        if (!c._owner) throw Error(p(290, a));
      }
      return a;
    }
    function Mg(a, b) {
      a = Object.prototype.toString.call(b);
      throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
    }
    function Ng(a) {
      var b = a._init;
      return b(a._payload);
    }
    function Og(a) {
      function b(b2, c2) {
        if (a) {
          var d2 = b2.deletions;
          null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
        }
      }
      function c(c2, d2) {
        if (!a) return null;
        for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
        return null;
      }
      function d(a2, b2) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
        return a2;
      }
      function e(a2, b2) {
        a2 = Pg(a2, b2);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      function f(b2, c2, d2) {
        b2.index = d2;
        if (!a) return b2.flags |= 1048576, c2;
        d2 = b2.alternate;
        if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
        b2.flags |= 2;
        return c2;
      }
      function g(b2) {
        a && null === b2.alternate && (b2.flags |= 2);
        return b2;
      }
      function h(a2, b2, c2, d2) {
        if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function k(a2, b2, c2, d2) {
        var f2 = c2.type;
        if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
        if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
        d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
        d2.ref = Lg(a2, b2, c2);
        d2.return = a2;
        return d2;
      }
      function l(a2, b2, c2, d2) {
        if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
        b2 = e(b2, c2.children || []);
        b2.return = a2;
        return b2;
      }
      function m(a2, b2, c2, d2, f2) {
        if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function q(a2, b2, c2) {
        if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
        if ("object" === typeof b2 && null !== b2) {
          switch (b2.$$typeof) {
            case va:
              return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
            case wa:
              return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
            case Ha:
              var d2 = b2._init;
              return q(a2, d2(b2._payload), c2);
          }
          if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
          Mg(a2, b2);
        }
        return null;
      }
      function r2(a2, b2, c2, d2) {
        var e2 = null !== b2 ? b2.key : null;
        if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
        if ("object" === typeof c2 && null !== c2) {
          switch (c2.$$typeof) {
            case va:
              return c2.key === e2 ? k(a2, b2, c2, d2) : null;
            case wa:
              return c2.key === e2 ? l(a2, b2, c2, d2) : null;
            case Ha:
              return e2 = c2._init, r2(
                a2,
                b2,
                e2(c2._payload),
                d2
              );
          }
          if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d2, null);
          Mg(a2, c2);
        }
        return null;
      }
      function y(a2, b2, c2, d2, e2) {
        if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
        if ("object" === typeof d2 && null !== d2) {
          switch (d2.$$typeof) {
            case va:
              return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
            case wa:
              return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
            case Ha:
              var f2 = d2._init;
              return y(a2, b2, c2, f2(d2._payload), e2);
          }
          if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
          Mg(b2, d2);
        }
        return null;
      }
      function n(e2, g2, h2, k2) {
        for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
          u.index > w ? (x = u, u = null) : x = u.sibling;
          var n2 = r2(e2, u, h2[w], k2);
          if (null === n2) {
            null === u && (u = x);
            break;
          }
          a && u && null === n2.alternate && b(e2, u);
          g2 = f(n2, g2, w);
          null === m2 ? l2 = n2 : m2.sibling = n2;
          m2 = n2;
          u = x;
        }
        if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
        if (null === u) {
          for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
          I && tg(e2, w);
          return l2;
        }
        for (u = d(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
        a && u.forEach(function(a2) {
          return b(e2, a2);
        });
        I && tg(e2, w);
        return l2;
      }
      function t(e2, g2, h2, k2) {
        var l2 = Ka(h2);
        if ("function" !== typeof l2) throw Error(p(150));
        h2 = l2.call(h2);
        if (null == h2) throw Error(p(151));
        for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
          m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
          var t2 = r2(e2, m2, n2.value, k2);
          if (null === t2) {
            null === m2 && (m2 = x);
            break;
          }
          a && m2 && null === t2.alternate && b(e2, m2);
          g2 = f(t2, g2, w);
          null === u ? l2 = t2 : u.sibling = t2;
          u = t2;
          m2 = x;
        }
        if (n2.done) return c(
          e2,
          m2
        ), I && tg(e2, w), l2;
        if (null === m2) {
          for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
          I && tg(e2, w);
          return l2;
        }
        for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
        a && m2.forEach(function(a2) {
          return b(e2, a2);
        });
        I && tg(e2, w);
        return l2;
      }
      function J(a2, d2, f2, h2) {
        "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
        if ("object" === typeof f2 && null !== f2) {
          switch (f2.$$typeof) {
            case va:
              a: {
                for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                  if (l2.key === k2) {
                    k2 = f2.type;
                    if (k2 === ya) {
                      if (7 === l2.tag) {
                        c(a2, l2.sibling);
                        d2 = e(l2, f2.props.children);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      }
                    } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                      c(a2, l2.sibling);
                      d2 = e(l2, f2.props);
                      d2.ref = Lg(a2, l2, f2);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                    c(a2, l2);
                    break;
                  } else b(a2, l2);
                  l2 = l2.sibling;
                }
                f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
              }
              return g(a2);
            case wa:
              a: {
                for (l2 = f2.key; null !== d2; ) {
                  if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                    c(a2, d2.sibling);
                    d2 = e(d2, f2.children || []);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  } else {
                    c(a2, d2);
                    break;
                  }
                  else b(a2, d2);
                  d2 = d2.sibling;
                }
                d2 = Sg(f2, a2.mode, h2);
                d2.return = a2;
                a2 = d2;
              }
              return g(a2);
            case Ha:
              return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
          }
          if (eb(f2)) return n(a2, d2, f2, h2);
          if (Ka(f2)) return t(a2, d2, f2, h2);
          Mg(a2, f2);
        }
        return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
      }
      return J;
    }
    var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
    function $g() {
      Zg = Yg = Xg = null;
    }
    function ah(a) {
      var b = Wg.current;
      E(Wg);
      a._currentValue = b;
    }
    function bh(a, b, c) {
      for (; null !== a; ) {
        var d = a.alternate;
        (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
        if (a === c) break;
        a = a.return;
      }
    }
    function ch(a, b) {
      Xg = a;
      Zg = Yg = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
    }
    function eh(a) {
      var b = a._currentValue;
      if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
        if (null === Xg) throw Error(p(308));
        Yg = a;
        Xg.dependencies = { lanes: 0, firstContext: a };
      } else Yg = Yg.next = a;
      return b;
    }
    var fh = null;
    function gh(a) {
      null === fh ? fh = [a] : fh.push(a);
    }
    function hh(a, b, c, d) {
      var e = b.interleaved;
      null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
      b.interleaved = c;
      return ih(a, d);
    }
    function ih(a, b) {
      a.lanes |= b;
      var c = a.alternate;
      null !== c && (c.lanes |= b);
      c = a;
      for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
      return 3 === c.tag ? c.stateNode : null;
    }
    var jh = false;
    function kh(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function lh(a, b) {
      a = a.updateQueue;
      b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    function mh(a, b) {
      return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
    }
    function nh(a, b, c) {
      var d = a.updateQueue;
      if (null === d) return null;
      d = d.shared;
      if (0 !== (K & 2)) {
        var e = d.pending;
        null === e ? b.next = b : (b.next = e.next, e.next = b);
        d.pending = b;
        return ih(a, c);
      }
      e = d.interleaved;
      null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
      d.interleaved = b;
      return ih(a, c);
    }
    function oh(a, b, c) {
      b = b.updateQueue;
      if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
        var d = b.lanes;
        d &= a.pendingLanes;
        c |= d;
        b.lanes = c;
        Cc(a, c);
      }
    }
    function ph(a, b) {
      var c = a.updateQueue, d = a.alternate;
      if (null !== d && (d = d.updateQueue, c === d)) {
        var e = null, f = null;
        c = c.firstBaseUpdate;
        if (null !== c) {
          do {
            var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
            null === f ? e = f = g : f = f.next = g;
            c = c.next;
          } while (null !== c);
          null === f ? e = f = b : f = f.next = b;
        } else e = f = b;
        c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
        a.updateQueue = c;
        return;
      }
      a = c.lastBaseUpdate;
      null === a ? c.firstBaseUpdate = b : a.next = b;
      c.lastBaseUpdate = b;
    }
    function qh(a, b, c, d) {
      var e = a.updateQueue;
      jh = false;
      var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
      if (null !== h) {
        e.shared.pending = null;
        var k = h, l = k.next;
        k.next = null;
        null === g ? f = l : g.next = l;
        g = k;
        var m = a.alternate;
        null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
      }
      if (null !== f) {
        var q = e.baseState;
        g = 0;
        m = l = k = null;
        h = f;
        do {
          var r2 = h.lane, y = h.eventTime;
          if ((d & r2) === r2) {
            null !== m && (m = m.next = {
              eventTime: y,
              lane: 0,
              tag: h.tag,
              payload: h.payload,
              callback: h.callback,
              next: null
            });
            a: {
              var n = a, t = h;
              r2 = b;
              y = c;
              switch (t.tag) {
                case 1:
                  n = t.payload;
                  if ("function" === typeof n) {
                    q = n.call(y, q, r2);
                    break a;
                  }
                  q = n;
                  break a;
                case 3:
                  n.flags = n.flags & -65537 | 128;
                case 0:
                  n = t.payload;
                  r2 = "function" === typeof n ? n.call(y, q, r2) : n;
                  if (null === r2 || void 0 === r2) break a;
                  q = A({}, q, r2);
                  break a;
                case 2:
                  jh = true;
              }
            }
            null !== h.callback && 0 !== h.lane && (a.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [h] : r2.push(h));
          } else y = { eventTime: y, lane: r2, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r2;
          h = h.next;
          if (null === h) if (h = e.shared.pending, null === h) break;
          else r2 = h, h = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
        } while (1);
        null === m && (k = q);
        e.baseState = k;
        e.firstBaseUpdate = l;
        e.lastBaseUpdate = m;
        b = e.shared.interleaved;
        if (null !== b) {
          e = b;
          do
            g |= e.lane, e = e.next;
          while (e !== b);
        } else null === f && (e.shared.lanes = 0);
        rh |= g;
        a.lanes = g;
        a.memoizedState = q;
      }
    }
    function sh(a, b, c) {
      a = b.effects;
      b.effects = null;
      if (null !== a) for (b = 0; b < a.length; b++) {
        var d = a[b], e = d.callback;
        if (null !== e) {
          d.callback = null;
          d = c;
          if ("function" !== typeof e) throw Error(p(191, e));
          e.call(d);
        }
      }
    }
    var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
    function xh(a) {
      if (a === th) throw Error(p(174));
      return a;
    }
    function yh(a, b) {
      G(wh, b);
      G(vh, a);
      G(uh, th);
      a = b.nodeType;
      switch (a) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
          break;
        default:
          a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
      }
      E(uh);
      G(uh, b);
    }
    function zh() {
      E(uh);
      E(vh);
      E(wh);
    }
    function Ah(a) {
      xh(wh.current);
      var b = xh(uh.current);
      var c = lb(b, a.type);
      b !== c && (G(vh, a), G(uh, c));
    }
    function Bh(a) {
      vh.current === a && (E(uh), E(vh));
    }
    var L = Uf(0);
    function Ch(a) {
      for (var b = a; null !== b; ) {
        if (13 === b.tag) {
          var c = b.memoizedState;
          if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.flags & 128)) return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    var Dh = [];
    function Eh() {
      for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
      Dh.length = 0;
    }
    var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
    function P() {
      throw Error(p(321));
    }
    function Mh(a, b) {
      if (null === b) return false;
      for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
      return true;
    }
    function Nh(a, b, c, d, e, f) {
      Hh = f;
      M = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
      a = c(d, e);
      if (Jh) {
        f = 0;
        do {
          Jh = false;
          Kh = 0;
          if (25 <= f) throw Error(p(301));
          f += 1;
          O = N = null;
          b.updateQueue = null;
          Fh.current = Qh;
          a = c(d, e);
        } while (Jh);
      }
      Fh.current = Rh;
      b = null !== N && null !== N.next;
      Hh = 0;
      O = N = M = null;
      Ih = false;
      if (b) throw Error(p(300));
      return a;
    }
    function Sh() {
      var a = 0 !== Kh;
      Kh = 0;
      return a;
    }
    function Th() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === O ? M.memoizedState = O = a : O = O.next = a;
      return O;
    }
    function Uh() {
      if (null === N) {
        var a = M.alternate;
        a = null !== a ? a.memoizedState : null;
      } else a = N.next;
      var b = null === O ? M.memoizedState : O.next;
      if (null !== b) O = b, N = a;
      else {
        if (null === a) throw Error(p(310));
        N = a;
        a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
        null === O ? M.memoizedState = O = a : O = O.next = a;
      }
      return O;
    }
    function Vh(a, b) {
      return "function" === typeof b ? b(a) : b;
    }
    function Wh(a) {
      var b = Uh(), c = b.queue;
      if (null === c) throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = N, e = d.baseQueue, f = c.pending;
      if (null !== f) {
        if (null !== e) {
          var g = e.next;
          e.next = f.next;
          f.next = g;
        }
        d.baseQueue = e = f;
        c.pending = null;
      }
      if (null !== e) {
        f = e.next;
        d = d.baseState;
        var h = g = null, k = null, l = f;
        do {
          var m = l.lane;
          if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
          else {
            var q = {
              lane: m,
              action: l.action,
              hasEagerState: l.hasEagerState,
              eagerState: l.eagerState,
              next: null
            };
            null === k ? (h = k = q, g = d) : k = k.next = q;
            M.lanes |= m;
            rh |= m;
          }
          l = l.next;
        } while (null !== l && l !== f);
        null === k ? g = d : k.next = h;
        He(d, b.memoizedState) || (dh = true);
        b.memoizedState = d;
        b.baseState = g;
        b.baseQueue = k;
        c.lastRenderedState = d;
      }
      a = c.interleaved;
      if (null !== a) {
        e = a;
        do
          f = e.lane, M.lanes |= f, rh |= f, e = e.next;
        while (e !== a);
      } else null === e && (c.lanes = 0);
      return [b.memoizedState, c.dispatch];
    }
    function Xh(a) {
      var b = Uh(), c = b.queue;
      if (null === c) throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = c.dispatch, e = c.pending, f = b.memoizedState;
      if (null !== e) {
        c.pending = null;
        var g = e = e.next;
        do
          f = a(f, g.action), g = g.next;
        while (g !== e);
        He(f, b.memoizedState) || (dh = true);
        b.memoizedState = f;
        null === b.baseQueue && (b.baseState = f);
        c.lastRenderedState = f;
      }
      return [f, d];
    }
    function Yh() {
    }
    function Zh(a, b) {
      var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
      f && (d.memoizedState = e, dh = true);
      d = d.queue;
      $h(ai.bind(null, c, d, a), [a]);
      if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
        c.flags |= 2048;
        bi(9, ci.bind(null, c, d, e, b), void 0, null);
        if (null === Q) throw Error(p(349));
        0 !== (Hh & 30) || di(c, b, e);
      }
      return e;
    }
    function di(a, b, c) {
      a.flags |= 16384;
      a = { getSnapshot: b, value: c };
      b = M.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
    }
    function ci(a, b, c, d) {
      b.value = c;
      b.getSnapshot = d;
      ei(b) && fi(a);
    }
    function ai(a, b, c) {
      return c(function() {
        ei(b) && fi(a);
      });
    }
    function ei(a) {
      var b = a.getSnapshot;
      a = a.value;
      try {
        var c = b();
        return !He(a, c);
      } catch (d) {
        return true;
      }
    }
    function fi(a) {
      var b = ih(a, 1);
      null !== b && gi(b, a, 1, -1);
    }
    function hi(a) {
      var b = Th();
      "function" === typeof a && (a = a());
      b.memoizedState = b.baseState = a;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
      b.queue = a;
      a = a.dispatch = ii.bind(null, M, a);
      return [b.memoizedState, a];
    }
    function bi(a, b, c, d) {
      a = { tag: a, create: b, destroy: c, deps: d, next: null };
      b = M.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
      return a;
    }
    function ji() {
      return Uh().memoizedState;
    }
    function ki(a, b, c, d) {
      var e = Th();
      M.flags |= a;
      e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
    }
    function li(a, b, c, d) {
      var e = Uh();
      d = void 0 === d ? null : d;
      var f = void 0;
      if (null !== N) {
        var g = N.memoizedState;
        f = g.destroy;
        if (null !== d && Mh(d, g.deps)) {
          e.memoizedState = bi(b, c, f, d);
          return;
        }
      }
      M.flags |= a;
      e.memoizedState = bi(1 | b, c, f, d);
    }
    function mi(a, b) {
      return ki(8390656, 8, a, b);
    }
    function $h(a, b) {
      return li(2048, 8, a, b);
    }
    function ni(a, b) {
      return li(4, 2, a, b);
    }
    function oi(a, b) {
      return li(4, 4, a, b);
    }
    function pi(a, b) {
      if ("function" === typeof b) return a = a(), b(a), function() {
        b(null);
      };
      if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
        b.current = null;
      };
    }
    function qi(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return li(4, 4, pi.bind(null, b, a), c);
    }
    function ri() {
    }
    function si(a, b) {
      var c = Uh();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Mh(b, d[1])) return d[0];
      c.memoizedState = [a, b];
      return a;
    }
    function ti(a, b) {
      var c = Uh();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Mh(b, d[1])) return d[0];
      a = a();
      c.memoizedState = [a, b];
      return a;
    }
    function ui(a, b, c) {
      if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
      He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
      return b;
    }
    function vi(a, b) {
      var c = C;
      C = 0 !== c && 4 > c ? c : 4;
      a(true);
      var d = Gh.transition;
      Gh.transition = {};
      try {
        a(false), b();
      } finally {
        C = c, Gh.transition = d;
      }
    }
    function wi() {
      return Uh().memoizedState;
    }
    function xi(a, b, c) {
      var d = yi(a);
      c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
      if (zi(a)) Ai(b, c);
      else if (c = hh(a, b, c, d), null !== c) {
        var e = R();
        gi(c, a, d, e);
        Bi(c, b, d);
      }
    }
    function ii(a, b, c) {
      var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
      if (zi(a)) Ai(b, e);
      else {
        var f = a.alternate;
        if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
          var g = b.lastRenderedState, h = f(g, c);
          e.hasEagerState = true;
          e.eagerState = h;
          if (He(h, g)) {
            var k = b.interleaved;
            null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
            b.interleaved = e;
            return;
          }
        } catch (l) {
        } finally {
        }
        c = hh(a, b, e, d);
        null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
      }
    }
    function zi(a) {
      var b = a.alternate;
      return a === M || null !== b && b === M;
    }
    function Ai(a, b) {
      Jh = Ih = true;
      var c = a.pending;
      null === c ? b.next = b : (b.next = c.next, c.next = b);
      a.pending = b;
    }
    function Bi(a, b, c) {
      if (0 !== (c & 4194240)) {
        var d = b.lanes;
        d &= a.pendingLanes;
        c |= d;
        b.lanes = c;
        Cc(a, c);
      }
    }
    var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
      Th().memoizedState = [a, void 0 === b ? null : b];
      return a;
    }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ki(
        4194308,
        4,
        pi.bind(null, b, a),
        c
      );
    }, useLayoutEffect: function(a, b) {
      return ki(4194308, 4, a, b);
    }, useInsertionEffect: function(a, b) {
      return ki(4, 2, a, b);
    }, useMemo: function(a, b) {
      var c = Th();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    }, useReducer: function(a, b, c) {
      var d = Th();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
      d.queue = a;
      a = a.dispatch = xi.bind(null, M, a);
      return [d.memoizedState, a];
    }, useRef: function(a) {
      var b = Th();
      a = { current: a };
      return b.memoizedState = a;
    }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
      return Th().memoizedState = a;
    }, useTransition: function() {
      var a = hi(false), b = a[0];
      a = vi.bind(null, a[1]);
      Th().memoizedState = a;
      return [b, a];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a, b, c) {
      var d = M, e = Th();
      if (I) {
        if (void 0 === c) throw Error(p(407));
        c = c();
      } else {
        c = b();
        if (null === Q) throw Error(p(349));
        0 !== (Hh & 30) || di(d, b, c);
      }
      e.memoizedState = c;
      var f = { value: c, getSnapshot: b };
      e.queue = f;
      mi(ai.bind(
        null,
        d,
        f,
        a
      ), [a]);
      d.flags |= 2048;
      bi(9, ci.bind(null, d, f, c, b), void 0, null);
      return c;
    }, useId: function() {
      var a = Th(), b = Q.identifierPrefix;
      if (I) {
        var c = sg;
        var d = rg;
        c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
        b = ":" + b + "R" + c;
        c = Kh++;
        0 < c && (b += "H" + c.toString(32));
        b += ":";
      } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
      return a.memoizedState = b;
    }, unstable_isNewReconciler: false }, Ph = {
      readContext: eh,
      useCallback: si,
      useContext: eh,
      useEffect: $h,
      useImperativeHandle: qi,
      useInsertionEffect: ni,
      useLayoutEffect: oi,
      useMemo: ti,
      useReducer: Wh,
      useRef: ji,
      useState: function() {
        return Wh(Vh);
      },
      useDebugValue: ri,
      useDeferredValue: function(a) {
        var b = Uh();
        return ui(b, N.memoizedState, a);
      },
      useTransition: function() {
        var a = Wh(Vh)[0], b = Uh().memoizedState;
        return [a, b];
      },
      useMutableSource: Yh,
      useSyncExternalStore: Zh,
      useId: wi,
      unstable_isNewReconciler: false
    }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
      return Xh(Vh);
    }, useDebugValue: ri, useDeferredValue: function(a) {
      var b = Uh();
      return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
    }, useTransition: function() {
      var a = Xh(Vh)[0], b = Uh().memoizedState;
      return [a, b];
    }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
    function Ci(a, b) {
      if (a && a.defaultProps) {
        b = A({}, b);
        a = a.defaultProps;
        for (var c in a) void 0 === b[c] && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    function Di(a, b, c, d) {
      b = a.memoizedState;
      c = c(d, b);
      c = null === c || void 0 === c ? b : A({}, b, c);
      a.memoizedState = c;
      0 === a.lanes && (a.updateQueue.baseState = c);
    }
    var Ei = { isMounted: function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : false;
    }, enqueueSetState: function(a, b, c) {
      a = a._reactInternals;
      var d = R(), e = yi(a), f = mh(d, e);
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      b = nh(a, f, e);
      null !== b && (gi(b, a, e, d), oh(b, a, e));
    }, enqueueReplaceState: function(a, b, c) {
      a = a._reactInternals;
      var d = R(), e = yi(a), f = mh(d, e);
      f.tag = 1;
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      b = nh(a, f, e);
      null !== b && (gi(b, a, e, d), oh(b, a, e));
    }, enqueueForceUpdate: function(a, b) {
      a = a._reactInternals;
      var c = R(), d = yi(a), e = mh(c, d);
      e.tag = 2;
      void 0 !== b && null !== b && (e.callback = b);
      b = nh(a, e, d);
      null !== b && (gi(b, a, d, c), oh(b, a, d));
    } };
    function Fi(a, b, c, d, e, f, g) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
    }
    function Gi(a, b, c) {
      var d = false, e = Vf;
      var f = b.contextType;
      "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
      b = new b(c, f);
      a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = Ei;
      a.stateNode = b;
      b._reactInternals = a;
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
      return b;
    }
    function Hi(a, b, c, d) {
      a = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
      b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
    }
    function Ii(a, b, c, d) {
      var e = a.stateNode;
      e.props = c;
      e.state = a.memoizedState;
      e.refs = {};
      kh(a);
      var f = b.contextType;
      "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
      e.state = a.memoizedState;
      f = b.getDerivedStateFromProps;
      "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
      "function" === typeof e.componentDidMount && (a.flags |= 4194308);
    }
    function Ji(a, b) {
      try {
        var c = "", d = b;
        do
          c += Pa(d), d = d.return;
        while (d);
        var e = c;
      } catch (f) {
        e = "\nError generating stack: " + f.message + "\n" + f.stack;
      }
      return { value: a, source: b, stack: e, digest: null };
    }
    function Ki(a, b, c) {
      return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
    }
    function Li(a, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    var Mi = "function" === typeof WeakMap ? WeakMap : Map;
    function Ni(a, b, c) {
      c = mh(-1, c);
      c.tag = 3;
      c.payload = { element: null };
      var d = b.value;
      c.callback = function() {
        Oi || (Oi = true, Pi = d);
        Li(a, b);
      };
      return c;
    }
    function Qi(a, b, c) {
      c = mh(-1, c);
      c.tag = 3;
      var d = a.type.getDerivedStateFromError;
      if ("function" === typeof d) {
        var e = b.value;
        c.payload = function() {
          return d(e);
        };
        c.callback = function() {
          Li(a, b);
        };
      }
      var f = a.stateNode;
      null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
        Li(a, b);
        "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
        var c2 = b.stack;
        this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
      });
      return c;
    }
    function Si(a, b, c) {
      var d = a.pingCache;
      if (null === d) {
        d = a.pingCache = new Mi();
        var e = /* @__PURE__ */ new Set();
        d.set(b, e);
      } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
      e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
    }
    function Ui(a) {
      do {
        var b;
        if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
        if (b) return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    function Vi(a, b, c, d, e) {
      if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
      a.flags |= 65536;
      a.lanes = e;
      return a;
    }
    var Wi = ua.ReactCurrentOwner, dh = false;
    function Xi(a, b, c, d) {
      b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
    }
    function Yi(a, b, c, d, e) {
      c = c.render;
      var f = b.ref;
      ch(b, e);
      d = Nh(a, b, c, d, f, e);
      c = Sh();
      if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
      I && c && vg(b);
      b.flags |= 1;
      Xi(a, b, d, e);
      return b.child;
    }
    function $i(a, b, c, d, e) {
      if (null === a) {
        var f = c.type;
        if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
        a = Rg(c.type, null, d, b, b.mode, e);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      f = a.child;
      if (0 === (a.lanes & e)) {
        var g = f.memoizedProps;
        c = c.compare;
        c = null !== c ? c : Ie;
        if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
      }
      b.flags |= 1;
      a = Pg(f, d);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    function bj(a, b, c, d, e) {
      if (null !== a) {
        var f = a.memoizedProps;
        if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
        else return b.lanes = a.lanes, Zi(a, b, e);
      }
      return cj(a, b, c, d, e);
    }
    function dj(a, b, c) {
      var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
      if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
      else {
        if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
        b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
        d = null !== f ? f.baseLanes : c;
        G(ej, fj);
        fj |= d;
      }
      else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
      Xi(a, b, e, c);
      return b.child;
    }
    function gj(a, b) {
      var c = b.ref;
      if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
    }
    function cj(a, b, c, d, e) {
      var f = Zf(c) ? Xf : H.current;
      f = Yf(b, f);
      ch(b, e);
      c = Nh(a, b, c, d, f, e);
      d = Sh();
      if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
      I && d && vg(b);
      b.flags |= 1;
      Xi(a, b, c, e);
      return b.child;
    }
    function hj(a, b, c, d, e) {
      if (Zf(c)) {
        var f = true;
        cg(b);
      } else f = false;
      ch(b, e);
      if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
      else if (null === a) {
        var g = b.stateNode, h = b.memoizedProps;
        g.props = h;
        var k = g.context, l = c.contextType;
        "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
        var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
        q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
        jh = false;
        var r2 = b.memoizedState;
        g.state = r2;
        qh(b, d, g, e);
        k = b.memoizedState;
        h !== d || r2 !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r2, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
      } else {
        g = b.stateNode;
        lh(a, b);
        h = b.memoizedProps;
        l = b.type === b.elementType ? h : Ci(b.type, h);
        g.props = l;
        q = b.pendingProps;
        r2 = g.context;
        k = c.contextType;
        "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
        var y = c.getDerivedStateFromProps;
        (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r2 !== k) && Hi(b, g, d, k);
        jh = false;
        r2 = b.memoizedState;
        g.state = r2;
        qh(b, d, g, e);
        var n = b.memoizedState;
        h !== q || r2 !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r2, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), d = false);
      }
      return jj(a, b, c, d, f, e);
    }
    function jj(a, b, c, d, e, f) {
      gj(a, b);
      var g = 0 !== (b.flags & 128);
      if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
      d = b.stateNode;
      Wi.current = b;
      var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
      b.flags |= 1;
      null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
      b.memoizedState = d.state;
      e && dg(b, c, true);
      return b.child;
    }
    function kj(a) {
      var b = a.stateNode;
      b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
      yh(a, b.containerInfo);
    }
    function lj(a, b, c, d, e) {
      Ig();
      Jg(e);
      b.flags |= 256;
      Xi(a, b, c, d);
      return b.child;
    }
    var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function nj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function oj(a, b, c) {
      var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
      (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
      if (h) f = true, b.flags &= -129;
      else if (null === a || null !== a.memoizedState) e |= 1;
      G(L, e & 1);
      if (null === a) {
        Eg(b);
        a = b.memoizedState;
        if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
        g = d.children;
        a = d.fallback;
        return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
      }
      e = a.memoizedState;
      if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
      if (f) {
        f = d.fallback;
        g = b.mode;
        e = a.child;
        h = e.sibling;
        var k = { mode: "hidden", children: d.children };
        0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
        null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
        f.return = b;
        d.return = b;
        d.sibling = f;
        b.child = d;
        d = f;
        f = b.child;
        g = a.child.memoizedState;
        g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
        f.memoizedState = g;
        f.childLanes = a.childLanes & ~c;
        b.memoizedState = mj;
        return d;
      }
      f = a.child;
      a = f.sibling;
      d = Pg(f, { mode: "visible", children: d.children });
      0 === (b.mode & 1) && (d.lanes = c);
      d.return = b;
      d.sibling = null;
      null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
      b.child = d;
      b.memoizedState = null;
      return d;
    }
    function qj(a, b) {
      b = pj({ mode: "visible", children: b }, a.mode, 0, null);
      b.return = a;
      return a.child = b;
    }
    function sj(a, b, c, d) {
      null !== d && Jg(d);
      Ug(b, a.child, null, c);
      a = qj(b, b.pendingProps.children);
      a.flags |= 2;
      b.memoizedState = null;
      return a;
    }
    function rj(a, b, c, d, e, f, g) {
      if (c) {
        if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
        if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
        f = d.fallback;
        e = b.mode;
        d = pj({ mode: "visible", children: d.children }, e, 0, null);
        f = Tg(f, e, g, null);
        f.flags |= 2;
        d.return = b;
        f.return = b;
        d.sibling = f;
        b.child = d;
        0 !== (b.mode & 1) && Ug(b, a.child, null, g);
        b.child.memoizedState = nj(g);
        b.memoizedState = mj;
        return f;
      }
      if (0 === (b.mode & 1)) return sj(a, b, g, null);
      if ("$!" === e.data) {
        d = e.nextSibling && e.nextSibling.dataset;
        if (d) var h = d.dgst;
        d = h;
        f = Error(p(419));
        d = Ki(f, d, void 0);
        return sj(a, b, g, d);
      }
      h = 0 !== (g & a.childLanes);
      if (dh || h) {
        d = Q;
        if (null !== d) {
          switch (g & -g) {
            case 4:
              e = 2;
              break;
            case 16:
              e = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e = 32;
              break;
            case 536870912:
              e = 268435456;
              break;
            default:
              e = 0;
          }
          e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
          0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
        }
        tj();
        d = Ki(Error(p(421)));
        return sj(a, b, g, d);
      }
      if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
      a = f.treeContext;
      yg = Lf(e.nextSibling);
      xg = b;
      I = true;
      zg = null;
      null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
      b = qj(b, d.children);
      b.flags |= 4096;
      return b;
    }
    function vj(a, b, c) {
      a.lanes |= b;
      var d = a.alternate;
      null !== d && (d.lanes |= b);
      bh(a.return, b, c);
    }
    function wj(a, b, c, d, e) {
      var f = a.memoizedState;
      null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
    }
    function xj(a, b, c) {
      var d = b.pendingProps, e = d.revealOrder, f = d.tail;
      Xi(a, b, d.children, c);
      d = L.current;
      if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
      else {
        if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
          if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
          else if (19 === a.tag) vj(a, c, b);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b) break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b) break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
        d &= 1;
      }
      G(L, d);
      if (0 === (b.mode & 1)) b.memoizedState = null;
      else switch (e) {
        case "forwards":
          c = b.child;
          for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
          c = e;
          null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
          wj(b, false, e, c, f);
          break;
        case "backwards":
          c = null;
          e = b.child;
          for (b.child = null; null !== e; ) {
            a = e.alternate;
            if (null !== a && null === Ch(a)) {
              b.child = e;
              break;
            }
            a = e.sibling;
            e.sibling = c;
            c = e;
            e = a;
          }
          wj(b, true, c, null, f);
          break;
        case "together":
          wj(b, false, null, null, void 0);
          break;
        default:
          b.memoizedState = null;
      }
      return b.child;
    }
    function ij(a, b) {
      0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
    }
    function Zi(a, b, c) {
      null !== a && (b.dependencies = a.dependencies);
      rh |= b.lanes;
      if (0 === (c & b.childLanes)) return null;
      if (null !== a && b.child !== a.child) throw Error(p(153));
      if (null !== b.child) {
        a = b.child;
        c = Pg(a, a.pendingProps);
        b.child = c;
        for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
        c.sibling = null;
      }
      return b.child;
    }
    function yj(a, b, c) {
      switch (b.tag) {
        case 3:
          kj(b);
          Ig();
          break;
        case 5:
          Ah(b);
          break;
        case 1:
          Zf(b.type) && cg(b);
          break;
        case 4:
          yh(b, b.stateNode.containerInfo);
          break;
        case 10:
          var d = b.type._context, e = b.memoizedProps.value;
          G(Wg, d._currentValue);
          d._currentValue = e;
          break;
        case 13:
          d = b.memoizedState;
          if (null !== d) {
            if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
            if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
            G(L, L.current & 1);
            a = Zi(a, b, c);
            return null !== a ? a.sibling : null;
          }
          G(L, L.current & 1);
          break;
        case 19:
          d = 0 !== (c & b.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d) return xj(a, b, c);
            b.flags |= 128;
          }
          e = b.memoizedState;
          null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
          G(L, L.current);
          if (d) break;
          else return null;
        case 22:
        case 23:
          return b.lanes = 0, dj(a, b, c);
      }
      return Zi(a, b, c);
    }
    var zj, Aj, Bj, Cj;
    zj = function(a, b) {
      for (var c = b.child; null !== c; ) {
        if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
        else if (4 !== c.tag && null !== c.child) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b) break;
        for (; null === c.sibling; ) {
          if (null === c.return || c.return === b) return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    };
    Aj = function() {
    };
    Bj = function(a, b, c, d) {
      var e = a.memoizedProps;
      if (e !== d) {
        a = b.stateNode;
        xh(uh.current);
        var f = null;
        switch (c) {
          case "input":
            e = Ya(a, e);
            d = Ya(a, d);
            f = [];
            break;
          case "select":
            e = A({}, e, { value: void 0 });
            d = A({}, d, { value: void 0 });
            f = [];
            break;
          case "textarea":
            e = gb(a, e);
            d = gb(a, d);
            f = [];
            break;
          default:
            "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
        }
        ub(c, d);
        var g;
        c = null;
        for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
          var h = e[l];
          for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
        for (l in d) {
          var k = d[l];
          h = null != e ? e[l] : void 0;
          if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
            for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
            for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          } else c || (f || (f = []), f.push(
            l,
            c
          )), c = k;
          else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
        }
        c && (f = f || []).push("style", c);
        var l = f;
        if (b.updateQueue = l) b.flags |= 4;
      }
    };
    Cj = function(a, b, c, d) {
      c !== d && (b.flags |= 4);
    };
    function Dj(a, b) {
      if (!I) switch (a.tailMode) {
        case "hidden":
          b = a.tail;
          for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
          null === c ? a.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = a.tail;
          for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
          null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
      }
    }
    function S(a) {
      var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
      if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
      else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
      a.subtreeFlags |= d;
      a.childLanes = c;
      return b;
    }
    function Ej(a, b, c) {
      var d = b.pendingProps;
      wg(b);
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b), null;
        case 1:
          return Zf(b.type) && $f(), S(b), null;
        case 3:
          d = b.stateNode;
          zh();
          E(Wf);
          E(H);
          Eh();
          d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
          if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
          Aj(a, b);
          S(b);
          return null;
        case 5:
          Bh(b);
          var e = xh(wh.current);
          c = b.type;
          if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          else {
            if (!d) {
              if (null === b.stateNode) throw Error(p(166));
              S(b);
              return null;
            }
            a = xh(uh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c = b.type;
              var f = b.memoizedProps;
              d[Of] = b;
              d[Pf] = f;
              a = 0 !== (b.mode & 1);
              switch (c) {
                case "dialog":
                  D("cancel", d);
                  D("close", d);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d);
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], d);
                  break;
                case "source":
                  D("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d
                  );
                  D("load", d);
                  break;
                case "details":
                  D("toggle", d);
                  break;
                case "input":
                  Za(d, f);
                  D("invalid", d);
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!f.multiple };
                  D("invalid", d);
                  break;
                case "textarea":
                  hb(d, f), D("invalid", d);
              }
              ub(c, f);
              e = null;
              for (var g in f) if (f.hasOwnProperty(g)) {
                var h = f[g];
                "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                  d.textContent,
                  h,
                  a
                ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
              }
              switch (c) {
                case "input":
                  Va(d);
                  db(d, f, true);
                  break;
                case "textarea":
                  Va(d);
                  jb(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f.onClick && (d.onclick = Bf);
              }
              d = e;
              b.updateQueue = d;
              null !== d && (b.flags |= 4);
            } else {
              g = 9 === e.nodeType ? e : e.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
              "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
              a[Of] = b;
              a[Pf] = d;
              zj(a, b, false, false);
              b.stateNode = a;
              a: {
                g = vb(c, d);
                switch (c) {
                  case "dialog":
                    D("cancel", a);
                    D("close", a);
                    e = d;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a);
                    e = d;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], a);
                    e = d;
                    break;
                  case "source":
                    D("error", a);
                    e = d;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    );
                    D("load", a);
                    e = d;
                    break;
                  case "details":
                    D("toggle", a);
                    e = d;
                    break;
                  case "input":
                    Za(a, d);
                    e = Ya(a, d);
                    D("invalid", a);
                    break;
                  case "option":
                    e = d;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d.multiple };
                    e = A({}, d, { value: void 0 });
                    D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d);
                    e = gb(a, d);
                    D("invalid", a);
                    break;
                  default:
                    e = d;
                }
                ub(c, e);
                h = e;
                for (f in h) if (h.hasOwnProperty(f)) {
                  var k = h[f];
                  "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                }
                switch (c) {
                  case "input":
                    Va(a);
                    db(a, d, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d.value && a.setAttribute("value", "" + Sa(d.value));
                    break;
                  case "select":
                    a.multiple = !!d.multiple;
                    f = d.value;
                    null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                      a,
                      !!d.multiple,
                      d.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e.onClick && (a.onclick = Bf);
                }
                switch (c) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d = !!d.autoFocus;
                    break a;
                  case "img":
                    d = true;
                    break a;
                  default:
                    d = false;
                }
              }
              d && (b.flags |= 4);
            }
            null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          }
          S(b);
          return null;
        case 6:
          if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
          else {
            if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
            c = xh(wh.current);
            xh(uh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c = b.memoizedProps;
              d[Of] = b;
              if (f = d.nodeValue !== c) {
                if (a = xg, null !== a) switch (a.tag) {
                  case 3:
                    Af(d.nodeValue, c, 0 !== (a.mode & 1));
                    break;
                  case 5:
                    true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                }
              }
              f && (b.flags |= 4);
            } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
          }
          S(b);
          return null;
        case 13:
          E(L);
          d = b.memoizedState;
          if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
            if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
            else if (f = Gg(b), null !== d && null !== d.dehydrated) {
              if (null === a) {
                if (!f) throw Error(p(318));
                f = b.memoizedState;
                f = null !== f ? f.dehydrated : null;
                if (!f) throw Error(p(317));
                f[Of] = b;
              } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
              S(b);
              f = false;
            } else null !== zg && (Fj(zg), zg = null), f = true;
            if (!f) return b.flags & 65536 ? b : null;
          }
          if (0 !== (b.flags & 128)) return b.lanes = c, b;
          d = null !== d;
          d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
          null !== b.updateQueue && (b.flags |= 4);
          S(b);
          return null;
        case 4:
          return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
        case 10:
          return ah(b.type._context), S(b), null;
        case 17:
          return Zf(b.type) && $f(), S(b), null;
        case 19:
          E(L);
          f = b.memoizedState;
          if (null === f) return S(b), null;
          d = 0 !== (b.flags & 128);
          g = f.rendering;
          if (null === g) if (d) Dj(f, false);
          else {
            if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
              g = Ch(a);
              if (null !== g) {
                b.flags |= 128;
                Dj(f, false);
                d = g.updateQueue;
                null !== d && (b.updateQueue = d, b.flags |= 4);
                b.subtreeFlags = 0;
                d = c;
                for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                G(L, L.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
            null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
          }
          else {
            if (!d) if (a = Ch(g), null !== a) {
              if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
            } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
            f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
          }
          if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
          S(b);
          return null;
        case 22:
        case 23:
          return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p(156, b.tag));
    }
    function Ij(a, b) {
      wg(b);
      switch (b.tag) {
        case 1:
          return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 3:
          return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
        case 5:
          return Bh(b), null;
        case 13:
          E(L);
          a = b.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b.alternate) throw Error(p(340));
            Ig();
          }
          a = b.flags;
          return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 19:
          return E(L), null;
        case 4:
          return zh(), null;
        case 10:
          return ah(b.type._context), null;
        case 22:
        case 23:
          return Hj(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
    function Lj(a, b) {
      var c = a.ref;
      if (null !== c) if ("function" === typeof c) try {
        c(null);
      } catch (d) {
        W(a, b, d);
      }
      else c.current = null;
    }
    function Mj(a, b, c) {
      try {
        c();
      } catch (d) {
        W(a, b, d);
      }
    }
    var Nj = false;
    function Oj(a, b) {
      Cf = dd;
      a = Me();
      if (Ne(a)) {
        if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
        else a: {
          c = (c = a.ownerDocument) && c.defaultView || window;
          var d = c.getSelection && c.getSelection();
          if (d && 0 !== d.rangeCount) {
            c = d.anchorNode;
            var e = d.anchorOffset, f = d.focusNode;
            d = d.focusOffset;
            try {
              c.nodeType, f.nodeType;
            } catch (F) {
              c = null;
              break a;
            }
            var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r2 = null;
            b: for (; ; ) {
              for (var y; ; ) {
                q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                3 === q.nodeType && (g += q.nodeValue.length);
                if (null === (y = q.firstChild)) break;
                r2 = q;
                q = y;
              }
              for (; ; ) {
                if (q === a) break b;
                r2 === c && ++l === e && (h = g);
                r2 === f && ++m === d && (k = g);
                if (null !== (y = q.nextSibling)) break;
                q = r2;
                r2 = q.parentNode;
              }
              q = y;
            }
            c = -1 === h || -1 === k ? null : { start: h, end: k };
          } else c = null;
        }
        c = c || { start: 0, end: 0 };
      } else c = null;
      Df = { focusedElem: a, selectionRange: c };
      dd = false;
      for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
      else for (; null !== V; ) {
        b = V;
        try {
          var n = b.alternate;
          if (0 !== (b.flags & 1024)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (null !== n) {
                var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                x.__reactInternalSnapshotBeforeUpdate = w;
              }
              break;
            case 3:
              var u = b.stateNode.containerInfo;
              1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(p(163));
          }
        } catch (F) {
          W(b, b.return, F);
        }
        a = b.sibling;
        if (null !== a) {
          a.return = b.return;
          V = a;
          break;
        }
        V = b.return;
      }
      n = Nj;
      Nj = false;
      return n;
    }
    function Pj(a, b, c) {
      var d = b.updateQueue;
      d = null !== d ? d.lastEffect : null;
      if (null !== d) {
        var e = d = d.next;
        do {
          if ((e.tag & a) === a) {
            var f = e.destroy;
            e.destroy = void 0;
            void 0 !== f && Mj(b, c, f);
          }
          e = e.next;
        } while (e !== d);
      }
    }
    function Qj(a, b) {
      b = b.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        var c = b = b.next;
        do {
          if ((c.tag & a) === a) {
            var d = c.create;
            c.destroy = d();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    function Rj(a) {
      var b = a.ref;
      if (null !== b) {
        var c = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c;
            break;
          default:
            a = c;
        }
        "function" === typeof b ? b(a) : b.current = a;
      }
    }
    function Sj(a) {
      var b = a.alternate;
      null !== b && (a.alternate = null, Sj(b));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    function Tj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    function Uj(a) {
      a: for (; ; ) {
        for (; null === a.sibling; ) {
          if (null === a.return || Tj(a.return)) return null;
          a = a.return;
        }
        a.sibling.return = a.return;
        for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
          if (a.flags & 2) continue a;
          if (null === a.child || 4 === a.tag) continue a;
          else a.child.return = a, a = a.child;
        }
        if (!(a.flags & 2)) return a.stateNode;
      }
    }
    function Vj(a, b, c) {
      var d = a.tag;
      if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
      else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
    }
    function Wj(a, b, c) {
      var d = a.tag;
      if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
      else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
    }
    var X2 = null, Xj = false;
    function Yj(a, b, c) {
      for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
    }
    function Zj(a, b, c) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
        lc.onCommitFiberUnmount(kc, c);
      } catch (h) {
      }
      switch (c.tag) {
        case 5:
          U || Lj(c, b);
        case 6:
          var d = X2, e = Xj;
          X2 = null;
          Yj(a, b, c);
          X2 = d;
          Xj = e;
          null !== X2 && (Xj ? (a = X2, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X2.removeChild(c.stateNode));
          break;
        case 18:
          null !== X2 && (Xj ? (a = X2, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X2, c.stateNode));
          break;
        case 4:
          d = X2;
          e = Xj;
          X2 = c.stateNode.containerInfo;
          Xj = true;
          Yj(a, b, c);
          X2 = d;
          Xj = e;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
            e = d = d.next;
            do {
              var f = e, g = f.destroy;
              f = f.tag;
              void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
              e = e.next;
            } while (e !== d);
          }
          Yj(a, b, c);
          break;
        case 1:
          if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
            d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
          } catch (h) {
            W(c, b, h);
          }
          Yj(a, b, c);
          break;
        case 21:
          Yj(a, b, c);
          break;
        case 22:
          c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
          break;
        default:
          Yj(a, b, c);
      }
    }
    function ak(a) {
      var b = a.updateQueue;
      if (null !== b) {
        a.updateQueue = null;
        var c = a.stateNode;
        null === c && (c = a.stateNode = new Kj());
        b.forEach(function(b2) {
          var d = bk.bind(null, a, b2);
          c.has(b2) || (c.add(b2), b2.then(d, d));
        });
      }
    }
    function ck(a, b) {
      var c = b.deletions;
      if (null !== c) for (var d = 0; d < c.length; d++) {
        var e = c[d];
        try {
          var f = a, g = b, h = g;
          a: for (; null !== h; ) {
            switch (h.tag) {
              case 5:
                X2 = h.stateNode;
                Xj = false;
                break a;
              case 3:
                X2 = h.stateNode.containerInfo;
                Xj = true;
                break a;
              case 4:
                X2 = h.stateNode.containerInfo;
                Xj = true;
                break a;
            }
            h = h.return;
          }
          if (null === X2) throw Error(p(160));
          Zj(f, g, e);
          X2 = null;
          Xj = false;
          var k = e.alternate;
          null !== k && (k.return = null);
          e.return = null;
        } catch (l) {
          W(e, b, l);
        }
      }
      if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
    }
    function dk(a, b) {
      var c = a.alternate, d = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ck(b, a);
          ek(a);
          if (d & 4) {
            try {
              Pj(3, a, a.return), Qj(3, a);
            } catch (t) {
              W(a, a.return, t);
            }
            try {
              Pj(5, a, a.return);
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 1:
          ck(b, a);
          ek(a);
          d & 512 && null !== c && Lj(c, c.return);
          break;
        case 5:
          ck(b, a);
          ek(a);
          d & 512 && null !== c && Lj(c, c.return);
          if (a.flags & 32) {
            var e = a.stateNode;
            try {
              ob(e, "");
            } catch (t) {
              W(a, a.return, t);
            }
          }
          if (d & 4 && (e = a.stateNode, null != e)) {
            var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
            a.updateQueue = null;
            if (null !== k) try {
              "input" === h && "radio" === f.type && null != f.name && ab(e, f);
              vb(h, g);
              var l = vb(h, f);
              for (g = 0; g < k.length; g += 2) {
                var m = k[g], q = k[g + 1];
                "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
              }
              switch (h) {
                case "input":
                  bb(e, f);
                  break;
                case "textarea":
                  ib(e, f);
                  break;
                case "select":
                  var r2 = e._wrapperState.wasMultiple;
                  e._wrapperState.wasMultiple = !!f.multiple;
                  var y = f.value;
                  null != y ? fb(e, !!f.multiple, y, false) : r2 !== !!f.multiple && (null != f.defaultValue ? fb(
                    e,
                    !!f.multiple,
                    f.defaultValue,
                    true
                  ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
              }
              e[Pf] = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 6:
          ck(b, a);
          ek(a);
          if (d & 4) {
            if (null === a.stateNode) throw Error(p(162));
            e = a.stateNode;
            f = a.memoizedProps;
            try {
              e.nodeValue = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 3:
          ck(b, a);
          ek(a);
          if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
            bd(b.containerInfo);
          } catch (t) {
            W(a, a.return, t);
          }
          break;
        case 4:
          ck(b, a);
          ek(a);
          break;
        case 13:
          ck(b, a);
          ek(a);
          e = a.child;
          e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
          d & 4 && ak(a);
          break;
        case 22:
          m = null !== c && null !== c.memoizedState;
          a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
          ek(a);
          if (d & 8192) {
            l = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
              for (q = V = m; null !== V; ) {
                r2 = V;
                y = r2.child;
                switch (r2.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Pj(4, r2, r2.return);
                    break;
                  case 1:
                    Lj(r2, r2.return);
                    var n = r2.stateNode;
                    if ("function" === typeof n.componentWillUnmount) {
                      d = r2;
                      c = r2.return;
                      try {
                        b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                      } catch (t) {
                        W(d, c, t);
                      }
                    }
                    break;
                  case 5:
                    Lj(r2, r2.return);
                    break;
                  case 22:
                    if (null !== r2.memoizedState) {
                      gk(q);
                      continue;
                    }
                }
                null !== y ? (y.return = r2, V = y) : gk(q);
              }
              m = m.sibling;
            }
            a: for (m = null, q = a; ; ) {
              if (5 === q.tag) {
                if (null === m) {
                  m = q;
                  try {
                    e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                  } catch (t) {
                    W(a, a.return, t);
                  }
                }
              } else if (6 === q.tag) {
                if (null === m) try {
                  q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                } catch (t) {
                  W(a, a.return, t);
                }
              } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                q.child.return = q;
                q = q.child;
                continue;
              }
              if (q === a) break a;
              for (; null === q.sibling; ) {
                if (null === q.return || q.return === a) break a;
                m === q && (m = null);
                q = q.return;
              }
              m === q && (m = null);
              q.sibling.return = q.return;
              q = q.sibling;
            }
          }
          break;
        case 19:
          ck(b, a);
          ek(a);
          d & 4 && ak(a);
          break;
        case 21:
          break;
        default:
          ck(
            b,
            a
          ), ek(a);
      }
    }
    function ek(a) {
      var b = a.flags;
      if (b & 2) {
        try {
          a: {
            for (var c = a.return; null !== c; ) {
              if (Tj(c)) {
                var d = c;
                break a;
              }
              c = c.return;
            }
            throw Error(p(160));
          }
          switch (d.tag) {
            case 5:
              var e = d.stateNode;
              d.flags & 32 && (ob(e, ""), d.flags &= -33);
              var f = Uj(a);
              Wj(a, f, e);
              break;
            case 3:
            case 4:
              var g = d.stateNode.containerInfo, h = Uj(a);
              Vj(a, h, g);
              break;
            default:
              throw Error(p(161));
          }
        } catch (k) {
          W(a, a.return, k);
        }
        a.flags &= -3;
      }
      b & 4096 && (a.flags &= -4097);
    }
    function hk(a, b, c) {
      V = a;
      ik(a);
    }
    function ik(a, b, c) {
      for (var d = 0 !== (a.mode & 1); null !== V; ) {
        var e = V, f = e.child;
        if (22 === e.tag && d) {
          var g = null !== e.memoizedState || Jj;
          if (!g) {
            var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
            h = Jj;
            var l = U;
            Jj = g;
            if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
            for (; null !== f; ) V = f, ik(f), f = f.sibling;
            V = e;
            Jj = h;
            U = l;
          }
          kk(a);
        } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a);
      }
    }
    function kk(a) {
      for (; null !== V; ) {
        var b = V;
        if (0 !== (b.flags & 8772)) {
          var c = b.alternate;
          try {
            if (0 !== (b.flags & 8772)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                U || Qj(5, b);
                break;
              case 1:
                var d = b.stateNode;
                if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
                else {
                  var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                  d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                }
                var f = b.updateQueue;
                null !== f && sh(b, f, d);
                break;
              case 3:
                var g = b.updateQueue;
                if (null !== g) {
                  c = null;
                  if (null !== b.child) switch (b.child.tag) {
                    case 5:
                      c = b.child.stateNode;
                      break;
                    case 1:
                      c = b.child.stateNode;
                  }
                  sh(b, g, c);
                }
                break;
              case 5:
                var h = b.stateNode;
                if (null === c && b.flags & 4) {
                  c = h;
                  var k = b.memoizedProps;
                  switch (b.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      k.autoFocus && c.focus();
                      break;
                    case "img":
                      k.src && (c.src = k.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (null === b.memoizedState) {
                  var l = b.alternate;
                  if (null !== l) {
                    var m = l.memoizedState;
                    if (null !== m) {
                      var q = m.dehydrated;
                      null !== q && bd(q);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(p(163));
            }
            U || b.flags & 512 && Rj(b);
          } catch (r2) {
            W(b, b.return, r2);
          }
        }
        if (b === a) {
          V = null;
          break;
        }
        c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    function gk(a) {
      for (; null !== V; ) {
        var b = V;
        if (b === a) {
          V = null;
          break;
        }
        var c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    function jk(a) {
      for (; null !== V; ) {
        var b = V;
        try {
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              var c = b.return;
              try {
                Qj(4, b);
              } catch (k) {
                W(b, c, k);
              }
              break;
            case 1:
              var d = b.stateNode;
              if ("function" === typeof d.componentDidMount) {
                var e = b.return;
                try {
                  d.componentDidMount();
                } catch (k) {
                  W(b, e, k);
                }
              }
              var f = b.return;
              try {
                Rj(b);
              } catch (k) {
                W(b, f, k);
              }
              break;
            case 5:
              var g = b.return;
              try {
                Rj(b);
              } catch (k) {
                W(b, g, k);
              }
          }
        } catch (k) {
          W(b, b.return, k);
        }
        if (b === a) {
          V = null;
          break;
        }
        var h = b.sibling;
        if (null !== h) {
          h.return = b.return;
          V = h;
          break;
        }
        V = b.return;
      }
    }
    var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
    function R() {
      return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
    }
    function yi(a) {
      if (0 === (a.mode & 1)) return 1;
      if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
      if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
      a = C;
      if (0 !== a) return a;
      a = window.event;
      a = void 0 === a ? 16 : jd(a.type);
      return a;
    }
    function gi(a, b, c, d) {
      if (50 < yk) throw yk = 0, zk = null, Error(p(185));
      Ac(a, c, d);
      if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
    }
    function Dk(a, b) {
      var c = a.callbackNode;
      wc(a, b);
      var d = uc(a, a === Q ? Z : 0);
      if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
      else if (b = d & -d, a.callbackPriority !== b) {
        null != c && bc(c);
        if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
          0 === (K & 6) && jg();
        }), c = null;
        else {
          switch (Dc(d)) {
            case 1:
              c = fc;
              break;
            case 4:
              c = gc;
              break;
            case 16:
              c = hc;
              break;
            case 536870912:
              c = jc;
              break;
            default:
              c = hc;
          }
          c = Fk(c, Gk.bind(null, a));
        }
        a.callbackPriority = b;
        a.callbackNode = c;
      }
    }
    function Gk(a, b) {
      Ak = -1;
      Bk = 0;
      if (0 !== (K & 6)) throw Error(p(327));
      var c = a.callbackNode;
      if (Hk() && a.callbackNode !== c) return null;
      var d = uc(a, a === Q ? Z : 0);
      if (0 === d) return null;
      if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
      else {
        b = d;
        var e = K;
        K |= 2;
        var f = Jk();
        if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
        do
          try {
            Lk();
            break;
          } catch (h) {
            Mk(a, h);
          }
        while (1);
        $g();
        mk.current = f;
        K = e;
        null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
      }
      if (0 !== b) {
        2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
        if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
        if (6 === b) Ck(a, d);
        else {
          e = a.current.alternate;
          if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
          a.finishedWork = e;
          a.finishedLanes = d;
          switch (b) {
            case 0:
            case 1:
              throw Error(p(345));
            case 2:
              Pk(a, tk, uk);
              break;
            case 3:
              Ck(a, d);
              if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                if (0 !== uc(a, 0)) break;
                e = a.suspendedLanes;
                if ((e & d) !== d) {
                  R();
                  a.pingedLanes |= a.suspendedLanes & e;
                  break;
                }
                a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                break;
              }
              Pk(a, tk, uk);
              break;
            case 4:
              Ck(a, d);
              if ((d & 4194240) === d) break;
              b = a.eventTimes;
              for (e = -1; 0 < d; ) {
                var g = 31 - oc(d);
                f = 1 << g;
                g = b[g];
                g > e && (e = g);
                d &= ~f;
              }
              d = e;
              d = B() - d;
              d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
              if (10 < d) {
                a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                break;
              }
              Pk(a, tk, uk);
              break;
            case 5:
              Pk(a, tk, uk);
              break;
            default:
              throw Error(p(329));
          }
        }
      }
      Dk(a, B());
      return a.callbackNode === c ? Gk.bind(null, a) : null;
    }
    function Nk(a, b) {
      var c = sk;
      a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
      a = Ik(a, b);
      2 !== a && (b = tk, tk = c, null !== b && Fj(b));
      return a;
    }
    function Fj(a) {
      null === tk ? tk = a : tk.push.apply(tk, a);
    }
    function Ok(a) {
      for (var b = a; ; ) {
        if (b.flags & 16384) {
          var c = b.updateQueue;
          if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
            var e = c[d], f = e.getSnapshot;
            e = e.value;
            try {
              if (!He(f(), e)) return false;
            } catch (g) {
              return false;
            }
          }
        }
        c = b.child;
        if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
        else {
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return true;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return true;
    }
    function Ck(a, b) {
      b &= ~rk;
      b &= ~qk;
      a.suspendedLanes |= b;
      a.pingedLanes &= ~b;
      for (a = a.expirationTimes; 0 < b; ) {
        var c = 31 - oc(b), d = 1 << c;
        a[c] = -1;
        b &= ~d;
      }
    }
    function Ek(a) {
      if (0 !== (K & 6)) throw Error(p(327));
      Hk();
      var b = uc(a, 0);
      if (0 === (b & 1)) return Dk(a, B()), null;
      var c = Ik(a, b);
      if (0 !== a.tag && 2 === c) {
        var d = xc(a);
        0 !== d && (b = d, c = Nk(a, d));
      }
      if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
      if (6 === c) throw Error(p(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b;
      Pk(a, tk, uk);
      Dk(a, B());
      return null;
    }
    function Qk(a, b) {
      var c = K;
      K |= 1;
      try {
        return a(b);
      } finally {
        K = c, 0 === K && (Gj = B() + 500, fg && jg());
      }
    }
    function Rk(a) {
      null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
      var b = K;
      K |= 1;
      var c = ok.transition, d = C;
      try {
        if (ok.transition = null, C = 1, a) return a();
      } finally {
        C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
      }
    }
    function Hj() {
      fj = ej.current;
      E(ej);
    }
    function Kk(a, b) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c = a.timeoutHandle;
      -1 !== c && (a.timeoutHandle = -1, Gf(c));
      if (null !== Y) for (c = Y.return; null !== c; ) {
        var d = c;
        wg(d);
        switch (d.tag) {
          case 1:
            d = d.type.childContextTypes;
            null !== d && void 0 !== d && $f();
            break;
          case 3:
            zh();
            E(Wf);
            E(H);
            Eh();
            break;
          case 5:
            Bh(d);
            break;
          case 4:
            zh();
            break;
          case 13:
            E(L);
            break;
          case 19:
            E(L);
            break;
          case 10:
            ah(d.type._context);
            break;
          case 22:
          case 23:
            Hj();
        }
        c = c.return;
      }
      Q = a;
      Y = a = Pg(a.current, null);
      Z = fj = b;
      T = 0;
      pk = null;
      rk = qk = rh = 0;
      tk = sk = null;
      if (null !== fh) {
        for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
          c.interleaved = null;
          var e = d.next, f = c.pending;
          if (null !== f) {
            var g = f.next;
            f.next = e;
            d.next = g;
          }
          c.pending = d;
        }
        fh = null;
      }
      return a;
    }
    function Mk(a, b) {
      do {
        var c = Y;
        try {
          $g();
          Fh.current = Rh;
          if (Ih) {
            for (var d = M.memoizedState; null !== d; ) {
              var e = d.queue;
              null !== e && (e.pending = null);
              d = d.next;
            }
            Ih = false;
          }
          Hh = 0;
          O = N = M = null;
          Jh = false;
          Kh = 0;
          nk.current = null;
          if (null === c || null === c.return) {
            T = 1;
            pk = b;
            Y = null;
            break;
          }
          a: {
            var f = a, g = c.return, h = c, k = b;
            b = Z;
            h.flags |= 32768;
            if (null !== k && "object" === typeof k && "function" === typeof k.then) {
              var l = k, m = h, q = m.tag;
              if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                var r2 = m.alternate;
                r2 ? (m.updateQueue = r2.updateQueue, m.memoizedState = r2.memoizedState, m.lanes = r2.lanes) : (m.updateQueue = null, m.memoizedState = null);
              }
              var y = Ui(g);
              if (null !== y) {
                y.flags &= -257;
                Vi(y, g, h, f, b);
                y.mode & 1 && Si(f, l, b);
                b = y;
                k = l;
                var n = b.updateQueue;
                if (null === n) {
                  var t = /* @__PURE__ */ new Set();
                  t.add(k);
                  b.updateQueue = t;
                } else n.add(k);
                break a;
              } else {
                if (0 === (b & 1)) {
                  Si(f, l, b);
                  tj();
                  break a;
                }
                k = Error(p(426));
              }
            } else if (I && h.mode & 1) {
              var J = Ui(g);
              if (null !== J) {
                0 === (J.flags & 65536) && (J.flags |= 256);
                Vi(J, g, h, f, b);
                Jg(Ji(k, h));
                break a;
              }
            }
            f = k = Ji(k, h);
            4 !== T && (T = 2);
            null === sk ? sk = [f] : sk.push(f);
            f = g;
            do {
              switch (f.tag) {
                case 3:
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var x = Ni(f, k, b);
                  ph(f, x);
                  break a;
                case 1:
                  h = k;
                  var w = f.type, u = f.stateNode;
                  if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var F = Qi(f, h, b);
                    ph(f, F);
                    break a;
                  }
              }
              f = f.return;
            } while (null !== f);
          }
          Sk(c);
        } catch (na) {
          b = na;
          Y === c && null !== c && (Y = c = c.return);
          continue;
        }
        break;
      } while (1);
    }
    function Jk() {
      var a = mk.current;
      mk.current = Rh;
      return null === a ? Rh : a;
    }
    function tj() {
      if (0 === T || 3 === T || 2 === T) T = 4;
      null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
    }
    function Ik(a, b) {
      var c = K;
      K |= 2;
      var d = Jk();
      if (Q !== a || Z !== b) uk = null, Kk(a, b);
      do
        try {
          Tk();
          break;
        } catch (e) {
          Mk(a, e);
        }
      while (1);
      $g();
      K = c;
      mk.current = d;
      if (null !== Y) throw Error(p(261));
      Q = null;
      Z = 0;
      return T;
    }
    function Tk() {
      for (; null !== Y; ) Uk(Y);
    }
    function Lk() {
      for (; null !== Y && !cc(); ) Uk(Y);
    }
    function Uk(a) {
      var b = Vk(a.alternate, a, fj);
      a.memoizedProps = a.pendingProps;
      null === b ? Sk(a) : Y = b;
      nk.current = null;
    }
    function Sk(a) {
      var b = a;
      do {
        var c = b.alternate;
        a = b.return;
        if (0 === (b.flags & 32768)) {
          if (c = Ej(c, b, fj), null !== c) {
            Y = c;
            return;
          }
        } else {
          c = Ij(c, b);
          if (null !== c) {
            c.flags &= 32767;
            Y = c;
            return;
          }
          if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b = b.sibling;
        if (null !== b) {
          Y = b;
          return;
        }
        Y = b = a;
      } while (null !== b);
      0 === T && (T = 5);
    }
    function Pk(a, b, c) {
      var d = C, e = ok.transition;
      try {
        ok.transition = null, C = 1, Wk(a, b, c, d);
      } finally {
        ok.transition = e, C = d;
      }
      return null;
    }
    function Wk(a, b, c, d) {
      do
        Hk();
      while (null !== wk);
      if (0 !== (K & 6)) throw Error(p(327));
      c = a.finishedWork;
      var e = a.finishedLanes;
      if (null === c) return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c === a.current) throw Error(p(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f = c.lanes | c.childLanes;
      Bc(a, f);
      a === Q && (Y = Q = null, Z = 0);
      0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
        Hk();
        return null;
      }));
      f = 0 !== (c.flags & 15990);
      if (0 !== (c.subtreeFlags & 15990) || f) {
        f = ok.transition;
        ok.transition = null;
        var g = C;
        C = 1;
        var h = K;
        K |= 4;
        nk.current = null;
        Oj(a, c);
        dk(c, a);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a.current = c;
        hk(c);
        dc();
        K = h;
        C = g;
        ok.transition = f;
      } else a.current = c;
      vk && (vk = false, wk = a, xk = e);
      f = a.pendingLanes;
      0 === f && (Ri = null);
      mc(c.stateNode);
      Dk(a, B());
      if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
      if (Oi) throw Oi = false, a = Pi, Pi = null, a;
      0 !== (xk & 1) && 0 !== a.tag && Hk();
      f = a.pendingLanes;
      0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
      jg();
      return null;
    }
    function Hk() {
      if (null !== wk) {
        var a = Dc(xk), b = ok.transition, c = C;
        try {
          ok.transition = null;
          C = 16 > a ? 16 : a;
          if (null === wk) var d = false;
          else {
            a = wk;
            wk = null;
            xk = 0;
            if (0 !== (K & 6)) throw Error(p(331));
            var e = K;
            K |= 4;
            for (V = a.current; null !== V; ) {
              var f = V, g = f.child;
              if (0 !== (V.flags & 16)) {
                var h = f.deletions;
                if (null !== h) {
                  for (var k = 0; k < h.length; k++) {
                    var l = h[k];
                    for (V = l; null !== V; ) {
                      var m = V;
                      switch (m.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(8, m, f);
                      }
                      var q = m.child;
                      if (null !== q) q.return = m, V = q;
                      else for (; null !== V; ) {
                        m = V;
                        var r2 = m.sibling, y = m.return;
                        Sj(m);
                        if (m === l) {
                          V = null;
                          break;
                        }
                        if (null !== r2) {
                          r2.return = y;
                          V = r2;
                          break;
                        }
                        V = y;
                      }
                    }
                  }
                  var n = f.alternate;
                  if (null !== n) {
                    var t = n.child;
                    if (null !== t) {
                      n.child = null;
                      do {
                        var J = t.sibling;
                        t.sibling = null;
                        t = J;
                      } while (null !== t);
                    }
                  }
                  V = f;
                }
              }
              if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
              else b: for (; null !== V; ) {
                f = V;
                if (0 !== (f.flags & 2048)) switch (f.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Pj(9, f, f.return);
                }
                var x = f.sibling;
                if (null !== x) {
                  x.return = f.return;
                  V = x;
                  break b;
                }
                V = f.return;
              }
            }
            var w = a.current;
            for (V = w; null !== V; ) {
              g = V;
              var u = g.child;
              if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
              else b: for (g = w; null !== V; ) {
                h = V;
                if (0 !== (h.flags & 2048)) try {
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, h);
                  }
                } catch (na) {
                  W(h, h.return, na);
                }
                if (h === g) {
                  V = null;
                  break b;
                }
                var F = h.sibling;
                if (null !== F) {
                  F.return = h.return;
                  V = F;
                  break b;
                }
                V = h.return;
              }
            }
            K = e;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
              lc.onPostCommitFiberRoot(kc, a);
            } catch (na) {
            }
            d = true;
          }
          return d;
        } finally {
          C = c, ok.transition = b;
        }
      }
      return false;
    }
    function Xk(a, b, c) {
      b = Ji(c, b);
      b = Ni(a, b, 1);
      a = nh(a, b, 1);
      b = R();
      null !== a && (Ac(a, 1, b), Dk(a, b));
    }
    function W(a, b, c) {
      if (3 === a.tag) Xk(a, a, c);
      else for (; null !== b; ) {
        if (3 === b.tag) {
          Xk(b, a, c);
          break;
        } else if (1 === b.tag) {
          var d = b.stateNode;
          if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
            a = Ji(c, a);
            a = Qi(b, a, 1);
            b = nh(b, a, 1);
            a = R();
            null !== b && (Ac(b, 1, a), Dk(b, a));
            break;
          }
        }
        b = b.return;
      }
    }
    function Ti(a, b, c) {
      var d = a.pingCache;
      null !== d && d.delete(b);
      b = R();
      a.pingedLanes |= a.suspendedLanes & c;
      Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
      Dk(a, b);
    }
    function Yk(a, b) {
      0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c = R();
      a = ih(a, b);
      null !== a && (Ac(a, b, c), Dk(a, c));
    }
    function uj(a) {
      var b = a.memoizedState, c = 0;
      null !== b && (c = b.retryLane);
      Yk(a, c);
    }
    function bk(a, b) {
      var c = 0;
      switch (a.tag) {
        case 13:
          var d = a.stateNode;
          var e = a.memoizedState;
          null !== e && (c = e.retryLane);
          break;
        case 19:
          d = a.stateNode;
          break;
        default:
          throw Error(p(314));
      }
      null !== d && d.delete(b);
      Yk(a, c);
    }
    var Vk;
    Vk = function(a, b, c) {
      if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
      else {
        if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
        dh = 0 !== (a.flags & 131072) ? true : false;
      }
      else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          var d = b.type;
          ij(a, b);
          a = b.pendingProps;
          var e = Yf(b, H.current);
          ch(b, c);
          e = Nh(null, b, d, a, e, c);
          var f = Sh();
          b.flags |= 1;
          "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
          return b;
        case 16:
          d = b.elementType;
          a: {
            ij(a, b);
            a = b.pendingProps;
            e = d._init;
            d = e(d._payload);
            b.type = d;
            e = b.tag = Zk(d);
            a = Ci(d, a);
            switch (e) {
              case 0:
                b = cj(null, b, d, a, c);
                break a;
              case 1:
                b = hj(null, b, d, a, c);
                break a;
              case 11:
                b = Yi(null, b, d, a, c);
                break a;
              case 14:
                b = $i(null, b, d, Ci(d.type, a), c);
                break a;
            }
            throw Error(p(
              306,
              d,
              ""
            ));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
        case 3:
          a: {
            kj(b);
            if (null === a) throw Error(p(387));
            d = b.pendingProps;
            f = b.memoizedState;
            e = f.element;
            lh(a, b);
            qh(b, d, null, c);
            var g = b.memoizedState;
            d = g.element;
            if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
              e = Ji(Error(p(423)), b);
              b = lj(a, b, d, c, e);
              break a;
            } else if (d !== e) {
              e = Ji(Error(p(424)), b);
              b = lj(a, b, d, c, e);
              break a;
            } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
            else {
              Ig();
              if (d === e) {
                b = Zi(a, b, c);
                break a;
              }
              Xi(a, b, d, c);
            }
            b = b.child;
          }
          return b;
        case 5:
          return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
        case 6:
          return null === a && Eg(b), null;
        case 13:
          return oj(a, b, c);
        case 4:
          return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
        case 7:
          return Xi(a, b, b.pendingProps, c), b.child;
        case 8:
          return Xi(a, b, b.pendingProps.children, c), b.child;
        case 12:
          return Xi(a, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            d = b.type._context;
            e = b.pendingProps;
            f = b.memoizedProps;
            g = e.value;
            G(Wg, d._currentValue);
            d._currentValue = g;
            if (null !== f) if (He(f.value, g)) {
              if (f.children === e.children && !Wf.current) {
                b = Zi(a, b, c);
                break a;
              }
            } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
              var h = f.dependencies;
              if (null !== h) {
                g = f.child;
                for (var k = h.firstContext; null !== k; ) {
                  if (k.context === d) {
                    if (1 === f.tag) {
                      k = mh(-1, c & -c);
                      k.tag = 2;
                      var l = f.updateQueue;
                      if (null !== l) {
                        l = l.shared;
                        var m = l.pending;
                        null === m ? k.next = k : (k.next = m.next, m.next = k);
                        l.pending = k;
                      }
                    }
                    f.lanes |= c;
                    k = f.alternate;
                    null !== k && (k.lanes |= c);
                    bh(
                      f.return,
                      c,
                      b
                    );
                    h.lanes |= c;
                    break;
                  }
                  k = k.next;
                }
              } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
              else if (18 === f.tag) {
                g = f.return;
                if (null === g) throw Error(p(341));
                g.lanes |= c;
                h = g.alternate;
                null !== h && (h.lanes |= c);
                bh(g, c, b);
                g = f.sibling;
              } else g = f.child;
              if (null !== g) g.return = f;
              else for (g = f; null !== g; ) {
                if (g === b) {
                  g = null;
                  break;
                }
                f = g.sibling;
                if (null !== f) {
                  f.return = g.return;
                  g = f;
                  break;
                }
                g = g.return;
              }
              f = g;
            }
            Xi(a, b, e.children, c);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
        case 14:
          return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
        case 15:
          return bj(a, b, b.type, b.pendingProps, c);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
        case 19:
          return xj(a, b, c);
        case 22:
          return dj(a, b, c);
      }
      throw Error(p(156, b.tag));
    };
    function Fk(a, b) {
      return ac(a, b);
    }
    function $k(a, b, c, d) {
      this.tag = a;
      this.key = c;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a, b, c, d) {
      return new $k(a, b, c, d);
    }
    function aj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function Zk(a) {
      if ("function" === typeof a) return aj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da) return 11;
        if (a === Ga) return 14;
      }
      return 2;
    }
    function Pg(a, b) {
      var c = a.alternate;
      null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
      c.flags = a.flags & 14680064;
      c.childLanes = a.childLanes;
      c.lanes = a.lanes;
      c.child = a.child;
      c.memoizedProps = a.memoizedProps;
      c.memoizedState = a.memoizedState;
      c.updateQueue = a.updateQueue;
      b = a.dependencies;
      c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
      c.sibling = a.sibling;
      c.index = a.index;
      c.ref = a.ref;
      return c;
    }
    function Rg(a, b, c, d, e, f) {
      var g = 2;
      d = a;
      if ("function" === typeof a) aj(a) && (g = 1);
      else if ("string" === typeof a) g = 5;
      else a: switch (a) {
        case ya:
          return Tg(c.children, e, f, b);
        case za:
          g = 8;
          e |= 8;
          break;
        case Aa:
          return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
        case Ea:
          return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
        case Fa:
          return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
        case Ia:
          return pj(c, e, f, b);
        default:
          if ("object" === typeof a && null !== a) switch (a.$$typeof) {
            case Ba:
              g = 10;
              break a;
            case Ca:
              g = 9;
              break a;
            case Da:
              g = 11;
              break a;
            case Ga:
              g = 14;
              break a;
            case Ha:
              g = 16;
              d = null;
              break a;
          }
          throw Error(p(130, null == a ? a : typeof a, ""));
      }
      b = Bg(g, c, b, e);
      b.elementType = a;
      b.type = d;
      b.lanes = f;
      return b;
    }
    function Tg(a, b, c, d) {
      a = Bg(7, a, d, b);
      a.lanes = c;
      return a;
    }
    function pj(a, b, c, d) {
      a = Bg(22, a, d, b);
      a.elementType = Ia;
      a.lanes = c;
      a.stateNode = { isHidden: false };
      return a;
    }
    function Qg(a, b, c) {
      a = Bg(6, a, null, b);
      a.lanes = c;
      return a;
    }
    function Sg(a, b, c) {
      b = Bg(4, null !== a.children ? a.children : [], a.key, b);
      b.lanes = c;
      b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b;
    }
    function al(a, b, c, d, e) {
      this.tag = b;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d;
      this.onRecoverableError = e;
      this.mutableSourceEagerHydrationData = null;
    }
    function bl(a, b, c, d, e, f, g, h, k) {
      a = new al(a, b, c, h, k);
      1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
      f = Bg(3, null, null, b);
      a.current = f;
      f.stateNode = a;
      f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      kh(f);
      return a;
    }
    function cl(a, b, c) {
      var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
    }
    function dl(a) {
      if (!a) return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
        var b = a;
        do {
          switch (b.tag) {
            case 3:
              b = b.stateNode.context;
              break a;
            case 1:
              if (Zf(b.type)) {
                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b = b.return;
        } while (null !== b);
        throw Error(p(171));
      }
      if (1 === a.tag) {
        var c = a.type;
        if (Zf(c)) return bg(a, c, b);
      }
      return b;
    }
    function el(a, b, c, d, e, f, g, h, k) {
      a = bl(c, d, true, a, e, f, g, h, k);
      a.context = dl(null);
      c = a.current;
      d = R();
      e = yi(c);
      f = mh(d, e);
      f.callback = void 0 !== b && null !== b ? b : null;
      nh(c, f, e);
      a.current.lanes = e;
      Ac(a, e, d);
      Dk(a, d);
      return a;
    }
    function fl(a, b, c, d) {
      var e = b.current, f = R(), g = yi(e);
      c = dl(c);
      null === b.context ? b.context = c : b.pendingContext = c;
      b = mh(f, g);
      b.payload = { element: a };
      d = void 0 === d ? null : d;
      null !== d && (b.callback = d);
      a = nh(e, b, g);
      null !== a && (gi(a, e, g, f), oh(a, e, g));
      return g;
    }
    function gl(a) {
      a = a.current;
      if (!a.child) return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function hl(a, b) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c = a.retryLane;
        a.retryLane = 0 !== c && c < b ? c : b;
      }
    }
    function il(a, b) {
      hl(a, b);
      (a = a.alternate) && hl(a, b);
    }
    function jl() {
      return null;
    }
    var kl = "function" === typeof reportError ? reportError : function(a) {
      console.error(a);
    };
    function ll(a) {
      this._internalRoot = a;
    }
    ml.prototype.render = ll.prototype.render = function(a) {
      var b = this._internalRoot;
      if (null === b) throw Error(p(409));
      fl(a, b, null, null);
    };
    ml.prototype.unmount = ll.prototype.unmount = function() {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b = a.containerInfo;
        Rk(function() {
          fl(null, a, null, null);
        });
        b[uf] = null;
      }
    };
    function ml(a) {
      this._internalRoot = a;
    }
    ml.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b = Hc();
        a = { blockedOn: null, target: a, priority: b };
        for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
        Qc.splice(c, 0, a);
        0 === c && Vc(a);
      }
    };
    function nl(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
    }
    function ol(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    function pl() {
    }
    function ql(a, b, c, d, e) {
      if (e) {
        if ("function" === typeof d) {
          var f = d;
          d = function() {
            var a2 = gl(g);
            f.call(a2);
          };
        }
        var g = el(b, d, a, 0, null, false, false, "", pl);
        a._reactRootContainer = g;
        a[uf] = g.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Rk();
        return g;
      }
      for (; e = a.lastChild; ) a.removeChild(e);
      if ("function" === typeof d) {
        var h = d;
        d = function() {
          var a2 = gl(k);
          h.call(a2);
        };
      }
      var k = bl(a, 0, false, null, null, false, false, "", pl);
      a._reactRootContainer = k;
      a[uf] = k.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Rk(function() {
        fl(b, k, c, d);
      });
      return k;
    }
    function rl(a, b, c, d, e) {
      var f = c._reactRootContainer;
      if (f) {
        var g = f;
        if ("function" === typeof e) {
          var h = e;
          e = function() {
            var a2 = gl(g);
            h.call(a2);
          };
        }
        fl(b, g, a, e);
      } else g = ql(c, b, a, e, d);
      return gl(g);
    }
    Ec = function(a) {
      switch (a.tag) {
        case 3:
          var b = a.stateNode;
          if (b.current.memoizedState.isDehydrated) {
            var c = tc(b.pendingLanes);
            0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
          }
          break;
        case 13:
          Rk(function() {
            var b2 = ih(a, 1);
            if (null !== b2) {
              var c2 = R();
              gi(b2, a, 1, c2);
            }
          }), il(a, 1);
      }
    };
    Fc = function(a) {
      if (13 === a.tag) {
        var b = ih(a, 134217728);
        if (null !== b) {
          var c = R();
          gi(b, a, 134217728, c);
        }
        il(a, 134217728);
      }
    };
    Gc = function(a) {
      if (13 === a.tag) {
        var b = yi(a), c = ih(a, b);
        if (null !== c) {
          var d = R();
          gi(c, a, b, d);
        }
        il(a, b);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a, b) {
      var c = C;
      try {
        return C = a, b();
      } finally {
        C = c;
      }
    };
    yb = function(a, b, c) {
      switch (b) {
        case "input":
          bb(a, c);
          b = c.name;
          if ("radio" === c.type && null != b) {
            for (c = a; c.parentNode; ) c = c.parentNode;
            c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
            for (b = 0; b < c.length; b++) {
              var d = c[b];
              if (d !== a && d.form === a.form) {
                var e = Db(d);
                if (!e) throw Error(p(90));
                Wa(d);
                bb(d, e);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c);
          break;
        case "select":
          b = c.value, null != b && fb(a, !!c.multiple, b, false);
      }
    };
    Gb = Qk;
    Hb = Rk;
    var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
    var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      a = Zb(a);
      return null === a ? null : a.stateNode;
    }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!vl.isDisabled && vl.supportsFiber) try {
        kc = vl.inject(ul), lc = vl;
      } catch (a) {
      }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
    reactDom_production_min.createPortal = function(a, b) {
      var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!nl(b)) throw Error(p(200));
      return cl(a, b, null, c);
    };
    reactDom_production_min.createRoot = function(a, b) {
      if (!nl(a)) throw Error(p(299));
      var c = false, d = "", e = kl;
      null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
      b = bl(a, 1, false, null, null, c, false, d, e);
      a[uf] = b.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      return new ll(b);
    };
    reactDom_production_min.findDOMNode = function(a) {
      if (null == a) return null;
      if (1 === a.nodeType) return a;
      var b = a._reactInternals;
      if (void 0 === b) {
        if ("function" === typeof a.render) throw Error(p(188));
        a = Object.keys(a).join(",");
        throw Error(p(268, a));
      }
      a = Zb(b);
      a = null === a ? null : a.stateNode;
      return a;
    };
    reactDom_production_min.flushSync = function(a) {
      return Rk(a);
    };
    reactDom_production_min.hydrate = function(a, b, c) {
      if (!ol(b)) throw Error(p(200));
      return rl(null, a, b, true, c);
    };
    reactDom_production_min.hydrateRoot = function(a, b, c) {
      if (!nl(a)) throw Error(p(405));
      var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
      null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
      b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
      a[uf] = b.current;
      sf(a);
      if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
        c,
        e
      );
      return new ml(b);
    };
    reactDom_production_min.render = function(a, b, c) {
      if (!ol(b)) throw Error(p(200));
      return rl(null, a, b, false, c);
    };
    reactDom_production_min.unmountComponentAtNode = function(a) {
      if (!ol(a)) throw Error(p(40));
      return a._reactRootContainer ? (Rk(function() {
        rl(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[uf] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Qk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
      if (!ol(c)) throw Error(p(200));
      if (null == a || void 0 === a._reactInternals) throw Error(p(38));
      return rl(a, b, c, false, d);
    };
    reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
    return reactDom_production_min;
  }
  var hasRequiredReactDom;
  function requireReactDom() {
    if (hasRequiredReactDom) return reactDom.exports;
    hasRequiredReactDom = 1;
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      reactDom.exports = requireReactDom_production_min();
    }
    return reactDom.exports;
  }
  var hasRequiredClient;
  function requireClient() {
    if (hasRequiredClient) return client;
    hasRequiredClient = 1;
    var m = requireReactDom();
    {
      client.createRoot = m.createRoot;
      client.hydrateRoot = m.hydrateRoot;
    }
    return client;
  }
  var clientExports = requireClient();
  const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
  var cjs$1 = { exports: {} };
  var Draggable$1 = {};
  var propTypes = { exports: {} };
  var ReactPropTypesSecret_1;
  var hasRequiredReactPropTypesSecret;
  function requireReactPropTypesSecret() {
    if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
    hasRequiredReactPropTypesSecret = 1;
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    ReactPropTypesSecret_1 = ReactPropTypesSecret;
    return ReactPropTypesSecret_1;
  }
  var factoryWithThrowingShims;
  var hasRequiredFactoryWithThrowingShims;
  function requireFactoryWithThrowingShims() {
    if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
    hasRequiredFactoryWithThrowingShims = 1;
    var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
    function emptyFunction() {
    }
    function emptyFunctionWithReset() {
    }
    emptyFunctionWithReset.resetWarningCache = emptyFunction;
    factoryWithThrowingShims = function() {
      function shim(props, propName, componentName, location2, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          return;
        }
        var err = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        err.name = "Invariant Violation";
        throw err;
      }
      shim.isRequired = shim;
      function getShim() {
        return shim;
      }
      var ReactPropTypes = {
        array: shim,
        bigint: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,
        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
    return factoryWithThrowingShims;
  }
  var hasRequiredPropTypes;
  function requirePropTypes() {
    if (hasRequiredPropTypes) return propTypes.exports;
    hasRequiredPropTypes = 1;
    {
      propTypes.exports = /* @__PURE__ */ requireFactoryWithThrowingShims()();
    }
    return propTypes.exports;
  }
  function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    else for (t in e) e[t] && (n && (n += " "), n += t);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = ""; f < arguments.length; ) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }
  const clsx_m = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    clsx,
    default: clsx
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$3 = /* @__PURE__ */ getAugmentedNamespace(clsx_m);
  var domFns = {};
  var shims = {};
  var hasRequiredShims;
  function requireShims() {
    if (hasRequiredShims) return shims;
    hasRequiredShims = 1;
    Object.defineProperty(shims, "__esModule", {
      value: true
    });
    shims.dontSetMe = dontSetMe;
    shims.findInArray = findInArray;
    shims.int = int;
    shims.isFunction = isFunction;
    shims.isNum = isNum;
    function findInArray(array, callback) {
      for (let i = 0, length = array.length; i < length; i++) {
        if (callback.apply(callback, [array[i], i, array])) return array[i];
      }
    }
    function isFunction(func) {
      return typeof func === "function" || Object.prototype.toString.call(func) === "[object Function]";
    }
    function isNum(num) {
      return typeof num === "number" && !isNaN(num);
    }
    function int(a) {
      return parseInt(a, 10);
    }
    function dontSetMe(props, propName, componentName) {
      if (props[propName]) {
        return new Error("Invalid prop ".concat(propName, " passed to ").concat(componentName, " - do not set this, set it on the child."));
      }
    }
    return shims;
  }
  var getPrefix = {};
  var hasRequiredGetPrefix;
  function requireGetPrefix() {
    if (hasRequiredGetPrefix) return getPrefix;
    hasRequiredGetPrefix = 1;
    Object.defineProperty(getPrefix, "__esModule", {
      value: true
    });
    getPrefix.browserPrefixToKey = browserPrefixToKey;
    getPrefix.browserPrefixToStyle = browserPrefixToStyle;
    getPrefix.default = void 0;
    getPrefix.getPrefix = getPrefix$1;
    const prefixes = ["Moz", "Webkit", "O", "ms"];
    function getPrefix$1() {
      var _window$document;
      let prop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
      if (typeof window === "undefined") return "";
      const style = (_window$document = window.document) === null || _window$document === void 0 || (_window$document = _window$document.documentElement) === null || _window$document === void 0 ? void 0 : _window$document.style;
      if (!style) return "";
      if (prop in style) return "";
      for (let i = 0; i < prefixes.length; i++) {
        if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
      }
      return "";
    }
    function browserPrefixToKey(prop, prefix) {
      return prefix ? "".concat(prefix).concat(kebabToTitleCase(prop)) : prop;
    }
    function browserPrefixToStyle(prop, prefix) {
      return prefix ? "-".concat(prefix.toLowerCase(), "-").concat(prop) : prop;
    }
    function kebabToTitleCase(str) {
      let out = "";
      let shouldCapitalize = true;
      for (let i = 0; i < str.length; i++) {
        if (shouldCapitalize) {
          out += str[i].toUpperCase();
          shouldCapitalize = false;
        } else if (str[i] === "-") {
          shouldCapitalize = true;
        } else {
          out += str[i];
        }
      }
      return out;
    }
    getPrefix.default = getPrefix$1();
    return getPrefix;
  }
  var hasRequiredDomFns;
  function requireDomFns() {
    if (hasRequiredDomFns) return domFns;
    hasRequiredDomFns = 1;
    Object.defineProperty(domFns, "__esModule", {
      value: true
    });
    domFns.addClassName = addClassName;
    domFns.addEvent = addEvent;
    domFns.addUserSelectStyles = addUserSelectStyles;
    domFns.createCSSTransform = createCSSTransform;
    domFns.createSVGTransform = createSVGTransform;
    domFns.getTouch = getTouch;
    domFns.getTouchIdentifier = getTouchIdentifier;
    domFns.getTranslation = getTranslation;
    domFns.innerHeight = innerHeight;
    domFns.innerWidth = innerWidth;
    domFns.matchesSelector = matchesSelector;
    domFns.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
    domFns.offsetXYFromParent = offsetXYFromParent;
    domFns.outerHeight = outerHeight;
    domFns.outerWidth = outerWidth;
    domFns.removeClassName = removeClassName;
    domFns.removeEvent = removeEvent;
    domFns.removeUserSelectStyles = removeUserSelectStyles;
    var _shims = requireShims();
    var _getPrefix = _interopRequireWildcard(requireGetPrefix());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    let matchesSelectorFunc = "";
    function matchesSelector(el, selector) {
      if (!matchesSelectorFunc) {
        matchesSelectorFunc = (0, _shims.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(method) {
          return (0, _shims.isFunction)(el[method]);
        });
      }
      if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;
      return el[matchesSelectorFunc](selector);
    }
    function matchesSelectorAndParentsTo(el, selector, baseNode) {
      let node = el;
      do {
        if (matchesSelector(node, selector)) return true;
        if (node === baseNode) return false;
        node = node.parentNode;
      } while (node);
      return false;
    }
    function addEvent(el, event, handler, inputOptions) {
      if (!el) return;
      const options = {
        capture: true,
        ...inputOptions
      };
      if (el.addEventListener) {
        el.addEventListener(event, handler, options);
      } else if (el.attachEvent) {
        el.attachEvent("on" + event, handler);
      } else {
        el["on" + event] = handler;
      }
    }
    function removeEvent(el, event, handler, inputOptions) {
      if (!el) return;
      const options = {
        capture: true,
        ...inputOptions
      };
      if (el.removeEventListener) {
        el.removeEventListener(event, handler, options);
      } else if (el.detachEvent) {
        el.detachEvent("on" + event, handler);
      } else {
        el["on" + event] = null;
      }
    }
    function outerHeight(node) {
      let height = node.clientHeight;
      const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      height += (0, _shims.int)(computedStyle.borderTopWidth);
      height += (0, _shims.int)(computedStyle.borderBottomWidth);
      return height;
    }
    function outerWidth(node) {
      let width = node.clientWidth;
      const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      width += (0, _shims.int)(computedStyle.borderLeftWidth);
      width += (0, _shims.int)(computedStyle.borderRightWidth);
      return width;
    }
    function innerHeight(node) {
      let height = node.clientHeight;
      const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      height -= (0, _shims.int)(computedStyle.paddingTop);
      height -= (0, _shims.int)(computedStyle.paddingBottom);
      return height;
    }
    function innerWidth(node) {
      let width = node.clientWidth;
      const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      width -= (0, _shims.int)(computedStyle.paddingLeft);
      width -= (0, _shims.int)(computedStyle.paddingRight);
      return width;
    }
    function offsetXYFromParent(evt, offsetParent, scale) {
      const isBody = offsetParent === offsetParent.ownerDocument.body;
      const offsetParentRect = isBody ? {
        left: 0,
        top: 0
      } : offsetParent.getBoundingClientRect();
      const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
      const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
      return {
        x,
        y
      };
    }
    function createCSSTransform(controlPos, positionOffset) {
      const translation = getTranslation(controlPos, positionOffset, "px");
      return {
        [(0, _getPrefix.browserPrefixToKey)("transform", _getPrefix.default)]: translation
      };
    }
    function createSVGTransform(controlPos, positionOffset) {
      const translation = getTranslation(controlPos, positionOffset, "");
      return translation;
    }
    function getTranslation(_ref, positionOffset, unitSuffix) {
      let {
        x,
        y
      } = _ref;
      let translation = "translate(".concat(x).concat(unitSuffix, ",").concat(y).concat(unitSuffix, ")");
      if (positionOffset) {
        const defaultX = "".concat(typeof positionOffset.x === "string" ? positionOffset.x : positionOffset.x + unitSuffix);
        const defaultY = "".concat(typeof positionOffset.y === "string" ? positionOffset.y : positionOffset.y + unitSuffix);
        translation = "translate(".concat(defaultX, ", ").concat(defaultY, ")") + translation;
      }
      return translation;
    }
    function getTouch(e, identifier) {
      return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, (t) => identifier === t.identifier) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, (t) => identifier === t.identifier);
    }
    function getTouchIdentifier(e) {
      if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
      if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
    }
    function addUserSelectStyles(doc) {
      if (!doc) return;
      let styleEl = doc.getElementById("react-draggable-style-el");
      if (!styleEl) {
        styleEl = doc.createElement("style");
        styleEl.type = "text/css";
        styleEl.id = "react-draggable-style-el";
        styleEl.innerHTML = ".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n";
        styleEl.innerHTML += ".react-draggable-transparent-selection *::selection {all: inherit;}\n";
        doc.getElementsByTagName("head")[0].appendChild(styleEl);
      }
      if (doc.body) addClassName(doc.body, "react-draggable-transparent-selection");
    }
    function removeUserSelectStyles(doc) {
      if (!doc) return;
      try {
        if (doc.body) removeClassName(doc.body, "react-draggable-transparent-selection");
        if (doc.selection) {
          doc.selection.empty();
        } else {
          const selection = (doc.defaultView || window).getSelection();
          if (selection && selection.type !== "Caret") {
            selection.removeAllRanges();
          }
        }
      } catch (e) {
      }
    }
    function addClassName(el, className) {
      if (el.classList) {
        el.classList.add(className);
      } else {
        if (!el.className.match(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)")))) {
          el.className += " ".concat(className);
        }
      }
    }
    function removeClassName(el, className) {
      if (el.classList) {
        el.classList.remove(className);
      } else {
        el.className = el.className.replace(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)"), "g"), "");
      }
    }
    return domFns;
  }
  var positionFns = {};
  var hasRequiredPositionFns;
  function requirePositionFns() {
    if (hasRequiredPositionFns) return positionFns;
    hasRequiredPositionFns = 1;
    Object.defineProperty(positionFns, "__esModule", {
      value: true
    });
    positionFns.canDragX = canDragX;
    positionFns.canDragY = canDragY;
    positionFns.createCoreData = createCoreData;
    positionFns.createDraggableData = createDraggableData;
    positionFns.getBoundPosition = getBoundPosition;
    positionFns.getControlPosition = getControlPosition;
    positionFns.snapToGrid = snapToGrid;
    var _shims = requireShims();
    var _domFns = requireDomFns();
    function getBoundPosition(draggable, x, y) {
      if (!draggable.props.bounds) return [x, y];
      let {
        bounds
      } = draggable.props;
      bounds = typeof bounds === "string" ? bounds : cloneBounds(bounds);
      const node = findDOMNode(draggable);
      if (typeof bounds === "string") {
        const {
          ownerDocument
        } = node;
        const ownerWindow = ownerDocument.defaultView;
        let boundNode;
        if (bounds === "parent") {
          boundNode = node.parentNode;
        } else {
          boundNode = ownerDocument.querySelector(bounds);
        }
        if (!(boundNode instanceof ownerWindow.HTMLElement)) {
          throw new Error('Bounds selector "' + bounds + '" could not find an element.');
        }
        const boundNodeEl = boundNode;
        const nodeStyle = ownerWindow.getComputedStyle(node);
        const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);
        bounds = {
          left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
          top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
          right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
          bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
        };
      }
      if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
      if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);
      if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
      if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);
      return [x, y];
    }
    function snapToGrid(grid, pendingX, pendingY) {
      const x = Math.round(pendingX / grid[0]) * grid[0];
      const y = Math.round(pendingY / grid[1]) * grid[1];
      return [x, y];
    }
    function canDragX(draggable) {
      return draggable.props.axis === "both" || draggable.props.axis === "x";
    }
    function canDragY(draggable) {
      return draggable.props.axis === "both" || draggable.props.axis === "y";
    }
    function getControlPosition(e, touchIdentifier, draggableCore) {
      const touchObj = typeof touchIdentifier === "number" ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
      if (typeof touchIdentifier === "number" && !touchObj) return null;
      const node = findDOMNode(draggableCore);
      const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
      return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);
    }
    function createCoreData(draggable, x, y) {
      const isStart = !(0, _shims.isNum)(draggable.lastX);
      const node = findDOMNode(draggable);
      if (isStart) {
        return {
          node,
          deltaX: 0,
          deltaY: 0,
          lastX: x,
          lastY: y,
          x,
          y
        };
      } else {
        return {
          node,
          deltaX: x - draggable.lastX,
          deltaY: y - draggable.lastY,
          lastX: draggable.lastX,
          lastY: draggable.lastY,
          x,
          y
        };
      }
    }
    function createDraggableData(draggable, coreData) {
      const scale = draggable.props.scale;
      return {
        node: coreData.node,
        x: draggable.state.x + coreData.deltaX / scale,
        y: draggable.state.y + coreData.deltaY / scale,
        deltaX: coreData.deltaX / scale,
        deltaY: coreData.deltaY / scale,
        lastX: draggable.state.x,
        lastY: draggable.state.y
      };
    }
    function cloneBounds(bounds) {
      return {
        left: bounds.left,
        top: bounds.top,
        right: bounds.right,
        bottom: bounds.bottom
      };
    }
    function findDOMNode(draggable) {
      const node = draggable.findDOMNode();
      if (!node) {
        throw new Error("<DraggableCore>: Unmounted during event!");
      }
      return node;
    }
    return positionFns;
  }
  var DraggableCore = {};
  var log = {};
  var hasRequiredLog;
  function requireLog() {
    if (hasRequiredLog) return log;
    hasRequiredLog = 1;
    Object.defineProperty(log, "__esModule", {
      value: true
    });
    log.default = log$12;
    function log$12() {
    }
    return log;
  }
  var hasRequiredDraggableCore;
  function requireDraggableCore() {
    if (hasRequiredDraggableCore) return DraggableCore;
    hasRequiredDraggableCore = 1;
    Object.defineProperty(DraggableCore, "__esModule", {
      value: true
    });
    DraggableCore.default = void 0;
    var React2 = _interopRequireWildcard(requireReact());
    var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes());
    var _reactDom = _interopRequireDefault(requireReactDom());
    var _domFns = requireDomFns();
    var _positionFns = requirePositionFns();
    var _shims = requireShims();
    var _log = _interopRequireDefault(requireLog());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint);
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    const eventsFor = {
      touch: {
        start: "touchstart",
        move: "touchmove",
        stop: "touchend"
      },
      mouse: {
        start: "mousedown",
        move: "mousemove",
        stop: "mouseup"
      }
    };
    let dragEventFor = eventsFor.mouse;
    let DraggableCore$1 = class DraggableCore extends React2.Component {
      constructor() {
        super(...arguments);
        _defineProperty(this, "dragging", false);
        _defineProperty(this, "lastX", NaN);
        _defineProperty(this, "lastY", NaN);
        _defineProperty(this, "touchIdentifier", null);
        _defineProperty(this, "mounted", false);
        _defineProperty(this, "handleDragStart", (e) => {
          this.props.onMouseDown(e);
          if (!this.props.allowAnyClick && typeof e.button === "number" && e.button !== 0) return false;
          const thisNode = this.findDOMNode();
          if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
            throw new Error("<DraggableCore> not mounted on DragStart!");
          }
          const {
            ownerDocument
          } = thisNode;
          if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {
            return;
          }
          if (e.type === "touchstart") e.preventDefault();
          const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
          this.touchIdentifier = touchIdentifier;
          const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);
          if (position == null) return;
          const {
            x,
            y
          } = position;
          const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
          (0, _log.default)("DraggableCore: handleDragStart: %j", coreEvent);
          (0, _log.default)("calling", this.props.onStart);
          const shouldUpdate = this.props.onStart(e, coreEvent);
          if (shouldUpdate === false || this.mounted === false) return;
          if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);
          this.dragging = true;
          this.lastX = x;
          this.lastY = y;
          (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);
          (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);
        });
        _defineProperty(this, "handleDrag", (e) => {
          const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);
          if (position == null) return;
          let {
            x,
            y
          } = position;
          if (Array.isArray(this.props.grid)) {
            let deltaX = x - this.lastX, deltaY = y - this.lastY;
            [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
            if (!deltaX && !deltaY) return;
            x = this.lastX + deltaX, y = this.lastY + deltaY;
          }
          const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
          (0, _log.default)("DraggableCore: handleDrag: %j", coreEvent);
          const shouldUpdate = this.props.onDrag(e, coreEvent);
          if (shouldUpdate === false || this.mounted === false) {
            try {
              this.handleDragStop(new MouseEvent("mouseup"));
            } catch (err) {
              const event = document.createEvent("MouseEvents");
              event.initMouseEvent("mouseup", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
              this.handleDragStop(event);
            }
            return;
          }
          this.lastX = x;
          this.lastY = y;
        });
        _defineProperty(this, "handleDragStop", (e) => {
          if (!this.dragging) return;
          const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);
          if (position == null) return;
          let {
            x,
            y
          } = position;
          if (Array.isArray(this.props.grid)) {
            let deltaX = x - this.lastX || 0;
            let deltaY = y - this.lastY || 0;
            [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
            x = this.lastX + deltaX, y = this.lastY + deltaY;
          }
          const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
          const shouldContinue = this.props.onStop(e, coreEvent);
          if (shouldContinue === false || this.mounted === false) return false;
          const thisNode = this.findDOMNode();
          if (thisNode) {
            if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);
          }
          (0, _log.default)("DraggableCore: handleDragStop: %j", coreEvent);
          this.dragging = false;
          this.lastX = NaN;
          this.lastY = NaN;
          if (thisNode) {
            (0, _log.default)("DraggableCore: Removing handlers");
            (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);
            (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);
          }
        });
        _defineProperty(this, "onMouseDown", (e) => {
          dragEventFor = eventsFor.mouse;
          return this.handleDragStart(e);
        });
        _defineProperty(this, "onMouseUp", (e) => {
          dragEventFor = eventsFor.mouse;
          return this.handleDragStop(e);
        });
        _defineProperty(this, "onTouchStart", (e) => {
          dragEventFor = eventsFor.touch;
          return this.handleDragStart(e);
        });
        _defineProperty(this, "onTouchEnd", (e) => {
          dragEventFor = eventsFor.touch;
          return this.handleDragStop(e);
        });
      }
      componentDidMount() {
        this.mounted = true;
        const thisNode = this.findDOMNode();
        if (thisNode) {
          (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
            passive: false
          });
        }
      }
      componentWillUnmount() {
        this.mounted = false;
        const thisNode = this.findDOMNode();
        if (thisNode) {
          const {
            ownerDocument
          } = thisNode;
          (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
          (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
          (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
          (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
          (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
            passive: false
          });
          if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);
        }
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        var _this$props, _this$props2;
        return (_this$props = this.props) !== null && _this$props !== void 0 && _this$props.nodeRef ? (_this$props2 = this.props) === null || _this$props2 === void 0 || (_this$props2 = _this$props2.nodeRef) === null || _this$props2 === void 0 ? void 0 : _this$props2.current : _reactDom.default.findDOMNode(this);
      }
      render() {
        return /* @__PURE__ */ React2.cloneElement(React2.Children.only(this.props.children), {
          // Note: mouseMove handler is attached to document so it will still function
          // when the user drags quickly and leaves the bounds of the element.
          onMouseDown: this.onMouseDown,
          onMouseUp: this.onMouseUp,
          // onTouchStart is added on `componentDidMount` so they can be added with
          // {passive: false}, which allows it to cancel. See
          // https://developers.google.com/web/updates/2017/01/scrolling-intervention
          onTouchEnd: this.onTouchEnd
        });
      }
    };
    DraggableCore.default = DraggableCore$1;
    _defineProperty(DraggableCore$1, "displayName", "DraggableCore");
    _defineProperty(DraggableCore$1, "propTypes", {
      /**
       * `allowAnyClick` allows dragging using any mouse button.
       * By default, we only accept the left button.
       *
       * Defaults to `false`.
       */
      allowAnyClick: _propTypes.default.bool,
      children: _propTypes.default.node.isRequired,
      /**
       * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
       * with the exception of `onMouseDown`, will not fire.
       */
      disabled: _propTypes.default.bool,
      /**
       * By default, we add 'user-select:none' attributes to the document body
       * to prevent ugly text selection during drag. If this is causing problems
       * for your app, set this to `false`.
       */
      enableUserSelectHack: _propTypes.default.bool,
      /**
       * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
       * instead of using the parent node.
       */
      offsetParent: function(props, propName) {
        if (props[propName] && props[propName].nodeType !== 1) {
          throw new Error("Draggable's offsetParent must be a DOM Node.");
        }
      },
      /**
       * `grid` specifies the x and y that dragging should snap to.
       */
      grid: _propTypes.default.arrayOf(_propTypes.default.number),
      /**
       * `handle` specifies a selector to be used as the handle that initiates drag.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable handle=".handle">
       *              <div>
       *                  <div className="handle">Click me to drag</div>
       *                  <div>This is some other content</div>
       *              </div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      handle: _propTypes.default.string,
      /**
       * `cancel` specifies a selector to be used to prevent drag initialization.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *           return(
       *               <Draggable cancel=".cancel">
       *                   <div>
       *                     <div className="cancel">You can't drag from here</div>
       *                     <div>Dragging here works fine</div>
       *                   </div>
       *               </Draggable>
       *           );
       *       }
       *   });
       * ```
       */
      cancel: _propTypes.default.string,
      /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
       * Unfortunately, in order for <Draggable> to work properly, we need raw access
       * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
       * as in this example:
       *
       * function MyComponent() {
       *   const nodeRef = React.useRef(null);
       *   return (
       *     <Draggable nodeRef={nodeRef}>
       *       <div ref={nodeRef}>Example Target</div>
       *     </Draggable>
       *   );
       * }
       *
       * This can be used for arbitrarily nested components, so long as the ref ends up
       * pointing to the actual child DOM node and not a custom component.
       */
      nodeRef: _propTypes.default.object,
      /**
       * Called when dragging starts.
       * If this function returns the boolean false, dragging will be canceled.
       */
      onStart: _propTypes.default.func,
      /**
       * Called while dragging.
       * If this function returns the boolean false, dragging will be canceled.
       */
      onDrag: _propTypes.default.func,
      /**
       * Called when dragging stops.
       * If this function returns the boolean false, the drag will remain active.
       */
      onStop: _propTypes.default.func,
      /**
       * A workaround option which can be passed if onMouseDown needs to be accessed,
       * since it'll always be blocked (as there is internal use of onMouseDown)
       */
      onMouseDown: _propTypes.default.func,
      /**
       * `scale`, if set, applies scaling while dragging an element
       */
      scale: _propTypes.default.number,
      /**
       * These properties should be defined on the child, not here.
       */
      className: _shims.dontSetMe,
      style: _shims.dontSetMe,
      transform: _shims.dontSetMe
    });
    _defineProperty(DraggableCore$1, "defaultProps", {
      allowAnyClick: false,
      // by default only accept left click
      disabled: false,
      enableUserSelectHack: true,
      onStart: function() {
      },
      onDrag: function() {
      },
      onStop: function() {
      },
      onMouseDown: function() {
      },
      scale: 1
    });
    return DraggableCore;
  }
  var hasRequiredDraggable;
  function requireDraggable() {
    if (hasRequiredDraggable) return Draggable$1;
    hasRequiredDraggable = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", {
        value: true
      });
      Object.defineProperty(exports$1, "DraggableCore", {
        enumerable: true,
        get: function() {
          return _DraggableCore.default;
        }
      });
      exports$1.default = void 0;
      var React2 = _interopRequireWildcard(requireReact());
      var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes());
      var _reactDom = _interopRequireDefault(requireReactDom());
      var _clsx = _interopRequireDefault(require$$3);
      var _domFns = requireDomFns();
      var _positionFns = requirePositionFns();
      var _shims = requireShims();
      var _DraggableCore = _interopRequireDefault(requireDraggableCore());
      var _log = _interopRequireDefault(requireLog());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { default: obj };
        }
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) {
          return cache.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        if (cache) {
          cache.set(obj, newObj);
        }
        return newObj;
      }
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _defineProperty(obj, key, value) {
        key = _toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return typeof key === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (typeof input !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint);
          if (typeof res !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      class Draggable2 extends React2.Component {
        // React 16.3+
        // Arity (props, state)
        static getDerivedStateFromProps(_ref, _ref2) {
          let {
            position
          } = _ref;
          let {
            prevPropsPosition
          } = _ref2;
          if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {
            (0, _log.default)("Draggable: getDerivedStateFromProps %j", {
              position,
              prevPropsPosition
            });
            return {
              x: position.x,
              y: position.y,
              prevPropsPosition: {
                ...position
              }
            };
          }
          return null;
        }
        constructor(props) {
          super(props);
          _defineProperty(this, "onDragStart", (e, coreData) => {
            (0, _log.default)("Draggable: onDragStart: %j", coreData);
            const shouldStart = this.props.onStart(e, (0, _positionFns.createDraggableData)(this, coreData));
            if (shouldStart === false) return false;
            this.setState({
              dragging: true,
              dragged: true
            });
          });
          _defineProperty(this, "onDrag", (e, coreData) => {
            if (!this.state.dragging) return false;
            (0, _log.default)("Draggable: onDrag: %j", coreData);
            const uiData = (0, _positionFns.createDraggableData)(this, coreData);
            const newState = {
              x: uiData.x,
              y: uiData.y,
              slackX: 0,
              slackY: 0
            };
            if (this.props.bounds) {
              const {
                x,
                y
              } = newState;
              newState.x += this.state.slackX;
              newState.y += this.state.slackY;
              const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);
              newState.x = newStateX;
              newState.y = newStateY;
              newState.slackX = this.state.slackX + (x - newState.x);
              newState.slackY = this.state.slackY + (y - newState.y);
              uiData.x = newState.x;
              uiData.y = newState.y;
              uiData.deltaX = newState.x - this.state.x;
              uiData.deltaY = newState.y - this.state.y;
            }
            const shouldUpdate = this.props.onDrag(e, uiData);
            if (shouldUpdate === false) return false;
            this.setState(newState);
          });
          _defineProperty(this, "onDragStop", (e, coreData) => {
            if (!this.state.dragging) return false;
            const shouldContinue = this.props.onStop(e, (0, _positionFns.createDraggableData)(this, coreData));
            if (shouldContinue === false) return false;
            (0, _log.default)("Draggable: onDragStop: %j", coreData);
            const newState = {
              dragging: false,
              slackX: 0,
              slackY: 0
            };
            const controlled = Boolean(this.props.position);
            if (controlled) {
              const {
                x,
                y
              } = this.props.position;
              newState.x = x;
              newState.y = y;
            }
            this.setState(newState);
          });
          this.state = {
            // Whether or not we are currently dragging.
            dragging: false,
            // Whether or not we have been dragged before.
            dragged: false,
            // Current transform x and y.
            x: props.position ? props.position.x : props.defaultPosition.x,
            y: props.position ? props.position.y : props.defaultPosition.y,
            prevPropsPosition: {
              ...props.position
            },
            // Used for compensating for out-of-bounds drags
            slackX: 0,
            slackY: 0,
            // Can only determine if SVG after mounting
            isElementSVG: false
          };
          if (props.position && !(props.onDrag || props.onStop)) {
            console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
          }
        }
        componentDidMount() {
          if (typeof window.SVGElement !== "undefined" && this.findDOMNode() instanceof window.SVGElement) {
            this.setState({
              isElementSVG: true
            });
          }
        }
        componentWillUnmount() {
          this.setState({
            dragging: false
          });
        }
        // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
        // the underlying DOM node ourselves. See the README for more information.
        findDOMNode() {
          var _this$props$nodeRef$c, _this$props;
          return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 || (_this$props = _this$props.nodeRef) === null || _this$props === void 0 ? void 0 : _this$props.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);
        }
        render() {
          const {
            axis,
            bounds,
            children,
            defaultPosition,
            defaultClassName,
            defaultClassNameDragging,
            defaultClassNameDragged,
            position,
            positionOffset,
            scale,
            ...draggableCoreProps
          } = this.props;
          let style = {};
          let svgTransform = null;
          const controlled = Boolean(position);
          const draggable = !controlled || this.state.dragging;
          const validPosition = position || defaultPosition;
          const transformOpts = {
            // Set left if horizontal drag is enabled
            x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,
            // Set top if vertical drag is enabled
            y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y
          };
          if (this.state.isElementSVG) {
            svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);
          } else {
            style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);
          }
          const className = (0, _clsx.default)(children.props.className || "", defaultClassName, {
            [defaultClassNameDragging]: this.state.dragging,
            [defaultClassNameDragged]: this.state.dragged
          });
          return /* @__PURE__ */ React2.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {
            onStart: this.onDragStart,
            onDrag: this.onDrag,
            onStop: this.onDragStop
          }), /* @__PURE__ */ React2.cloneElement(React2.Children.only(children), {
            className,
            style: {
              ...children.props.style,
              ...style
            },
            transform: svgTransform
          }));
        }
      }
      exports$1.default = Draggable2;
      _defineProperty(Draggable2, "displayName", "Draggable");
      _defineProperty(Draggable2, "propTypes", {
        // Accepts all props <DraggableCore> accepts.
        ..._DraggableCore.default.propTypes,
        /**
         * `axis` determines which axis the draggable can move.
         *
         *  Note that all callbacks will still return data as normal. This only
         *  controls flushing to the DOM.
         *
         * 'both' allows movement horizontally and vertically.
         * 'x' limits movement to horizontal axis.
         * 'y' limits movement to vertical axis.
         * 'none' limits all movement.
         *
         * Defaults to 'both'.
         */
        axis: _propTypes.default.oneOf(["both", "x", "y", "none"]),
        /**
         * `bounds` determines the range of movement available to the element.
         * Available values are:
         *
         * 'parent' restricts movement within the Draggable's parent node.
         *
         * Alternatively, pass an object with the following properties, all of which are optional:
         *
         * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
         *
         * All values are in px.
         *
         * Example:
         *
         * ```jsx
         *   let App = React.createClass({
         *       render: function () {
         *         return (
         *            <Draggable bounds={{right: 300, bottom: 300}}>
         *              <div>Content</div>
         *           </Draggable>
         *         );
         *       }
         *   });
         * ```
         */
        bounds: _propTypes.default.oneOfType([_propTypes.default.shape({
          left: _propTypes.default.number,
          right: _propTypes.default.number,
          top: _propTypes.default.number,
          bottom: _propTypes.default.number
        }), _propTypes.default.string, _propTypes.default.oneOf([false])]),
        defaultClassName: _propTypes.default.string,
        defaultClassNameDragging: _propTypes.default.string,
        defaultClassNameDragged: _propTypes.default.string,
        /**
         * `defaultPosition` specifies the x and y that the dragged item should start at
         *
         * Example:
         *
         * ```jsx
         *      let App = React.createClass({
         *          render: function () {
         *              return (
         *                  <Draggable defaultPosition={{x: 25, y: 25}}>
         *                      <div>I start with transformX: 25px and transformY: 25px;</div>
         *                  </Draggable>
         *              );
         *          }
         *      });
         * ```
         */
        defaultPosition: _propTypes.default.shape({
          x: _propTypes.default.number,
          y: _propTypes.default.number
        }),
        positionOffset: _propTypes.default.shape({
          x: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
          y: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
        }),
        /**
         * `position`, if present, defines the current position of the element.
         *
         *  This is similar to how form elements in React work - if no `position` is supplied, the component
         *  is uncontrolled.
         *
         * Example:
         *
         * ```jsx
         *      let App = React.createClass({
         *          render: function () {
         *              return (
         *                  <Draggable position={{x: 25, y: 25}}>
         *                      <div>I start with transformX: 25px and transformY: 25px;</div>
         *                  </Draggable>
         *              );
         *          }
         *      });
         * ```
         */
        position: _propTypes.default.shape({
          x: _propTypes.default.number,
          y: _propTypes.default.number
        }),
        /**
         * These properties should be defined on the child, not here.
         */
        className: _shims.dontSetMe,
        style: _shims.dontSetMe,
        transform: _shims.dontSetMe
      });
      _defineProperty(Draggable2, "defaultProps", {
        ..._DraggableCore.default.defaultProps,
        axis: "both",
        bounds: false,
        defaultClassName: "react-draggable",
        defaultClassNameDragging: "react-draggable-dragging",
        defaultClassNameDragged: "react-draggable-dragged",
        defaultPosition: {
          x: 0,
          y: 0
        },
        scale: 1
      });
    })(Draggable$1);
    return Draggable$1;
  }
  var hasRequiredCjs$1;
  function requireCjs$1() {
    if (hasRequiredCjs$1) return cjs$1.exports;
    hasRequiredCjs$1 = 1;
    const {
      default: Draggable2,
      DraggableCore: DraggableCore2
    } = requireDraggable();
    cjs$1.exports = Draggable2;
    cjs$1.exports.default = Draggable2;
    cjs$1.exports.DraggableCore = DraggableCore2;
    return cjs$1.exports;
  }
  var cjsExports$1 = requireCjs$1();
  const Draggable = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports$1);
  var reactDomExports = requireReactDom();
  var __assign$3 = function() {
    __assign$3 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
      return t;
    };
    return __assign$3.apply(this, arguments);
  };
  var rowSizeBase = {
    width: "100%",
    height: "10px",
    top: "0px",
    left: "0px",
    cursor: "row-resize"
  };
  var colSizeBase = {
    width: "10px",
    height: "100%",
    top: "0px",
    left: "0px",
    cursor: "col-resize"
  };
  var edgeBase = {
    width: "20px",
    height: "20px",
    position: "absolute",
    zIndex: 1
  };
  var styles = {
    top: __assign$3(__assign$3({}, rowSizeBase), { top: "-5px" }),
    right: __assign$3(__assign$3({}, colSizeBase), { left: void 0, right: "-5px" }),
    bottom: __assign$3(__assign$3({}, rowSizeBase), { top: void 0, bottom: "-5px" }),
    left: __assign$3(__assign$3({}, colSizeBase), { left: "-5px" }),
    topRight: __assign$3(__assign$3({}, edgeBase), { right: "-10px", top: "-10px", cursor: "ne-resize" }),
    bottomRight: __assign$3(__assign$3({}, edgeBase), { right: "-10px", bottom: "-10px", cursor: "se-resize" }),
    bottomLeft: __assign$3(__assign$3({}, edgeBase), { left: "-10px", bottom: "-10px", cursor: "sw-resize" }),
    topLeft: __assign$3(__assign$3({}, edgeBase), { left: "-10px", top: "-10px", cursor: "nw-resize" })
  };
  var Resizer = reactExports.memo(function(props) {
    var onResizeStart = props.onResizeStart, direction = props.direction, children = props.children, replaceStyles = props.replaceStyles, className = props.className;
    var onMouseDown = reactExports.useCallback(function(e) {
      onResizeStart(e, direction);
    }, [onResizeStart, direction]);
    var onTouchStart = reactExports.useCallback(function(e) {
      onResizeStart(e, direction);
    }, [onResizeStart, direction]);
    var style = reactExports.useMemo(function() {
      return __assign$3(__assign$3({ position: "absolute", userSelect: "none" }, styles[direction]), replaceStyles !== null && replaceStyles !== void 0 ? replaceStyles : {});
    }, [replaceStyles, direction]);
    return jsxRuntimeExports.jsx("div", { className: className || void 0, style, onMouseDown, onTouchStart, children });
  });
  var __extends$2 = /* @__PURE__ */ (function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  })();
  var __assign$2 = function() {
    __assign$2 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
      return t;
    };
    return __assign$2.apply(this, arguments);
  };
  var DEFAULT_SIZE = {
    width: "auto",
    height: "auto"
  };
  var clamp = function(n, min, max) {
    return Math.max(Math.min(n, max), min);
  };
  var snap = function(n, size, gridGap) {
    var v = Math.round(n / size);
    return v * size + gridGap * (v - 1);
  };
  var hasDirection = function(dir, target) {
    return new RegExp(dir, "i").test(target);
  };
  var isTouchEvent = function(event) {
    return Boolean(event.touches && event.touches.length);
  };
  var isMouseEvent = function(event) {
    return Boolean((event.clientX || event.clientX === 0) && (event.clientY || event.clientY === 0));
  };
  var findClosestSnap = function(n, snapArray, snapGap) {
    if (snapGap === void 0) {
      snapGap = 0;
    }
    var closestGapIndex = snapArray.reduce(function(prev, curr, index2) {
      return Math.abs(curr - n) < Math.abs(snapArray[prev] - n) ? index2 : prev;
    }, 0);
    var gap = Math.abs(snapArray[closestGapIndex] - n);
    return snapGap === 0 || gap < snapGap ? snapArray[closestGapIndex] : n;
  };
  var getStringSize = function(n) {
    n = n.toString();
    if (n === "auto") {
      return n;
    }
    if (n.endsWith("px")) {
      return n;
    }
    if (n.endsWith("%")) {
      return n;
    }
    if (n.endsWith("vh")) {
      return n;
    }
    if (n.endsWith("vw")) {
      return n;
    }
    if (n.endsWith("vmax")) {
      return n;
    }
    if (n.endsWith("vmin")) {
      return n;
    }
    return "".concat(n, "px");
  };
  var getPixelSize = function(size, parentSize, innerWidth, innerHeight) {
    if (size && typeof size === "string") {
      if (size.endsWith("px")) {
        return Number(size.replace("px", ""));
      }
      if (size.endsWith("%")) {
        var ratio = Number(size.replace("%", "")) / 100;
        return parentSize * ratio;
      }
      if (size.endsWith("vw")) {
        var ratio = Number(size.replace("vw", "")) / 100;
        return innerWidth * ratio;
      }
      if (size.endsWith("vh")) {
        var ratio = Number(size.replace("vh", "")) / 100;
        return innerHeight * ratio;
      }
    }
    return size;
  };
  var calculateNewMax = function(parentSize, innerWidth, innerHeight, maxWidth, maxHeight, minWidth, minHeight) {
    maxWidth = getPixelSize(maxWidth, parentSize.width, innerWidth, innerHeight);
    maxHeight = getPixelSize(maxHeight, parentSize.height, innerWidth, innerHeight);
    minWidth = getPixelSize(minWidth, parentSize.width, innerWidth, innerHeight);
    minHeight = getPixelSize(minHeight, parentSize.height, innerWidth, innerHeight);
    return {
      maxWidth: typeof maxWidth === "undefined" ? void 0 : Number(maxWidth),
      maxHeight: typeof maxHeight === "undefined" ? void 0 : Number(maxHeight),
      minWidth: typeof minWidth === "undefined" ? void 0 : Number(minWidth),
      minHeight: typeof minHeight === "undefined" ? void 0 : Number(minHeight)
    };
  };
  var normalizeToPair = function(val) {
    return Array.isArray(val) ? val : [val, val];
  };
  var definedProps = [
    "as",
    "ref",
    "style",
    "className",
    "grid",
    "gridGap",
    "snap",
    "bounds",
    "boundsByDirection",
    "size",
    "defaultSize",
    "minWidth",
    "minHeight",
    "maxWidth",
    "maxHeight",
    "lockAspectRatio",
    "lockAspectRatioExtraWidth",
    "lockAspectRatioExtraHeight",
    "enable",
    "handleStyles",
    "handleClasses",
    "handleWrapperStyle",
    "handleWrapperClass",
    "children",
    "onResizeStart",
    "onResize",
    "onResizeStop",
    "handleComponent",
    "scale",
    "resizeRatio",
    "snapGap"
  ];
  var baseClassName = "__resizable_base__";
  var Resizable = (
    /** @class */
    (function(_super) {
      __extends$2(Resizable2, _super);
      function Resizable2(props) {
        var _a2, _b, _c, _d;
        var _this = _super.call(this, props) || this;
        _this.ratio = 1;
        _this.resizable = null;
        _this.parentLeft = 0;
        _this.parentTop = 0;
        _this.resizableLeft = 0;
        _this.resizableRight = 0;
        _this.resizableTop = 0;
        _this.resizableBottom = 0;
        _this.targetLeft = 0;
        _this.targetTop = 0;
        _this.delta = {
          width: 0,
          height: 0
        };
        _this.appendBase = function() {
          if (!_this.resizable || !_this.window) {
            return null;
          }
          var parent = _this.parentNode;
          if (!parent) {
            return null;
          }
          var element = _this.window.document.createElement("div");
          element.style.width = "100%";
          element.style.height = "100%";
          element.style.position = "absolute";
          element.style.transform = "scale(0, 0)";
          element.style.left = "0";
          element.style.flex = "0 0 100%";
          if (element.classList) {
            element.classList.add(baseClassName);
          } else {
            element.className += baseClassName;
          }
          parent.appendChild(element);
          return element;
        };
        _this.removeBase = function(base) {
          var parent = _this.parentNode;
          if (!parent) {
            return;
          }
          parent.removeChild(base);
        };
        _this.state = {
          isResizing: false,
          width: (_b = (_a2 = _this.propsSize) === null || _a2 === void 0 ? void 0 : _a2.width) !== null && _b !== void 0 ? _b : "auto",
          height: (_d = (_c = _this.propsSize) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : "auto",
          direction: "right",
          original: {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          },
          backgroundStyle: {
            height: "100%",
            width: "100%",
            backgroundColor: "rgba(0,0,0,0)",
            cursor: "auto",
            opacity: 0,
            position: "fixed",
            zIndex: 9999,
            top: "0",
            left: "0",
            bottom: "0",
            right: "0"
          },
          flexBasis: void 0
        };
        _this.onResizeStart = _this.onResizeStart.bind(_this);
        _this.onMouseMove = _this.onMouseMove.bind(_this);
        _this.onMouseUp = _this.onMouseUp.bind(_this);
        return _this;
      }
      Object.defineProperty(Resizable2.prototype, "parentNode", {
        get: function() {
          if (!this.resizable) {
            return null;
          }
          return this.resizable.parentNode;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Resizable2.prototype, "window", {
        get: function() {
          if (!this.resizable) {
            return null;
          }
          if (!this.resizable.ownerDocument) {
            return null;
          }
          return this.resizable.ownerDocument.defaultView;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Resizable2.prototype, "propsSize", {
        get: function() {
          return this.props.size || this.props.defaultSize || DEFAULT_SIZE;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Resizable2.prototype, "size", {
        get: function() {
          var width = 0;
          var height = 0;
          if (this.resizable && this.window) {
            var orgWidth = this.resizable.offsetWidth;
            var orgHeight = this.resizable.offsetHeight;
            var orgPosition = this.resizable.style.position;
            if (orgPosition !== "relative") {
              this.resizable.style.position = "relative";
            }
            width = this.resizable.style.width !== "auto" ? this.resizable.offsetWidth : orgWidth;
            height = this.resizable.style.height !== "auto" ? this.resizable.offsetHeight : orgHeight;
            this.resizable.style.position = orgPosition;
          }
          return { width, height };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Resizable2.prototype, "sizeStyle", {
        get: function() {
          var _this = this;
          var size = this.props.size;
          var getSize = function(key) {
            var _a2;
            if (typeof _this.state[key] === "undefined" || _this.state[key] === "auto") {
              return "auto";
            }
            if (_this.propsSize && _this.propsSize[key] && ((_a2 = _this.propsSize[key]) === null || _a2 === void 0 ? void 0 : _a2.toString().endsWith("%"))) {
              if (_this.state[key].toString().endsWith("%")) {
                return _this.state[key].toString();
              }
              var parentSize = _this.getParentSize();
              var value = Number(_this.state[key].toString().replace("px", ""));
              var percent = value / parentSize[key] * 100;
              return "".concat(percent, "%");
            }
            return getStringSize(_this.state[key]);
          };
          var width = size && typeof size.width !== "undefined" && !this.state.isResizing ? getStringSize(size.width) : getSize("width");
          var height = size && typeof size.height !== "undefined" && !this.state.isResizing ? getStringSize(size.height) : getSize("height");
          return { width, height };
        },
        enumerable: false,
        configurable: true
      });
      Resizable2.prototype.getParentSize = function() {
        if (!this.parentNode) {
          if (!this.window) {
            return { width: 0, height: 0 };
          }
          return { width: this.window.innerWidth, height: this.window.innerHeight };
        }
        var base = this.appendBase();
        if (!base) {
          return { width: 0, height: 0 };
        }
        var wrapChanged = false;
        var wrap = this.parentNode.style.flexWrap;
        if (wrap !== "wrap") {
          wrapChanged = true;
          this.parentNode.style.flexWrap = "wrap";
        }
        base.style.position = "relative";
        base.style.minWidth = "100%";
        base.style.minHeight = "100%";
        var size = {
          width: base.offsetWidth,
          height: base.offsetHeight
        };
        if (wrapChanged) {
          this.parentNode.style.flexWrap = wrap;
        }
        this.removeBase(base);
        return size;
      };
      Resizable2.prototype.bindEvents = function() {
        if (this.window) {
          this.window.addEventListener("mouseup", this.onMouseUp);
          this.window.addEventListener("mousemove", this.onMouseMove);
          this.window.addEventListener("mouseleave", this.onMouseUp);
          this.window.addEventListener("touchmove", this.onMouseMove, {
            capture: true,
            passive: false
          });
          this.window.addEventListener("touchend", this.onMouseUp);
        }
      };
      Resizable2.prototype.unbindEvents = function() {
        if (this.window) {
          this.window.removeEventListener("mouseup", this.onMouseUp);
          this.window.removeEventListener("mousemove", this.onMouseMove);
          this.window.removeEventListener("mouseleave", this.onMouseUp);
          this.window.removeEventListener("touchmove", this.onMouseMove, true);
          this.window.removeEventListener("touchend", this.onMouseUp);
        }
      };
      Resizable2.prototype.componentDidMount = function() {
        if (!this.resizable || !this.window) {
          return;
        }
        var computedStyle = this.window.getComputedStyle(this.resizable);
        this.setState({
          width: this.state.width || this.size.width,
          height: this.state.height || this.size.height,
          flexBasis: computedStyle.flexBasis !== "auto" ? computedStyle.flexBasis : void 0
        });
      };
      Resizable2.prototype.componentWillUnmount = function() {
        if (this.window) {
          this.unbindEvents();
        }
      };
      Resizable2.prototype.createSizeForCssProperty = function(newSize, kind2) {
        var propsSize = this.propsSize && this.propsSize[kind2];
        return this.state[kind2] === "auto" && this.state.original[kind2] === newSize && (typeof propsSize === "undefined" || propsSize === "auto") ? "auto" : newSize;
      };
      Resizable2.prototype.calculateNewMaxFromBoundary = function(maxWidth, maxHeight) {
        var boundsByDirection = this.props.boundsByDirection;
        var direction = this.state.direction;
        var widthByDirection = boundsByDirection && hasDirection("left", direction);
        var heightByDirection = boundsByDirection && hasDirection("top", direction);
        var boundWidth;
        var boundHeight;
        if (this.props.bounds === "parent") {
          var parent_1 = this.parentNode;
          if (parent_1) {
            boundWidth = widthByDirection ? this.resizableRight - this.parentLeft : parent_1.offsetWidth + (this.parentLeft - this.resizableLeft);
            boundHeight = heightByDirection ? this.resizableBottom - this.parentTop : parent_1.offsetHeight + (this.parentTop - this.resizableTop);
          }
        } else if (this.props.bounds === "window") {
          if (this.window) {
            boundWidth = widthByDirection ? this.resizableRight : this.window.innerWidth - this.resizableLeft;
            boundHeight = heightByDirection ? this.resizableBottom : this.window.innerHeight - this.resizableTop;
          }
        } else if (this.props.bounds) {
          boundWidth = widthByDirection ? this.resizableRight - this.targetLeft : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft);
          boundHeight = heightByDirection ? this.resizableBottom - this.targetTop : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop);
        }
        if (boundWidth && Number.isFinite(boundWidth)) {
          maxWidth = maxWidth && maxWidth < boundWidth ? maxWidth : boundWidth;
        }
        if (boundHeight && Number.isFinite(boundHeight)) {
          maxHeight = maxHeight && maxHeight < boundHeight ? maxHeight : boundHeight;
        }
        return { maxWidth, maxHeight };
      };
      Resizable2.prototype.calculateNewSizeFromDirection = function(clientX, clientY) {
        var scale = this.props.scale || 1;
        var _a2 = normalizeToPair(this.props.resizeRatio || 1), resizeRatioX = _a2[0], resizeRatioY = _a2[1];
        var _b = this.state, direction = _b.direction, original = _b.original;
        var _c = this.props, lockAspectRatio = _c.lockAspectRatio, lockAspectRatioExtraHeight = _c.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _c.lockAspectRatioExtraWidth;
        var newWidth = original.width;
        var newHeight = original.height;
        var extraHeight = lockAspectRatioExtraHeight || 0;
        var extraWidth = lockAspectRatioExtraWidth || 0;
        if (hasDirection("right", direction)) {
          newWidth = original.width + (clientX - original.x) * resizeRatioX / scale;
          if (lockAspectRatio) {
            newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
          }
        }
        if (hasDirection("left", direction)) {
          newWidth = original.width - (clientX - original.x) * resizeRatioX / scale;
          if (lockAspectRatio) {
            newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
          }
        }
        if (hasDirection("bottom", direction)) {
          newHeight = original.height + (clientY - original.y) * resizeRatioY / scale;
          if (lockAspectRatio) {
            newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
          }
        }
        if (hasDirection("top", direction)) {
          newHeight = original.height - (clientY - original.y) * resizeRatioY / scale;
          if (lockAspectRatio) {
            newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
          }
        }
        return { newWidth, newHeight };
      };
      Resizable2.prototype.calculateNewSizeFromAspectRatio = function(newWidth, newHeight, max, min) {
        var _a2 = this.props, lockAspectRatio = _a2.lockAspectRatio, lockAspectRatioExtraHeight = _a2.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _a2.lockAspectRatioExtraWidth;
        var computedMinWidth = typeof min.width === "undefined" ? 10 : min.width;
        var computedMaxWidth = typeof max.width === "undefined" || max.width < 0 ? newWidth : max.width;
        var computedMinHeight = typeof min.height === "undefined" ? 10 : min.height;
        var computedMaxHeight = typeof max.height === "undefined" || max.height < 0 ? newHeight : max.height;
        var extraHeight = lockAspectRatioExtraHeight || 0;
        var extraWidth = lockAspectRatioExtraWidth || 0;
        if (lockAspectRatio) {
          var extraMinWidth = (computedMinHeight - extraHeight) * this.ratio + extraWidth;
          var extraMaxWidth = (computedMaxHeight - extraHeight) * this.ratio + extraWidth;
          var extraMinHeight = (computedMinWidth - extraWidth) / this.ratio + extraHeight;
          var extraMaxHeight = (computedMaxWidth - extraWidth) / this.ratio + extraHeight;
          var lockedMinWidth = Math.max(computedMinWidth, extraMinWidth);
          var lockedMaxWidth = Math.min(computedMaxWidth, extraMaxWidth);
          var lockedMinHeight = Math.max(computedMinHeight, extraMinHeight);
          var lockedMaxHeight = Math.min(computedMaxHeight, extraMaxHeight);
          newWidth = clamp(newWidth, lockedMinWidth, lockedMaxWidth);
          newHeight = clamp(newHeight, lockedMinHeight, lockedMaxHeight);
        } else {
          newWidth = clamp(newWidth, computedMinWidth, computedMaxWidth);
          newHeight = clamp(newHeight, computedMinHeight, computedMaxHeight);
        }
        return { newWidth, newHeight };
      };
      Resizable2.prototype.setBoundingClientRect = function() {
        var adjustedScale = 1 / (this.props.scale || 1);
        if (this.props.bounds === "parent") {
          var parent_2 = this.parentNode;
          if (parent_2) {
            var parentRect = parent_2.getBoundingClientRect();
            this.parentLeft = parentRect.left * adjustedScale;
            this.parentTop = parentRect.top * adjustedScale;
          }
        }
        if (this.props.bounds && typeof this.props.bounds !== "string") {
          var targetRect = this.props.bounds.getBoundingClientRect();
          this.targetLeft = targetRect.left * adjustedScale;
          this.targetTop = targetRect.top * adjustedScale;
        }
        if (this.resizable) {
          var _a2 = this.resizable.getBoundingClientRect(), left = _a2.left, top_1 = _a2.top, right = _a2.right, bottom = _a2.bottom;
          this.resizableLeft = left * adjustedScale;
          this.resizableRight = right * adjustedScale;
          this.resizableTop = top_1 * adjustedScale;
          this.resizableBottom = bottom * adjustedScale;
        }
      };
      Resizable2.prototype.onResizeStart = function(event, direction) {
        if (!this.resizable || !this.window) {
          return;
        }
        var clientX = 0;
        var clientY = 0;
        if (event.nativeEvent && isMouseEvent(event.nativeEvent)) {
          clientX = event.nativeEvent.clientX;
          clientY = event.nativeEvent.clientY;
        } else if (event.nativeEvent && isTouchEvent(event.nativeEvent)) {
          clientX = event.nativeEvent.touches[0].clientX;
          clientY = event.nativeEvent.touches[0].clientY;
        }
        if (this.props.onResizeStart) {
          if (this.resizable) {
            var startResize = this.props.onResizeStart(event, direction, this.resizable);
            if (startResize === false) {
              return;
            }
          }
        }
        if (this.props.size) {
          if (typeof this.props.size.height !== "undefined" && this.props.size.height !== this.state.height) {
            this.setState({ height: this.props.size.height });
          }
          if (typeof this.props.size.width !== "undefined" && this.props.size.width !== this.state.width) {
            this.setState({ width: this.props.size.width });
          }
        }
        this.ratio = typeof this.props.lockAspectRatio === "number" ? this.props.lockAspectRatio : this.size.width / this.size.height;
        var flexBasis;
        var computedStyle = this.window.getComputedStyle(this.resizable);
        if (computedStyle.flexBasis !== "auto") {
          var parent_3 = this.parentNode;
          if (parent_3) {
            var dir = this.window.getComputedStyle(parent_3).flexDirection;
            this.flexDir = dir.startsWith("row") ? "row" : "column";
            flexBasis = computedStyle.flexBasis;
          }
        }
        this.setBoundingClientRect();
        this.bindEvents();
        var state = {
          original: {
            x: clientX,
            y: clientY,
            width: this.size.width,
            height: this.size.height
          },
          isResizing: true,
          backgroundStyle: __assign$2(__assign$2({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(event.target).cursor || "auto" }),
          direction,
          flexBasis
        };
        this.setState(state);
      };
      Resizable2.prototype.onMouseMove = function(event) {
        var _this = this;
        if (!this.state.isResizing || !this.resizable || !this.window) {
          return;
        }
        if (this.window.TouchEvent && isTouchEvent(event)) {
          try {
            event.preventDefault();
            event.stopPropagation();
          } catch (e) {
          }
        }
        var _a2 = this.props, maxWidth = _a2.maxWidth, maxHeight = _a2.maxHeight, minWidth = _a2.minWidth, minHeight = _a2.minHeight;
        var clientX = isTouchEvent(event) ? event.touches[0].clientX : event.clientX;
        var clientY = isTouchEvent(event) ? event.touches[0].clientY : event.clientY;
        var _b = this.state, direction = _b.direction, original = _b.original, width = _b.width, height = _b.height;
        var parentSize = this.getParentSize();
        var max = calculateNewMax(parentSize, this.window.innerWidth, this.window.innerHeight, maxWidth, maxHeight, minWidth, minHeight);
        maxWidth = max.maxWidth;
        maxHeight = max.maxHeight;
        minWidth = max.minWidth;
        minHeight = max.minHeight;
        var _c = this.calculateNewSizeFromDirection(clientX, clientY), newHeight = _c.newHeight, newWidth = _c.newWidth;
        var boundaryMax = this.calculateNewMaxFromBoundary(maxWidth, maxHeight);
        if (this.props.snap && this.props.snap.x) {
          newWidth = findClosestSnap(newWidth, this.props.snap.x, this.props.snapGap);
        }
        if (this.props.snap && this.props.snap.y) {
          newHeight = findClosestSnap(newHeight, this.props.snap.y, this.props.snapGap);
        }
        var newSize = this.calculateNewSizeFromAspectRatio(newWidth, newHeight, { width: boundaryMax.maxWidth, height: boundaryMax.maxHeight }, { width: minWidth, height: minHeight });
        newWidth = newSize.newWidth;
        newHeight = newSize.newHeight;
        if (this.props.grid) {
          var newGridWidth = snap(newWidth, this.props.grid[0], this.props.gridGap ? this.props.gridGap[0] : 0);
          var newGridHeight = snap(newHeight, this.props.grid[1], this.props.gridGap ? this.props.gridGap[1] : 0);
          var gap = this.props.snapGap || 0;
          var w = gap === 0 || Math.abs(newGridWidth - newWidth) <= gap ? newGridWidth : newWidth;
          var h = gap === 0 || Math.abs(newGridHeight - newHeight) <= gap ? newGridHeight : newHeight;
          newWidth = w;
          newHeight = h;
        }
        var delta = {
          width: newWidth - original.width,
          height: newHeight - original.height
        };
        this.delta = delta;
        if (width && typeof width === "string") {
          if (width.endsWith("%")) {
            var percent = newWidth / parentSize.width * 100;
            newWidth = "".concat(percent, "%");
          } else if (width.endsWith("vw")) {
            var vw = newWidth / this.window.innerWidth * 100;
            newWidth = "".concat(vw, "vw");
          } else if (width.endsWith("vh")) {
            var vh = newWidth / this.window.innerHeight * 100;
            newWidth = "".concat(vh, "vh");
          }
        }
        if (height && typeof height === "string") {
          if (height.endsWith("%")) {
            var percent = newHeight / parentSize.height * 100;
            newHeight = "".concat(percent, "%");
          } else if (height.endsWith("vw")) {
            var vw = newHeight / this.window.innerWidth * 100;
            newHeight = "".concat(vw, "vw");
          } else if (height.endsWith("vh")) {
            var vh = newHeight / this.window.innerHeight * 100;
            newHeight = "".concat(vh, "vh");
          }
        }
        var newState = {
          width: this.createSizeForCssProperty(newWidth, "width"),
          height: this.createSizeForCssProperty(newHeight, "height")
        };
        if (this.flexDir === "row") {
          newState.flexBasis = newState.width;
        } else if (this.flexDir === "column") {
          newState.flexBasis = newState.height;
        }
        var widthChanged = this.state.width !== newState.width;
        var heightChanged = this.state.height !== newState.height;
        var flexBaseChanged = this.state.flexBasis !== newState.flexBasis;
        var changed = widthChanged || heightChanged || flexBaseChanged;
        if (changed) {
          reactDomExports.flushSync(function() {
            _this.setState(newState);
          });
        }
        if (this.props.onResize) {
          if (changed) {
            this.props.onResize(event, direction, this.resizable, delta);
          }
        }
      };
      Resizable2.prototype.onMouseUp = function(event) {
        var _a2, _b;
        var _c = this.state, isResizing = _c.isResizing, direction = _c.direction;
        _c.original;
        if (!isResizing || !this.resizable) {
          return;
        }
        if (this.props.onResizeStop) {
          this.props.onResizeStop(event, direction, this.resizable, this.delta);
        }
        if (this.props.size) {
          this.setState({ width: (_a2 = this.props.size.width) !== null && _a2 !== void 0 ? _a2 : "auto", height: (_b = this.props.size.height) !== null && _b !== void 0 ? _b : "auto" });
        }
        this.unbindEvents();
        this.setState({
          isResizing: false,
          backgroundStyle: __assign$2(__assign$2({}, this.state.backgroundStyle), { cursor: "auto" })
        });
      };
      Resizable2.prototype.updateSize = function(size) {
        var _a2, _b;
        this.setState({ width: (_a2 = size.width) !== null && _a2 !== void 0 ? _a2 : "auto", height: (_b = size.height) !== null && _b !== void 0 ? _b : "auto" });
      };
      Resizable2.prototype.renderResizer = function() {
        var _this = this;
        var _a2 = this.props, enable = _a2.enable, handleStyles = _a2.handleStyles, handleClasses = _a2.handleClasses, handleWrapperStyle = _a2.handleWrapperStyle, handleWrapperClass = _a2.handleWrapperClass, handleComponent = _a2.handleComponent;
        if (!enable) {
          return null;
        }
        var resizers = Object.keys(enable).map(function(dir) {
          if (enable[dir] !== false) {
            return jsxRuntimeExports.jsx(Resizer, { direction: dir, onResizeStart: _this.onResizeStart, replaceStyles: handleStyles && handleStyles[dir], className: handleClasses && handleClasses[dir], children: handleComponent && handleComponent[dir] ? handleComponent[dir] : null }, dir);
          }
          return null;
        });
        return jsxRuntimeExports.jsx("div", { className: handleWrapperClass, style: handleWrapperStyle, children: resizers });
      };
      Resizable2.prototype.render = function() {
        var _this = this;
        var extendsProps = Object.keys(this.props).reduce(function(acc, key) {
          if (definedProps.indexOf(key) !== -1) {
            return acc;
          }
          acc[key] = _this.props[key];
          return acc;
        }, {});
        var style = __assign$2(__assign$2(__assign$2({ position: "relative", userSelect: this.state.isResizing ? "none" : "auto" }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: "border-box", flexShrink: 0 });
        if (this.state.flexBasis) {
          style.flexBasis = this.state.flexBasis;
        }
        var Wrapper = this.props.as || "div";
        return jsxRuntimeExports.jsxs(Wrapper, __assign$2({ style, className: this.props.className }, extendsProps, {
          // `ref` is after `extendsProps` to ensure this one wins over a version
          // passed in
          ref: function(c) {
            if (c) {
              _this.resizable = c;
            }
          },
          children: [this.state.isResizing && jsxRuntimeExports.jsx("div", { style: this.state.backgroundStyle }), this.props.children, this.renderResizer()]
        }));
      };
      Resizable2.defaultProps = {
        as: "div",
        onResizeStart: function() {
        },
        onResize: function() {
        },
        onResizeStop: function() {
        },
        enable: {
          top: true,
          right: true,
          bottom: true,
          left: true,
          topRight: true,
          bottomRight: true,
          bottomLeft: true,
          topLeft: true
        },
        style: {},
        grid: [1, 1],
        gridGap: [0, 0],
        lockAspectRatio: false,
        lockAspectRatioExtraWidth: 0,
        lockAspectRatioExtraHeight: 0,
        scale: 1,
        resizeRatio: 1,
        snapGap: 0
      };
      return Resizable2;
    })(reactExports.PureComponent)
  );
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
  
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
  
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
  var extendStatics$1 = function(d, b) {
    extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics$1(d, b);
  };
  function __extends$1(d, b) {
    extendStatics$1(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign2(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign$1.apply(this, arguments);
  };
  function __rest$1(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  var resizableStyle = {
    width: "auto",
    height: "auto",
    display: "inline-block",
    position: "absolute",
    top: 0,
    left: 0
  };
  var getEnableResizingByFlag = function(flag) {
    return {
      bottom: flag,
      bottomLeft: flag,
      bottomRight: flag,
      left: flag,
      right: flag,
      top: flag,
      topLeft: flag,
      topRight: flag
    };
  };
  var Rnd = (
    /** @class */
    (function(_super) {
      __extends$1(Rnd2, _super);
      function Rnd2(props) {
        var _this = _super.call(this, props) || this;
        _this.resizingPosition = { x: 0, y: 0 };
        _this.offsetFromParent = { left: 0, top: 0 };
        _this.resizableElement = { current: null };
        _this.originalPosition = { x: 0, y: 0 };
        _this.state = {
          resizing: false,
          bounds: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          },
          maxWidth: props.maxWidth,
          maxHeight: props.maxHeight
        };
        _this.onResizeStart = _this.onResizeStart.bind(_this);
        _this.onResize = _this.onResize.bind(_this);
        _this.onResizeStop = _this.onResizeStop.bind(_this);
        _this.onDragStart = _this.onDragStart.bind(_this);
        _this.onDrag = _this.onDrag.bind(_this);
        _this.onDragStop = _this.onDragStop.bind(_this);
        _this.getMaxSizesFromProps = _this.getMaxSizesFromProps.bind(_this);
        return _this;
      }
      Rnd2.prototype.componentDidMount = function() {
        this.updateOffsetFromParent();
        var _a2 = this.offsetFromParent, left = _a2.left, top = _a2.top;
        var _b = this.getDraggablePosition(), x = _b.x, y = _b.y;
        this.draggable.setState({
          x: x - left,
          y: y - top
        });
        this.forceUpdate();
      };
      Rnd2.prototype.getDraggablePosition = function() {
        var _a2 = this.draggable.state, x = _a2.x, y = _a2.y;
        return { x, y };
      };
      Rnd2.prototype.getParent = function() {
        return this.resizable && this.resizable.parentNode;
      };
      Rnd2.prototype.getParentSize = function() {
        return this.resizable.getParentSize();
      };
      Rnd2.prototype.getMaxSizesFromProps = function() {
        var maxWidth = typeof this.props.maxWidth === "undefined" ? Number.MAX_SAFE_INTEGER : this.props.maxWidth;
        var maxHeight = typeof this.props.maxHeight === "undefined" ? Number.MAX_SAFE_INTEGER : this.props.maxHeight;
        return { maxWidth, maxHeight };
      };
      Rnd2.prototype.getSelfElement = function() {
        return this.resizable && this.resizable.resizable;
      };
      Rnd2.prototype.getOffsetHeight = function(boundary) {
        var scale = this.props.scale;
        switch (this.props.bounds) {
          case "window":
            return window.innerHeight / scale;
          case "body":
            return document.body.offsetHeight / scale;
          default:
            return boundary.offsetHeight;
        }
      };
      Rnd2.prototype.getOffsetWidth = function(boundary) {
        var scale = this.props.scale;
        switch (this.props.bounds) {
          case "window":
            return window.innerWidth / scale;
          case "body":
            return document.body.offsetWidth / scale;
          default:
            return boundary.offsetWidth;
        }
      };
      Rnd2.prototype.onDragStart = function(e, data) {
        if (this.props.onDragStart) {
          this.props.onDragStart(e, data);
        }
        var pos = this.getDraggablePosition();
        this.originalPosition = pos;
        if (!this.props.bounds)
          return;
        var parent = this.getParent();
        var scale = this.props.scale;
        var boundary;
        if (this.props.bounds === "parent") {
          boundary = parent;
        } else if (this.props.bounds === "body") {
          var parentRect_1 = parent.getBoundingClientRect();
          var parentLeft_1 = parentRect_1.left;
          var parentTop_1 = parentRect_1.top;
          var bodyRect = document.body.getBoundingClientRect();
          var left_1 = -(parentLeft_1 - parent.offsetLeft * scale - bodyRect.left) / scale;
          var top_1 = -(parentTop_1 - parent.offsetTop * scale - bodyRect.top) / scale;
          var right = (document.body.offsetWidth - this.resizable.size.width * scale) / scale + left_1;
          var bottom = (document.body.offsetHeight - this.resizable.size.height * scale) / scale + top_1;
          return this.setState({ bounds: { top: top_1, right, bottom, left: left_1 } });
        } else if (this.props.bounds === "window") {
          if (!this.resizable)
            return;
          var parentRect_2 = parent.getBoundingClientRect();
          var parentLeft_2 = parentRect_2.left;
          var parentTop_2 = parentRect_2.top;
          var left_2 = -(parentLeft_2 - parent.offsetLeft * scale) / scale;
          var top_2 = -(parentTop_2 - parent.offsetTop * scale) / scale;
          var right = (window.innerWidth - this.resizable.size.width * scale) / scale + left_2;
          var bottom = (window.innerHeight - this.resizable.size.height * scale) / scale + top_2;
          return this.setState({ bounds: { top: top_2, right, bottom, left: left_2 } });
        } else if (typeof this.props.bounds === "string") {
          boundary = document.querySelector(this.props.bounds);
        } else if (this.props.bounds instanceof HTMLElement) {
          boundary = this.props.bounds;
        }
        if (!(boundary instanceof HTMLElement) || !(parent instanceof HTMLElement)) {
          return;
        }
        var boundaryRect = boundary.getBoundingClientRect();
        var boundaryLeft = boundaryRect.left;
        var boundaryTop = boundaryRect.top;
        var parentRect = parent.getBoundingClientRect();
        var parentLeft = parentRect.left;
        var parentTop = parentRect.top;
        var left = (boundaryLeft - parentLeft) / scale;
        var top = boundaryTop - parentTop;
        if (!this.resizable)
          return;
        this.updateOffsetFromParent();
        var offset = this.offsetFromParent;
        this.setState({
          bounds: {
            top: top - offset.top,
            right: left + (boundary.offsetWidth - this.resizable.size.width) - offset.left / scale,
            bottom: top + (boundary.offsetHeight - this.resizable.size.height) - offset.top,
            left: left - offset.left / scale
          }
        });
      };
      Rnd2.prototype.onDrag = function(e, data) {
        if (!this.props.onDrag)
          return;
        var _a2 = this.offsetFromParent, left = _a2.left, top = _a2.top;
        if (!this.props.dragAxis || this.props.dragAxis === "both") {
          return this.props.onDrag(e, __assign$1(__assign$1({}, data), { x: data.x + left, y: data.y + top }));
        } else if (this.props.dragAxis === "x") {
          return this.props.onDrag(e, __assign$1(__assign$1({}, data), { x: data.x + left, y: this.originalPosition.y + top, deltaY: 0 }));
        } else if (this.props.dragAxis === "y") {
          return this.props.onDrag(e, __assign$1(__assign$1({}, data), { x: this.originalPosition.x + left, y: data.y + top, deltaX: 0 }));
        }
      };
      Rnd2.prototype.onDragStop = function(e, data) {
        if (!this.props.onDragStop)
          return;
        var _a2 = this.offsetFromParent, left = _a2.left, top = _a2.top;
        if (!this.props.dragAxis || this.props.dragAxis === "both") {
          return this.props.onDragStop(e, __assign$1(__assign$1({}, data), { x: data.x + left, y: data.y + top }));
        } else if (this.props.dragAxis === "x") {
          return this.props.onDragStop(e, __assign$1(__assign$1({}, data), { x: data.x + left, y: this.originalPosition.y + top, deltaY: 0 }));
        } else if (this.props.dragAxis === "y") {
          return this.props.onDragStop(e, __assign$1(__assign$1({}, data), { x: this.originalPosition.x + left, y: data.y + top, deltaX: 0 }));
        }
      };
      Rnd2.prototype.onResizeStart = function(e, dir, elementRef) {
        e.stopPropagation();
        this.setState({
          resizing: true
        });
        var scale = this.props.scale;
        var offset = this.offsetFromParent;
        var pos = this.getDraggablePosition();
        this.resizingPosition = { x: pos.x + offset.left, y: pos.y + offset.top };
        this.originalPosition = pos;
        if (this.props.bounds) {
          var parent_1 = this.getParent();
          var boundary = void 0;
          if (this.props.bounds === "parent") {
            boundary = parent_1;
          } else if (this.props.bounds === "body") {
            boundary = document.body;
          } else if (this.props.bounds === "window") {
            boundary = window;
          } else if (typeof this.props.bounds === "string") {
            boundary = document.querySelector(this.props.bounds);
          } else if (this.props.bounds instanceof HTMLElement) {
            boundary = this.props.bounds;
          }
          var self_1 = this.getSelfElement();
          if (self_1 instanceof Element && (boundary instanceof HTMLElement || boundary === window) && parent_1 instanceof HTMLElement) {
            var _a2 = this.getMaxSizesFromProps(), maxWidth = _a2.maxWidth, maxHeight = _a2.maxHeight;
            var parentSize = this.getParentSize();
            if (maxWidth && typeof maxWidth === "string") {
              if (maxWidth.endsWith("%")) {
                var ratio = Number(maxWidth.replace("%", "")) / 100;
                maxWidth = parentSize.width * ratio;
              } else if (maxWidth.endsWith("px")) {
                maxWidth = Number(maxWidth.replace("px", ""));
              }
            }
            if (maxHeight && typeof maxHeight === "string") {
              if (maxHeight.endsWith("%")) {
                var ratio = Number(maxHeight.replace("%", "")) / 100;
                maxHeight = parentSize.height * ratio;
              } else if (maxHeight.endsWith("px")) {
                maxHeight = Number(maxHeight.replace("px", ""));
              }
            }
            var selfRect = self_1.getBoundingClientRect();
            var selfLeft = selfRect.left;
            var selfTop = selfRect.top;
            var boundaryRect = this.props.bounds === "window" ? { left: 0, top: 0 } : boundary.getBoundingClientRect();
            var boundaryLeft = boundaryRect.left;
            var boundaryTop = boundaryRect.top;
            var offsetWidth = this.getOffsetWidth(boundary);
            var offsetHeight = this.getOffsetHeight(boundary);
            var hasLeft = dir.toLowerCase().endsWith("left");
            var hasRight = dir.toLowerCase().endsWith("right");
            var hasTop = dir.startsWith("top");
            var hasBottom = dir.startsWith("bottom");
            if ((hasLeft || hasTop) && this.resizable) {
              var max = (selfLeft - boundaryLeft) / scale + this.resizable.size.width;
              this.setState({ maxWidth: max > Number(maxWidth) ? maxWidth : max });
            }
            if (hasRight || this.props.lockAspectRatio && !hasLeft && !hasTop) {
              var max = offsetWidth + (boundaryLeft - selfLeft) / scale;
              this.setState({ maxWidth: max > Number(maxWidth) ? maxWidth : max });
            }
            if ((hasTop || hasLeft) && this.resizable) {
              var max = (selfTop - boundaryTop) / scale + this.resizable.size.height;
              this.setState({
                maxHeight: max > Number(maxHeight) ? maxHeight : max
              });
            }
            if (hasBottom || this.props.lockAspectRatio && !hasTop && !hasLeft) {
              var max = offsetHeight + (boundaryTop - selfTop) / scale;
              this.setState({
                maxHeight: max > Number(maxHeight) ? maxHeight : max
              });
            }
          }
        } else {
          this.setState({
            maxWidth: this.props.maxWidth,
            maxHeight: this.props.maxHeight
          });
        }
        if (this.props.onResizeStart) {
          this.props.onResizeStart(e, dir, elementRef);
        }
      };
      Rnd2.prototype.onResize = function(e, direction, elementRef, delta) {
        var _this = this;
        var newPos = { x: this.originalPosition.x, y: this.originalPosition.y };
        var left = -delta.width;
        var top = -delta.height;
        var directions = ["top", "left", "topLeft", "bottomLeft", "topRight"];
        if (directions.includes(direction)) {
          if (direction === "bottomLeft") {
            newPos.x += left;
          } else if (direction === "topRight") {
            newPos.y += top;
          } else {
            newPos.x += left;
            newPos.y += top;
          }
        }
        var draggableState = this.draggable.state;
        if (newPos.x !== draggableState.x || newPos.y !== draggableState.y) {
          reactDomExports.flushSync(function() {
            _this.draggable.setState(newPos);
          });
        }
        this.updateOffsetFromParent();
        var offset = this.offsetFromParent;
        var x = this.getDraggablePosition().x + offset.left;
        var y = this.getDraggablePosition().y + offset.top;
        this.resizingPosition = { x, y };
        if (!this.props.onResize)
          return;
        this.props.onResize(e, direction, elementRef, delta, {
          x,
          y
        });
      };
      Rnd2.prototype.onResizeStop = function(e, direction, elementRef, delta) {
        this.setState({
          resizing: false
        });
        var _a2 = this.getMaxSizesFromProps(), maxWidth = _a2.maxWidth, maxHeight = _a2.maxHeight;
        this.setState({ maxWidth, maxHeight });
        if (this.props.onResizeStop) {
          this.props.onResizeStop(e, direction, elementRef, delta, this.resizingPosition);
        }
      };
      Rnd2.prototype.updateSize = function(size) {
        if (!this.resizable)
          return;
        this.resizable.updateSize({ width: size.width, height: size.height });
      };
      Rnd2.prototype.updatePosition = function(position) {
        this.draggable.setState(position);
      };
      Rnd2.prototype.updateOffsetFromParent = function() {
        var scale = this.props.scale;
        var parent = this.getParent();
        var self2 = this.getSelfElement();
        if (!parent || self2 === null) {
          return {
            top: 0,
            left: 0
          };
        }
        var parentRect = parent.getBoundingClientRect();
        var parentLeft = parentRect.left;
        var parentTop = parentRect.top;
        var selfRect = self2.getBoundingClientRect();
        var position = this.getDraggablePosition();
        var scrollLeft = parent.scrollLeft;
        var scrollTop = parent.scrollTop;
        this.offsetFromParent = {
          left: selfRect.left - parentLeft + scrollLeft - position.x * scale,
          top: selfRect.top - parentTop + scrollTop - position.y * scale
        };
      };
      Rnd2.prototype.render = function() {
        var _this = this;
        var _a2 = this.props, disableDragging = _a2.disableDragging, style = _a2.style, dragHandleClassName = _a2.dragHandleClassName, position = _a2.position, onMouseDown = _a2.onMouseDown, onMouseUp = _a2.onMouseUp, dragAxis = _a2.dragAxis, dragGrid = _a2.dragGrid, bounds = _a2.bounds, enableUserSelectHack = _a2.enableUserSelectHack, cancel = _a2.cancel, children = _a2.children;
        _a2.onResizeStart;
        _a2.onResize;
        _a2.onResizeStop;
        _a2.onDragStart;
        _a2.onDrag;
        _a2.onDragStop;
        var resizeHandleStyles = _a2.resizeHandleStyles, resizeHandleClasses = _a2.resizeHandleClasses, resizeHandleComponent = _a2.resizeHandleComponent, enableResizing = _a2.enableResizing, resizeGrid = _a2.resizeGrid, resizeHandleWrapperClass = _a2.resizeHandleWrapperClass, resizeHandleWrapperStyle = _a2.resizeHandleWrapperStyle, scale = _a2.scale, allowAnyClick = _a2.allowAnyClick, dragPositionOffset = _a2.dragPositionOffset, resizableProps = __rest$1(_a2, ["disableDragging", "style", "dragHandleClassName", "position", "onMouseDown", "onMouseUp", "dragAxis", "dragGrid", "bounds", "enableUserSelectHack", "cancel", "children", "onResizeStart", "onResize", "onResizeStop", "onDragStart", "onDrag", "onDragStop", "resizeHandleStyles", "resizeHandleClasses", "resizeHandleComponent", "enableResizing", "resizeGrid", "resizeHandleWrapperClass", "resizeHandleWrapperStyle", "scale", "allowAnyClick", "dragPositionOffset"]);
        var defaultValue = this.props.default ? __assign$1({}, this.props.default) : void 0;
        delete resizableProps.default;
        var cursorStyle = disableDragging || dragHandleClassName ? { cursor: "auto" } : { cursor: "move" };
        var innerStyle = __assign$1(__assign$1(__assign$1({}, resizableStyle), cursorStyle), style);
        var _b = this.offsetFromParent, left = _b.left, top = _b.top;
        var draggablePosition;
        if (position) {
          draggablePosition = {
            x: position.x - left,
            y: position.y - top
          };
        }
        var pos = this.state.resizing ? void 0 : draggablePosition;
        var dragAxisOrUndefined = this.state.resizing ? "both" : dragAxis;
        return reactExports.createElement(
          Draggable,
          {
            ref: function(c) {
              if (!c)
                return;
              _this.draggable = c;
            },
            handle: dragHandleClassName ? ".".concat(dragHandleClassName) : void 0,
            defaultPosition: defaultValue,
            onMouseDown,
            // @ts-expect-error
            onMouseUp,
            onStart: this.onDragStart,
            onDrag: this.onDrag,
            onStop: this.onDragStop,
            axis: dragAxisOrUndefined,
            disabled: disableDragging,
            grid: dragGrid,
            bounds: bounds ? this.state.bounds : void 0,
            position: pos,
            enableUserSelectHack,
            cancel,
            scale,
            allowAnyClick,
            nodeRef: this.resizableElement,
            positionOffset: dragPositionOffset
          },
          reactExports.createElement(Resizable, __assign$1({}, resizableProps, { ref: function(c) {
            if (!c)
              return;
            _this.resizable = c;
            _this.resizableElement.current = c.resizable;
          }, defaultSize: defaultValue, size: this.props.size, enable: typeof enableResizing === "boolean" ? getEnableResizingByFlag(enableResizing) : enableResizing, onResizeStart: this.onResizeStart, onResize: this.onResize, onResizeStop: this.onResizeStop, style: innerStyle, minWidth: this.props.minWidth, minHeight: this.props.minHeight, maxWidth: this.state.resizing ? this.state.maxWidth : this.props.maxWidth, maxHeight: this.state.resizing ? this.state.maxHeight : this.props.maxHeight, grid: resizeGrid, handleWrapperClass: resizeHandleWrapperClass, handleWrapperStyle: resizeHandleWrapperStyle, lockAspectRatio: this.props.lockAspectRatio, lockAspectRatioExtraWidth: this.props.lockAspectRatioExtraWidth, lockAspectRatioExtraHeight: this.props.lockAspectRatioExtraHeight, handleStyles: resizeHandleStyles, handleClasses: resizeHandleClasses, handleComponent: resizeHandleComponent, scale: this.props.scale }), children)
        );
      };
      Rnd2.defaultProps = {
        maxWidth: Number.MAX_SAFE_INTEGER,
        maxHeight: Number.MAX_SAFE_INTEGER,
        scale: 1,
        onResizeStart: function() {
        },
        onResize: function() {
        },
        onResizeStop: function() {
        },
        onDragStart: function() {
        },
        onDrag: function() {
        },
        onDragStop: function() {
        }
      };
      return Rnd2;
    })(reactExports.PureComponent)
  );
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
    return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
  }).join(" ").trim();
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  };
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Icon = reactExports.forwardRef(
    ({
      color = "currentColor",
      size = 24,
      strokeWidth = 2,
      absoluteStrokeWidth,
      className = "",
      children,
      iconNode,
      ...rest
    }, ref) => {
      return reactExports.createElement(
        "svg",
        {
          ref,
          ...defaultAttributes,
          width: size,
          height: size,
          stroke: color,
          strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
          className: mergeClasses("lucide", className),
          ...rest
        },
        [
          ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
          ...Array.isArray(children) ? children : [children]
        ]
      );
    }
  );
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const createLucideIcon = (iconName, iconNode) => {
    const Component = reactExports.forwardRef(
      ({ className, ...props }, ref) => reactExports.createElement(Icon, {
        ref,
        iconNode,
        className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
        ...props
      })
    );
    Component.displayName = `${iconName}`;
    return Component;
  };
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Activity = createLucideIcon("Activity", [
    [
      "path",
      {
        d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
        key: "169zse"
      }
    ]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const ArrowLeft = createLucideIcon("ArrowLeft", [
    ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
    ["path", { d: "M19 12H5", key: "x3x0zl" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const ArrowRight = createLucideIcon("ArrowRight", [
    ["path", { d: "M5 12h14", key: "1ays0h" }],
    ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Award = createLucideIcon("Award", [
    [
      "path",
      {
        d: "m15.477 12.89 1.515 8.526a.5.5 0 0 1-.81.47l-3.58-2.687a1 1 0 0 0-1.197 0l-3.586 2.686a.5.5 0 0 1-.81-.469l1.514-8.526",
        key: "1yiouv"
      }
    ],
    ["circle", { cx: "12", cy: "8", r: "6", key: "1vp47v" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Bell = createLucideIcon("Bell", [
    ["path", { d: "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9", key: "1qo2s2" }],
    ["path", { d: "M10.3 21a1.94 1.94 0 0 0 3.4 0", key: "qgo35s" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const BookmarkCheck = createLucideIcon("BookmarkCheck", [
    ["path", { d: "m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2Z", key: "169p4p" }],
    ["path", { d: "m9 10 2 2 4-4", key: "1gnqz4" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const BookmarkPlus = createLucideIcon("BookmarkPlus", [
    ["path", { d: "m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z", key: "1fy3hk" }],
    ["line", { x1: "12", x2: "12", y1: "7", y2: "13", key: "1cppfj" }],
    ["line", { x1: "15", x2: "9", y1: "10", y2: "10", key: "1gty7f" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Briefcase = createLucideIcon("Briefcase", [
    ["path", { d: "M16 20V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16", key: "jecpp" }],
    ["rect", { width: "20", height: "14", x: "2", y: "6", rx: "2", key: "i6l2r4" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Building2 = createLucideIcon("Building2", [
    ["path", { d: "M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z", key: "1b4qmf" }],
    ["path", { d: "M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2", key: "i71pzd" }],
    ["path", { d: "M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2", key: "10jefs" }],
    ["path", { d: "M10 6h4", key: "1itunk" }],
    ["path", { d: "M10 10h4", key: "tcdvrf" }],
    ["path", { d: "M10 14h4", key: "kelpxr" }],
    ["path", { d: "M10 18h4", key: "1ulq68" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Calendar = createLucideIcon("Calendar", [
    ["path", { d: "M8 2v4", key: "1cmpym" }],
    ["path", { d: "M16 2v4", key: "4m81vk" }],
    ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
    ["path", { d: "M3 10h18", key: "8toen8" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const ChevronDown = createLucideIcon("ChevronDown", [
    ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const ChevronLeft = createLucideIcon("ChevronLeft", [
    ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const ChevronRight = createLucideIcon("ChevronRight", [
    ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const CircleAlert = createLucideIcon("CircleAlert", [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
    ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const CircleCheckBig = createLucideIcon("CircleCheckBig", [
    ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
    ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const CircleCheck = createLucideIcon("CircleCheck", [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const CircleUser = createLucideIcon("CircleUser", [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }],
    ["path", { d: "M7 20.662V19a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v1.662", key: "154egf" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const CircleX = createLucideIcon("CircleX", [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
    ["path", { d: "m9 9 6 6", key: "z0biqf" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Circle = createLucideIcon("Circle", [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Clock = createLucideIcon("Clock", [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Code = createLucideIcon("Code", [
    ["polyline", { points: "16 18 22 12 16 6", key: "z7tu5w" }],
    ["polyline", { points: "8 6 2 12 8 18", key: "1eg1df" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Copy = createLucideIcon("Copy", [
    ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
    ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const CreditCard = createLucideIcon("CreditCard", [
    ["rect", { width: "20", height: "14", x: "2", y: "5", rx: "2", key: "ynyp8z" }],
    ["line", { x1: "2", x2: "22", y1: "10", y2: "10", key: "1b3vmo" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Crown = createLucideIcon("Crown", [
    [
      "path",
      {
        d: "M11.562 3.266a.5.5 0 0 1 .876 0L15.39 8.87a1 1 0 0 0 1.516.294L21.183 5.5a.5.5 0 0 1 .798.519l-2.834 10.246a1 1 0 0 1-.956.734H5.81a1 1 0 0 1-.957-.734L2.02 6.02a.5.5 0 0 1 .798-.519l4.276 3.664a1 1 0 0 0 1.516-.294z",
        key: "1vdc57"
      }
    ],
    ["path", { d: "M5 21h14", key: "11awu3" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Database = createLucideIcon("Database", [
    ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }],
    ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }],
    ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Download = createLucideIcon("Download", [
    ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
    ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
    ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const ExternalLink = createLucideIcon("ExternalLink", [
    ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
    ["path", { d: "M10 14 21 3", key: "gplh6r" }],
    ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const FileText = createLucideIcon("FileText", [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
    ["path", { d: "M10 9H8", key: "b1mrlr" }],
    ["path", { d: "M16 13H8", key: "t4e002" }],
    ["path", { d: "M16 17H8", key: "z1uh3a" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Filter = createLucideIcon("Filter", [
    ["polygon", { points: "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3", key: "1yg77f" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Flame = createLucideIcon("Flame", [
    [
      "path",
      {
        d: "M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z",
        key: "96xj49"
      }
    ]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const GitBranch = createLucideIcon("GitBranch", [
    ["line", { x1: "6", x2: "6", y1: "3", y2: "15", key: "17qcm7" }],
    ["circle", { cx: "18", cy: "6", r: "3", key: "1h7g24" }],
    ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
    ["path", { d: "M18 9a9 9 0 0 1-9 9", key: "n2h4wq" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const GraduationCap = createLucideIcon("GraduationCap", [
    [
      "path",
      {
        d: "M21.42 10.922a1 1 0 0 0-.019-1.838L12.83 5.18a2 2 0 0 0-1.66 0L2.6 9.08a1 1 0 0 0 0 1.832l8.57 3.908a2 2 0 0 0 1.66 0z",
        key: "j76jl0"
      }
    ],
    ["path", { d: "M22 10v6", key: "1lu8f3" }],
    ["path", { d: "M6 12.5V16a6 3 0 0 0 12 0v-3.5", key: "1r8lef" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Info = createLucideIcon("Info", [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["path", { d: "M12 16v-4", key: "1dtifu" }],
    ["path", { d: "M12 8h.01", key: "e9boi3" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const LoaderCircle = createLucideIcon("LoaderCircle", [
    ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Lock = createLucideIcon("Lock", [
    ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
    ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Mail = createLucideIcon("Mail", [
    ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }],
    ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const MapPin = createLucideIcon("MapPin", [
    [
      "path",
      {
        d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
        key: "1r0f0z"
      }
    ],
    ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Maximize2 = createLucideIcon("Maximize2", [
    ["polyline", { points: "15 3 21 3 21 9", key: "mznyad" }],
    ["polyline", { points: "9 21 3 21 3 15", key: "1avn1i" }],
    ["line", { x1: "21", x2: "14", y1: "3", y2: "10", key: "ota7mn" }],
    ["line", { x1: "3", x2: "10", y1: "21", y2: "14", key: "1atl0r" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const MessageSquare = createLucideIcon("MessageSquare", [
    ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z", key: "1lielz" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Minimize2 = createLucideIcon("Minimize2", [
    ["polyline", { points: "4 14 10 14 10 20", key: "11kfnr" }],
    ["polyline", { points: "20 10 14 10 14 4", key: "rlmsce" }],
    ["line", { x1: "14", x2: "21", y1: "10", y2: "3", key: "o5lafz" }],
    ["line", { x1: "3", x2: "10", y1: "21", y2: "14", key: "1atl0r" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Palette = createLucideIcon("Palette", [
    ["circle", { cx: "13.5", cy: "6.5", r: ".5", fill: "currentColor", key: "1okk4w" }],
    ["circle", { cx: "17.5", cy: "10.5", r: ".5", fill: "currentColor", key: "f64h9f" }],
    ["circle", { cx: "8.5", cy: "7.5", r: ".5", fill: "currentColor", key: "fotxhn" }],
    ["circle", { cx: "6.5", cy: "12.5", r: ".5", fill: "currentColor", key: "qy21gx" }],
    [
      "path",
      {
        d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z",
        key: "12rzf8"
      }
    ]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Pen = createLucideIcon("Pen", [
    [
      "path",
      {
        d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",
        key: "1a8usu"
      }
    ]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Plus = createLucideIcon("Plus", [
    ["path", { d: "M5 12h14", key: "1ays0h" }],
    ["path", { d: "M12 5v14", key: "s699le" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const RefreshCw = createLucideIcon("RefreshCw", [
    ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
    ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
    ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
    ["path", { d: "M8 16H3v5", key: "1cv678" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Rocket = createLucideIcon("Rocket", [
    [
      "path",
      {
        d: "M4.5 16.5c-1.5 1.26-2 5-2 5s3.74-.5 5-2c.71-.84.7-2.13-.09-2.91a2.18 2.18 0 0 0-2.91-.09z",
        key: "m3kijz"
      }
    ],
    [
      "path",
      {
        d: "m12 15-3-3a22 22 0 0 1 2-3.95A12.88 12.88 0 0 1 22 2c0 2.72-.78 7.5-6 11a22.35 22.35 0 0 1-4 2z",
        key: "1fmvmk"
      }
    ],
    ["path", { d: "M9 12H4s.55-3.03 2-4c1.62-1.08 5 0 5 0", key: "1f8sc4" }],
    ["path", { d: "M12 15v5s3.03-.55 4-2c1.08-1.62 0-5 0-5", key: "qeys4" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const RotateCcw = createLucideIcon("RotateCcw", [
    ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
    ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Save = createLucideIcon("Save", [
    [
      "path",
      {
        d: "M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z",
        key: "1c8476"
      }
    ],
    ["path", { d: "M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7", key: "1ydtos" }],
    ["path", { d: "M7 3v4a1 1 0 0 0 1 1h7", key: "t51u73" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Scan = createLucideIcon("Scan", [
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2", key: "aa7l1z" }],
    ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2", key: "4qcy5o" }],
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2", key: "6vwrx8" }],
    ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2", key: "ioqczr" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Search = createLucideIcon("Search", [
    ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
    ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Settings2 = createLucideIcon("Settings2", [
    ["path", { d: "M20 7h-9", key: "3s1dr2" }],
    ["path", { d: "M14 17H5", key: "gfn3mx" }],
    ["circle", { cx: "17", cy: "17", r: "3", key: "18b49y" }],
    ["circle", { cx: "7", cy: "7", r: "3", key: "dfmy0x" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Settings = createLucideIcon("Settings", [
    [
      "path",
      {
        d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
        key: "1qme2f"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Sparkles = createLucideIcon("Sparkles", [
    [
      "path",
      {
        d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z",
        key: "4pj2yx"
      }
    ],
    ["path", { d: "M20 3v4", key: "1olli1" }],
    ["path", { d: "M22 5h-4", key: "1gvqau" }],
    ["path", { d: "M4 17v2", key: "vumght" }],
    ["path", { d: "M5 18H3", key: "zchphs" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Star = createLucideIcon("Star", [
    [
      "path",
      {
        d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z",
        key: "r04s7s"
      }
    ]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Target = createLucideIcon("Target", [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["circle", { cx: "12", cy: "12", r: "6", key: "1vlfrh" }],
    ["circle", { cx: "12", cy: "12", r: "2", key: "1c9p78" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Trash2 = createLucideIcon("Trash2", [
    ["path", { d: "M3 6h18", key: "d0wm0j" }],
    ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
    ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
    ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
    ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const TrendingUp = createLucideIcon("TrendingUp", [
    ["polyline", { points: "22 7 13.5 15.5 8.5 10.5 2 17", key: "126l90" }],
    ["polyline", { points: "16 7 22 7 22 13", key: "kwv8wd" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const TriangleAlert = createLucideIcon("TriangleAlert", [
    [
      "path",
      {
        d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
        key: "wmoenq"
      }
    ],
    ["path", { d: "M12 9v4", key: "juzpu7" }],
    ["path", { d: "M12 17h.01", key: "p32p05" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const User = createLucideIcon("User", [
    ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
    ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const X = createLucideIcon("X", [
    ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
    ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
  ]);
  /**
   * @license lucide-react v0.454.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Zap = createLucideIcon("Zap", [
    [
      "path",
      {
        d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
        key: "1xq2db"
      }
    ]
  ]);
  function TabBadge({ count, color = "red" }) {
    reactExports.useEffect(() => {
      if (count > 0) {
        log$1.debug(LogCategory.UI, "TabBadge displayed", { count, color });
      }
    }, [count, color]);
    if (count === 0) return null;
    const colors = {
      red: {
        background: "#FF3B30",
        text: "#FFFFFF"
      },
      orange: {
        background: "#FF9500",
        text: "#FFFFFF"
      },
      blue: {
        background: "#0077B5",
        text: "#FFFFFF"
      },
      green: {
        background: "#30D158",
        text: "#FFFFFF"
      }
    };
    const displayCount = count > 99 ? "99+" : count.toString();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          position: "absolute",
          top: "-6px",
          right: "-8px",
          minWidth: "18px",
          height: "18px",
          borderRadius: "9px",
          backgroundColor: colors[color].background,
          color: colors[color].text,
          fontSize: "11px",
          fontWeight: "600",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          padding: "0 5px",
          boxShadow: "0 2px 4px rgba(0, 0, 0, 0.2)",
          zIndex: 10,
          animation: "badgePopIn 200ms cubic-bezier(0.34, 1.56, 0.64, 1)"
        },
        children: [
          displayCount,
          /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
          @keyframes badgePopIn {
            0% {
              transform: scale(0.5);
              opacity: 0;
            }
            100% {
              transform: scale(1);
              opacity: 1;
            }
          }
        ` })
        ]
      }
    );
  }
  content;
  function TabButton$1({ tab, isActive, onClick, badgeCount, compact = false, totalVisibleTabs = 6 }) {
    const [isHovered, setIsHovered] = reactExports.useState(false);
    const buttonRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      log$1.debug(LogCategory.UI, "TabButton state changed", {
        tabId: tab.id,
        isActive,
        badgeCount
      });
    }, [isActive, tab.id, badgeCount]);
    const Icon2 = tab.icon;
    const shouldShrink = totalVisibleTabs >= 7;
    const minWidth = compact ? "50px" : shouldShrink ? "48px" : "60px";
    const padding = compact ? "6px 8px" : shouldShrink ? "8px 8px" : "8px 12px";
    const baseStyles = {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      gap: compact ? "2px" : "4px",
      padding,
      minWidth,
      background: isActive ? "rgba(0, 119, 181, 0.1)" : "transparent",
      border: "none",
      borderRadius: "12px",
      cursor: "pointer",
      transition: "all 150ms ease-in-out",
      outline: "none",
      WebkitTapHighlightColor: "transparent"
    };
    const hoverStyles = isHovered && !isActive ? {
      background: "rgba(0, 0, 0, 0.04)"
    } : {};
    const iconColor = isActive ? "#0077B5" : isHovered ? "#1d1d1f" : "#8e8e93";
    const labelColor = isActive ? "#0077B5" : isHovered ? "#1d1d1f" : "#8e8e93";
    const handleClick = (e) => {
      e.preventDefault();
      log$1.action("Tab button clicked", {
        tabId: tab.id,
        tabLabel: tab.label,
        wasActive: isActive,
        component: "TabButton"
      });
      onClick();
      if (buttonRef.current) {
        buttonRef.current.style.transform = "scale(0.95)";
        setTimeout(() => {
          if (buttonRef.current) {
            buttonRef.current.style.transform = "scale(1)";
          }
        }, 100);
      }
    };
    const shortcutLabel = tab.shortcut ? `Alt+${tab.shortcut}` : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        ref: buttonRef,
        role: "tab",
        "aria-selected": isActive,
        "aria-controls": `panel-${tab.id}`,
        "aria-label": `${tab.label}${badgeCount ? ` (${badgeCount} items)` : ""}`,
        tabIndex: isActive ? 0 : -1,
        onClick: handleClick,
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        style: { ...baseStyles, ...hoverStyles },
        title: shortcutLabel ? `${tab.label} (${shortcutLabel})` : tab.label,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: compact ? 18 : 20, color: iconColor, strokeWidth: 2 }),
            badgeCount !== void 0 && badgeCount > 0 && tab.badge && /* @__PURE__ */ jsxRuntimeExports.jsx(TabBadge, { count: badgeCount, color: tab.badgeColor || "blue" })
          ] }),
          !compact && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                fontSize: "11px",
                fontWeight: isActive ? "600" : "500",
                color: labelColor,
                transition: "color 150ms ease-in-out",
                whiteSpace: "nowrap"
              },
              children: tab.label
            }
          ),
          isActive && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                position: "absolute",
                bottom: "-8px",
                left: "50%",
                transform: "translateX(-50%)",
                width: "32px",
                height: "3px",
                borderRadius: "1.5px",
                backgroundColor: "#0077B5",
                animation: "indicatorSlideIn 300ms cubic-bezier(0.25, 0.1, 0.25, 1)"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
          @keyframes indicatorSlideIn {
            0% {
              width: 0px;
              opacity: 0;
            }
            100% {
              width: 32px;
              opacity: 1;
            }
          }
        ` })
        ]
      }
    );
  }
  content;
  function detectContext() {
    const url = window.location.href;
    const pathname = window.location.pathname;
    if (url.includes("/in/") || pathname.match(/^\/in\/[^/]+\/?$/)) {
      const nameElement = document.querySelector("h1.text-heading-xlarge") || document.querySelector('h1[class*="text-heading"]') || document.querySelector('[data-anonymize="person-name"]') || document.querySelector("h1");
      const headlineElement = document.querySelector("div.text-body-medium.break-words") || document.querySelector("div.text-body-medium") || document.querySelector("[data-generated-suggestion-target]") || document.querySelector(".pv-text-details__left-panel .text-body-medium");
      let profileImage = null;
      const imageElement = document.querySelector("img.pv-top-card-profile-picture__image") || document.querySelector('img[class*="profile"][class*="photo"]') || document.querySelector('button[aria-label*="profile"] img') || document.querySelector(".pv-top-card img") || document.querySelector(".pv-top-card-profile-picture img");
      if (imageElement) {
        profileImage = imageElement.src;
      }
      let jsonLdData = null;
      try {
        const jsonLdScript = document.querySelector('script[type="application/ld+json"]');
        if (jsonLdScript?.textContent) {
          jsonLdData = JSON.parse(jsonLdScript.textContent);
        }
      } catch (e) {
      }
      if (!profileImage && jsonLdData?.image) {
        profileImage = jsonLdData.image.url || jsonLdData.image;
      }
      if (!profileImage) {
        const ogImage = document.querySelector('meta[property="og:image"]');
        if (ogImage?.content) {
          profileImage = ogImage.content;
        }
      }
      if (!profileImage) {
        try {
          const windowAny = window;
          if (windowAny.__RELAY_BOOTSTRAP_DATA__) {
            const relayData = windowAny.__RELAY_BOOTSTRAP_DATA__;
            for (const key in relayData) {
              const entry = relayData[key];
              if (entry?.included) {
                for (const included of entry.included) {
                  if (included?.picture?.rootUrl && !profileImage) {
                    profileImage = included.picture.rootUrl;
                    break;
                  }
                }
              }
            }
          }
        } catch (e) {
        }
      }
      const name = nameElement?.textContent?.trim() || jsonLdData?.name || "Unknown Person";
      const headline = headlineElement?.textContent?.trim() || jsonLdData?.headline || "";
      const publicIdMatch = url.match(/\/in\/([^\/]+)/);
      const publicId = publicIdMatch ? publicIdMatch[1] : void 0;
      console.log("[Uproot] Profile detected:", {
        name,
        headline,
        profileImage,
        hasImage: !!profileImage,
        publicId,
        url
      });
      return {
        type: "profile",
        isProfilePage: true,
        isJobPage: false,
        profileData: {
          name,
          headline,
          profileUrl: url,
          profileImage,
          publicId
        },
        jobData: null
      };
    }
    if (url.includes("/jobs/view/") || pathname.startsWith("/jobs/view/") || pathname.includes("/jobs/collections/") || pathname.startsWith("/jobs/") && (url.includes("currentJobId=") || url.includes("jobId="))) {
      const titleElement = document.querySelector(".job-details-jobs-unified-top-card__job-title") || document.querySelector(".jobs-unified-top-card__job-title") || document.querySelector("[data-job-title]");
      const companyElement = document.querySelector(".job-details-jobs-unified-top-card__company-name") || document.querySelector(".jobs-unified-top-card__company-name") || document.querySelector("[data-company-name]");
      return {
        type: "job",
        isProfilePage: false,
        isJobPage: true,
        profileData: null,
        jobData: {
          title: titleElement?.textContent?.trim() || "Unknown Job",
          company: companyElement?.textContent?.trim() || "Unknown Company",
          jobUrl: url
        }
      };
    }
    if (url.includes("/company/") || pathname.match(/^\/company\/[^/]+\/?$/)) {
      const nameElement = document.querySelector("h1.org-top-card-summary__title") || document.querySelector('h1[data-anonymize="company-name"]') || document.querySelector(".org-top-card-summary__title") || document.querySelector("h1");
      const industryElement = document.querySelector(".org-top-card-summary__tagline") || document.querySelector('[data-anonymize="industry"]') || document.querySelector(".org-page-details__definition-text");
      const logoElement = document.querySelector("img.org-top-card-primary-content__logo") || document.querySelector('img[alt*="logo" i]') || document.querySelector(".org-top-card-primary-content__logo img");
      const statsElements = document.querySelectorAll(".org-top-card-summary-info-list__info-item");
      let followerCount = "";
      let employeeCount = "";
      statsElements.forEach((stat) => {
        const text = stat.textContent?.trim() || "";
        if (text.includes("followers")) {
          followerCount = text.replace(/\s*followers/i, "").trim();
        } else if (text.includes("employees")) {
          employeeCount = text.replace(/\s*employees/i, "").trim();
        }
      });
      const name = nameElement?.textContent?.trim() || "Unknown Company";
      const industry = industryElement?.textContent?.trim() || "";
      const companyLogo = logoElement?.src || null;
      console.log("[Uproot] Company detected:", {
        name,
        industry,
        hasLogo: !!companyLogo,
        followerCount,
        employeeCount,
        url
      });
      return {
        type: "company",
        isProfilePage: false,
        isJobPage: false,
        profileData: null,
        jobData: null,
        companyData: {
          name,
          industry: industry || void 0,
          companyUrl: url,
          companyLogo,
          followerCount: followerCount || void 0,
          employeeCount: employeeCount || void 0
        }
      };
    }
    if (url.includes("/messaging/")) {
      return {
        type: "messaging",
        isProfilePage: false,
        isJobPage: false,
        profileData: null,
        jobData: null
      };
    }
    if (url.includes("/mynetwork/")) {
      return {
        type: "network",
        isProfilePage: false,
        isJobPage: false,
        profileData: null,
        jobData: null
      };
    }
    console.log("[Uproot] Page type detected: feed/other", { url, pathname });
    return {
      type: "feed",
      isProfilePage: false,
      isJobPage: false,
      profileData: null,
      jobData: null
    };
  }
  function usePageContext() {
    const [context, setContext] = reactExports.useState(() => detectContext());
    reactExports.useEffect(() => {
      const handleUrlChange = () => {
        setContext(detectContext());
      };
      const intervalId = setInterval(handleUrlChange, 200);
      window.addEventListener("linkedin-extension:page-change", handleUrlChange);
      return () => {
        clearInterval(intervalId);
        window.removeEventListener("linkedin-extension:page-change", handleUrlChange);
      };
    }, []);
    return context;
  }
  content;
  const SHORTCUTS = {
    "alt+1": "feed",
    "alt+2": "watchlist",
    "alt+3": "resume",
    "alt+4": "settings",
    "alt+5": "profile",
    // Context-sensitive
    "alt+6": "company",
    // Context-sensitive
    "alt+7": "jobs",
    // Context-sensitive
    "alt+8": "onboarding"
    // First-run only
  };
  function useKeyboardShortcuts({
    activeTab,
    visibleTabs,
    onTabChange,
    enabled = true
  }) {
    reactExports.useEffect(() => {
      if (!enabled) return;
      const handleKeyDown = (event) => {
        const target = event.target;
        if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
          return;
        }
        const key = event.key.toLowerCase();
        const modifiers = {
          alt: event.altKey,
          ctrl: event.ctrlKey,
          shift: event.shiftKey,
          meta: event.metaKey
        };
        const shortcutParts = [];
        if (modifiers.alt) shortcutParts.push("alt");
        if (modifiers.ctrl) shortcutParts.push("ctrl");
        if (modifiers.shift) shortcutParts.push("shift");
        if (modifiers.meta) shortcutParts.push("meta");
        shortcutParts.push(key);
        const shortcut = shortcutParts.join("+");
        const action = SHORTCUTS[shortcut];
        if (action) {
          event.preventDefault();
          if (action === "nextTab") {
            const currentIndex = visibleTabs.indexOf(activeTab);
            const nextIndex = (currentIndex + 1) % visibleTabs.length;
            onTabChange(visibleTabs[nextIndex]);
          } else if (action === "prevTab") {
            const currentIndex = visibleTabs.indexOf(activeTab);
            const prevIndex = (currentIndex - 1 + visibleTabs.length) % visibleTabs.length;
            onTabChange(visibleTabs[prevIndex]);
          } else {
            const tabId = action;
            if (visibleTabs.includes(tabId)) {
              onTabChange(tabId);
            }
          }
        }
      };
      window.addEventListener("keydown", handleKeyDown);
      return () => window.removeEventListener("keydown", handleKeyDown);
    }, [activeTab, visibleTabs, onTabChange, enabled]);
    return SHORTCUTS;
  }
  content;
  async function getWatchlist() {
    return log$1.trackAsync(LogCategory.STORAGE, "getWatchlist", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Fetching watchlist from storage");
        const result2 = await chrome.storage.local.get("uproot_watchlist");
        const watchlist = result2.uproot_watchlist || [];
        log$1.info(LogCategory.STORAGE, "Watchlist retrieved", { count: watchlist.length });
        console.log("[Uproot] Retrieved watchlist:", watchlist.length, "people");
        return watchlist;
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return [];
        }
        log$1.error(LogCategory.STORAGE, "Error getting watchlist", { error });
        console.error("[Uproot] Error getting watchlist:", error);
        return [];
      }
    });
  }
  async function saveWatchlist(watchlist) {
    return log$1.trackAsync(LogCategory.STORAGE, "saveWatchlist", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Saving watchlist to storage", { count: watchlist.length });
        await chrome.storage.local.set({ uproot_watchlist: watchlist });
        log$1.change(LogCategory.STORAGE, "watchlist", "update", { count: watchlist.length });
        console.log("[Uproot] Watchlist saved:", watchlist.length, "people");
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return;
        }
        log$1.error(LogCategory.STORAGE, "Error saving watchlist", error);
        console.error("[Uproot] Error saving watchlist:", error);
        throw error;
      }
    });
  }
  async function addToWatchlist(person) {
    return log$1.trackAsync(LogCategory.STORAGE, "addToWatchlist", async () => {
      log$1.debug(LogCategory.STORAGE, "Adding person to watchlist", { name: person.name, profileUrl: person.profileUrl });
      const watchlist = await getWatchlist();
      const id = person.profileUrl;
      const existingIndex = watchlist.findIndex((p) => p.id === id);
      if (existingIndex !== -1) {
        log$1.info(LogCategory.STORAGE, "Person already in watchlist", { name: person.name, id });
        console.log("[Uproot] Person already in watchlist:", person.name);
        return watchlist[existingIndex];
      }
      const newPerson = {
        ...person,
        id,
        addedAt: Date.now()
      };
      watchlist.unshift(newPerson);
      await saveWatchlist(watchlist);
      log$1.change(LogCategory.STORAGE, "watchlist", "create", { id: newPerson.id, name: newPerson.name });
      console.log("[Uproot] Added to watchlist:", person.name);
      return newPerson;
    });
  }
  async function removeFromWatchlist(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "removeFromWatchlist", async () => {
      log$1.debug(LogCategory.STORAGE, "Removing person from watchlist", { id });
      const watchlist = await getWatchlist();
      const filteredWatchlist = watchlist.filter((p) => p.id !== id);
      await saveWatchlist(filteredWatchlist);
      log$1.change(LogCategory.STORAGE, "watchlist", "delete", { id });
      console.log("[Uproot] Removed from watchlist:", id);
    });
  }
  async function updateWatchlistPerson(id, updates) {
    return log$1.trackAsync(LogCategory.STORAGE, "updateWatchlistPerson", async () => {
      log$1.debug(LogCategory.STORAGE, "Updating watchlist person", { id, updates });
      const watchlist = await getWatchlist();
      const index2 = watchlist.findIndex((p) => p.id === id);
      if (index2 === -1) {
        const error = new Error(`Person not found in watchlist: ${id}`);
        log$1.error(LogCategory.STORAGE, "Person not found in watchlist", error);
        throw error;
      }
      watchlist[index2] = {
        ...watchlist[index2],
        ...updates
      };
      await saveWatchlist(watchlist);
      log$1.change(LogCategory.STORAGE, "watchlist", "update", { id, updates });
      console.log("[Uproot] Updated watchlist person:", id);
    });
  }
  async function isInWatchlist(profileUrl) {
    return log$1.trackAsync(LogCategory.STORAGE, "isInWatchlist", async () => {
      log$1.debug(LogCategory.STORAGE, "Checking if person is in watchlist", { profileUrl });
      const watchlist = await getWatchlist();
      const isInList = watchlist.some((p) => p.id === profileUrl);
      log$1.info(LogCategory.STORAGE, "Watchlist check complete", { profileUrl, isInList });
      return isInList;
    });
  }
  content;
  const CONNECTION_PATHS_STORAGE_KEY = "uproot_connection_paths";
  const WATCHLIST_PEOPLE_STORAGE_KEY = "uproot_watchlist";
  const WATCHLIST_COMPANIES_STORAGE_KEY = "uproot_watchlist_companies";
  content;
  const createStoreImpl = (createState) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const getInitialState = () => initialState;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const api = { setState, getState, getInitialState, subscribe };
    const initialState = state = createState(setState, getState, api);
    return api;
  };
  const createStore = ((createState) => createState ? createStoreImpl(createState) : createStoreImpl);
  const identity = (arg) => arg;
  function useStore(api, selector = identity) {
    const slice = React.useSyncExternalStore(
      api.subscribe,
      React.useCallback(() => selector(api.getState()), [api, selector]),
      React.useCallback(() => selector(api.getInitialState()), [api, selector])
    );
    React.useDebugValue(slice);
    return slice;
  }
  const createImpl = (createState) => {
    const api = createStore(createState);
    const useBoundStore = (selector) => useStore(api, selector);
    Object.assign(useBoundStore, api);
    return useBoundStore;
  };
  const create = ((createState) => createState ? createImpl(createState) : createImpl);
  var util;
  (function(util2) {
    util2.assertEqual = (_) => {
    };
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  class ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "bigint")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  let overrideErrorMap = errorMap;
  function getErrorMap() {
    return overrideErrorMap;
  }
  const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === errorMap ? void 0 : errorMap
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  const INVALID = Object.freeze({
    status: "aborted"
  });
  const DIRTY = (value) => ({ status: "dirty", value });
  const OK = (value) => ({ status: "valid", value });
  const isAborted = (x) => x.status === "aborted";
  const isDirty = (x) => x.status === "dirty";
  const isValid = (x) => x.status === "valid";
  const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil || (errorUtil = {}));
  class ParseInputLazyPath {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (Array.isArray(this._key)) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result2) => {
    if (isValid(result2)) {
      return { success: true, data: result2.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message ?? ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: message ?? required_error ?? ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result2 = this._parse(input);
      if (isAsync(result2)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result2;
    }
    _parseAsync(input) {
      const result2 = this._parse(input);
      return Promise.resolve(result2);
    }
    parse(data, params) {
      const result2 = this.safeParse(data, params);
      if (result2.success)
        return result2.data;
      throw result2.error;
    }
    safeParse(data, params) {
      const ctx = {
        common: {
          issues: [],
          async: params?.async ?? false,
          contextualErrorMap: params?.errorMap
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result2 = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result2);
    }
    "~validate"(data) {
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      if (!this["~standard"].async) {
        try {
          const result2 = this._parseSync({ data, path: [], parent: ctx });
          return isValid(result2) ? {
            value: result2.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if (err?.message?.toLowerCase()?.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data, path: [], parent: ctx }).then((result2) => isValid(result2) ? {
        value: result2.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data, params) {
      const result2 = await this.safeParseAsync(data, params);
      if (result2.success)
        return result2.data;
      throw result2.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params?.errorMap,
          async: true
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result2 = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result2);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result2 = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result2 instanceof Promise) {
          return result2.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result2) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data) => this["~validate"](data)
      };
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[0-9a-z]+$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const nanoidRegex = /^[a-z0-9_-]{21}$/i;
  const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex;
  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  const dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
      secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      if (!header)
        return false;
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if ("typ" in decoded && decoded?.typ !== "JWT")
        return false;
      if (!decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch {
      return false;
    }
  }
  function isValidCidr(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind2, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: kind2,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  }
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind2, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: kind2,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  }
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  }
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result3) => {
          return ParseStatus.mergeArray(status, result3);
        });
      }
      const result2 = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result2);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index2) {
      return new ZodObject({
        ...this._def,
        catchall: index2
      });
    }
    pick(mask) {
      const shape = {};
      for (const key of util.objectKeys(mask)) {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  }
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result2 of results) {
          if (result2.result.status === "valid") {
            return result2.result;
          }
        }
        for (const result2 of results) {
          if (result2.result.status === "dirty") {
            ctx.common.issues.push(...result2.ctx.common.issues);
            return result2.result;
          }
        }
        const unionErrors = results.map((result2) => new ZodError(result2.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result2 = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result2.status === "valid") {
            return result2;
          } else if (result2.status === "dirty" && !dirty) {
            dirty = { result: result2, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index2 = 0; index2 < a.length; index2++) {
        const itemA = a[index2];
        const itemB = b[index2];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  }
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result2 = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result2.status === "aborted")
              return INVALID;
            if (result2.status === "dirty")
              return DIRTY(result2.value);
            if (status.value === "dirty")
              return DIRTY(result2.value);
            return result2;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result2 = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result2.status === "aborted")
            return INVALID;
          if (result2.status === "dirty")
            return DIRTY(result2.value);
          if (status.value === "dirty")
            return DIRTY(result2.value);
          return result2;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result2 = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result2);
          }
          if (result2 instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return INVALID;
          const result2 = effect.transform(base.value, checkCtx);
          if (result2 instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result2 };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result2) => ({
              status: status.value,
              value: result2
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  }
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result2 = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result2)) {
        return result2.then((result3) => {
          return {
            status: "valid",
            value: result3.status === "valid" ? result3.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result2 = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result2) ? result2.then((data) => freeze(data)) : freeze(result2);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  const stringType = ZodString.create;
  const numberType = ZodNumber.create;
  const booleanType = ZodBoolean.create;
  const anyType = ZodAny.create;
  ZodNever.create;
  const arrayType = ZodArray.create;
  const objectType = ZodObject.create;
  ZodUnion.create;
  ZodIntersection.create;
  ZodTuple.create;
  const recordType = ZodRecord.create;
  const enumType = ZodEnum.create;
  ZodPromise.create;
  ZodOptional.create;
  ZodNullable.create;
  const SubscriptionTierSchema = enumType(["free", "pro", "elite"]);
  objectType({
    id: stringType().uuid(),
    email: stringType().email(),
    firstName: stringType().optional(),
    lastName: stringType().optional(),
    fullName: stringType().optional(),
    phone: stringType().optional(),
    address: stringType().optional(),
    education: arrayType(objectType({
      school: stringType(),
      degree: stringType().optional(),
      field: stringType().optional(),
      startDate: stringType().optional(),
      endDate: stringType().optional()
    })).default([]),
    certifications: arrayType(objectType({
      name: stringType(),
      issuer: stringType().optional(),
      date: stringType().optional(),
      credentialId: stringType().optional()
    })).default([]),
    experience: arrayType(objectType({
      company: stringType(),
      role: stringType(),
      startDate: stringType().optional(),
      endDate: stringType().optional(),
      bullets: arrayType(stringType()).default([]),
      keywords: arrayType(stringType()).default([])
    })).default([]),
    projects: arrayType(objectType({
      name: stringType(),
      description: stringType().optional(),
      technologies: arrayType(stringType()).default([]),
      url: stringType().url().optional()
    })).default([]),
    skills: arrayType(stringType()).default([]),
    subscriptionTier: SubscriptionTierSchema.default("free"),
    subscriptionExpiresAt: stringType().datetime().optional(),
    createdAt: stringType().datetime(),
    updatedAt: stringType().datetime()
  });
  const LinkedInProfileSchema = objectType({
    id: stringType(),
    // LinkedIn public identifier
    publicId: stringType().optional(),
    name: stringType(),
    headline: stringType().optional(),
    location: stringType().optional(),
    industry: stringType().optional(),
    avatarUrl: stringType().url().optional(),
    photoUrl: stringType().url().optional(),
    // Alias for avatarUrl
    profileUrl: stringType().url().optional(),
    // LinkedIn profile URL
    about: stringType().optional(),
    currentRole: objectType({
      title: stringType(),
      company: stringType()
    }).optional(),
    // Current employment position
    experience: arrayType(objectType({
      company: stringType(),
      title: stringType(),
      duration: stringType().optional(),
      location: stringType().optional()
    })).default([]),
    education: arrayType(objectType({
      school: stringType(),
      degree: stringType().optional(),
      field: stringType().optional(),
      startYear: numberType().optional(),
      // Year started (e.g., 2016)
      endYear: numberType().optional()
      // Year graduated (e.g., 2020, null if Present)
    })).default([]),
    certifications: arrayType(objectType({
      name: stringType(),
      issuer: stringType().optional(),
      dateObtained: stringType().optional()
      // ISO date string
    })).default([]),
    skills: arrayType(objectType({
      name: stringType(),
      endorsementCount: numberType().default(0),
      // Number of endorsements
      endorsedBy: arrayType(stringType()).default([])
      // Array of profile IDs who endorsed
    })).default([]),
    connections: numberType().optional(),
    mutualConnections: arrayType(stringType()).default([]),
    recentPosts: arrayType(objectType({
      content: stringType(),
      date: stringType(),
      engagement: numberType().optional()
    })).default([]),
    userPosts: arrayType(objectType({
      content: stringType(),
      timestamp: stringType().datetime(),
      likes: numberType().default(0),
      comments: numberType().default(0)
    })).default([]),
    engagedPosts: arrayType(objectType({
      authorId: stringType(),
      // LinkedIn profile ID of post author
      authorName: stringType(),
      // Display name of post author
      topic: stringType(),
      // Post topic/content preview
      timestamp: stringType().datetime(),
      engagementType: enumType(["comment", "reaction", "share"]).optional()
    })).default([]),
    recentActivity: arrayType(objectType({
      preview: stringType(),
      // Activity content preview
      timestamp: stringType().datetime().optional(),
      type: stringType().optional(),
      // Activity type (post, comment, share, etc.)
      url: stringType().url().optional()
      // URL to the activity
    })).default([]),
    scrapedAt: stringType().datetime()
  });
  const ConnectionStatusSchema = enumType(["connected", "pending", "not_contacted"]);
  const NetworkNodeSchema = objectType({
    id: stringType(),
    profile: LinkedInProfileSchema,
    status: ConnectionStatusSchema,
    degree: numberType().min(1).max(3),
    // 1st, 2nd, 3rd degree
    matchScore: numberType().min(0).max(100),
    // 0-100 percentage
    activityScore: numberType().optional(),
    lastContactedAt: stringType().datetime().optional()
  });
  const NetworkEdgeSchema = objectType({
    from: stringType(),
    // node ID
    to: stringType(),
    // node ID
    weight: numberType().min(0.1).max(1),
    // Lower is better for Dijkstra
    relationshipType: enumType(["mutual", "colleague", "school", "unknown"]).optional()
  });
  const ConnectionRouteSchema = objectType({
    targetId: stringType(),
    nodes: arrayType(NetworkNodeSchema),
    edges: arrayType(NetworkEdgeSchema),
    totalWeight: numberType(),
    successProbability: numberType().min(0).max(100),
    // Percentage
    computedAt: stringType().datetime()
  });
  const WatchlistPersonSchema = objectType({
    id: stringType().uuid(),
    profileId: stringType(),
    profile: LinkedInProfileSchema,
    bestRoute: ConnectionRouteSchema.optional(),
    matchScore: numberType().min(0).max(100),
    progress: objectType({
      connectedNodes: numberType(),
      totalNodes: numberType(),
      percentage: numberType().min(0).max(100)
    }),
    keywords: arrayType(stringType()).default([]),
    notes: stringType().optional(),
    addedAt: stringType().datetime(),
    lastCheckedAt: stringType().datetime().optional()
  });
  objectType({
    id: stringType().uuid(),
    companyId: stringType(),
    name: stringType(),
    description: stringType().optional(),
    logoUrl: stringType().url().optional(),
    website: stringType().url().optional(),
    industry: stringType().optional(),
    size: stringType().optional(),
    location: stringType().optional(),
    jobs: arrayType(objectType({
      id: stringType(),
      title: stringType(),
      location: stringType().optional(),
      postedDate: stringType().optional(),
      url: stringType().url()
    })).default([]),
    bestContact: WatchlistPersonSchema.optional(),
    addedAt: stringType().datetime(),
    lastCheckedAt: stringType().datetime().optional()
  });
  const JobPostingSchema = objectType({
    id: stringType(),
    title: stringType(),
    company: stringType(),
    location: stringType().optional(),
    description: stringType(),
    requirements: arrayType(stringType()).default([]),
    keywords: arrayType(stringType()).default([]),
    salaryRange: stringType().optional(),
    experienceLevel: enumType(["entry", "mid", "senior", "lead", "executive"]).optional(),
    jobType: enumType(["full-time", "part-time", "contract", "internship"]).optional(),
    postedDate: stringType(),
    url: stringType().url(),
    source: enumType(["linkedin", "manual"]),
    scrapedAt: stringType().datetime()
  });
  objectType({
    id: stringType().uuid(),
    job: JobPostingSchema,
    tailoredResume: stringType().optional(),
    // PDF base64 or URL
    coverLetter: stringType().optional(),
    matchScore: numberType().min(0).max(100).optional(),
    applicationStatus: enumType(["saved", "applied", "interview", "rejected", "accepted"]).default("saved"),
    appliedAt: stringType().datetime().optional(),
    notes: stringType().optional(),
    savedAt: stringType().datetime()
  });
  objectType({
    targetProfileId: stringType(),
    messageType: enumType(["connection_request", "follow_up", "introduction"]),
    content: stringType(),
    tone: enumType(["professional", "casual", "enthusiastic", "formal"]).default("professional"),
    citations: arrayType(objectType({
      fact: stringType(),
      source: stringType()
      // e.g., "profile.about", "recentPosts[0]"
    })).default([]),
    validatedAt: stringType().datetime(),
    generatedAt: stringType().datetime()
  });
  objectType({
    jobId: stringType(),
    sections: objectType({
      opening: stringType(),
      body: arrayType(stringType()),
      value: stringType(),
      closing: stringType()
    }),
    fullText: stringType(),
    tone: enumType(["professional", "casual", "enthusiastic", "formal"]).default("professional"),
    generatedAt: stringType().datetime()
  });
  const NotificationTypeSchema = enumType([
    "job_alert",
    "connection_accepted",
    "message_follow_up",
    "activity_update",
    "system"
  ]);
  objectType({
    id: stringType().uuid(),
    type: NotificationTypeSchema,
    title: stringType(),
    message: stringType(),
    actionUrl: stringType().url().optional(),
    read: booleanType().default(false),
    createdAt: stringType().datetime()
  });
  const NotificationPreferencesSchema = objectType({
    email: objectType({
      enabled: booleanType().default(false),
      types: arrayType(NotificationTypeSchema).default([]),
      frequency: enumType(["instant", "daily", "weekly"]).default("daily")
    }),
    sms: objectType({
      enabled: booleanType().default(false),
      types: arrayType(NotificationTypeSchema).default([])
    }),
    push: objectType({
      enabled: booleanType().default(true),
      types: arrayType(NotificationTypeSchema).default(["job_alert", "connection_accepted"])
    })
  });
  const ThemeSchema = objectType({
    mode: enumType(["light", "dark", "system"]).default("system"),
    accentColor: stringType().regex(/^#[0-9A-Fa-f]{6}$/).default("#0A66C2"),
    // LinkedIn blue
    blurIntensity: numberType().min(0).max(20).default(10),
    curvePreset: enumType(["subtle", "moderate", "pronounced"]).default("moderate")
  });
  const PrivacySettingsSchema = objectType({
    cloudSyncEnabled: booleanType().default(false),
    autoSendEnabled: booleanType().default(false),
    // Elite only
    analyticsEnabled: booleanType().default(false),
    clearDataOnLogout: booleanType().default(false)
  });
  objectType({
    theme: ThemeSchema,
    notifications: NotificationPreferencesSchema,
    privacy: PrivacySettingsSchema,
    panelPosition: objectType({
      x: numberType().default(100),
      y: numberType().default(100)
    }),
    panelSize: objectType({
      width: numberType().default(420),
      height: numberType().default(680)
    })
  });
  objectType({
    type: enumType(["message", "resume", "cover_letter", "rewrite"]),
    context: recordType(anyType()),
    // Flexible context object
    tone: enumType(["professional", "casual", "enthusiastic", "formal"]).optional(),
    maxTokens: numberType().optional()
  });
  const STORAGE_KEYS = {
    // Session storage (in-memory, sensitive)
    AUTH_TOKEN: "auth_token",
    REFRESH_TOKEN: "refresh_token"
  };
  content;
  class StorageManager {
    /**
     * Get data from session storage (in-memory, cleared on restart)
     * Use for sensitive data like tokens
     */
    static async getSession(key) {
      try {
        const result2 = await chrome.storage.session.get(key);
        return result2[key] ?? null;
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return null;
        }
        const errorMsg = error?.message?.toLowerCase() || String(error).toLowerCase();
        if (errorMsg.includes("cannot access") || errorMsg.includes("not available") || errorMsg.includes("disconnected") || errorMsg.includes("receiving end does not exist")) {
          return null;
        }
        console.error("Session storage get error:", error);
        return null;
      }
    }
    /**
     * Set data in session storage
     */
    static async setSession(key, value) {
      try {
        await chrome.storage.session.set({ [key]: value });
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return;
        }
        const errorMsg = error?.message?.toLowerCase() || String(error).toLowerCase();
        if (errorMsg.includes("cannot access") || errorMsg.includes("not available") || errorMsg.includes("disconnected") || errorMsg.includes("receiving end does not exist")) {
          return;
        }
        console.error("Session storage set error:", error);
        throw error;
      }
    }
    /**
     * Get data from local storage (persistent)
     */
    static async getLocal(key) {
      try {
        const result2 = await chrome.storage.local.get(key);
        return result2[key] ?? null;
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return null;
        }
        const errorMsg = error?.message?.toLowerCase() || String(error).toLowerCase();
        if (errorMsg.includes("cannot access") || errorMsg.includes("not available") || errorMsg.includes("disconnected") || errorMsg.includes("receiving end does not exist")) {
          return null;
        }
        console.error("Local storage get error:", error);
        return null;
      }
    }
    /**
     * Set data in local storage
     */
    static async setLocal(key, value) {
      try {
        await chrome.storage.local.set({ [key]: value });
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return;
        }
        const errorMsg = error?.message?.toLowerCase() || String(error).toLowerCase();
        if (errorMsg.includes("cannot access") || errorMsg.includes("not available") || errorMsg.includes("disconnected") || errorMsg.includes("receiving end does not exist")) {
          return;
        }
        console.error("Local storage set error:", error);
        throw error;
      }
    }
    /**
     * Remove from session storage
     */
    static async removeSession(key) {
      try {
        await chrome.storage.session.remove(key);
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return;
        }
        console.error("Session storage remove error:", error);
      }
    }
    /**
     * Remove from local storage
     */
    static async removeLocal(key) {
      try {
        await chrome.storage.local.remove(key);
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return;
        }
        console.error("Local storage remove error:", error);
      }
    }
    /**
     * Clear all session storage
     */
    static async clearSession() {
      try {
        await chrome.storage.session.clear();
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return;
        }
        console.error("Session storage clear error:", error);
      }
    }
    /**
     * Clear all local storage
     */
    static async clearLocal() {
      try {
        await chrome.storage.local.clear();
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return;
        }
        console.error("Local storage clear error:", error);
      }
    }
    /**
     * Get auth tokens (from session storage)
     */
    static async getAuthToken() {
      return this.getSession(STORAGE_KEYS.AUTH_TOKEN);
    }
    /**
     * Set auth tokens (in session storage)
     */
    static async setAuthToken(token) {
      await this.setSession(STORAGE_KEYS.AUTH_TOKEN, token);
    }
    /**
     * Clear all auth data
     */
    static async clearAuth() {
      await this.removeSession(STORAGE_KEYS.AUTH_TOKEN);
      await this.removeSession(STORAGE_KEYS.REFRESH_TOKEN);
    }
    /**
     * Listen to storage changes
     */
    static onChanged(callback) {
      chrome.storage.onChanged.addListener((changes, areaName) => {
        if (areaName === "local" || areaName === "session") {
          callback(changes);
        }
      });
    }
  }
  content;
  const DEFAULT_FEED_PREFERENCES = {
    enabledCompanies: [],
    globalFilters: {}
  };
  const DEFAULT_SETTINGS = {
    theme: {
      mode: "system",
      accentColor: "#0A66C2",
      blurIntensity: 10,
      curvePreset: "moderate"
    },
    notifications: {
      email: { enabled: false, types: [], frequency: "daily" },
      sms: { enabled: false, types: [] },
      push: { enabled: true, types: ["job_alert", "connection_accepted"] }
    },
    privacy: {
      cloudSyncEnabled: false,
      autoSendEnabled: false,
      analyticsEnabled: false,
      clearDataOnLogout: false
    },
    panelPosition: { x: 100, y: 100 },
    panelSize: { width: 420, height: 680 }
  };
  const useSettingsStore = create((set, get2) => ({
    ...DEFAULT_SETTINGS,
    feedPreferences: DEFAULT_FEED_PREFERENCES,
    loadSettings: async () => {
      const settings = await StorageManager.getLocal("app_settings");
      const feedPreferences = await StorageManager.getLocal("feed_preferences");
      if (settings) {
        set({ ...settings, feedPreferences: feedPreferences || DEFAULT_FEED_PREFERENCES });
      }
    },
    updateTheme: async (themeUpdates) => {
      const currentTheme = get2().theme;
      const updatedTheme = { ...currentTheme, ...themeUpdates };
      const newSettings = {
        ...get2(),
        theme: updatedTheme
      };
      await StorageManager.setLocal("app_settings", newSettings);
      set({ theme: updatedTheme });
    },
    updateNotifications: async (notificationUpdates) => {
      const currentNotifications = get2().notifications;
      const updatedNotifications = {
        ...currentNotifications,
        ...notificationUpdates
      };
      const newSettings = {
        ...get2(),
        notifications: updatedNotifications
      };
      await StorageManager.setLocal("app_settings", newSettings);
      set({ notifications: updatedNotifications });
    },
    updatePrivacy: async (privacyUpdates) => {
      const currentPrivacy = get2().privacy;
      const updatedPrivacy = { ...currentPrivacy, ...privacyUpdates };
      const newSettings = {
        ...get2(),
        privacy: updatedPrivacy
      };
      await StorageManager.setLocal("app_settings", newSettings);
      set({ privacy: updatedPrivacy });
    },
    updatePanelPosition: async (position) => {
      const newSettings = {
        ...get2(),
        panelPosition: position
      };
      await StorageManager.setLocal("app_settings", newSettings);
      set({ panelPosition: position });
    },
    updatePanelSize: async (size) => {
      const newSettings = {
        ...get2(),
        panelSize: size
      };
      await StorageManager.setLocal("app_settings", newSettings);
      set({ panelSize: size });
    },
    updateFeedPreferences: async (updates) => {
      const currentFeedPreferences = get2().feedPreferences;
      const updatedFeedPreferences = {
        ...currentFeedPreferences,
        ...updates,
        globalFilters: {
          ...currentFeedPreferences.globalFilters,
          ...updates.globalFilters || {}
        }
      };
      await StorageManager.setLocal("feed_preferences", updatedFeedPreferences);
      set({ feedPreferences: updatedFeedPreferences });
    },
    resetSettings: async () => {
      await StorageManager.setLocal("app_settings", DEFAULT_SETTINGS);
      await StorageManager.setLocal("feed_preferences", DEFAULT_FEED_PREFERENCES);
      set({ ...DEFAULT_SETTINGS, feedPreferences: DEFAULT_FEED_PREFERENCES });
    }
  }));
  content;
  async function getCompanyWatchlist() {
    return log$1.trackAsync(LogCategory.STORAGE, "getCompanyWatchlist", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Fetching company watchlist from storage");
        const result2 = await chrome.storage.local.get(WATCHLIST_COMPANIES_STORAGE_KEY);
        const companies = result2[WATCHLIST_COMPANIES_STORAGE_KEY] || [];
        log$1.info(LogCategory.STORAGE, "Company watchlist retrieved", { count: companies.length });
        console.log("[Uproot] Retrieved company watchlist:", companies.length, "companies");
        return companies;
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return [];
        }
        log$1.error(LogCategory.STORAGE, "Error getting company watchlist", { error });
        console.error("[Uproot] Error getting company watchlist:", error);
        return [];
      }
    });
  }
  async function saveCompanyWatchlist(companies) {
    return log$1.trackAsync(LogCategory.STORAGE, "saveCompanyWatchlist", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Saving company watchlist to storage", { count: companies.length });
        await chrome.storage.local.set({ [WATCHLIST_COMPANIES_STORAGE_KEY]: companies });
        log$1.change(LogCategory.STORAGE, "companyWatchlist", "update", { count: companies.length });
        console.log("[Uproot] Company watchlist saved:", companies.length, "companies");
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return;
        }
        log$1.error(LogCategory.STORAGE, "Error saving company watchlist", { error, count: companies.length });
        console.error("[Uproot] Error saving company watchlist:", error);
        throw error;
      }
    });
  }
  async function addCompanyToWatchlist(company) {
    return log$1.trackAsync(LogCategory.STORAGE, "addCompanyToWatchlist", async () => {
      log$1.debug(LogCategory.STORAGE, "Adding company to watchlist", { name: company.name, companyUrl: company.companyUrl });
      const companies = await getCompanyWatchlist();
      const id = company.companyUrl;
      const existingIndex = companies.findIndex((c) => c.id === id);
      if (existingIndex !== -1) {
        log$1.info(LogCategory.STORAGE, "Company already in watchlist", { name: company.name, id });
        console.log("[Uproot] Company already in watchlist:", company.name);
        return companies[existingIndex];
      }
      const newCompany = {
        ...company,
        id,
        addedAt: Date.now(),
        jobAlertEnabled: company.jobAlertEnabled ?? false
      };
      companies.unshift(newCompany);
      await saveCompanyWatchlist(companies);
      log$1.change(LogCategory.STORAGE, "companyWatchlist", "create", { id: newCompany.id, name: newCompany.name });
      console.log("[Uproot] Added company to watchlist:", company.name);
      if (newCompany.jobAlertEnabled) {
        try {
          const { feedPreferences, updateFeedPreferences } = useSettingsStore.getState();
          const enabledCompanies = feedPreferences.enabledCompanies || [];
          if (!enabledCompanies.includes(newCompany.id)) {
            await updateFeedPreferences({
              enabledCompanies: [...enabledCompanies, newCompany.id]
            });
            log$1.info(LogCategory.STORAGE, "Synced company to feedPreferences.enabledCompanies", { companyId: newCompany.id });
            console.log("[Uproot] Synced company to feedPreferences:", newCompany.name);
          }
        } catch (error) {
          log$1.error(LogCategory.STORAGE, "Error syncing to feedPreferences", { error, companyId: newCompany.id });
        }
      }
      return newCompany;
    });
  }
  async function removeCompanyFromWatchlist(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "removeCompanyFromWatchlist", async () => {
      log$1.debug(LogCategory.STORAGE, "Removing company from watchlist", { id });
      const companies = await getCompanyWatchlist();
      const filteredCompanies = companies.filter((c) => c.id !== id);
      await saveCompanyWatchlist(filteredCompanies);
      log$1.change(LogCategory.STORAGE, "companyWatchlist", "delete", { id });
      console.log("[Uproot] Removed company from watchlist:", id);
      try {
        const { feedPreferences, updateFeedPreferences } = useSettingsStore.getState();
        const enabledCompanies = feedPreferences.enabledCompanies || [];
        if (enabledCompanies.includes(id)) {
          await updateFeedPreferences({
            enabledCompanies: enabledCompanies.filter((companyId) => companyId !== id)
          });
          log$1.info(LogCategory.STORAGE, "Removed company from feedPreferences.enabledCompanies", { companyId: id });
          console.log("[Uproot] Removed company from feedPreferences:", id);
        }
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Error removing from feedPreferences", { error, companyId: id });
      }
    });
  }
  async function updateWatchlistCompany(id, updates) {
    return log$1.trackAsync(LogCategory.STORAGE, "updateWatchlistCompany", async () => {
      log$1.debug(LogCategory.STORAGE, "Updating watchlist company", { id, updates });
      const companies = await getCompanyWatchlist();
      const index2 = companies.findIndex((c) => c.id === id);
      if (index2 === -1) {
        log$1.error(LogCategory.STORAGE, "Company not found in watchlist", { id });
        throw new Error("Company not found in watchlist");
      }
      companies[index2] = {
        ...companies[index2],
        ...updates
      };
      const updatedCompany = companies[index2];
      await saveCompanyWatchlist(companies);
      log$1.change(LogCategory.STORAGE, "companyWatchlist", "update", { id, updates });
      console.log("[Uproot] Updated watchlist company:", id);
      if ("jobAlertEnabled" in updates) {
        try {
          const { feedPreferences, updateFeedPreferences } = useSettingsStore.getState();
          const enabledCompanies = feedPreferences.enabledCompanies || [];
          if (updatedCompany.jobAlertEnabled && !enabledCompanies.includes(id)) {
            await updateFeedPreferences({
              enabledCompanies: [...enabledCompanies, id]
            });
            log$1.info(LogCategory.STORAGE, "Added company to feedPreferences.enabledCompanies", { companyId: id });
            console.log("[Uproot] Added company to feedPreferences (alerts enabled):", id);
          } else if (!updatedCompany.jobAlertEnabled && enabledCompanies.includes(id)) {
            await updateFeedPreferences({
              enabledCompanies: enabledCompanies.filter((companyId) => companyId !== id)
            });
            log$1.info(LogCategory.STORAGE, "Removed company from feedPreferences.enabledCompanies", { companyId: id });
            console.log("[Uproot] Removed company from feedPreferences (alerts disabled):", id);
          }
        } catch (error) {
          log$1.error(LogCategory.STORAGE, "Error syncing jobAlertEnabled to feedPreferences", { error, companyId: id });
        }
      }
    });
  }
  async function isCompanyInWatchlist(companyUrl) {
    return log$1.trackAsync(LogCategory.STORAGE, "isCompanyInWatchlist", async () => {
      log$1.debug(LogCategory.STORAGE, "Checking if company is in watchlist", { companyUrl });
      const companies = await getCompanyWatchlist();
      const isInList = companies.some((c) => c.id === companyUrl);
      log$1.info(LogCategory.STORAGE, "Company watchlist check complete", { companyUrl, isInList });
      return isInList;
    });
  }
  content;
  async function getConnectionPaths() {
    return log$1.trackAsync(LogCategory.STORAGE, "getConnectionPaths", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Fetching connection paths from storage");
        const result2 = await chrome.storage.local.get(CONNECTION_PATHS_STORAGE_KEY);
        const paths = result2[CONNECTION_PATHS_STORAGE_KEY] || [];
        log$1.info(LogCategory.STORAGE, "Connection paths retrieved", { count: paths.length });
        console.log("[Uproot] Retrieved connection paths:", paths.length, "paths");
        return paths;
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Error getting connection paths", { error });
        console.error("[Uproot] Error getting connection paths:", error);
        return [];
      }
    });
  }
  async function saveConnectionPaths(paths) {
    return log$1.trackAsync(LogCategory.STORAGE, "saveConnectionPaths", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Saving connection paths to storage", { count: paths.length });
        await chrome.storage.local.set({ [CONNECTION_PATHS_STORAGE_KEY]: paths });
        log$1.change(LogCategory.STORAGE, "connectionPaths", "update", { count: paths.length });
        console.log("[Uproot] Connection paths saved:", paths.length, "paths");
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Error saving connection paths", { error, count: paths.length });
        console.error("[Uproot] Error saving connection paths:", error);
        throw error;
      }
    });
  }
  async function addConnectionPath(path) {
    return log$1.trackAsync(LogCategory.STORAGE, "addConnectionPath", async () => {
      log$1.debug(LogCategory.STORAGE, "Adding connection path", { targetName: path.targetName, targetProfileUrl: path.targetProfileUrl });
      const paths = await getConnectionPaths();
      const id = path.targetProfileUrl;
      const existingIndex = paths.findIndex((p) => p.id === id);
      if (existingIndex !== -1) {
        log$1.info(LogCategory.STORAGE, "Connection path already exists", { targetName: path.targetName, id });
        console.log("[Uproot] Connection path already exists:", path.targetName);
        return paths[existingIndex];
      }
      const newPath = {
        ...path,
        id,
        addedAt: Date.now(),
        lastUpdated: Date.now()
      };
      paths.unshift(newPath);
      await saveConnectionPaths(paths);
      log$1.change(LogCategory.STORAGE, "connectionPaths", "create", { id: newPath.id, targetName: newPath.targetName });
      console.log("[Uproot] Added connection path:", path.targetName);
      return newPath;
    });
  }
  async function removeConnectionPath(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "removeConnectionPath", async () => {
      log$1.debug(LogCategory.STORAGE, "Removing connection path", { id });
      const paths = await getConnectionPaths();
      const filteredPaths = paths.filter((p) => p.id !== id);
      await saveConnectionPaths(filteredPaths);
      log$1.change(LogCategory.STORAGE, "connectionPaths", "delete", { id });
      console.log("[Uproot] Removed connection path:", id);
    });
  }
  async function updateConnectionPath(id, updates) {
    return log$1.trackAsync(LogCategory.STORAGE, "updateConnectionPath", async () => {
      log$1.debug(LogCategory.STORAGE, "Updating connection path", { id, updates });
      const paths = await getConnectionPaths();
      const index2 = paths.findIndex((p) => p.id === id);
      if (index2 === -1) {
        log$1.error(LogCategory.STORAGE, "Connection path not found", { id });
        throw new Error("Connection path not found");
      }
      paths[index2] = {
        ...paths[index2],
        ...updates,
        lastUpdated: Date.now()
      };
      await saveConnectionPaths(paths);
      log$1.change(LogCategory.STORAGE, "connectionPaths", "update", { id, updates });
      console.log("[Uproot] Updated connection path:", id);
    });
  }
  async function markStepConnected(pathId, stepIndex) {
    return log$1.trackAsync(LogCategory.STORAGE, "markStepConnected", async () => {
      log$1.debug(LogCategory.STORAGE, "Marking step as connected", { pathId, stepIndex });
      const paths = await getConnectionPaths();
      const pathIndex = paths.findIndex((p) => p.id === pathId);
      if (pathIndex === -1) {
        log$1.error(LogCategory.STORAGE, "Connection path not found", { pathId });
        throw new Error("Connection path not found");
      }
      const path = paths[pathIndex];
      if (stepIndex < 0 || stepIndex >= path.path.length) {
        log$1.error(LogCategory.STORAGE, "Invalid step index", { pathId, stepIndex, maxIndex: path.path.length - 1 });
        throw new Error("Invalid step index");
      }
      path.path[stepIndex].connected = true;
      path.completedSteps = path.path.filter((step) => step.connected).length;
      path.isComplete = path.completedSteps === path.totalSteps;
      path.lastUpdated = Date.now();
      await saveConnectionPaths(paths);
      log$1.change(LogCategory.STORAGE, "connectionPaths", "update", { pathId, stepIndex, isComplete: path.isComplete });
      console.log("[Uproot] Marked step as connected:", pathId, stepIndex);
    });
  }
  async function isConnectionPathSaved(targetProfileUrl) {
    return log$1.trackAsync(LogCategory.STORAGE, "isConnectionPathSaved", async () => {
      log$1.debug(LogCategory.STORAGE, "Checking if connection path exists", { targetProfileUrl });
      const paths = await getConnectionPaths();
      const exists = paths.some((p) => p.id === targetProfileUrl);
      log$1.info(LogCategory.STORAGE, "Connection path check complete", { targetProfileUrl, exists });
      return exists;
    });
  }
  content;
  const ONBOARDING_STORAGE_KEY = "uproot_onboarding";
  content;
  async function getOnboardingState() {
    return log$1.trackAsync(LogCategory.STORAGE, "getOnboardingState", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Fetching onboarding state from storage");
        const result2 = await chrome.storage.local.get(ONBOARDING_STORAGE_KEY);
        const state = result2[ONBOARDING_STORAGE_KEY] || {
          isComplete: false,
          currentStep: 0
        };
        log$1.info(LogCategory.STORAGE, "Onboarding state retrieved", { isComplete: state.isComplete, currentStep: state.currentStep });
        console.log("[Uproot] Retrieved onboarding state:", state);
        return state;
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return {
            isComplete: false,
            currentStep: 0
          };
        }
        log$1.error(LogCategory.STORAGE, "Error getting onboarding state", { error });
        console.error("[Uproot] Error getting onboarding state:", error);
        return {
          isComplete: false,
          currentStep: 0
        };
      }
    });
  }
  async function saveOnboardingState(state) {
    return log$1.trackAsync(LogCategory.STORAGE, "saveOnboardingState", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Saving onboarding state to storage", { isComplete: state.isComplete, currentStep: state.currentStep });
        await chrome.storage.local.set({ [ONBOARDING_STORAGE_KEY]: state });
        log$1.change(LogCategory.STORAGE, "onboarding", "update", { isComplete: state.isComplete, currentStep: state.currentStep });
        console.log("[Uproot] Onboarding state saved:", state);
      } catch (error) {
        if (isContextInvalidatedError(error)) {
          return;
        }
        log$1.error(LogCategory.STORAGE, "Error saving onboarding state", { error, state });
        console.error("[Uproot] Error saving onboarding state:", error);
        throw error;
      }
    });
  }
  async function completeOnboarding(preferences) {
    return log$1.trackAsync(LogCategory.STORAGE, "completeOnboarding", async () => {
      log$1.debug(LogCategory.STORAGE, "Completing onboarding", { preferences });
      const state = {
        isComplete: true,
        completedAt: Date.now(),
        currentStep: 3,
        // Final step
        preferences
      };
      await saveOnboardingState(state);
      log$1.change(LogCategory.STORAGE, "onboarding", "complete", { preferences });
      console.log("[Uproot] Onboarding completed with preferences");
    });
  }
  async function isOnboardingComplete() {
    return log$1.trackAsync(LogCategory.STORAGE, "isOnboardingComplete", async () => {
      log$1.debug(LogCategory.STORAGE, "Checking if onboarding is complete");
      const state = await getOnboardingState();
      log$1.info(LogCategory.STORAGE, "Onboarding completion check", { isComplete: state.isComplete });
      return state.isComplete;
    });
  }
  content;
  const FEED_STORAGE_KEY = "uproot_feed";
  content;
  async function getFeedItems() {
    return log$1.trackAsync(LogCategory.STORAGE, "getFeedItems", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Fetching feed items from storage");
        const result2 = await chrome.storage.local.get(FEED_STORAGE_KEY);
        const items = result2[FEED_STORAGE_KEY] || [];
        const sortedItems = items.sort((a, b) => b.timestamp - a.timestamp);
        log$1.info(LogCategory.STORAGE, "Feed items retrieved", { count: sortedItems.length });
        console.log("[Uproot] Retrieved feed items:", sortedItems.length, "items");
        return sortedItems;
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Error getting feed items", { error });
        console.error("[Uproot] Error getting feed items:", error);
        return [];
      }
    });
  }
  async function saveFeedItems(items) {
    return log$1.trackAsync(LogCategory.STORAGE, "saveFeedItems", async () => {
      try {
        log$1.debug(LogCategory.STORAGE, "Saving feed items to storage", { count: items.length });
        const sortedItems = items.sort((a, b) => b.timestamp - a.timestamp);
        await chrome.storage.local.set({ [FEED_STORAGE_KEY]: sortedItems });
        log$1.change(LogCategory.STORAGE, "feedItems", "update", { count: items.length });
        console.log("[Uproot] Feed items saved:", items.length, "items");
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Error saving feed items", { error, count: items.length });
        console.error("[Uproot] Error saving feed items:", error);
        throw error;
      }
    });
  }
  async function addFeedItem(item) {
    return log$1.trackAsync(LogCategory.STORAGE, "addFeedItem", async () => {
      log$1.debug(LogCategory.STORAGE, "Adding feed item", { type: item.type, title: item.title });
      const items = await getFeedItems();
      const id = `feed_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const newItem = {
        ...item,
        id
      };
      items.unshift(newItem);
      await saveFeedItems(items);
      log$1.change(LogCategory.STORAGE, "feedItems", "create", { id, type: newItem.type, title: newItem.title });
      console.log("[Uproot] Added feed item:", newItem.type, newItem.title);
      return newItem;
    });
  }
  async function toggleFeedItemRead(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "toggleFeedItemRead", async () => {
      log$1.debug(LogCategory.STORAGE, "Toggling feed item read status", { id });
      const items = await getFeedItems();
      const index2 = items.findIndex((item) => item.id === id);
      if (index2 === -1) {
        log$1.error(LogCategory.STORAGE, "Feed item not found", { id });
        throw new Error("Feed item not found");
      }
      items[index2].read = !items[index2].read;
      await saveFeedItems(items);
      log$1.change(LogCategory.STORAGE, "feedItems", "update", { id, read: items[index2].read });
      console.log("[Uproot] Toggled read status for feed item:", id, "â†’", items[index2].read);
    });
  }
  async function markAllFeedItemsAsRead() {
    return log$1.trackAsync(LogCategory.STORAGE, "markAllFeedItemsAsRead", async () => {
      log$1.debug(LogCategory.STORAGE, "Marking all feed items as read");
      const items = await getFeedItems();
      const updatedItems = items.map((item) => ({ ...item, read: true }));
      await saveFeedItems(updatedItems);
      log$1.change(LogCategory.STORAGE, "feedItems", "markAllRead", { count: items.length });
      console.log("[Uproot] Marked all feed items as read");
    });
  }
  async function deleteFeedItem(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "deleteFeedItem", async () => {
      log$1.debug(LogCategory.STORAGE, "Deleting feed item", { id });
      const items = await getFeedItems();
      const filteredItems = items.filter((item) => item.id !== id);
      await saveFeedItems(filteredItems);
      log$1.change(LogCategory.STORAGE, "feedItems", "delete", { id });
      console.log("[Uproot] Deleted feed item:", id);
    });
  }
  async function getFeedStats() {
    return log$1.trackAsync(LogCategory.STORAGE, "getFeedStats", async () => {
      log$1.debug(LogCategory.STORAGE, "Calculating feed statistics");
      const items = await getFeedItems();
      const stats = {
        totalItems: items.length,
        unreadCount: items.filter((item) => !item.read).length,
        jobAlerts: items.filter((item) => item.type === "job_alert").length,
        companyUpdates: items.filter((item) => item.type === "company_update").length,
        connectionUpdates: items.filter((item) => item.type === "connection_update").length,
        warmPaths: items.filter((item) => item.type === "warm_path_opened").length
      };
      log$1.info(LogCategory.STORAGE, "Feed statistics calculated", stats);
      return stats;
    });
  }
  content;
  async function addJobExperience(job) {
    return log$1.trackAsync(LogCategory.STORAGE, "addJobExperience", async () => {
      log$1.debug(LogCategory.STORAGE, "Adding job experience", { title: job.title, company: job.company });
      const profile = await getProfessionalProfile();
      const newJob = {
        ...job,
        id: `job_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
      profile.jobs.push(newJob);
      await saveProfessionalProfile(profile);
      log$1.change(LogCategory.STORAGE, "jobExperience", "create", { id: newJob.id, title: newJob.title, company: newJob.company });
      console.log("[Uproot] Added job:", newJob.title, "at", newJob.company);
      return newJob;
    });
  }
  async function updateJobExperience(id, updates) {
    return log$1.trackAsync(LogCategory.STORAGE, "updateJobExperience", async () => {
      log$1.debug(LogCategory.STORAGE, "Updating job experience", { id, updates });
      const profile = await getProfessionalProfile();
      const index2 = profile.jobs.findIndex((j) => j.id === id);
      if (index2 === -1) {
        log$1.error(LogCategory.STORAGE, "Job not found", { id });
        throw new Error("Job not found");
      }
      profile.jobs[index2] = {
        ...profile.jobs[index2],
        ...updates,
        updatedAt: Date.now()
      };
      await saveProfessionalProfile(profile);
      log$1.change(LogCategory.STORAGE, "jobExperience", "update", { id, updates });
      console.log("[Uproot] Updated job:", id);
    });
  }
  async function deleteJobExperience(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "deleteJobExperience", async () => {
      log$1.debug(LogCategory.STORAGE, "Deleting job experience", { id });
      const profile = await getProfessionalProfile();
      profile.jobs = profile.jobs.filter((j) => j.id !== id);
      await saveProfessionalProfile(profile);
      log$1.change(LogCategory.STORAGE, "jobExperience", "delete", { id });
      console.log("[Uproot] Deleted job:", id);
    });
  }
  async function addInternshipExperience(internship) {
    return log$1.trackAsync(LogCategory.STORAGE, "addInternshipExperience", async () => {
      log$1.debug(LogCategory.STORAGE, "Adding internship experience", { title: internship.title, company: internship.company });
      const profile = await getProfessionalProfile();
      const newInternship = {
        ...internship,
        id: `intern_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
      profile.internships.push(newInternship);
      await saveProfessionalProfile(profile);
      log$1.change(LogCategory.STORAGE, "internshipExperience", "create", { id: newInternship.id, title: newInternship.title, company: newInternship.company });
      console.log("[Uproot] Added internship:", newInternship.title, "at", newInternship.company);
      return newInternship;
    });
  }
  async function deleteInternshipExperience(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "deleteInternshipExperience", async () => {
      log$1.debug(LogCategory.STORAGE, "Deleting internship experience", { id });
      const profile = await getProfessionalProfile();
      profile.internships = profile.internships.filter((i) => i.id !== id);
      await saveProfessionalProfile(profile);
      log$1.change(LogCategory.STORAGE, "internshipExperience", "delete", { id });
      console.log("[Uproot] Deleted internship:", id);
    });
  }
  async function addVolunteerExperience(volunteer) {
    return log$1.trackAsync(LogCategory.STORAGE, "addVolunteerExperience", async () => {
      log$1.debug(LogCategory.STORAGE, "Adding volunteer experience", { role: volunteer.role, organization: volunteer.organization });
      const profile = await getProfessionalProfile();
      const newVolunteer = {
        ...volunteer,
        id: `volunteer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
      profile.volunteerWork.push(newVolunteer);
      await saveProfessionalProfile(profile);
      log$1.change(LogCategory.STORAGE, "volunteerExperience", "create", { id: newVolunteer.id, role: newVolunteer.role, organization: newVolunteer.organization });
      console.log("[Uproot] Added volunteer work:", newVolunteer.role, "at", newVolunteer.organization);
      return newVolunteer;
    });
  }
  async function deleteVolunteerExperience(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "deleteVolunteerExperience", async () => {
      log$1.debug(LogCategory.STORAGE, "Deleting volunteer experience", { id });
      const profile = await getProfessionalProfile();
      profile.volunteerWork = profile.volunteerWork.filter((v) => v.id !== id);
      await saveProfessionalProfile(profile);
      log$1.change(LogCategory.STORAGE, "volunteerExperience", "delete", { id });
      console.log("[Uproot] Deleted volunteer work:", id);
    });
  }
  content;
  async function addTechnicalSkill(skill) {
    return log$1.trackAsync(LogCategory.STORAGE, "addTechnicalSkill", async () => {
      log$1.debug(LogCategory.STORAGE, "Adding technical skill to profile", { skillName: skill.name });
      try {
        const profile = await getProfessionalProfile();
        const newSkill = {
          ...skill,
          id: `skill_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        };
        profile.technicalSkills.push(newSkill);
        await saveProfessionalProfile(profile);
        log$1.change(LogCategory.STORAGE, "technicalSkill", "create", { id: newSkill.id, name: newSkill.name });
        console.log("[Uproot] Added technical skill:", newSkill.name);
        return newSkill;
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to add technical skill", error, { skillName: skill.name });
        console.error("[Uproot] Error adding technical skill:", error);
        throw error;
      }
    });
  }
  async function updateTechnicalSkill(id, updates) {
    return log$1.trackAsync(LogCategory.STORAGE, "updateTechnicalSkill", async () => {
      log$1.debug(LogCategory.STORAGE, "Updating technical skill", { id, updates });
      try {
        const profile = await getProfessionalProfile();
        const index2 = profile.technicalSkills.findIndex((s) => s.id === id);
        if (index2 === -1) {
          log$1.error(LogCategory.STORAGE, "Technical skill not found", new Error("Skill not found"), { id });
          throw new Error("Skill not found");
        }
        profile.technicalSkills[index2] = {
          ...profile.technicalSkills[index2],
          ...updates
        };
        await saveProfessionalProfile(profile);
        log$1.change(LogCategory.STORAGE, "technicalSkill", "update", { id, updated: Object.keys(updates) });
        console.log("[Uproot] Updated technical skill:", id);
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to update technical skill", error, { id });
        console.error("[Uproot] Error updating technical skill:", error);
        throw error;
      }
    });
  }
  async function deleteTechnicalSkill(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "deleteTechnicalSkill", async () => {
      log$1.debug(LogCategory.STORAGE, "Deleting technical skill", { id });
      try {
        const profile = await getProfessionalProfile();
        profile.technicalSkills = profile.technicalSkills.filter((s) => s.id !== id);
        await saveProfessionalProfile(profile);
        log$1.change(LogCategory.STORAGE, "technicalSkill", "delete", { id });
        console.log("[Uproot] Deleted technical skill:", id);
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to delete technical skill", error, { id });
        console.error("[Uproot] Error deleting technical skill:", error);
        throw error;
      }
    });
  }
  async function addTool(tool) {
    return log$1.trackAsync(LogCategory.STORAGE, "addTool", async () => {
      log$1.debug(LogCategory.STORAGE, "Adding tool to profile", { toolName: tool.name });
      try {
        const profile = await getProfessionalProfile();
        const newTool = {
          ...tool,
          id: `tool_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        };
        profile.tools.push(newTool);
        await saveProfessionalProfile(profile);
        log$1.change(LogCategory.STORAGE, "tool", "create", { id: newTool.id, name: newTool.name });
        console.log("[Uproot] Added tool:", newTool.name);
        return newTool;
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to add tool", error, { toolName: tool.name });
        console.error("[Uproot] Error adding tool:", error);
        throw error;
      }
    });
  }
  async function updateTool(id, updates) {
    return log$1.trackAsync(LogCategory.STORAGE, "updateTool", async () => {
      log$1.debug(LogCategory.STORAGE, "Updating tool", { id, updates });
      try {
        const profile = await getProfessionalProfile();
        const index2 = profile.tools.findIndex((t) => t.id === id);
        if (index2 === -1) {
          log$1.error(LogCategory.STORAGE, "Tool not found", new Error("Tool not found"), { id });
          throw new Error("Tool not found");
        }
        profile.tools[index2] = {
          ...profile.tools[index2],
          ...updates
        };
        await saveProfessionalProfile(profile);
        log$1.change(LogCategory.STORAGE, "tool", "update", { id, updated: Object.keys(updates) });
        console.log("[Uproot] Updated tool:", id);
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to update tool", error, { id });
        console.error("[Uproot] Error updating tool:", error);
        throw error;
      }
    });
  }
  async function deleteTool(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "deleteTool", async () => {
      log$1.debug(LogCategory.STORAGE, "Deleting tool", { id });
      try {
        const profile = await getProfessionalProfile();
        profile.tools = profile.tools.filter((t) => t.id !== id);
        await saveProfessionalProfile(profile);
        log$1.change(LogCategory.STORAGE, "tool", "delete", { id });
        console.log("[Uproot] Deleted tool:", id);
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to delete tool", error, { id });
        console.error("[Uproot] Error deleting tool:", error);
        throw error;
      }
    });
  }
  async function addCertification(cert) {
    return log$1.trackAsync(LogCategory.STORAGE, "addCertification", async () => {
      log$1.debug(LogCategory.STORAGE, "Adding certification to profile", { certName: cert.name });
      try {
        const profile = await getProfessionalProfile();
        const newCert = {
          ...cert,
          id: `cert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        };
        profile.certifications.push(newCert);
        await saveProfessionalProfile(profile);
        log$1.change(LogCategory.STORAGE, "certification", "create", { id: newCert.id, name: newCert.name });
        console.log("[Uproot] Added certification:", newCert.name);
        return newCert;
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to add certification", error, { certName: cert.name });
        console.error("[Uproot] Error adding certification:", error);
        throw error;
      }
    });
  }
  async function deleteCertification(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "deleteCertification", async () => {
      log$1.debug(LogCategory.STORAGE, "Deleting certification", { id });
      try {
        const profile = await getProfessionalProfile();
        profile.certifications = profile.certifications.filter((c) => c.id !== id);
        await saveProfessionalProfile(profile);
        log$1.change(LogCategory.STORAGE, "certification", "delete", { id });
        console.log("[Uproot] Deleted certification:", id);
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to delete certification", error, { id });
        console.error("[Uproot] Error deleting certification:", error);
        throw error;
      }
    });
  }
  content;
  async function addEducation(edu) {
    return log$1.trackAsync(LogCategory.STORAGE, "addEducation", async () => {
      log$1.debug(LogCategory.STORAGE, "Adding education to profile", { degree: edu.degree, institution: edu.institution });
      try {
        const profile = await getProfessionalProfile();
        const newEdu = {
          ...edu,
          id: `edu_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
        profile.education.push(newEdu);
        await saveProfessionalProfile(profile);
        log$1.change(LogCategory.STORAGE, "education", "create", { id: newEdu.id, degree: newEdu.degree, institution: newEdu.institution });
        console.log("[Uproot] Added education:", newEdu.degree, "in", newEdu.field);
        return newEdu;
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to add education", error, { degree: edu.degree });
        console.error("[Uproot] Error adding education:", error);
        throw error;
      }
    });
  }
  async function deleteEducation(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "deleteEducation", async () => {
      log$1.debug(LogCategory.STORAGE, "Deleting education", { id });
      try {
        const profile = await getProfessionalProfile();
        profile.education = profile.education.filter((e) => e.id !== id);
        await saveProfessionalProfile(profile);
        log$1.change(LogCategory.STORAGE, "education", "delete", { id });
        console.log("[Uproot] Deleted education:", id);
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to delete education", error, { id });
        console.error("[Uproot] Error deleting education:", error);
        throw error;
      }
    });
  }
  async function addProject(project) {
    return log$1.trackAsync(LogCategory.STORAGE, "addProject", async () => {
      log$1.debug(LogCategory.STORAGE, "Adding project to profile", { projectName: project.name });
      try {
        const profile = await getProfessionalProfile();
        const newProject = {
          ...project,
          id: `project_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
        profile.projects.push(newProject);
        await saveProfessionalProfile(profile);
        log$1.change(LogCategory.STORAGE, "project", "create", { id: newProject.id, name: newProject.name });
        console.log("[Uproot] Added project:", newProject.name);
        return newProject;
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to add project", error, { projectName: project.name });
        console.error("[Uproot] Error adding project:", error);
        throw error;
      }
    });
  }
  async function deleteProject(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "deleteProject", async () => {
      log$1.debug(LogCategory.STORAGE, "Deleting project", { id });
      try {
        const profile = await getProfessionalProfile();
        profile.projects = profile.projects.filter((p) => p.id !== id);
        await saveProfessionalProfile(profile);
        log$1.change(LogCategory.STORAGE, "project", "delete", { id });
        console.log("[Uproot] Deleted project:", id);
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to delete project", error, { id });
        console.error("[Uproot] Error deleting project:", error);
        throw error;
      }
    });
  }
  content;
  async function getJobDescriptionAnalyses() {
    return log$1.trackAsync(LogCategory.STORAGE, "getJobDescriptionAnalyses", async () => {
      log$1.debug(LogCategory.STORAGE, "Fetching all job description analyses from storage");
      try {
        const result2 = await chrome.storage.local.get(JOB_DESCRIPTIONS_KEY);
        const analyses = result2[JOB_DESCRIPTIONS_KEY] || [];
        const sorted = analyses.sort((a, b) => b.analyzedAt - a.analyzedAt);
        log$1.info(LogCategory.STORAGE, "Job description analyses retrieved", { count: sorted.length });
        return sorted;
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to get job description analyses", error);
        console.error("[Uproot] Error getting job description analyses:", error);
        return [];
      }
    });
  }
  async function saveJobDescriptionAnalysis(analysis) {
    return log$1.trackAsync(LogCategory.STORAGE, "saveJobDescriptionAnalysis", async () => {
      log$1.debug(LogCategory.STORAGE, "Saving job description analysis", { id: analysis.id, jobTitle: analysis.jobTitle, company: analysis.company });
      try {
        const analyses = await getJobDescriptionAnalyses();
        const existingIndex = analyses.findIndex((a) => a.id === analysis.id);
        if (existingIndex !== -1) {
          analyses[existingIndex] = analysis;
          log$1.change(LogCategory.STORAGE, "jobDescriptionAnalysis", "update", { id: analysis.id, jobTitle: analysis.jobTitle });
        } else {
          analyses.push(analysis);
          log$1.change(LogCategory.STORAGE, "jobDescriptionAnalysis", "create", { id: analysis.id, jobTitle: analysis.jobTitle });
        }
        await chrome.storage.local.set({ [JOB_DESCRIPTIONS_KEY]: analyses });
        console.log("[Uproot] Job description analysis saved:", analysis.jobTitle);
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to save job description analysis", error, { id: analysis.id });
        console.error("[Uproot] Error saving job description analysis:", error);
        throw error;
      }
    });
  }
  async function deleteJobDescriptionAnalysis(id) {
    return log$1.trackAsync(LogCategory.STORAGE, "deleteJobDescriptionAnalysis", async () => {
      log$1.debug(LogCategory.STORAGE, "Deleting job description analysis", { id });
      try {
        const analyses = await getJobDescriptionAnalyses();
        const filtered = analyses.filter((a) => a.id !== id);
        await chrome.storage.local.set({ [JOB_DESCRIPTIONS_KEY]: filtered });
        log$1.change(LogCategory.STORAGE, "jobDescriptionAnalysis", "delete", { id });
        console.log("[Uproot] Job description analysis deleted:", id);
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to delete job description analysis", error, { id });
        console.error("[Uproot] Error deleting job description analysis:", error);
        throw error;
      }
    });
  }
  content;
  async function saveGeneratedResume(resume) {
    return log$1.trackAsync(LogCategory.STORAGE, "saveGeneratedResume", async () => {
      log$1.debug(LogCategory.STORAGE, "Saving generated resume", { id: resume.id, jobTitle: resume.jobTitle, company: resume.company });
      try {
        const result2 = await chrome.storage.local.get(GENERATED_RESUMES_KEY);
        const resumes = result2[GENERATED_RESUMES_KEY] || [];
        resumes.unshift(resume);
        await chrome.storage.local.set({ [GENERATED_RESUMES_KEY]: resumes });
        log$1.change(LogCategory.STORAGE, "generatedResume", "create", { id: resume.id, jobTitle: resume.jobTitle, company: resume.company });
        console.log("[Uproot] Saved generated resume for:", resume.jobTitle, "at", resume.company);
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to save generated resume", error, { id: resume.id });
        console.error("[Uproot] Error saving generated resume:", error);
        throw error;
      }
    });
  }
  async function getGeneratedResumes() {
    return log$1.trackAsync(LogCategory.STORAGE, "getGeneratedResumes", async () => {
      log$1.debug(LogCategory.STORAGE, "Fetching all generated resumes from storage");
      try {
        const result2 = await chrome.storage.local.get(GENERATED_RESUMES_KEY);
        const resumes = result2[GENERATED_RESUMES_KEY] || [];
        log$1.info(LogCategory.STORAGE, "Generated resumes retrieved", { count: resumes.length });
        return resumes;
      } catch (error) {
        log$1.error(LogCategory.STORAGE, "Failed to get generated resumes", error);
        console.error("[Uproot] Error getting generated resumes:", error);
        return [];
      }
    });
  }
  content;
  content;
  content;
  content;
  content;
  const storage = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    addCertification,
    addCompanyToWatchlist,
    addConnectionPath,
    addEducation,
    addFeedItem,
    addInternshipExperience,
    addJobExperience,
    addProject,
    addTechnicalSkill,
    addToWatchlist,
    addTool,
    addVolunteerExperience,
    completeOnboarding,
    deleteCertification,
    deleteEducation,
    deleteFeedItem,
    deleteInternshipExperience,
    deleteJobDescriptionAnalysis,
    deleteJobExperience,
    deleteProject,
    deleteTechnicalSkill,
    deleteTool,
    deleteVolunteerExperience,
    getCompanyWatchlist,
    getConnectionPaths,
    getFeedItems,
    getFeedStats,
    getGeneratedResumes,
    getJobDescriptionAnalyses,
    getOnboardingState,
    getProfessionalProfile,
    getProfileStats,
    getWatchlist,
    isCompanyInWatchlist,
    isConnectionPathSaved,
    isInWatchlist,
    isOnboardingComplete,
    markAllFeedItemsAsRead,
    markStepConnected,
    removeCompanyFromWatchlist,
    removeConnectionPath,
    removeFromWatchlist,
    saveCompanyWatchlist,
    saveConnectionPaths,
    saveFeedItems,
    saveGeneratedResume,
    saveJobDescriptionAnalysis,
    saveOnboardingState,
    saveProfessionalProfile,
    saveWatchlist,
    toggleFeedItemRead,
    updateConnectionPath,
    updateJobExperience,
    updateTechnicalSkill,
    updateTool,
    updateWatchlistCompany,
    updateWatchlistPerson
  }, Symbol.toStringTag, { value: "Module" }));
  function useBadgeCounts() {
    const [counts, setCounts] = reactExports.useState({
      watchlist: 0,
      feed: 0,
      jobs: 0
    });
    reactExports.useEffect(() => {
      const fetchCounts = async () => {
        try {
          const feedStats = await getFeedStats();
          const watchlistPeople = await getWatchlist();
          const jobs = await getJobDescriptionAnalyses();
          setCounts({
            feed: feedStats.unreadCount,
            watchlist: watchlistPeople.length,
            jobs: jobs.length
          });
          console.log("[Uproot] Badge counts updated:", {
            feed: feedStats.unreadCount,
            watchlist: watchlistPeople.length,
            jobs: jobs.length
          });
        } catch (error) {
          console.error("[Uproot] Failed to fetch badge counts:", error);
        }
      };
      fetchCounts();
      const handleStorageChange = (changes, areaName) => {
        if (areaName === "local") {
          if (changes[FEED_STORAGE_KEY] || changes[WATCHLIST_PEOPLE_STORAGE_KEY] || changes[JOB_DESCRIPTIONS_KEY]) {
            fetchCounts();
          }
        }
      };
      chrome.storage.onChanged.addListener(handleStorageChange);
      return () => {
        chrome.storage.onChanged.removeListener(handleStorageChange);
      };
    }, []);
    const getCountForTab = (tabId) => {
      switch (tabId) {
        case "watchlist":
          return counts.watchlist;
        case "feed":
          return counts.feed;
        case "jobs":
          return counts.jobs;
        default:
          return 0;
      }
    };
    return {
      counts,
      getCountForTab
    };
  }
  content;
  const TAB_CONFIGS = [
    // ========================================
    // ALWAYS VISIBLE (4 core tabs)
    // ========================================
    {
      id: "feed",
      label: "Feed",
      icon: Activity,
      shortcut: 1,
      alwaysVisible: true,
      badge: true,
      badgeColor: "orange"
    },
    {
      id: "watchlist",
      label: "Watchlist",
      icon: BookmarkCheck,
      shortcut: 2,
      alwaysVisible: true,
      badge: false
    },
    {
      id: "resume",
      label: "Resume",
      icon: FileText,
      shortcut: 3,
      alwaysVisible: true,
      badge: false
    },
    {
      id: "jobs",
      label: "Jobs",
      icon: Briefcase,
      shortcut: 4,
      alwaysVisible: false,
      visibleOn: ["job"],
      // Only on LinkedIn job pages
      badge: true,
      // Show count of analyzed jobs
      badgeColor: "blue"
    },
    {
      id: "settings",
      label: "Settings",
      icon: Settings2,
      shortcut: 5,
      alwaysVisible: true,
      badge: false
    },
    // ========================================
    // CONTEXT-SENSITIVE (3 tabs)
    // ========================================
    {
      id: "profile",
      label: "Profile",
      icon: CircleUser,
      shortcut: 6,
      alwaysVisible: false,
      visibleOn: ["profile"],
      // Only on person pages
      badge: false
    },
    {
      id: "company",
      label: "Company",
      icon: Building2,
      shortcut: 7,
      alwaysVisible: false,
      visibleOn: ["company"],
      // Only on company pages
      badge: false
    },
    // ========================================
    // SPECIAL (1 tab - first-run only)
    // ========================================
    {
      id: "onboarding",
      label: "Get Started",
      icon: Rocket,
      shortcut: 8,
      alwaysVisible: false,
      // Only shown on first run
      badge: false
    }
  ];
  function getVisibleTabs(pageContextType, isFirstRun) {
    console.log("[Uproot] getVisibleTabs called with:", { pageContextType, isFirstRun });
    if (isFirstRun) {
      const onboardingTab = TAB_CONFIGS.find((tab) => tab.id === "onboarding");
      if (onboardingTab) {
        console.log("[Uproot] First run - showing ONLY onboarding tab");
        return [onboardingTab];
      }
    }
    const visibleTabs = TAB_CONFIGS.filter((tab) => {
      if (tab.id === "onboarding") {
        console.log(`[Uproot] Tab "${tab.id}": HIDDEN (not first run)`);
        return false;
      }
      if (tab.alwaysVisible) {
        console.log(`[Uproot] Tab "${tab.id}": VISIBLE (always visible)`);
        return true;
      }
      if (tab.visibleOn) {
        const shouldShow = tab.visibleOn.includes(pageContextType);
        console.log(`[Uproot] Tab "${tab.id}": ${shouldShow ? "VISIBLE" : "HIDDEN"} (visibleOn: ${JSON.stringify(tab.visibleOn)}, current: ${pageContextType})`);
        return shouldShow;
      }
      console.log(`[Uproot] Tab "${tab.id}": HIDDEN (no visibility rules)`);
      return false;
    });
    console.log("[Uproot] Final visible tabs:", visibleTabs.map((t) => t.id));
    return visibleTabs;
  }
  content;
  function useWatchlist() {
    const [watchlist, setWatchlist] = reactExports.useState([]);
    const [companyWatchlist, setCompanyWatchlist] = reactExports.useState([]);
    const [connectionPaths, setConnectionPaths] = reactExports.useState([]);
    const [isLoading, setIsLoading] = reactExports.useState(true);
    const loadWatchlist = reactExports.useCallback(async () => {
      setIsLoading(true);
      try {
        const [paths, people, companies] = await Promise.all([
          getConnectionPaths(),
          getWatchlist(),
          getCompanyWatchlist()
        ]);
        setConnectionPaths(paths);
        setWatchlist(people);
        setCompanyWatchlist(companies);
      } catch (error) {
        console.error("[Uproot] Error loading watchlist:", error instanceof Error ? error.message : String(error), error);
      } finally {
        setIsLoading(false);
      }
    }, []);
    const addPerson = reactExports.useCallback(async (person) => {
      try {
        const newPerson = await addToWatchlist(person);
        setWatchlist((prev) => [newPerson, ...prev.filter((p) => p.id !== newPerson.id)]);
        return newPerson;
      } catch (error) {
        console.error("[Uproot] Error adding to watchlist:", error instanceof Error ? error.message : String(error), error);
        throw error;
      }
    }, []);
    const removePerson = reactExports.useCallback(async (id) => {
      try {
        await removeFromWatchlist(id);
        setWatchlist((prev) => prev.filter((p) => p.id !== id));
      } catch (error) {
        console.error("[Uproot] Error removing from watchlist:", error instanceof Error ? error.message : String(error), error);
        throw error;
      }
    }, []);
    const updatePerson = reactExports.useCallback(async (id, updates) => {
      try {
        await updateWatchlistPerson(id, updates);
        setWatchlist(
          (prev) => prev.map((p) => p.id === id ? { ...p, ...updates } : p)
        );
      } catch (error) {
        console.error("[Uproot] Error updating watchlist person:", error instanceof Error ? error.message : String(error), error);
        throw error;
      }
    }, []);
    const isPersonInWatchlist = reactExports.useCallback(async (profileUrl) => {
      return isInWatchlist(profileUrl);
    }, []);
    const addCompany = reactExports.useCallback(async (company) => {
      try {
        const newCompany = await addCompanyToWatchlist(company);
        setCompanyWatchlist((prev) => [newCompany, ...prev.filter((c) => c.id !== newCompany.id)]);
        return newCompany;
      } catch (error) {
        console.error("[Uproot] Error adding company to watchlist:", error instanceof Error ? error.message : String(error), error);
        throw error;
      }
    }, []);
    const removeCompany = reactExports.useCallback(async (id) => {
      try {
        await removeCompanyFromWatchlist(id);
        setCompanyWatchlist((prev) => prev.filter((c) => c.id !== id));
      } catch (error) {
        console.error("[Uproot] Error removing company from watchlist:", error instanceof Error ? error.message : String(error), error);
        throw error;
      }
    }, []);
    const updateCompany = reactExports.useCallback(async (id, updates) => {
      try {
        await updateWatchlistCompany(id, updates);
        setCompanyWatchlist(
          (prev) => prev.map((c) => c.id === id ? { ...c, ...updates } : c)
        );
      } catch (error) {
        console.error("[Uproot] Error updating watchlist company:", error instanceof Error ? error.message : String(error), error);
        throw error;
      }
    }, []);
    const isCompanyInWatchlist$1 = reactExports.useCallback(async (companyUrl) => {
      return isCompanyInWatchlist(companyUrl);
    }, []);
    const addPath = reactExports.useCallback(async (path) => {
      try {
        const newPath = await addConnectionPath(path);
        setConnectionPaths((prev) => [newPath, ...prev.filter((p) => p.id !== newPath.id)]);
        return newPath;
      } catch (error) {
        console.error("[Uproot] Error adding connection path:", error instanceof Error ? error.message : String(error), error);
        throw error;
      }
    }, []);
    const removePath = reactExports.useCallback(async (id) => {
      try {
        await removeConnectionPath(id);
        setConnectionPaths((prev) => prev.filter((p) => p.id !== id));
      } catch (error) {
        console.error("[Uproot] Error removing connection path:", error instanceof Error ? error.message : String(error), error);
        throw error;
      }
    }, []);
    const updatePath = reactExports.useCallback(async (id, updates) => {
      try {
        await updateConnectionPath(id, updates);
        setConnectionPaths(
          (prev) => prev.map((p) => p.id === id ? { ...p, ...updates, lastUpdated: Date.now() } : p)
        );
      } catch (error) {
        console.error("[Uproot] Error updating connection path:", error instanceof Error ? error.message : String(error), error);
        throw error;
      }
    }, []);
    const markStepConnected$1 = reactExports.useCallback(async (pathId, stepIndex) => {
      try {
        await markStepConnected(pathId, stepIndex);
        await loadWatchlist();
      } catch (error) {
        console.error("[Uproot] Error marking step as connected:", error instanceof Error ? error.message : String(error), error);
        throw error;
      }
    }, [loadWatchlist]);
    const isPathSaved = reactExports.useCallback(async (targetProfileUrl) => {
      return isConnectionPathSaved(targetProfileUrl);
    }, []);
    reactExports.useEffect(() => {
      loadWatchlist();
    }, [loadWatchlist]);
    reactExports.useEffect(() => {
      const handleStorageChange = (changes, areaName) => {
        if (areaName === "local") {
          if (changes.uproot_connection_paths) {
            setConnectionPaths(changes.uproot_connection_paths.newValue || []);
          }
          if (changes.uproot_watchlist) {
            setWatchlist(changes.uproot_watchlist.newValue || []);
          }
          if (changes.uproot_watchlist_companies) {
            setCompanyWatchlist(changes.uproot_watchlist_companies.newValue || []);
          }
        }
      };
      chrome.storage.onChanged.addListener(handleStorageChange);
      return () => chrome.storage.onChanged.removeListener(handleStorageChange);
    }, []);
    return {
      // Connection paths
      connectionPaths,
      addPath,
      removePath,
      updatePath,
      markStepConnected: markStepConnected$1,
      isPathSaved,
      // People watchlist
      watchlist,
      isLoading,
      addPerson,
      removePerson,
      updatePerson,
      isPersonInWatchlist,
      // Company watchlist
      companyWatchlist,
      addCompany,
      removeCompany,
      updateCompany,
      isCompanyInWatchlist: isCompanyInWatchlist$1,
      // Common
      refresh: loadWatchlist
    };
  }
  content;
  var events = { exports: {} };
  var hasRequiredEvents;
  function requireEvents() {
    if (hasRequiredEvents) return events.exports;
    hasRequiredEvents = 1;
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    events.exports = EventEmitter;
    events.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index2) {
      for (; index2 + 1 < list.length; index2++)
        list[index2] = list[index2 + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
    return events.exports;
  }
  var eventsExports = requireEvents();
  var iterator;
  var hasRequiredIterator;
  function requireIterator() {
    if (hasRequiredIterator) return iterator;
    hasRequiredIterator = 1;
    function Iterator2(next) {
      if (typeof next !== "function")
        throw new Error("obliterator/iterator: expecting a function!");
      this.next = next;
    }
    if (typeof Symbol !== "undefined")
      Iterator2.prototype[Symbol.iterator] = function() {
        return this;
      };
    Iterator2.of = function() {
      var args = arguments, l = args.length, i = 0;
      return new Iterator2(function() {
        if (i >= l) return { done: true };
        return { done: false, value: args[i++] };
      });
    };
    Iterator2.empty = function() {
      var iterator2 = new Iterator2(function() {
        return { done: true };
      });
      return iterator2;
    };
    Iterator2.fromSequence = function(sequence) {
      var i = 0, l = sequence.length;
      return new Iterator2(function() {
        if (i >= l) return { done: true };
        return { done: false, value: sequence[i++] };
      });
    };
    Iterator2.is = function(value) {
      if (value instanceof Iterator2) return true;
      return typeof value === "object" && value !== null && typeof value.next === "function";
    };
    iterator = Iterator2;
    return iterator;
  }
  var iteratorExports = requireIterator();
  const Iterator$1 = /* @__PURE__ */ getDefaultExportFromCjs(iteratorExports);
  var support = {};
  var hasRequiredSupport;
  function requireSupport() {
    if (hasRequiredSupport) return support;
    hasRequiredSupport = 1;
    support.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== "undefined";
    support.SYMBOL_SUPPORT = typeof Symbol !== "undefined";
    return support;
  }
  var iter;
  var hasRequiredIter;
  function requireIter() {
    if (hasRequiredIter) return iter;
    hasRequiredIter = 1;
    var Iterator2 = requireIterator();
    var support2 = requireSupport();
    var ARRAY_BUFFER_SUPPORT = support2.ARRAY_BUFFER_SUPPORT;
    var SYMBOL_SUPPORT = support2.SYMBOL_SUPPORT;
    function iterOrNull(target) {
      if (typeof target === "string" || Array.isArray(target) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(target))
        return Iterator2.fromSequence(target);
      if (typeof target !== "object" || target === null) return null;
      if (SYMBOL_SUPPORT && typeof target[Symbol.iterator] === "function")
        return target[Symbol.iterator]();
      if (typeof target.next === "function") return target;
      return null;
    }
    iter = function iter2(target) {
      var iterator2 = iterOrNull(target);
      if (!iterator2)
        throw new Error(
          "obliterator: target is not iterable nor a valid iterator."
        );
      return iterator2;
    };
    return iter;
  }
  var take$1;
  var hasRequiredTake;
  function requireTake() {
    if (hasRequiredTake) return take$1;
    hasRequiredTake = 1;
    var iter2 = requireIter();
    take$1 = function take2(iterable, n) {
      var l = arguments.length > 1 ? n : Infinity, array = l !== Infinity ? new Array(l) : [], step, i = 0;
      var iterator2 = iter2(iterable);
      while (true) {
        if (i === l) return array;
        step = iterator2.next();
        if (step.done) {
          if (i !== n) array.length = i;
          return array;
        }
        array[i++] = step.value;
      }
    };
    return take$1;
  }
  var takeExports = requireTake();
  const take = /* @__PURE__ */ getDefaultExportFromCjs(takeExports);
  var chain$1;
  var hasRequiredChain;
  function requireChain() {
    if (hasRequiredChain) return chain$1;
    hasRequiredChain = 1;
    var Iterator2 = requireIterator();
    var iter2 = requireIter();
    chain$1 = function chain2() {
      var iterables2 = arguments;
      var current = null;
      var i = -1;
      return new Iterator2(function next() {
        var step = null;
        do {
          if (current === null) {
            i++;
            if (i >= iterables2.length) return { done: true };
            current = iter2(iterables2[i]);
          }
          step = current.next();
          if (step.done === true) {
            current = null;
            continue;
          }
          break;
        } while (true);
        return step;
      });
    };
    return chain$1;
  }
  var chainExports = requireChain();
  const chain = /* @__PURE__ */ getDefaultExportFromCjs(chainExports);
  function assignPolyfill() {
    const target = arguments[0];
    for (let i = 1, l = arguments.length; i < l; i++) {
      if (!arguments[i]) continue;
      for (const k in arguments[i]) target[k] = arguments[i][k];
    }
    return target;
  }
  let assign = assignPolyfill;
  if (typeof Object.assign === "function") assign = Object.assign;
  function getMatchingEdge(graph, source, target, type) {
    const sourceData = graph._nodes.get(source);
    let edge = null;
    if (!sourceData) return edge;
    if (type === "mixed") {
      edge = sourceData.out && sourceData.out[target] || sourceData.undirected && sourceData.undirected[target];
    } else if (type === "directed") {
      edge = sourceData.out && sourceData.out[target];
    } else {
      edge = sourceData.undirected && sourceData.undirected[target];
    }
    return edge;
  }
  function isPlainObject$2(value) {
    return typeof value === "object" && value !== null;
  }
  function isEmpty(o) {
    let k;
    for (k in o) return false;
    return true;
  }
  function privateProperty(target, name, value) {
    Object.defineProperty(target, name, {
      enumerable: false,
      configurable: false,
      writable: true,
      value
    });
  }
  function readOnlyProperty(target, name, value) {
    const descriptor = {
      enumerable: true,
      configurable: true
    };
    if (typeof value === "function") {
      descriptor.get = value;
    } else {
      descriptor.value = value;
      descriptor.writable = false;
    }
    Object.defineProperty(target, name, descriptor);
  }
  function validateHints(hints) {
    if (!isPlainObject$2(hints)) return false;
    if (hints.attributes && !Array.isArray(hints.attributes)) return false;
    return true;
  }
  function incrementalIdStartingFromRandomByte() {
    let i = Math.floor(Math.random() * 256) & 255;
    return () => {
      return i++;
    };
  }
  class GraphError extends Error {
    constructor(message) {
      super();
      this.name = "GraphError";
      this.message = message;
    }
  }
  class InvalidArgumentsGraphError extends GraphError {
    constructor(message) {
      super(message);
      this.name = "InvalidArgumentsGraphError";
      if (typeof Error.captureStackTrace === "function")
        Error.captureStackTrace(
          this,
          InvalidArgumentsGraphError.prototype.constructor
        );
    }
  }
  class NotFoundGraphError extends GraphError {
    constructor(message) {
      super(message);
      this.name = "NotFoundGraphError";
      if (typeof Error.captureStackTrace === "function")
        Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);
    }
  }
  class UsageGraphError extends GraphError {
    constructor(message) {
      super(message);
      this.name = "UsageGraphError";
      if (typeof Error.captureStackTrace === "function")
        Error.captureStackTrace(this, UsageGraphError.prototype.constructor);
    }
  }
  function MixedNodeData(key, attributes) {
    this.key = key;
    this.attributes = attributes;
    this.clear();
  }
  MixedNodeData.prototype.clear = function() {
    this.inDegree = 0;
    this.outDegree = 0;
    this.undirectedDegree = 0;
    this.undirectedLoops = 0;
    this.directedLoops = 0;
    this.in = {};
    this.out = {};
    this.undirected = {};
  };
  function DirectedNodeData(key, attributes) {
    this.key = key;
    this.attributes = attributes;
    this.clear();
  }
  DirectedNodeData.prototype.clear = function() {
    this.inDegree = 0;
    this.outDegree = 0;
    this.directedLoops = 0;
    this.in = {};
    this.out = {};
  };
  function UndirectedNodeData(key, attributes) {
    this.key = key;
    this.attributes = attributes;
    this.clear();
  }
  UndirectedNodeData.prototype.clear = function() {
    this.undirectedDegree = 0;
    this.undirectedLoops = 0;
    this.undirected = {};
  };
  function EdgeData(undirected, key, source, target, attributes) {
    this.key = key;
    this.attributes = attributes;
    this.undirected = undirected;
    this.source = source;
    this.target = target;
  }
  EdgeData.prototype.attach = function() {
    let outKey = "out";
    let inKey = "in";
    if (this.undirected) outKey = inKey = "undirected";
    const source = this.source.key;
    const target = this.target.key;
    this.source[outKey][target] = this;
    if (this.undirected && source === target) return;
    this.target[inKey][source] = this;
  };
  EdgeData.prototype.attachMulti = function() {
    let outKey = "out";
    let inKey = "in";
    const source = this.source.key;
    const target = this.target.key;
    if (this.undirected) outKey = inKey = "undirected";
    const adj = this.source[outKey];
    const head2 = adj[target];
    if (typeof head2 === "undefined") {
      adj[target] = this;
      if (!(this.undirected && source === target)) {
        this.target[inKey][source] = this;
      }
      return;
    }
    head2.previous = this;
    this.next = head2;
    adj[target] = this;
    this.target[inKey][source] = this;
  };
  EdgeData.prototype.detach = function() {
    const source = this.source.key;
    const target = this.target.key;
    let outKey = "out";
    let inKey = "in";
    if (this.undirected) outKey = inKey = "undirected";
    delete this.source[outKey][target];
    delete this.target[inKey][source];
  };
  EdgeData.prototype.detachMulti = function() {
    const source = this.source.key;
    const target = this.target.key;
    let outKey = "out";
    let inKey = "in";
    if (this.undirected) outKey = inKey = "undirected";
    if (this.previous === void 0) {
      if (this.next === void 0) {
        delete this.source[outKey][target];
        delete this.target[inKey][source];
      } else {
        this.next.previous = void 0;
        this.source[outKey][target] = this.next;
        this.target[inKey][source] = this.next;
      }
    } else {
      this.previous.next = this.next;
      if (this.next !== void 0) {
        this.next.previous = this.previous;
      }
    }
  };
  const NODE = 0;
  const SOURCE = 1;
  const TARGET = 2;
  const OPPOSITE = 3;
  function findRelevantNodeData(graph, method, mode, nodeOrEdge, nameOrEdge, add1, add2) {
    let nodeData, edgeData, arg1, arg2;
    nodeOrEdge = "" + nodeOrEdge;
    if (mode === NODE) {
      nodeData = graph._nodes.get(nodeOrEdge);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${nodeOrEdge}" node in the graph.`
        );
      arg1 = nameOrEdge;
      arg2 = add1;
    } else if (mode === OPPOSITE) {
      nameOrEdge = "" + nameOrEdge;
      edgeData = graph._edges.get(nameOrEdge);
      if (!edgeData)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${nameOrEdge}" edge in the graph.`
        );
      const source = edgeData.source.key;
      const target = edgeData.target.key;
      if (nodeOrEdge === source) {
        nodeData = edgeData.target;
      } else if (nodeOrEdge === target) {
        nodeData = edgeData.source;
      } else {
        throw new NotFoundGraphError(
          `Graph.${method}: the "${nodeOrEdge}" node is not attached to the "${nameOrEdge}" edge (${source}, ${target}).`
        );
      }
      arg1 = add1;
      arg2 = add2;
    } else {
      edgeData = graph._edges.get(nodeOrEdge);
      if (!edgeData)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${nodeOrEdge}" edge in the graph.`
        );
      if (mode === SOURCE) {
        nodeData = edgeData.source;
      } else {
        nodeData = edgeData.target;
      }
      arg1 = nameOrEdge;
      arg2 = add1;
    }
    return [nodeData, arg1, arg2];
  }
  function attachNodeAttributeGetter(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
      const [data, name] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1
      );
      return data.attributes[name];
    };
  }
  function attachNodeAttributesGetter(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge) {
      const [data] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge
      );
      return data.attributes;
    };
  }
  function attachNodeAttributeChecker(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
      const [data, name] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1
      );
      return data.attributes.hasOwnProperty(name);
    };
  }
  function attachNodeAttributeSetter(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1, add2) {
      const [data, name, value] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1,
        add2
      );
      data.attributes[name] = value;
      this.emit("nodeAttributesUpdated", {
        key: data.key,
        type: "set",
        attributes: data.attributes,
        name
      });
      return this;
    };
  }
  function attachNodeAttributeUpdater(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1, add2) {
      const [data, name, updater] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1,
        add2
      );
      if (typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: updater should be a function.`
        );
      const attributes = data.attributes;
      const value = updater(attributes[name]);
      attributes[name] = value;
      this.emit("nodeAttributesUpdated", {
        key: data.key,
        type: "set",
        attributes: data.attributes,
        name
      });
      return this;
    };
  }
  function attachNodeAttributeRemover(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
      const [data, name] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1
      );
      delete data.attributes[name];
      this.emit("nodeAttributesUpdated", {
        key: data.key,
        type: "remove",
        attributes: data.attributes,
        name
      });
      return this;
    };
  }
  function attachNodeAttributesReplacer(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
      const [data, attributes] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1
      );
      if (!isPlainObject$2(attributes))
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: provided attributes are not a plain object.`
        );
      data.attributes = attributes;
      this.emit("nodeAttributesUpdated", {
        key: data.key,
        type: "replace",
        attributes: data.attributes
      });
      return this;
    };
  }
  function attachNodeAttributesMerger(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
      const [data, attributes] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1
      );
      if (!isPlainObject$2(attributes))
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: provided attributes are not a plain object.`
        );
      assign(data.attributes, attributes);
      this.emit("nodeAttributesUpdated", {
        key: data.key,
        type: "merge",
        attributes: data.attributes,
        data: attributes
      });
      return this;
    };
  }
  function attachNodeAttributesUpdater(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
      const [data, updater] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1
      );
      if (typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: provided updater is not a function.`
        );
      data.attributes = updater(data.attributes);
      this.emit("nodeAttributesUpdated", {
        key: data.key,
        type: "update",
        attributes: data.attributes
      });
      return this;
    };
  }
  const NODE_ATTRIBUTES_METHODS = [
    {
      name: (element) => `get${element}Attribute`,
      attacher: attachNodeAttributeGetter
    },
    {
      name: (element) => `get${element}Attributes`,
      attacher: attachNodeAttributesGetter
    },
    {
      name: (element) => `has${element}Attribute`,
      attacher: attachNodeAttributeChecker
    },
    {
      name: (element) => `set${element}Attribute`,
      attacher: attachNodeAttributeSetter
    },
    {
      name: (element) => `update${element}Attribute`,
      attacher: attachNodeAttributeUpdater
    },
    {
      name: (element) => `remove${element}Attribute`,
      attacher: attachNodeAttributeRemover
    },
    {
      name: (element) => `replace${element}Attributes`,
      attacher: attachNodeAttributesReplacer
    },
    {
      name: (element) => `merge${element}Attributes`,
      attacher: attachNodeAttributesMerger
    },
    {
      name: (element) => `update${element}Attributes`,
      attacher: attachNodeAttributesUpdater
    }
  ];
  function attachNodeAttributesMethods(Graph2) {
    NODE_ATTRIBUTES_METHODS.forEach(function({ name, attacher }) {
      attacher(Graph2, name("Node"), NODE);
      attacher(Graph2, name("Source"), SOURCE);
      attacher(Graph2, name("Target"), TARGET);
      attacher(Graph2, name("Opposite"), OPPOSITE);
    });
  }
  function attachEdgeAttributeGetter(Class, method, type) {
    Class.prototype[method] = function(element, name) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 2) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element;
        const target = "" + name;
        name = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      return data.attributes[name];
    };
  }
  function attachEdgeAttributesGetter(Class, method, type) {
    Class.prototype[method] = function(element) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 1) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element, target = "" + arguments[1];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      return data.attributes;
    };
  }
  function attachEdgeAttributeChecker(Class, method, type) {
    Class.prototype[method] = function(element, name) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 2) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element;
        const target = "" + name;
        name = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      return data.attributes.hasOwnProperty(name);
    };
  }
  function attachEdgeAttributeSetter(Class, method, type) {
    Class.prototype[method] = function(element, name, value) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 3) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element;
        const target = "" + name;
        name = arguments[2];
        value = arguments[3];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      data.attributes[name] = value;
      this.emit("edgeAttributesUpdated", {
        key: data.key,
        type: "set",
        attributes: data.attributes,
        name
      });
      return this;
    };
  }
  function attachEdgeAttributeUpdater(Class, method, type) {
    Class.prototype[method] = function(element, name, updater) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 3) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element;
        const target = "" + name;
        name = arguments[2];
        updater = arguments[3];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      if (typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: updater should be a function.`
        );
      data.attributes[name] = updater(data.attributes[name]);
      this.emit("edgeAttributesUpdated", {
        key: data.key,
        type: "set",
        attributes: data.attributes,
        name
      });
      return this;
    };
  }
  function attachEdgeAttributeRemover(Class, method, type) {
    Class.prototype[method] = function(element, name) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 2) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element;
        const target = "" + name;
        name = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      delete data.attributes[name];
      this.emit("edgeAttributesUpdated", {
        key: data.key,
        type: "remove",
        attributes: data.attributes,
        name
      });
      return this;
    };
  }
  function attachEdgeAttributesReplacer(Class, method, type) {
    Class.prototype[method] = function(element, attributes) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 2) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element, target = "" + attributes;
        attributes = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      if (!isPlainObject$2(attributes))
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: provided attributes are not a plain object.`
        );
      data.attributes = attributes;
      this.emit("edgeAttributesUpdated", {
        key: data.key,
        type: "replace",
        attributes: data.attributes
      });
      return this;
    };
  }
  function attachEdgeAttributesMerger(Class, method, type) {
    Class.prototype[method] = function(element, attributes) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 2) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element, target = "" + attributes;
        attributes = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      if (!isPlainObject$2(attributes))
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: provided attributes are not a plain object.`
        );
      assign(data.attributes, attributes);
      this.emit("edgeAttributesUpdated", {
        key: data.key,
        type: "merge",
        attributes: data.attributes,
        data: attributes
      });
      return this;
    };
  }
  function attachEdgeAttributesUpdater(Class, method, type) {
    Class.prototype[method] = function(element, updater) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 2) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element, target = "" + updater;
        updater = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      if (typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: provided updater is not a function.`
        );
      data.attributes = updater(data.attributes);
      this.emit("edgeAttributesUpdated", {
        key: data.key,
        type: "update",
        attributes: data.attributes
      });
      return this;
    };
  }
  const EDGE_ATTRIBUTES_METHODS = [
    {
      name: (element) => `get${element}Attribute`,
      attacher: attachEdgeAttributeGetter
    },
    {
      name: (element) => `get${element}Attributes`,
      attacher: attachEdgeAttributesGetter
    },
    {
      name: (element) => `has${element}Attribute`,
      attacher: attachEdgeAttributeChecker
    },
    {
      name: (element) => `set${element}Attribute`,
      attacher: attachEdgeAttributeSetter
    },
    {
      name: (element) => `update${element}Attribute`,
      attacher: attachEdgeAttributeUpdater
    },
    {
      name: (element) => `remove${element}Attribute`,
      attacher: attachEdgeAttributeRemover
    },
    {
      name: (element) => `replace${element}Attributes`,
      attacher: attachEdgeAttributesReplacer
    },
    {
      name: (element) => `merge${element}Attributes`,
      attacher: attachEdgeAttributesMerger
    },
    {
      name: (element) => `update${element}Attributes`,
      attacher: attachEdgeAttributesUpdater
    }
  ];
  function attachEdgeAttributesMethods(Graph2) {
    EDGE_ATTRIBUTES_METHODS.forEach(function({ name, attacher }) {
      attacher(Graph2, name("Edge"), "mixed");
      attacher(Graph2, name("DirectedEdge"), "directed");
      attacher(Graph2, name("UndirectedEdge"), "undirected");
    });
  }
  const EDGES_ITERATION = [
    {
      name: "edges",
      type: "mixed"
    },
    {
      name: "inEdges",
      type: "directed",
      direction: "in"
    },
    {
      name: "outEdges",
      type: "directed",
      direction: "out"
    },
    {
      name: "inboundEdges",
      type: "mixed",
      direction: "in"
    },
    {
      name: "outboundEdges",
      type: "mixed",
      direction: "out"
    },
    {
      name: "directedEdges",
      type: "directed"
    },
    {
      name: "undirectedEdges",
      type: "undirected"
    }
  ];
  function forEachSimple(breakable, object, callback, avoid) {
    let shouldBreak = false;
    for (const k in object) {
      if (k === avoid) continue;
      const edgeData = object[k];
      shouldBreak = callback(
        edgeData.key,
        edgeData.attributes,
        edgeData.source.key,
        edgeData.target.key,
        edgeData.source.attributes,
        edgeData.target.attributes,
        edgeData.undirected
      );
      if (breakable && shouldBreak) return edgeData.key;
    }
    return;
  }
  function forEachMulti(breakable, object, callback, avoid) {
    let edgeData, source, target;
    let shouldBreak = false;
    for (const k in object) {
      if (k === avoid) continue;
      edgeData = object[k];
      do {
        source = edgeData.source;
        target = edgeData.target;
        shouldBreak = callback(
          edgeData.key,
          edgeData.attributes,
          source.key,
          target.key,
          source.attributes,
          target.attributes,
          edgeData.undirected
        );
        if (breakable && shouldBreak) return edgeData.key;
        edgeData = edgeData.next;
      } while (edgeData !== void 0);
    }
    return;
  }
  function createIterator(object, avoid) {
    const keys = Object.keys(object);
    const l = keys.length;
    let edgeData;
    let i = 0;
    return new Iterator$1(function next() {
      do {
        if (!edgeData) {
          if (i >= l) return { done: true };
          const k = keys[i++];
          if (k === avoid) {
            edgeData = void 0;
            continue;
          }
          edgeData = object[k];
        } else {
          edgeData = edgeData.next;
        }
      } while (!edgeData);
      return {
        done: false,
        value: {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        }
      };
    });
  }
  function forEachForKeySimple(breakable, object, k, callback) {
    const edgeData = object[k];
    if (!edgeData) return;
    const sourceData = edgeData.source;
    const targetData = edgeData.target;
    if (callback(
      edgeData.key,
      edgeData.attributes,
      sourceData.key,
      targetData.key,
      sourceData.attributes,
      targetData.attributes,
      edgeData.undirected
    ) && breakable)
      return edgeData.key;
  }
  function forEachForKeyMulti(breakable, object, k, callback) {
    let edgeData = object[k];
    if (!edgeData) return;
    let shouldBreak = false;
    do {
      shouldBreak = callback(
        edgeData.key,
        edgeData.attributes,
        edgeData.source.key,
        edgeData.target.key,
        edgeData.source.attributes,
        edgeData.target.attributes,
        edgeData.undirected
      );
      if (breakable && shouldBreak) return edgeData.key;
      edgeData = edgeData.next;
    } while (edgeData !== void 0);
    return;
  }
  function createIteratorForKey(object, k) {
    let edgeData = object[k];
    if (edgeData.next !== void 0) {
      return new Iterator$1(function() {
        if (!edgeData) return { done: true };
        const value = {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        };
        edgeData = edgeData.next;
        return {
          done: false,
          value
        };
      });
    }
    return Iterator$1.of({
      edge: edgeData.key,
      attributes: edgeData.attributes,
      source: edgeData.source.key,
      target: edgeData.target.key,
      sourceAttributes: edgeData.source.attributes,
      targetAttributes: edgeData.target.attributes,
      undirected: edgeData.undirected
    });
  }
  function createEdgeArray(graph, type) {
    if (graph.size === 0) return [];
    if (type === "mixed" || type === graph.type) {
      if (typeof Array.from === "function")
        return Array.from(graph._edges.keys());
      return take(graph._edges.keys(), graph._edges.size);
    }
    const size = type === "undirected" ? graph.undirectedSize : graph.directedSize;
    const list = new Array(size), mask = type === "undirected";
    const iterator2 = graph._edges.values();
    let i = 0;
    let step, data;
    while (step = iterator2.next(), step.done !== true) {
      data = step.value;
      if (data.undirected === mask) list[i++] = data.key;
    }
    return list;
  }
  function forEachEdge(breakable, graph, type, callback) {
    if (graph.size === 0) return;
    const shouldFilter = type !== "mixed" && type !== graph.type;
    const mask = type === "undirected";
    let step, data;
    let shouldBreak = false;
    const iterator2 = graph._edges.values();
    while (step = iterator2.next(), step.done !== true) {
      data = step.value;
      if (shouldFilter && data.undirected !== mask) continue;
      const { key, attributes, source, target } = data;
      shouldBreak = callback(
        key,
        attributes,
        source.key,
        target.key,
        source.attributes,
        target.attributes,
        data.undirected
      );
      if (breakable && shouldBreak) return key;
    }
    return;
  }
  function createEdgeIterator(graph, type) {
    if (graph.size === 0) return Iterator$1.empty();
    const shouldFilter = type !== "mixed" && type !== graph.type;
    const mask = type === "undirected";
    const iterator2 = graph._edges.values();
    return new Iterator$1(function next() {
      let step, data;
      while (true) {
        step = iterator2.next();
        if (step.done) return step;
        data = step.value;
        if (shouldFilter && data.undirected !== mask) continue;
        break;
      }
      const value = {
        edge: data.key,
        attributes: data.attributes,
        source: data.source.key,
        target: data.target.key,
        sourceAttributes: data.source.attributes,
        targetAttributes: data.target.attributes,
        undirected: data.undirected
      };
      return { value, done: false };
    });
  }
  function forEachEdgeForNode(breakable, multi, type, direction, nodeData, callback) {
    const fn = multi ? forEachMulti : forEachSimple;
    let found;
    if (type !== "undirected") {
      if (direction !== "out") {
        found = fn(breakable, nodeData.in, callback);
        if (breakable && found) return found;
      }
      if (direction !== "in") {
        found = fn(
          breakable,
          nodeData.out,
          callback,
          !direction ? nodeData.key : void 0
        );
        if (breakable && found) return found;
      }
    }
    if (type !== "directed") {
      found = fn(breakable, nodeData.undirected, callback);
      if (breakable && found) return found;
    }
    return;
  }
  function createEdgeArrayForNode(multi, type, direction, nodeData) {
    const edges = [];
    forEachEdgeForNode(false, multi, type, direction, nodeData, function(key) {
      edges.push(key);
    });
    return edges;
  }
  function createEdgeIteratorForNode(type, direction, nodeData) {
    let iterator2 = Iterator$1.empty();
    if (type !== "undirected") {
      if (direction !== "out" && typeof nodeData.in !== "undefined")
        iterator2 = chain(iterator2, createIterator(nodeData.in));
      if (direction !== "in" && typeof nodeData.out !== "undefined")
        iterator2 = chain(
          iterator2,
          createIterator(nodeData.out, !direction ? nodeData.key : void 0)
        );
    }
    if (type !== "directed" && typeof nodeData.undirected !== "undefined") {
      iterator2 = chain(iterator2, createIterator(nodeData.undirected));
    }
    return iterator2;
  }
  function forEachEdgeForPath(breakable, type, multi, direction, sourceData, target, callback) {
    const fn = multi ? forEachForKeyMulti : forEachForKeySimple;
    let found;
    if (type !== "undirected") {
      if (typeof sourceData.in !== "undefined" && direction !== "out") {
        found = fn(breakable, sourceData.in, target, callback);
        if (breakable && found) return found;
      }
      if (typeof sourceData.out !== "undefined" && direction !== "in" && (direction || sourceData.key !== target)) {
        found = fn(breakable, sourceData.out, target, callback);
        if (breakable && found) return found;
      }
    }
    if (type !== "directed") {
      if (typeof sourceData.undirected !== "undefined") {
        found = fn(breakable, sourceData.undirected, target, callback);
        if (breakable && found) return found;
      }
    }
    return;
  }
  function createEdgeArrayForPath(type, multi, direction, sourceData, target) {
    const edges = [];
    forEachEdgeForPath(
      false,
      type,
      multi,
      direction,
      sourceData,
      target,
      function(key) {
        edges.push(key);
      }
    );
    return edges;
  }
  function createEdgeIteratorForPath(type, direction, sourceData, target) {
    let iterator2 = Iterator$1.empty();
    if (type !== "undirected") {
      if (typeof sourceData.in !== "undefined" && direction !== "out" && target in sourceData.in)
        iterator2 = chain(iterator2, createIteratorForKey(sourceData.in, target));
      if (typeof sourceData.out !== "undefined" && direction !== "in" && target in sourceData.out && (direction || sourceData.key !== target))
        iterator2 = chain(iterator2, createIteratorForKey(sourceData.out, target));
    }
    if (type !== "directed") {
      if (typeof sourceData.undirected !== "undefined" && target in sourceData.undirected)
        iterator2 = chain(
          iterator2,
          createIteratorForKey(sourceData.undirected, target)
        );
    }
    return iterator2;
  }
  function attachEdgeArrayCreator(Class, description) {
    const { name, type, direction } = description;
    Class.prototype[name] = function(source, target) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return [];
      if (!arguments.length) return createEdgeArray(this, type);
      if (arguments.length === 1) {
        source = "" + source;
        const nodeData = this._nodes.get(source);
        if (typeof nodeData === "undefined")
          throw new NotFoundGraphError(
            `Graph.${name}: could not find the "${source}" node in the graph.`
          );
        return createEdgeArrayForNode(
          this.multi,
          type === "mixed" ? this.type : type,
          direction,
          nodeData
        );
      }
      if (arguments.length === 2) {
        source = "" + source;
        target = "" + target;
        const sourceData = this._nodes.get(source);
        if (!sourceData)
          throw new NotFoundGraphError(
            `Graph.${name}:  could not find the "${source}" source node in the graph.`
          );
        if (!this._nodes.has(target))
          throw new NotFoundGraphError(
            `Graph.${name}:  could not find the "${target}" target node in the graph.`
          );
        return createEdgeArrayForPath(
          type,
          this.multi,
          direction,
          sourceData,
          target
        );
      }
      throw new InvalidArgumentsGraphError(
        `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`
      );
    };
  }
  function attachForEachEdge(Class, description) {
    const { name, type, direction } = description;
    const forEachName = "forEach" + name[0].toUpperCase() + name.slice(1, -1);
    Class.prototype[forEachName] = function(source, target, callback) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type) return;
      if (arguments.length === 1) {
        callback = source;
        return forEachEdge(false, this, type, callback);
      }
      if (arguments.length === 2) {
        source = "" + source;
        callback = target;
        const nodeData = this._nodes.get(source);
        if (typeof nodeData === "undefined")
          throw new NotFoundGraphError(
            `Graph.${forEachName}: could not find the "${source}" node in the graph.`
          );
        return forEachEdgeForNode(
          false,
          this.multi,
          type === "mixed" ? this.type : type,
          direction,
          nodeData,
          callback
        );
      }
      if (arguments.length === 3) {
        source = "" + source;
        target = "" + target;
        const sourceData = this._nodes.get(source);
        if (!sourceData)
          throw new NotFoundGraphError(
            `Graph.${forEachName}:  could not find the "${source}" source node in the graph.`
          );
        if (!this._nodes.has(target))
          throw new NotFoundGraphError(
            `Graph.${forEachName}:  could not find the "${target}" target node in the graph.`
          );
        return forEachEdgeForPath(
          false,
          type,
          this.multi,
          direction,
          sourceData,
          target,
          callback
        );
      }
      throw new InvalidArgumentsGraphError(
        `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`
      );
    };
    const mapName = "map" + name[0].toUpperCase() + name.slice(1);
    Class.prototype[mapName] = function() {
      const args = Array.prototype.slice.call(arguments);
      const callback = args.pop();
      let result2;
      if (args.length === 0) {
        let length = 0;
        if (type !== "directed") length += this.undirectedSize;
        if (type !== "undirected") length += this.directedSize;
        result2 = new Array(length);
        let i = 0;
        args.push((e, ea, s, t, sa, ta, u) => {
          result2[i++] = callback(e, ea, s, t, sa, ta, u);
        });
      } else {
        result2 = [];
        args.push((e, ea, s, t, sa, ta, u) => {
          result2.push(callback(e, ea, s, t, sa, ta, u));
        });
      }
      this[forEachName].apply(this, args);
      return result2;
    };
    const filterName = "filter" + name[0].toUpperCase() + name.slice(1);
    Class.prototype[filterName] = function() {
      const args = Array.prototype.slice.call(arguments);
      const callback = args.pop();
      const result2 = [];
      args.push((e, ea, s, t, sa, ta, u) => {
        if (callback(e, ea, s, t, sa, ta, u)) result2.push(e);
      });
      this[forEachName].apply(this, args);
      return result2;
    };
    const reduceName = "reduce" + name[0].toUpperCase() + name.slice(1);
    Class.prototype[reduceName] = function() {
      let args = Array.prototype.slice.call(arguments);
      if (args.length < 2 || args.length > 4) {
        throw new InvalidArgumentsGraphError(
          `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`
        );
      }
      if (typeof args[args.length - 1] === "function" && typeof args[args.length - 2] !== "function") {
        throw new InvalidArgumentsGraphError(
          `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`
        );
      }
      let callback;
      let initialValue;
      if (args.length === 2) {
        callback = args[0];
        initialValue = args[1];
        args = [];
      } else if (args.length === 3) {
        callback = args[1];
        initialValue = args[2];
        args = [args[0]];
      } else if (args.length === 4) {
        callback = args[2];
        initialValue = args[3];
        args = [args[0], args[1]];
      }
      let accumulator = initialValue;
      args.push((e, ea, s, t, sa, ta, u) => {
        accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);
      });
      this[forEachName].apply(this, args);
      return accumulator;
    };
  }
  function attachFindEdge(Class, description) {
    const { name, type, direction } = description;
    const findEdgeName = "find" + name[0].toUpperCase() + name.slice(1, -1);
    Class.prototype[findEdgeName] = function(source, target, callback) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return false;
      if (arguments.length === 1) {
        callback = source;
        return forEachEdge(true, this, type, callback);
      }
      if (arguments.length === 2) {
        source = "" + source;
        callback = target;
        const nodeData = this._nodes.get(source);
        if (typeof nodeData === "undefined")
          throw new NotFoundGraphError(
            `Graph.${findEdgeName}: could not find the "${source}" node in the graph.`
          );
        return forEachEdgeForNode(
          true,
          this.multi,
          type === "mixed" ? this.type : type,
          direction,
          nodeData,
          callback
        );
      }
      if (arguments.length === 3) {
        source = "" + source;
        target = "" + target;
        const sourceData = this._nodes.get(source);
        if (!sourceData)
          throw new NotFoundGraphError(
            `Graph.${findEdgeName}:  could not find the "${source}" source node in the graph.`
          );
        if (!this._nodes.has(target))
          throw new NotFoundGraphError(
            `Graph.${findEdgeName}:  could not find the "${target}" target node in the graph.`
          );
        return forEachEdgeForPath(
          true,
          type,
          this.multi,
          direction,
          sourceData,
          target,
          callback
        );
      }
      throw new InvalidArgumentsGraphError(
        `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`
      );
    };
    const someName = "some" + name[0].toUpperCase() + name.slice(1, -1);
    Class.prototype[someName] = function() {
      const args = Array.prototype.slice.call(arguments);
      const callback = args.pop();
      args.push((e, ea, s, t, sa, ta, u) => {
        return callback(e, ea, s, t, sa, ta, u);
      });
      const found = this[findEdgeName].apply(this, args);
      if (found) return true;
      return false;
    };
    const everyName = "every" + name[0].toUpperCase() + name.slice(1, -1);
    Class.prototype[everyName] = function() {
      const args = Array.prototype.slice.call(arguments);
      const callback = args.pop();
      args.push((e, ea, s, t, sa, ta, u) => {
        return !callback(e, ea, s, t, sa, ta, u);
      });
      const found = this[findEdgeName].apply(this, args);
      if (found) return false;
      return true;
    };
  }
  function attachEdgeIteratorCreator(Class, description) {
    const { name: originalName, type, direction } = description;
    const name = originalName.slice(0, -1) + "Entries";
    Class.prototype[name] = function(source, target) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return Iterator$1.empty();
      if (!arguments.length) return createEdgeIterator(this, type);
      if (arguments.length === 1) {
        source = "" + source;
        const sourceData = this._nodes.get(source);
        if (!sourceData)
          throw new NotFoundGraphError(
            `Graph.${name}: could not find the "${source}" node in the graph.`
          );
        return createEdgeIteratorForNode(type, direction, sourceData);
      }
      if (arguments.length === 2) {
        source = "" + source;
        target = "" + target;
        const sourceData = this._nodes.get(source);
        if (!sourceData)
          throw new NotFoundGraphError(
            `Graph.${name}:  could not find the "${source}" source node in the graph.`
          );
        if (!this._nodes.has(target))
          throw new NotFoundGraphError(
            `Graph.${name}:  could not find the "${target}" target node in the graph.`
          );
        return createEdgeIteratorForPath(type, direction, sourceData, target);
      }
      throw new InvalidArgumentsGraphError(
        `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`
      );
    };
  }
  function attachEdgeIterationMethods(Graph2) {
    EDGES_ITERATION.forEach((description) => {
      attachEdgeArrayCreator(Graph2, description);
      attachForEachEdge(Graph2, description);
      attachFindEdge(Graph2, description);
      attachEdgeIteratorCreator(Graph2, description);
    });
  }
  const NEIGHBORS_ITERATION = [
    {
      name: "neighbors",
      type: "mixed"
    },
    {
      name: "inNeighbors",
      type: "directed",
      direction: "in"
    },
    {
      name: "outNeighbors",
      type: "directed",
      direction: "out"
    },
    {
      name: "inboundNeighbors",
      type: "mixed",
      direction: "in"
    },
    {
      name: "outboundNeighbors",
      type: "mixed",
      direction: "out"
    },
    {
      name: "directedNeighbors",
      type: "directed"
    },
    {
      name: "undirectedNeighbors",
      type: "undirected"
    }
  ];
  function CompositeSetWrapper() {
    this.A = null;
    this.B = null;
  }
  CompositeSetWrapper.prototype.wrap = function(set) {
    if (this.A === null) this.A = set;
    else if (this.B === null) this.B = set;
  };
  CompositeSetWrapper.prototype.has = function(key) {
    if (this.A !== null && key in this.A) return true;
    if (this.B !== null && key in this.B) return true;
    return false;
  };
  function forEachInObjectOnce(breakable, visited, nodeData, object, callback) {
    for (const k in object) {
      const edgeData = object[k];
      const sourceData = edgeData.source;
      const targetData = edgeData.target;
      const neighborData = sourceData === nodeData ? targetData : sourceData;
      if (visited && visited.has(neighborData.key)) continue;
      const shouldBreak = callback(neighborData.key, neighborData.attributes);
      if (breakable && shouldBreak) return neighborData.key;
    }
    return;
  }
  function forEachNeighbor(breakable, type, direction, nodeData, callback) {
    if (type !== "mixed") {
      if (type === "undirected")
        return forEachInObjectOnce(
          breakable,
          null,
          nodeData,
          nodeData.undirected,
          callback
        );
      if (typeof direction === "string")
        return forEachInObjectOnce(
          breakable,
          null,
          nodeData,
          nodeData[direction],
          callback
        );
    }
    const visited = new CompositeSetWrapper();
    let found;
    if (type !== "undirected") {
      if (direction !== "out") {
        found = forEachInObjectOnce(
          breakable,
          null,
          nodeData,
          nodeData.in,
          callback
        );
        if (breakable && found) return found;
        visited.wrap(nodeData.in);
      }
      if (direction !== "in") {
        found = forEachInObjectOnce(
          breakable,
          visited,
          nodeData,
          nodeData.out,
          callback
        );
        if (breakable && found) return found;
        visited.wrap(nodeData.out);
      }
    }
    if (type !== "directed") {
      found = forEachInObjectOnce(
        breakable,
        visited,
        nodeData,
        nodeData.undirected,
        callback
      );
      if (breakable && found) return found;
    }
    return;
  }
  function createNeighborArrayForNode(type, direction, nodeData) {
    if (type !== "mixed") {
      if (type === "undirected") return Object.keys(nodeData.undirected);
      if (typeof direction === "string") return Object.keys(nodeData[direction]);
    }
    const neighbors = [];
    forEachNeighbor(false, type, direction, nodeData, function(key) {
      neighbors.push(key);
    });
    return neighbors;
  }
  function createDedupedObjectIterator(visited, nodeData, object) {
    const keys = Object.keys(object);
    const l = keys.length;
    let i = 0;
    return new Iterator$1(function next() {
      let neighborData = null;
      do {
        if (i >= l) {
          if (visited) visited.wrap(object);
          return { done: true };
        }
        const edgeData = object[keys[i++]];
        const sourceData = edgeData.source;
        const targetData = edgeData.target;
        neighborData = sourceData === nodeData ? targetData : sourceData;
        if (visited && visited.has(neighborData.key)) {
          neighborData = null;
          continue;
        }
      } while (neighborData === null);
      return {
        done: false,
        value: { neighbor: neighborData.key, attributes: neighborData.attributes }
      };
    });
  }
  function createNeighborIterator(type, direction, nodeData) {
    if (type !== "mixed") {
      if (type === "undirected")
        return createDedupedObjectIterator(null, nodeData, nodeData.undirected);
      if (typeof direction === "string")
        return createDedupedObjectIterator(null, nodeData, nodeData[direction]);
    }
    let iterator2 = Iterator$1.empty();
    const visited = new CompositeSetWrapper();
    if (type !== "undirected") {
      if (direction !== "out") {
        iterator2 = chain(
          iterator2,
          createDedupedObjectIterator(visited, nodeData, nodeData.in)
        );
      }
      if (direction !== "in") {
        iterator2 = chain(
          iterator2,
          createDedupedObjectIterator(visited, nodeData, nodeData.out)
        );
      }
    }
    if (type !== "directed") {
      iterator2 = chain(
        iterator2,
        createDedupedObjectIterator(visited, nodeData, nodeData.undirected)
      );
    }
    return iterator2;
  }
  function attachNeighborArrayCreator(Class, description) {
    const { name, type, direction } = description;
    Class.prototype[name] = function(node) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return [];
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(
          `Graph.${name}: could not find the "${node}" node in the graph.`
        );
      return createNeighborArrayForNode(
        type === "mixed" ? this.type : type,
        direction,
        nodeData
      );
    };
  }
  function attachForEachNeighbor(Class, description) {
    const { name, type, direction } = description;
    const forEachName = "forEach" + name[0].toUpperCase() + name.slice(1, -1);
    Class.prototype[forEachName] = function(node, callback) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type) return;
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(
          `Graph.${forEachName}: could not find the "${node}" node in the graph.`
        );
      forEachNeighbor(
        false,
        type === "mixed" ? this.type : type,
        direction,
        nodeData,
        callback
      );
    };
    const mapName = "map" + name[0].toUpperCase() + name.slice(1);
    Class.prototype[mapName] = function(node, callback) {
      const result2 = [];
      this[forEachName](node, (n, a) => {
        result2.push(callback(n, a));
      });
      return result2;
    };
    const filterName = "filter" + name[0].toUpperCase() + name.slice(1);
    Class.prototype[filterName] = function(node, callback) {
      const result2 = [];
      this[forEachName](node, (n, a) => {
        if (callback(n, a)) result2.push(n);
      });
      return result2;
    };
    const reduceName = "reduce" + name[0].toUpperCase() + name.slice(1);
    Class.prototype[reduceName] = function(node, callback, initialValue) {
      if (arguments.length < 3)
        throw new InvalidArgumentsGraphError(
          `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`
        );
      let accumulator = initialValue;
      this[forEachName](node, (n, a) => {
        accumulator = callback(accumulator, n, a);
      });
      return accumulator;
    };
  }
  function attachFindNeighbor(Class, description) {
    const { name, type, direction } = description;
    const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);
    const findName = "find" + capitalizedSingular;
    Class.prototype[findName] = function(node, callback) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type) return;
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(
          `Graph.${findName}: could not find the "${node}" node in the graph.`
        );
      return forEachNeighbor(
        true,
        type === "mixed" ? this.type : type,
        direction,
        nodeData,
        callback
      );
    };
    const someName = "some" + capitalizedSingular;
    Class.prototype[someName] = function(node, callback) {
      const found = this[findName](node, callback);
      if (found) return true;
      return false;
    };
    const everyName = "every" + capitalizedSingular;
    Class.prototype[everyName] = function(node, callback) {
      const found = this[findName](node, (n, a) => {
        return !callback(n, a);
      });
      if (found) return false;
      return true;
    };
  }
  function attachNeighborIteratorCreator(Class, description) {
    const { name, type, direction } = description;
    const iteratorName = name.slice(0, -1) + "Entries";
    Class.prototype[iteratorName] = function(node) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return Iterator$1.empty();
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(
          `Graph.${iteratorName}: could not find the "${node}" node in the graph.`
        );
      return createNeighborIterator(
        type === "mixed" ? this.type : type,
        direction,
        nodeData
      );
    };
  }
  function attachNeighborIterationMethods(Graph2) {
    NEIGHBORS_ITERATION.forEach((description) => {
      attachNeighborArrayCreator(Graph2, description);
      attachForEachNeighbor(Graph2, description);
      attachFindNeighbor(Graph2, description);
      attachNeighborIteratorCreator(Graph2, description);
    });
  }
  function forEachAdjacency(breakable, assymetric, disconnectedNodes, graph, callback) {
    const iterator2 = graph._nodes.values();
    const type = graph.type;
    let step, sourceData, neighbor, adj, edgeData, targetData;
    while (step = iterator2.next(), step.done !== true) {
      let hasEdges = false;
      sourceData = step.value;
      if (type !== "undirected") {
        adj = sourceData.out;
        for (neighbor in adj) {
          edgeData = adj[neighbor];
          do {
            targetData = edgeData.target;
            hasEdges = true;
            callback(
              sourceData.key,
              targetData.key,
              sourceData.attributes,
              targetData.attributes,
              edgeData.key,
              edgeData.attributes,
              edgeData.undirected
            );
            edgeData = edgeData.next;
          } while (edgeData);
        }
      }
      if (type !== "directed") {
        adj = sourceData.undirected;
        for (neighbor in adj) {
          if (assymetric && sourceData.key > neighbor) continue;
          edgeData = adj[neighbor];
          do {
            targetData = edgeData.target;
            if (targetData.key !== neighbor) targetData = edgeData.source;
            hasEdges = true;
            callback(
              sourceData.key,
              targetData.key,
              sourceData.attributes,
              targetData.attributes,
              edgeData.key,
              edgeData.attributes,
              edgeData.undirected
            );
            edgeData = edgeData.next;
          } while (edgeData);
        }
      }
      if (disconnectedNodes && !hasEdges) {
        callback(
          sourceData.key,
          null,
          sourceData.attributes,
          null,
          null,
          null,
          null
        );
      }
    }
    return;
  }
  function serializeNode(key, data) {
    const serialized = { key };
    if (!isEmpty(data.attributes))
      serialized.attributes = assign({}, data.attributes);
    return serialized;
  }
  function serializeEdge(type, key, data) {
    const serialized = {
      key,
      source: data.source.key,
      target: data.target.key
    };
    if (!isEmpty(data.attributes))
      serialized.attributes = assign({}, data.attributes);
    if (type === "mixed" && data.undirected) serialized.undirected = true;
    return serialized;
  }
  function validateSerializedNode(value) {
    if (!isPlainObject$2(value))
      throw new InvalidArgumentsGraphError(
        'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.'
      );
    if (!("key" in value))
      throw new InvalidArgumentsGraphError(
        "Graph.import: serialized node is missing its key."
      );
    if ("attributes" in value && (!isPlainObject$2(value.attributes) || value.attributes === null))
      throw new InvalidArgumentsGraphError(
        "Graph.import: invalid attributes. Attributes should be a plain object, null or omitted."
      );
  }
  function validateSerializedEdge(value) {
    if (!isPlainObject$2(value))
      throw new InvalidArgumentsGraphError(
        'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.'
      );
    if (!("source" in value))
      throw new InvalidArgumentsGraphError(
        "Graph.import: serialized edge is missing its source."
      );
    if (!("target" in value))
      throw new InvalidArgumentsGraphError(
        "Graph.import: serialized edge is missing its target."
      );
    if ("attributes" in value && (!isPlainObject$2(value.attributes) || value.attributes === null))
      throw new InvalidArgumentsGraphError(
        "Graph.import: invalid attributes. Attributes should be a plain object, null or omitted."
      );
    if ("undirected" in value && typeof value.undirected !== "boolean")
      throw new InvalidArgumentsGraphError(
        "Graph.import: invalid undirectedness information. Undirected should be boolean or omitted."
      );
  }
  const INSTANCE_ID = incrementalIdStartingFromRandomByte();
  const TYPES = /* @__PURE__ */ new Set(["directed", "undirected", "mixed"]);
  const EMITTER_PROPS = /* @__PURE__ */ new Set([
    "domain",
    "_events",
    "_eventsCount",
    "_maxListeners"
  ]);
  const EDGE_ADD_METHODS = [
    {
      name: (verb) => `${verb}Edge`,
      generateKey: true
    },
    {
      name: (verb) => `${verb}DirectedEdge`,
      generateKey: true,
      type: "directed"
    },
    {
      name: (verb) => `${verb}UndirectedEdge`,
      generateKey: true,
      type: "undirected"
    },
    {
      name: (verb) => `${verb}EdgeWithKey`
    },
    {
      name: (verb) => `${verb}DirectedEdgeWithKey`,
      type: "directed"
    },
    {
      name: (verb) => `${verb}UndirectedEdgeWithKey`,
      type: "undirected"
    }
  ];
  const DEFAULTS = {
    allowSelfLoops: true,
    multi: false,
    type: "mixed"
  };
  function addNode(graph, node, attributes) {
    if (attributes && !isPlainObject$2(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.addNode: invalid attributes. Expecting an object but got "${attributes}"`
      );
    node = "" + node;
    attributes = attributes || {};
    if (graph._nodes.has(node))
      throw new UsageGraphError(
        `Graph.addNode: the "${node}" node already exist in the graph.`
      );
    const data = new graph.NodeDataClass(node, attributes);
    graph._nodes.set(node, data);
    graph.emit("nodeAdded", {
      key: node,
      attributes
    });
    return data;
  }
  function unsafeAddNode(graph, node, attributes) {
    const data = new graph.NodeDataClass(node, attributes);
    graph._nodes.set(node, data);
    graph.emit("nodeAdded", {
      key: node,
      attributes
    });
    return data;
  }
  function addEdge(graph, name, mustGenerateKey, undirected, edge, source, target, attributes) {
    if (!undirected && graph.type === "undirected")
      throw new UsageGraphError(
        `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`
      );
    if (undirected && graph.type === "directed")
      throw new UsageGraphError(
        `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`
      );
    if (attributes && !isPlainObject$2(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.${name}: invalid attributes. Expecting an object but got "${attributes}"`
      );
    source = "" + source;
    target = "" + target;
    attributes = attributes || {};
    if (!graph.allowSelfLoops && source === target)
      throw new UsageGraphError(
        `Graph.${name}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`
      );
    const sourceData = graph._nodes.get(source), targetData = graph._nodes.get(target);
    if (!sourceData)
      throw new NotFoundGraphError(
        `Graph.${name}: source node "${source}" not found.`
      );
    if (!targetData)
      throw new NotFoundGraphError(
        `Graph.${name}: target node "${target}" not found.`
      );
    const eventData = {
      key: null,
      undirected,
      source,
      target,
      attributes
    };
    if (mustGenerateKey) {
      edge = graph._edgeKeyGenerator();
    } else {
      edge = "" + edge;
      if (graph._edges.has(edge))
        throw new UsageGraphError(
          `Graph.${name}: the "${edge}" edge already exists in the graph.`
        );
    }
    if (!graph.multi && (undirected ? typeof sourceData.undirected[target] !== "undefined" : typeof sourceData.out[target] !== "undefined")) {
      throw new UsageGraphError(
        `Graph.${name}: an edge linking "${source}" to "${target}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`
      );
    }
    const edgeData = new EdgeData(
      undirected,
      edge,
      sourceData,
      targetData,
      attributes
    );
    graph._edges.set(edge, edgeData);
    const isSelfLoop = source === target;
    if (undirected) {
      sourceData.undirectedDegree++;
      targetData.undirectedDegree++;
      if (isSelfLoop) {
        sourceData.undirectedLoops++;
        graph._undirectedSelfLoopCount++;
      }
    } else {
      sourceData.outDegree++;
      targetData.inDegree++;
      if (isSelfLoop) {
        sourceData.directedLoops++;
        graph._directedSelfLoopCount++;
      }
    }
    if (graph.multi) edgeData.attachMulti();
    else edgeData.attach();
    if (undirected) graph._undirectedSize++;
    else graph._directedSize++;
    eventData.key = edge;
    graph.emit("edgeAdded", eventData);
    return edge;
  }
  function mergeEdge(graph, name, mustGenerateKey, undirected, edge, source, target, attributes, asUpdater) {
    if (!undirected && graph.type === "undirected")
      throw new UsageGraphError(
        `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`
      );
    if (undirected && graph.type === "directed")
      throw new UsageGraphError(
        `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`
      );
    if (attributes) {
      if (asUpdater) {
        if (typeof attributes !== "function")
          throw new InvalidArgumentsGraphError(
            `Graph.${name}: invalid updater function. Expecting a function but got "${attributes}"`
          );
      } else {
        if (!isPlainObject$2(attributes))
          throw new InvalidArgumentsGraphError(
            `Graph.${name}: invalid attributes. Expecting an object but got "${attributes}"`
          );
      }
    }
    source = "" + source;
    target = "" + target;
    let updater;
    if (asUpdater) {
      updater = attributes;
      attributes = void 0;
    }
    if (!graph.allowSelfLoops && source === target)
      throw new UsageGraphError(
        `Graph.${name}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`
      );
    let sourceData = graph._nodes.get(source);
    let targetData = graph._nodes.get(target);
    let edgeData;
    let alreadyExistingEdgeData;
    if (!mustGenerateKey) {
      edgeData = graph._edges.get(edge);
      if (edgeData) {
        if (edgeData.source.key !== source || edgeData.target.key !== target) {
          if (!undirected || edgeData.source.key !== target || edgeData.target.key !== source) {
            throw new UsageGraphError(
              `Graph.${name}: inconsistency detected when attempting to merge the "${edge}" edge with "${source}" source & "${target}" target vs. ("${edgeData.source.key}", "${edgeData.target.key}").`
            );
          }
        }
        alreadyExistingEdgeData = edgeData;
      }
    }
    if (!alreadyExistingEdgeData && !graph.multi && sourceData) {
      alreadyExistingEdgeData = undirected ? sourceData.undirected[target] : sourceData.out[target];
    }
    if (alreadyExistingEdgeData) {
      const info = [alreadyExistingEdgeData.key, false, false, false];
      if (asUpdater ? !updater : !attributes) return info;
      if (asUpdater) {
        const oldAttributes = alreadyExistingEdgeData.attributes;
        alreadyExistingEdgeData.attributes = updater(oldAttributes);
        graph.emit("edgeAttributesUpdated", {
          type: "replace",
          key: alreadyExistingEdgeData.key,
          attributes: alreadyExistingEdgeData.attributes
        });
      } else {
        assign(alreadyExistingEdgeData.attributes, attributes);
        graph.emit("edgeAttributesUpdated", {
          type: "merge",
          key: alreadyExistingEdgeData.key,
          attributes: alreadyExistingEdgeData.attributes,
          data: attributes
        });
      }
      return info;
    }
    attributes = attributes || {};
    if (asUpdater && updater) attributes = updater(attributes);
    const eventData = {
      key: null,
      undirected,
      source,
      target,
      attributes
    };
    if (mustGenerateKey) {
      edge = graph._edgeKeyGenerator();
    } else {
      edge = "" + edge;
      if (graph._edges.has(edge))
        throw new UsageGraphError(
          `Graph.${name}: the "${edge}" edge already exists in the graph.`
        );
    }
    let sourceWasAdded = false;
    let targetWasAdded = false;
    if (!sourceData) {
      sourceData = unsafeAddNode(graph, source, {});
      sourceWasAdded = true;
      if (source === target) {
        targetData = sourceData;
        targetWasAdded = true;
      }
    }
    if (!targetData) {
      targetData = unsafeAddNode(graph, target, {});
      targetWasAdded = true;
    }
    edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);
    graph._edges.set(edge, edgeData);
    const isSelfLoop = source === target;
    if (undirected) {
      sourceData.undirectedDegree++;
      targetData.undirectedDegree++;
      if (isSelfLoop) {
        sourceData.undirectedLoops++;
        graph._undirectedSelfLoopCount++;
      }
    } else {
      sourceData.outDegree++;
      targetData.inDegree++;
      if (isSelfLoop) {
        sourceData.directedLoops++;
        graph._directedSelfLoopCount++;
      }
    }
    if (graph.multi) edgeData.attachMulti();
    else edgeData.attach();
    if (undirected) graph._undirectedSize++;
    else graph._directedSize++;
    eventData.key = edge;
    graph.emit("edgeAdded", eventData);
    return [edge, true, sourceWasAdded, targetWasAdded];
  }
  function dropEdgeFromData(graph, edgeData) {
    graph._edges.delete(edgeData.key);
    const { source: sourceData, target: targetData, attributes } = edgeData;
    const undirected = edgeData.undirected;
    const isSelfLoop = sourceData === targetData;
    if (undirected) {
      sourceData.undirectedDegree--;
      targetData.undirectedDegree--;
      if (isSelfLoop) {
        sourceData.undirectedLoops--;
        graph._undirectedSelfLoopCount--;
      }
    } else {
      sourceData.outDegree--;
      targetData.inDegree--;
      if (isSelfLoop) {
        sourceData.directedLoops--;
        graph._directedSelfLoopCount--;
      }
    }
    if (graph.multi) edgeData.detachMulti();
    else edgeData.detach();
    if (undirected) graph._undirectedSize--;
    else graph._directedSize--;
    graph.emit("edgeDropped", {
      key: edgeData.key,
      attributes,
      source: sourceData.key,
      target: targetData.key,
      undirected
    });
  }
  class Graph extends eventsExports.EventEmitter {
    constructor(options) {
      super();
      options = assign({}, DEFAULTS, options);
      if (typeof options.multi !== "boolean")
        throw new InvalidArgumentsGraphError(
          `Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${options.multi}".`
        );
      if (!TYPES.has(options.type))
        throw new InvalidArgumentsGraphError(
          `Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${options.type}".`
        );
      if (typeof options.allowSelfLoops !== "boolean")
        throw new InvalidArgumentsGraphError(
          `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${options.allowSelfLoops}".`
        );
      const NodeDataClass = options.type === "mixed" ? MixedNodeData : options.type === "directed" ? DirectedNodeData : UndirectedNodeData;
      privateProperty(this, "NodeDataClass", NodeDataClass);
      const instancePrefix = "geid_" + INSTANCE_ID() + "_";
      let edgeId = 0;
      const edgeKeyGenerator = () => {
        let availableEdgeKey;
        do {
          availableEdgeKey = instancePrefix + edgeId++;
        } while (this._edges.has(availableEdgeKey));
        return availableEdgeKey;
      };
      privateProperty(this, "_attributes", {});
      privateProperty(this, "_nodes", /* @__PURE__ */ new Map());
      privateProperty(this, "_edges", /* @__PURE__ */ new Map());
      privateProperty(this, "_directedSize", 0);
      privateProperty(this, "_undirectedSize", 0);
      privateProperty(this, "_directedSelfLoopCount", 0);
      privateProperty(this, "_undirectedSelfLoopCount", 0);
      privateProperty(this, "_edgeKeyGenerator", edgeKeyGenerator);
      privateProperty(this, "_options", options);
      EMITTER_PROPS.forEach((prop) => privateProperty(this, prop, this[prop]));
      readOnlyProperty(this, "order", () => this._nodes.size);
      readOnlyProperty(this, "size", () => this._edges.size);
      readOnlyProperty(this, "directedSize", () => this._directedSize);
      readOnlyProperty(this, "undirectedSize", () => this._undirectedSize);
      readOnlyProperty(
        this,
        "selfLoopCount",
        () => this._directedSelfLoopCount + this._undirectedSelfLoopCount
      );
      readOnlyProperty(
        this,
        "directedSelfLoopCount",
        () => this._directedSelfLoopCount
      );
      readOnlyProperty(
        this,
        "undirectedSelfLoopCount",
        () => this._undirectedSelfLoopCount
      );
      readOnlyProperty(this, "multi", this._options.multi);
      readOnlyProperty(this, "type", this._options.type);
      readOnlyProperty(this, "allowSelfLoops", this._options.allowSelfLoops);
      readOnlyProperty(this, "implementation", () => "graphology");
    }
    _resetInstanceCounters() {
      this._directedSize = 0;
      this._undirectedSize = 0;
      this._directedSelfLoopCount = 0;
      this._undirectedSelfLoopCount = 0;
    }
    /**---------------------------------------------------------------------------
     * Read
     **---------------------------------------------------------------------------
     */
    /**
     * Method returning whether the given node is found in the graph.
     *
     * @param  {any}     node - The node.
     * @return {boolean}
     */
    hasNode(node) {
      return this._nodes.has("" + node);
    }
    /**
     * Method returning whether the given directed edge is found in the graph.
     *
     * Arity 1:
     * @param  {any}     edge - The edge's key.
     *
     * Arity 2:
     * @param  {any}     source - The edge's source.
     * @param  {any}     target - The edge's target.
     *
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the arguments are invalid.
     */
    hasDirectedEdge(source, target) {
      if (this.type === "undirected") return false;
      if (arguments.length === 1) {
        const edge = "" + source;
        const edgeData = this._edges.get(edge);
        return !!edgeData && !edgeData.undirected;
      } else if (arguments.length === 2) {
        source = "" + source;
        target = "" + target;
        const nodeData = this._nodes.get(source);
        if (!nodeData) return false;
        return nodeData.out.hasOwnProperty(target);
      }
      throw new InvalidArgumentsGraphError(
        `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`
      );
    }
    /**
     * Method returning whether the given undirected edge is found in the graph.
     *
     * Arity 1:
     * @param  {any}     edge - The edge's key.
     *
     * Arity 2:
     * @param  {any}     source - The edge's source.
     * @param  {any}     target - The edge's target.
     *
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the arguments are invalid.
     */
    hasUndirectedEdge(source, target) {
      if (this.type === "directed") return false;
      if (arguments.length === 1) {
        const edge = "" + source;
        const edgeData = this._edges.get(edge);
        return !!edgeData && edgeData.undirected;
      } else if (arguments.length === 2) {
        source = "" + source;
        target = "" + target;
        const nodeData = this._nodes.get(source);
        if (!nodeData) return false;
        return nodeData.undirected.hasOwnProperty(target);
      }
      throw new InvalidArgumentsGraphError(
        `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`
      );
    }
    /**
     * Method returning whether the given edge is found in the graph.
     *
     * Arity 1:
     * @param  {any}     edge - The edge's key.
     *
     * Arity 2:
     * @param  {any}     source - The edge's source.
     * @param  {any}     target - The edge's target.
     *
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the arguments are invalid.
     */
    hasEdge(source, target) {
      if (arguments.length === 1) {
        const edge = "" + source;
        return this._edges.has(edge);
      } else if (arguments.length === 2) {
        source = "" + source;
        target = "" + target;
        const nodeData = this._nodes.get(source);
        if (!nodeData) return false;
        return typeof nodeData.out !== "undefined" && nodeData.out.hasOwnProperty(target) || typeof nodeData.undirected !== "undefined" && nodeData.undirected.hasOwnProperty(target);
      }
      throw new InvalidArgumentsGraphError(
        `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`
      );
    }
    /**
     * Method returning the edge matching source & target in a directed fashion.
     *
     * @param  {any} source - The edge's source.
     * @param  {any} target - The edge's target.
     *
     * @return {any|undefined}
     *
     * @throws {Error} - Will throw if the graph is multi.
     * @throws {Error} - Will throw if source or target doesn't exist.
     */
    directedEdge(source, target) {
      if (this.type === "undirected") return;
      source = "" + source;
      target = "" + target;
      if (this.multi)
        throw new UsageGraphError(
          "Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead."
        );
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.directedEdge: could not find the "${source}" source node in the graph.`
        );
      if (!this._nodes.has(target))
        throw new NotFoundGraphError(
          `Graph.directedEdge: could not find the "${target}" target node in the graph.`
        );
      const edgeData = sourceData.out && sourceData.out[target] || void 0;
      if (edgeData) return edgeData.key;
    }
    /**
     * Method returning the edge matching source & target in a undirected fashion.
     *
     * @param  {any} source - The edge's source.
     * @param  {any} target - The edge's target.
     *
     * @return {any|undefined}
     *
     * @throws {Error} - Will throw if the graph is multi.
     * @throws {Error} - Will throw if source or target doesn't exist.
     */
    undirectedEdge(source, target) {
      if (this.type === "directed") return;
      source = "" + source;
      target = "" + target;
      if (this.multi)
        throw new UsageGraphError(
          "Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead."
        );
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.undirectedEdge: could not find the "${source}" source node in the graph.`
        );
      if (!this._nodes.has(target))
        throw new NotFoundGraphError(
          `Graph.undirectedEdge: could not find the "${target}" target node in the graph.`
        );
      const edgeData = sourceData.undirected && sourceData.undirected[target] || void 0;
      if (edgeData) return edgeData.key;
    }
    /**
     * Method returning the edge matching source & target in a mixed fashion.
     *
     * @param  {any} source - The edge's source.
     * @param  {any} target - The edge's target.
     *
     * @return {any|undefined}
     *
     * @throws {Error} - Will throw if the graph is multi.
     * @throws {Error} - Will throw if source or target doesn't exist.
     */
    edge(source, target) {
      if (this.multi)
        throw new UsageGraphError(
          "Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead."
        );
      source = "" + source;
      target = "" + target;
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.edge: could not find the "${source}" source node in the graph.`
        );
      if (!this._nodes.has(target))
        throw new NotFoundGraphError(
          `Graph.edge: could not find the "${target}" target node in the graph.`
        );
      const edgeData = sourceData.out && sourceData.out[target] || sourceData.undirected && sourceData.undirected[target] || void 0;
      if (edgeData) return edgeData.key;
    }
    /**
     * Method returning whether two nodes are directed neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    areDirectedNeighbors(node, neighbor) {
      node = "" + node;
      neighbor = "" + neighbor;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.areDirectedNeighbors: could not find the "${node}" node in the graph.`
        );
      if (this.type === "undirected") return false;
      return neighbor in nodeData.in || neighbor in nodeData.out;
    }
    /**
     * Method returning whether two nodes are out neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    areOutNeighbors(node, neighbor) {
      node = "" + node;
      neighbor = "" + neighbor;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.areOutNeighbors: could not find the "${node}" node in the graph.`
        );
      if (this.type === "undirected") return false;
      return neighbor in nodeData.out;
    }
    /**
     * Method returning whether two nodes are in neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    areInNeighbors(node, neighbor) {
      node = "" + node;
      neighbor = "" + neighbor;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.areInNeighbors: could not find the "${node}" node in the graph.`
        );
      if (this.type === "undirected") return false;
      return neighbor in nodeData.in;
    }
    /**
     * Method returning whether two nodes are undirected neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    areUndirectedNeighbors(node, neighbor) {
      node = "" + node;
      neighbor = "" + neighbor;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.areUndirectedNeighbors: could not find the "${node}" node in the graph.`
        );
      if (this.type === "directed") return false;
      return neighbor in nodeData.undirected;
    }
    /**
     * Method returning whether two nodes are neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    areNeighbors(node, neighbor) {
      node = "" + node;
      neighbor = "" + neighbor;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.areNeighbors: could not find the "${node}" node in the graph.`
        );
      if (this.type !== "undirected") {
        if (neighbor in nodeData.in || neighbor in nodeData.out) return true;
      }
      if (this.type !== "directed") {
        if (neighbor in nodeData.undirected) return true;
      }
      return false;
    }
    /**
     * Method returning whether two nodes are inbound neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    areInboundNeighbors(node, neighbor) {
      node = "" + node;
      neighbor = "" + neighbor;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.areInboundNeighbors: could not find the "${node}" node in the graph.`
        );
      if (this.type !== "undirected") {
        if (neighbor in nodeData.in) return true;
      }
      if (this.type !== "directed") {
        if (neighbor in nodeData.undirected) return true;
      }
      return false;
    }
    /**
     * Method returning whether two nodes are outbound neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    areOutboundNeighbors(node, neighbor) {
      node = "" + node;
      neighbor = "" + neighbor;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.areOutboundNeighbors: could not find the "${node}" node in the graph.`
        );
      if (this.type !== "undirected") {
        if (neighbor in nodeData.out) return true;
      }
      if (this.type !== "directed") {
        if (neighbor in nodeData.undirected) return true;
      }
      return false;
    }
    /**
     * Method returning the given node's in degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    inDegree(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.inDegree: could not find the "${node}" node in the graph.`
        );
      if (this.type === "undirected") return 0;
      return nodeData.inDegree;
    }
    /**
     * Method returning the given node's out degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    outDegree(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.outDegree: could not find the "${node}" node in the graph.`
        );
      if (this.type === "undirected") return 0;
      return nodeData.outDegree;
    }
    /**
     * Method returning the given node's directed degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    directedDegree(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.directedDegree: could not find the "${node}" node in the graph.`
        );
      if (this.type === "undirected") return 0;
      return nodeData.inDegree + nodeData.outDegree;
    }
    /**
     * Method returning the given node's undirected degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    undirectedDegree(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.undirectedDegree: could not find the "${node}" node in the graph.`
        );
      if (this.type === "directed") return 0;
      return nodeData.undirectedDegree;
    }
    /**
     * Method returning the given node's inbound degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's inbound degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    inboundDegree(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.inboundDegree: could not find the "${node}" node in the graph.`
        );
      let degree = 0;
      if (this.type !== "directed") {
        degree += nodeData.undirectedDegree;
      }
      if (this.type !== "undirected") {
        degree += nodeData.inDegree;
      }
      return degree;
    }
    /**
     * Method returning the given node's outbound degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's outbound degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    outboundDegree(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.outboundDegree: could not find the "${node}" node in the graph.`
        );
      let degree = 0;
      if (this.type !== "directed") {
        degree += nodeData.undirectedDegree;
      }
      if (this.type !== "undirected") {
        degree += nodeData.outDegree;
      }
      return degree;
    }
    /**
     * Method returning the given node's directed degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    degree(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.degree: could not find the "${node}" node in the graph.`
        );
      let degree = 0;
      if (this.type !== "directed") {
        degree += nodeData.undirectedDegree;
      }
      if (this.type !== "undirected") {
        degree += nodeData.inDegree + nodeData.outDegree;
      }
      return degree;
    }
    /**
     * Method returning the given node's in degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    inDegreeWithoutSelfLoops(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.inDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
        );
      if (this.type === "undirected") return 0;
      return nodeData.inDegree - nodeData.directedLoops;
    }
    /**
     * Method returning the given node's out degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    outDegreeWithoutSelfLoops(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.outDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
        );
      if (this.type === "undirected") return 0;
      return nodeData.outDegree - nodeData.directedLoops;
    }
    /**
     * Method returning the given node's directed degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    directedDegreeWithoutSelfLoops(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.directedDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
        );
      if (this.type === "undirected") return 0;
      return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;
    }
    /**
     * Method returning the given node's undirected degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    undirectedDegreeWithoutSelfLoops(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.undirectedDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
        );
      if (this.type === "directed") return 0;
      return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;
    }
    /**
     * Method returning the given node's inbound degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's inbound degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    inboundDegreeWithoutSelfLoops(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.inboundDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
        );
      let degree = 0;
      let loops = 0;
      if (this.type !== "directed") {
        degree += nodeData.undirectedDegree;
        loops += nodeData.undirectedLoops * 2;
      }
      if (this.type !== "undirected") {
        degree += nodeData.inDegree;
        loops += nodeData.directedLoops;
      }
      return degree - loops;
    }
    /**
     * Method returning the given node's outbound degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's outbound degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    outboundDegreeWithoutSelfLoops(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.outboundDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
        );
      let degree = 0;
      let loops = 0;
      if (this.type !== "directed") {
        degree += nodeData.undirectedDegree;
        loops += nodeData.undirectedLoops * 2;
      }
      if (this.type !== "undirected") {
        degree += nodeData.outDegree;
        loops += nodeData.directedLoops;
      }
      return degree - loops;
    }
    /**
     * Method returning the given node's directed degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    degreeWithoutSelfLoops(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.degreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
        );
      let degree = 0;
      let loops = 0;
      if (this.type !== "directed") {
        degree += nodeData.undirectedDegree;
        loops += nodeData.undirectedLoops * 2;
      }
      if (this.type !== "undirected") {
        degree += nodeData.inDegree + nodeData.outDegree;
        loops += nodeData.directedLoops * 2;
      }
      return degree - loops;
    }
    /**
     * Method returning the given edge's source.
     *
     * @param  {any} edge - The edge's key.
     * @return {any}      - The edge's source.
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */
    source(edge) {
      edge = "" + edge;
      const data = this._edges.get(edge);
      if (!data)
        throw new NotFoundGraphError(
          `Graph.source: could not find the "${edge}" edge in the graph.`
        );
      return data.source.key;
    }
    /**
     * Method returning the given edge's target.
     *
     * @param  {any} edge - The edge's key.
     * @return {any}      - The edge's target.
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */
    target(edge) {
      edge = "" + edge;
      const data = this._edges.get(edge);
      if (!data)
        throw new NotFoundGraphError(
          `Graph.target: could not find the "${edge}" edge in the graph.`
        );
      return data.target.key;
    }
    /**
     * Method returning the given edge's extremities.
     *
     * @param  {any}   edge - The edge's key.
     * @return {array}      - The edge's extremities.
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */
    extremities(edge) {
      edge = "" + edge;
      const edgeData = this._edges.get(edge);
      if (!edgeData)
        throw new NotFoundGraphError(
          `Graph.extremities: could not find the "${edge}" edge in the graph.`
        );
      return [edgeData.source.key, edgeData.target.key];
    }
    /**
     * Given a node & an edge, returns the other extremity of the edge.
     *
     * @param  {any}   node - The node's key.
     * @param  {any}   edge - The edge's key.
     * @return {any}        - The related node.
     *
     * @throws {Error} - Will throw if the edge isn't in the graph or if the
     *                   edge & node are not related.
     */
    opposite(node, edge) {
      node = "" + node;
      edge = "" + edge;
      const data = this._edges.get(edge);
      if (!data)
        throw new NotFoundGraphError(
          `Graph.opposite: could not find the "${edge}" edge in the graph.`
        );
      const source = data.source.key;
      const target = data.target.key;
      if (node === source) return target;
      if (node === target) return source;
      throw new NotFoundGraphError(
        `Graph.opposite: the "${node}" node is not attached to the "${edge}" edge (${source}, ${target}).`
      );
    }
    /**
     * Returns whether the given edge has the given node as extremity.
     *
     * @param  {any}     edge - The edge's key.
     * @param  {any}     node - The node's key.
     * @return {boolean}      - The related node.
     *
     * @throws {Error} - Will throw if either the node or the edge isn't in the graph.
     */
    hasExtremity(edge, node) {
      edge = "" + edge;
      node = "" + node;
      const data = this._edges.get(edge);
      if (!data)
        throw new NotFoundGraphError(
          `Graph.hasExtremity: could not find the "${edge}" edge in the graph.`
        );
      return data.source.key === node || data.target.key === node;
    }
    /**
     * Method returning whether the given edge is undirected.
     *
     * @param  {any}     edge - The edge's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */
    isUndirected(edge) {
      edge = "" + edge;
      const data = this._edges.get(edge);
      if (!data)
        throw new NotFoundGraphError(
          `Graph.isUndirected: could not find the "${edge}" edge in the graph.`
        );
      return data.undirected;
    }
    /**
     * Method returning whether the given edge is directed.
     *
     * @param  {any}     edge - The edge's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */
    isDirected(edge) {
      edge = "" + edge;
      const data = this._edges.get(edge);
      if (!data)
        throw new NotFoundGraphError(
          `Graph.isDirected: could not find the "${edge}" edge in the graph.`
        );
      return !data.undirected;
    }
    /**
     * Method returning whether the given edge is a self loop.
     *
     * @param  {any}     edge - The edge's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */
    isSelfLoop(edge) {
      edge = "" + edge;
      const data = this._edges.get(edge);
      if (!data)
        throw new NotFoundGraphError(
          `Graph.isSelfLoop: could not find the "${edge}" edge in the graph.`
        );
      return data.source === data.target;
    }
    /**---------------------------------------------------------------------------
     * Mutation
     **---------------------------------------------------------------------------
     */
    /**
     * Method used to add a node to the graph.
     *
     * @param  {any}    node         - The node.
     * @param  {object} [attributes] - Optional attributes.
     * @return {any}                 - The node.
     *
     * @throws {Error} - Will throw if the given node already exist.
     * @throws {Error} - Will throw if the given attributes are not an object.
     */
    addNode(node, attributes) {
      const nodeData = addNode(this, node, attributes);
      return nodeData.key;
    }
    /**
     * Method used to merge a node into the graph.
     *
     * @param  {any}    node         - The node.
     * @param  {object} [attributes] - Optional attributes.
     * @return {any}                 - The node.
     */
    mergeNode(node, attributes) {
      if (attributes && !isPlainObject$2(attributes))
        throw new InvalidArgumentsGraphError(
          `Graph.mergeNode: invalid attributes. Expecting an object but got "${attributes}"`
        );
      node = "" + node;
      attributes = attributes || {};
      let data = this._nodes.get(node);
      if (data) {
        if (attributes) {
          assign(data.attributes, attributes);
          this.emit("nodeAttributesUpdated", {
            type: "merge",
            key: node,
            attributes: data.attributes,
            data: attributes
          });
        }
        return [node, false];
      }
      data = new this.NodeDataClass(node, attributes);
      this._nodes.set(node, data);
      this.emit("nodeAdded", {
        key: node,
        attributes
      });
      return [node, true];
    }
    /**
     * Method used to add a node if it does not exist in the graph or else to
     * update its attributes using a function.
     *
     * @param  {any}      node      - The node.
     * @param  {function} [updater] - Optional updater function.
     * @return {any}                - The node.
     */
    updateNode(node, updater) {
      if (updater && typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          `Graph.updateNode: invalid updater function. Expecting a function but got "${updater}"`
        );
      node = "" + node;
      let data = this._nodes.get(node);
      if (data) {
        if (updater) {
          const oldAttributes = data.attributes;
          data.attributes = updater(oldAttributes);
          this.emit("nodeAttributesUpdated", {
            type: "replace",
            key: node,
            attributes: data.attributes
          });
        }
        return [node, false];
      }
      const attributes = updater ? updater({}) : {};
      data = new this.NodeDataClass(node, attributes);
      this._nodes.set(node, data);
      this.emit("nodeAdded", {
        key: node,
        attributes
      });
      return [node, true];
    }
    /**
     * Method used to drop a single node & all its attached edges from the graph.
     *
     * @param  {any}    node - The node.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the node doesn't exist.
     */
    dropNode(node) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.dropNode: could not find the "${node}" node in the graph.`
        );
      let edgeData;
      if (this.type !== "undirected") {
        for (const neighbor in nodeData.out) {
          edgeData = nodeData.out[neighbor];
          do {
            dropEdgeFromData(this, edgeData);
            edgeData = edgeData.next;
          } while (edgeData);
        }
        for (const neighbor in nodeData.in) {
          edgeData = nodeData.in[neighbor];
          do {
            dropEdgeFromData(this, edgeData);
            edgeData = edgeData.next;
          } while (edgeData);
        }
      }
      if (this.type !== "directed") {
        for (const neighbor in nodeData.undirected) {
          edgeData = nodeData.undirected[neighbor];
          do {
            dropEdgeFromData(this, edgeData);
            edgeData = edgeData.next;
          } while (edgeData);
        }
      }
      this._nodes.delete(node);
      this.emit("nodeDropped", {
        key: node,
        attributes: nodeData.attributes
      });
    }
    /**
     * Method used to drop a single edge from the graph.
     *
     * Arity 1:
     * @param  {any}    edge - The edge.
     *
     * Arity 2:
     * @param  {any}    source - Source node.
     * @param  {any}    target - Target node.
     *
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the edge doesn't exist.
     */
    dropEdge(edge) {
      let edgeData;
      if (arguments.length > 1) {
        const source = "" + arguments[0];
        const target = "" + arguments[1];
        edgeData = getMatchingEdge(this, source, target, this.type);
        if (!edgeData)
          throw new NotFoundGraphError(
            `Graph.dropEdge: could not find the "${source}" -> "${target}" edge in the graph.`
          );
      } else {
        edge = "" + edge;
        edgeData = this._edges.get(edge);
        if (!edgeData)
          throw new NotFoundGraphError(
            `Graph.dropEdge: could not find the "${edge}" edge in the graph.`
          );
      }
      dropEdgeFromData(this, edgeData);
      return this;
    }
    /**
     * Method used to drop a single directed edge from the graph.
     *
     * @param  {any}    source - Source node.
     * @param  {any}    target - Target node.
     *
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the edge doesn't exist.
     */
    dropDirectedEdge(source, target) {
      if (arguments.length < 2)
        throw new UsageGraphError(
          "Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead."
        );
      if (this.multi)
        throw new UsageGraphError(
          "Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones."
        );
      source = "" + source;
      target = "" + target;
      const edgeData = getMatchingEdge(this, source, target, "directed");
      if (!edgeData)
        throw new NotFoundGraphError(
          `Graph.dropDirectedEdge: could not find a "${source}" -> "${target}" edge in the graph.`
        );
      dropEdgeFromData(this, edgeData);
      return this;
    }
    /**
     * Method used to drop a single undirected edge from the graph.
     *
     * @param  {any}    source - Source node.
     * @param  {any}    target - Target node.
     *
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the edge doesn't exist.
     */
    dropUndirectedEdge(source, target) {
      if (arguments.length < 2)
        throw new UsageGraphError(
          "Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead."
        );
      if (this.multi)
        throw new UsageGraphError(
          "Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones."
        );
      const edgeData = getMatchingEdge(this, source, target, "undirected");
      if (!edgeData)
        throw new NotFoundGraphError(
          `Graph.dropUndirectedEdge: could not find a "${source}" -> "${target}" edge in the graph.`
        );
      dropEdgeFromData(this, edgeData);
      return this;
    }
    /**
     * Method used to remove every edge & every node from the graph.
     *
     * @return {Graph}
     */
    clear() {
      this._edges.clear();
      this._nodes.clear();
      this._resetInstanceCounters();
      this.emit("cleared");
    }
    /**
     * Method used to remove every edge from the graph.
     *
     * @return {Graph}
     */
    clearEdges() {
      const iterator2 = this._nodes.values();
      let step;
      while (step = iterator2.next(), step.done !== true) {
        step.value.clear();
      }
      this._edges.clear();
      this._resetInstanceCounters();
      this.emit("edgesCleared");
    }
    /**---------------------------------------------------------------------------
     * Attributes-related methods
     **---------------------------------------------------------------------------
     */
    /**
     * Method returning the desired graph's attribute.
     *
     * @param  {string} name - Name of the attribute.
     * @return {any}
     */
    getAttribute(name) {
      return this._attributes[name];
    }
    /**
     * Method returning the graph's attributes.
     *
     * @return {object}
     */
    getAttributes() {
      return this._attributes;
    }
    /**
     * Method returning whether the graph has the desired attribute.
     *
     * @param  {string}  name - Name of the attribute.
     * @return {boolean}
     */
    hasAttribute(name) {
      return this._attributes.hasOwnProperty(name);
    }
    /**
     * Method setting a value for the desired graph's attribute.
     *
     * @param  {string}  name  - Name of the attribute.
     * @param  {any}     value - Value for the attribute.
     * @return {Graph}
     */
    setAttribute(name, value) {
      this._attributes[name] = value;
      this.emit("attributesUpdated", {
        type: "set",
        attributes: this._attributes,
        name
      });
      return this;
    }
    /**
     * Method using a function to update the desired graph's attribute's value.
     *
     * @param  {string}   name    - Name of the attribute.
     * @param  {function} updater - Function use to update the attribute's value.
     * @return {Graph}
     */
    updateAttribute(name, updater) {
      if (typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.updateAttribute: updater should be a function."
        );
      const value = this._attributes[name];
      this._attributes[name] = updater(value);
      this.emit("attributesUpdated", {
        type: "set",
        attributes: this._attributes,
        name
      });
      return this;
    }
    /**
     * Method removing the desired graph's attribute.
     *
     * @param  {string} name  - Name of the attribute.
     * @return {Graph}
     */
    removeAttribute(name) {
      delete this._attributes[name];
      this.emit("attributesUpdated", {
        type: "remove",
        attributes: this._attributes,
        name
      });
      return this;
    }
    /**
     * Method replacing the graph's attributes.
     *
     * @param  {object} attributes - New attributes.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if given attributes are not a plain object.
     */
    replaceAttributes(attributes) {
      if (!isPlainObject$2(attributes))
        throw new InvalidArgumentsGraphError(
          "Graph.replaceAttributes: provided attributes are not a plain object."
        );
      this._attributes = attributes;
      this.emit("attributesUpdated", {
        type: "replace",
        attributes: this._attributes
      });
      return this;
    }
    /**
     * Method merging the graph's attributes.
     *
     * @param  {object} attributes - Attributes to merge.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if given attributes are not a plain object.
     */
    mergeAttributes(attributes) {
      if (!isPlainObject$2(attributes))
        throw new InvalidArgumentsGraphError(
          "Graph.mergeAttributes: provided attributes are not a plain object."
        );
      assign(this._attributes, attributes);
      this.emit("attributesUpdated", {
        type: "merge",
        attributes: this._attributes,
        data: attributes
      });
      return this;
    }
    /**
     * Method updating the graph's attributes.
     *
     * @param  {function} updater - Function used to update the attributes.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if given updater is not a function.
     */
    updateAttributes(updater) {
      if (typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.updateAttributes: provided updater is not a function."
        );
      this._attributes = updater(this._attributes);
      this.emit("attributesUpdated", {
        type: "update",
        attributes: this._attributes
      });
      return this;
    }
    /**
     * Method used to update each node's attributes using the given function.
     *
     * @param {function}  updater - Updater function to use.
     * @param {object}    [hints] - Optional hints.
     */
    updateEachNodeAttributes(updater, hints) {
      if (typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.updateEachNodeAttributes: expecting an updater function."
        );
      if (hints && !validateHints(hints))
        throw new InvalidArgumentsGraphError(
          "Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}"
        );
      const iterator2 = this._nodes.values();
      let step, nodeData;
      while (step = iterator2.next(), step.done !== true) {
        nodeData = step.value;
        nodeData.attributes = updater(nodeData.key, nodeData.attributes);
      }
      this.emit("eachNodeAttributesUpdated", {
        hints: hints ? hints : null
      });
    }
    /**
     * Method used to update each edge's attributes using the given function.
     *
     * @param {function}  updater - Updater function to use.
     * @param {object}    [hints] - Optional hints.
     */
    updateEachEdgeAttributes(updater, hints) {
      if (typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.updateEachEdgeAttributes: expecting an updater function."
        );
      if (hints && !validateHints(hints))
        throw new InvalidArgumentsGraphError(
          "Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}"
        );
      const iterator2 = this._edges.values();
      let step, edgeData, sourceData, targetData;
      while (step = iterator2.next(), step.done !== true) {
        edgeData = step.value;
        sourceData = edgeData.source;
        targetData = edgeData.target;
        edgeData.attributes = updater(
          edgeData.key,
          edgeData.attributes,
          sourceData.key,
          targetData.key,
          sourceData.attributes,
          targetData.attributes,
          edgeData.undirected
        );
      }
      this.emit("eachEdgeAttributesUpdated", {
        hints: hints ? hints : null
      });
    }
    /**---------------------------------------------------------------------------
     * Iteration-related methods
     **---------------------------------------------------------------------------
     */
    /**
     * Method iterating over the graph's adjacency using the given callback.
     *
     * @param  {function}  callback - Callback to use.
     */
    forEachAdjacencyEntry(callback) {
      if (typeof callback !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.forEachAdjacencyEntry: expecting a callback."
        );
      forEachAdjacency(false, false, false, this, callback);
    }
    forEachAdjacencyEntryWithOrphans(callback) {
      if (typeof callback !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.forEachAdjacencyEntryWithOrphans: expecting a callback."
        );
      forEachAdjacency(false, false, true, this, callback);
    }
    /**
     * Method iterating over the graph's assymetric adjacency using the given callback.
     *
     * @param  {function}  callback - Callback to use.
     */
    forEachAssymetricAdjacencyEntry(callback) {
      if (typeof callback !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.forEachAssymetricAdjacencyEntry: expecting a callback."
        );
      forEachAdjacency(false, true, false, this, callback);
    }
    forEachAssymetricAdjacencyEntryWithOrphans(callback) {
      if (typeof callback !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback."
        );
      forEachAdjacency(false, true, true, this, callback);
    }
    /**
     * Method returning the list of the graph's nodes.
     *
     * @return {array} - The nodes.
     */
    nodes() {
      if (typeof Array.from === "function") return Array.from(this._nodes.keys());
      return take(this._nodes.keys(), this._nodes.size);
    }
    /**
     * Method iterating over the graph's nodes using the given callback.
     *
     * @param  {function}  callback - Callback (key, attributes, index).
     */
    forEachNode(callback) {
      if (typeof callback !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.forEachNode: expecting a callback."
        );
      const iterator2 = this._nodes.values();
      let step, nodeData;
      while (step = iterator2.next(), step.done !== true) {
        nodeData = step.value;
        callback(nodeData.key, nodeData.attributes);
      }
    }
    /**
     * Method iterating attempting to find a node matching the given predicate
     * function.
     *
     * @param  {function}  callback - Callback (key, attributes).
     */
    findNode(callback) {
      if (typeof callback !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.findNode: expecting a callback."
        );
      const iterator2 = this._nodes.values();
      let step, nodeData;
      while (step = iterator2.next(), step.done !== true) {
        nodeData = step.value;
        if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;
      }
      return;
    }
    /**
     * Method mapping nodes.
     *
     * @param  {function}  callback - Callback (key, attributes).
     */
    mapNodes(callback) {
      if (typeof callback !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.mapNode: expecting a callback."
        );
      const iterator2 = this._nodes.values();
      let step, nodeData;
      const result2 = new Array(this.order);
      let i = 0;
      while (step = iterator2.next(), step.done !== true) {
        nodeData = step.value;
        result2[i++] = callback(nodeData.key, nodeData.attributes);
      }
      return result2;
    }
    /**
     * Method returning whether some node verify the given predicate.
     *
     * @param  {function}  callback - Callback (key, attributes).
     */
    someNode(callback) {
      if (typeof callback !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.someNode: expecting a callback."
        );
      const iterator2 = this._nodes.values();
      let step, nodeData;
      while (step = iterator2.next(), step.done !== true) {
        nodeData = step.value;
        if (callback(nodeData.key, nodeData.attributes)) return true;
      }
      return false;
    }
    /**
     * Method returning whether all node verify the given predicate.
     *
     * @param  {function}  callback - Callback (key, attributes).
     */
    everyNode(callback) {
      if (typeof callback !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.everyNode: expecting a callback."
        );
      const iterator2 = this._nodes.values();
      let step, nodeData;
      while (step = iterator2.next(), step.done !== true) {
        nodeData = step.value;
        if (!callback(nodeData.key, nodeData.attributes)) return false;
      }
      return true;
    }
    /**
     * Method filtering nodes.
     *
     * @param  {function}  callback - Callback (key, attributes).
     */
    filterNodes(callback) {
      if (typeof callback !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.filterNodes: expecting a callback."
        );
      const iterator2 = this._nodes.values();
      let step, nodeData;
      const result2 = [];
      while (step = iterator2.next(), step.done !== true) {
        nodeData = step.value;
        if (callback(nodeData.key, nodeData.attributes))
          result2.push(nodeData.key);
      }
      return result2;
    }
    /**
     * Method reducing nodes.
     *
     * @param  {function}  callback - Callback (accumulator, key, attributes).
     */
    reduceNodes(callback, initialValue) {
      if (typeof callback !== "function")
        throw new InvalidArgumentsGraphError(
          "Graph.reduceNodes: expecting a callback."
        );
      if (arguments.length < 2)
        throw new InvalidArgumentsGraphError(
          "Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."
        );
      let accumulator = initialValue;
      const iterator2 = this._nodes.values();
      let step, nodeData;
      while (step = iterator2.next(), step.done !== true) {
        nodeData = step.value;
        accumulator = callback(accumulator, nodeData.key, nodeData.attributes);
      }
      return accumulator;
    }
    /**
     * Method returning an iterator over the graph's node entries.
     *
     * @return {Iterator}
     */
    nodeEntries() {
      const iterator2 = this._nodes.values();
      return new Iterator$1(() => {
        const step = iterator2.next();
        if (step.done) return step;
        const data = step.value;
        return {
          value: { node: data.key, attributes: data.attributes },
          done: false
        };
      });
    }
    /**---------------------------------------------------------------------------
     * Serialization
     **---------------------------------------------------------------------------
     */
    /**
     * Method used to export the whole graph.
     *
     * @return {object} - The serialized graph.
     */
    export() {
      const nodes = new Array(this._nodes.size);
      let i = 0;
      this._nodes.forEach((data, key) => {
        nodes[i++] = serializeNode(key, data);
      });
      const edges = new Array(this._edges.size);
      i = 0;
      this._edges.forEach((data, key) => {
        edges[i++] = serializeEdge(this.type, key, data);
      });
      return {
        options: {
          type: this.type,
          multi: this.multi,
          allowSelfLoops: this.allowSelfLoops
        },
        attributes: this.getAttributes(),
        nodes,
        edges
      };
    }
    /**
     * Method used to import a serialized graph.
     *
     * @param  {object|Graph} data  - The serialized graph.
     * @param  {boolean}      merge - Whether to merge data.
     * @return {Graph}              - Returns itself for chaining.
     */
    import(data, merge = false) {
      if (data instanceof Graph) {
        data.forEachNode((n, a) => {
          if (merge) this.mergeNode(n, a);
          else this.addNode(n, a);
        });
        data.forEachEdge((e, a, s, t, _sa, _ta, u) => {
          if (merge) {
            if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);
            else this.mergeDirectedEdgeWithKey(e, s, t, a);
          } else {
            if (u) this.addUndirectedEdgeWithKey(e, s, t, a);
            else this.addDirectedEdgeWithKey(e, s, t, a);
          }
        });
        return this;
      }
      if (!isPlainObject$2(data))
        throw new InvalidArgumentsGraphError(
          "Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance."
        );
      if (data.attributes) {
        if (!isPlainObject$2(data.attributes))
          throw new InvalidArgumentsGraphError(
            "Graph.import: invalid attributes. Expecting a plain object."
          );
        if (merge) this.mergeAttributes(data.attributes);
        else this.replaceAttributes(data.attributes);
      }
      let i, l, list, node, edge;
      if (data.nodes) {
        list = data.nodes;
        if (!Array.isArray(list))
          throw new InvalidArgumentsGraphError(
            "Graph.import: invalid nodes. Expecting an array."
          );
        for (i = 0, l = list.length; i < l; i++) {
          node = list[i];
          validateSerializedNode(node);
          const { key, attributes } = node;
          if (merge) this.mergeNode(key, attributes);
          else this.addNode(key, attributes);
        }
      }
      if (data.edges) {
        let undirectedByDefault = false;
        if (this.type === "undirected") {
          undirectedByDefault = true;
        }
        list = data.edges;
        if (!Array.isArray(list))
          throw new InvalidArgumentsGraphError(
            "Graph.import: invalid edges. Expecting an array."
          );
        for (i = 0, l = list.length; i < l; i++) {
          edge = list[i];
          validateSerializedEdge(edge);
          const {
            source,
            target,
            attributes,
            undirected = undirectedByDefault
          } = edge;
          let method;
          if ("key" in edge) {
            method = merge ? undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey : undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey;
            method.call(this, edge.key, source, target, attributes);
          } else {
            method = merge ? undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge : undirected ? this.addUndirectedEdge : this.addDirectedEdge;
            method.call(this, source, target, attributes);
          }
        }
      }
      return this;
    }
    /**---------------------------------------------------------------------------
     * Utils
     **---------------------------------------------------------------------------
     */
    /**
     * Method returning a null copy of the graph, i.e. a graph without nodes
     * & edges but with the exact same options.
     *
     * @param  {object} options - Options to merge with the current ones.
     * @return {Graph}          - The null copy.
     */
    nullCopy(options) {
      const graph = new Graph(assign({}, this._options, options));
      graph.replaceAttributes(assign({}, this.getAttributes()));
      return graph;
    }
    /**
     * Method returning an empty copy of the graph, i.e. a graph without edges but
     * with the exact same options.
     *
     * @param  {object} options - Options to merge with the current ones.
     * @return {Graph}          - The empty copy.
     */
    emptyCopy(options) {
      const graph = this.nullCopy(options);
      this._nodes.forEach((nodeData, key) => {
        const attributes = assign({}, nodeData.attributes);
        nodeData = new graph.NodeDataClass(key, attributes);
        graph._nodes.set(key, nodeData);
      });
      return graph;
    }
    /**
     * Method returning an exact copy of the graph.
     *
     * @param  {object} options - Upgrade options.
     * @return {Graph}          - The copy.
     */
    copy(options) {
      options = options || {};
      if (typeof options.type === "string" && options.type !== this.type && options.type !== "mixed")
        throw new UsageGraphError(
          `Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${options.type}" because this would mean losing information about the current graph.`
        );
      if (typeof options.multi === "boolean" && options.multi !== this.multi && options.multi !== true)
        throw new UsageGraphError(
          "Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph."
        );
      if (typeof options.allowSelfLoops === "boolean" && options.allowSelfLoops !== this.allowSelfLoops && options.allowSelfLoops !== true)
        throw new UsageGraphError(
          "Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph."
        );
      const graph = this.emptyCopy(options);
      const iterator2 = this._edges.values();
      let step, edgeData;
      while (step = iterator2.next(), step.done !== true) {
        edgeData = step.value;
        addEdge(
          graph,
          "copy",
          false,
          edgeData.undirected,
          edgeData.key,
          edgeData.source.key,
          edgeData.target.key,
          assign({}, edgeData.attributes)
        );
      }
      return graph;
    }
    /**---------------------------------------------------------------------------
     * Known methods
     **---------------------------------------------------------------------------
     */
    /**
     * Method used by JavaScript to perform JSON serialization.
     *
     * @return {object} - The serialized graph.
     */
    toJSON() {
      return this.export();
    }
    /**
     * Method returning [object Graph].
     */
    toString() {
      return "[object Graph]";
    }
    /**
     * Method used internally by node's console to display a custom object.
     *
     * @return {object} - Formatted object representation of the graph.
     */
    inspect() {
      const nodes = {};
      this._nodes.forEach((data, key) => {
        nodes[key] = data.attributes;
      });
      const edges = {}, multiIndex = {};
      this._edges.forEach((data, key) => {
        const direction = data.undirected ? "--" : "->";
        let label = "";
        let source = data.source.key;
        let target = data.target.key;
        let tmp;
        if (data.undirected && source > target) {
          tmp = source;
          source = target;
          target = tmp;
        }
        const desc = `(${source})${direction}(${target})`;
        if (!key.startsWith("geid_")) {
          label += `[${key}]: `;
        } else if (this.multi) {
          if (typeof multiIndex[desc] === "undefined") {
            multiIndex[desc] = 0;
          } else {
            multiIndex[desc]++;
          }
          label += `${multiIndex[desc]}. `;
        }
        label += desc;
        edges[label] = data.attributes;
      });
      const dummy = {};
      for (const k in this) {
        if (this.hasOwnProperty(k) && !EMITTER_PROPS.has(k) && typeof this[k] !== "function" && typeof k !== "symbol")
          dummy[k] = this[k];
      }
      dummy.attributes = this._attributes;
      dummy.nodes = nodes;
      dummy.edges = edges;
      privateProperty(dummy, "constructor", this.constructor);
      return dummy;
    }
  }
  if (typeof Symbol !== "undefined")
    Graph.prototype[Symbol.for("nodejs.util.inspect.custom")] = Graph.prototype.inspect;
  EDGE_ADD_METHODS.forEach((method) => {
    ["add", "merge", "update"].forEach((verb) => {
      const name = method.name(verb);
      const fn = verb === "add" ? addEdge : mergeEdge;
      if (method.generateKey) {
        Graph.prototype[name] = function(source, target, attributes) {
          return fn(
            this,
            name,
            true,
            (method.type || this.type) === "undirected",
            null,
            source,
            target,
            attributes,
            verb === "update"
          );
        };
      } else {
        Graph.prototype[name] = function(edge, source, target, attributes) {
          return fn(
            this,
            name,
            false,
            (method.type || this.type) === "undirected",
            edge,
            source,
            target,
            attributes,
            verb === "update"
          );
        };
      }
    });
  });
  attachNodeAttributesMethods(Graph);
  attachEdgeAttributesMethods(Graph);
  attachEdgeIterationMethods(Graph);
  attachNeighborIterationMethods(Graph);
  class DirectedGraph extends Graph {
    constructor(options) {
      const finalOptions = assign({ type: "directed" }, options);
      if ("multi" in finalOptions && finalOptions.multi !== false)
        throw new InvalidArgumentsGraphError(
          "DirectedGraph.from: inconsistent indication that the graph should be multi in given options!"
        );
      if (finalOptions.type !== "directed")
        throw new InvalidArgumentsGraphError(
          'DirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!'
        );
      super(finalOptions);
    }
  }
  class UndirectedGraph extends Graph {
    constructor(options) {
      const finalOptions = assign({ type: "undirected" }, options);
      if ("multi" in finalOptions && finalOptions.multi !== false)
        throw new InvalidArgumentsGraphError(
          "UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!"
        );
      if (finalOptions.type !== "undirected")
        throw new InvalidArgumentsGraphError(
          'UndirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!'
        );
      super(finalOptions);
    }
  }
  class MultiGraph extends Graph {
    constructor(options) {
      const finalOptions = assign({ multi: true }, options);
      if ("multi" in finalOptions && finalOptions.multi !== true)
        throw new InvalidArgumentsGraphError(
          "MultiGraph.from: inconsistent indication that the graph should be simple in given options!"
        );
      super(finalOptions);
    }
  }
  class MultiDirectedGraph extends Graph {
    constructor(options) {
      const finalOptions = assign({ type: "directed", multi: true }, options);
      if ("multi" in finalOptions && finalOptions.multi !== true)
        throw new InvalidArgumentsGraphError(
          "MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!"
        );
      if (finalOptions.type !== "directed")
        throw new InvalidArgumentsGraphError(
          'MultiDirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!'
        );
      super(finalOptions);
    }
  }
  class MultiUndirectedGraph extends Graph {
    constructor(options) {
      const finalOptions = assign({ type: "undirected", multi: true }, options);
      if ("multi" in finalOptions && finalOptions.multi !== true)
        throw new InvalidArgumentsGraphError(
          "MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!"
        );
      if (finalOptions.type !== "undirected")
        throw new InvalidArgumentsGraphError(
          'MultiUndirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!'
        );
      super(finalOptions);
    }
  }
  function attachStaticFromMethod(Class) {
    Class.from = function(data, options) {
      const finalOptions = assign({}, data.options, options);
      const instance = new Class(finalOptions);
      instance.import(data);
      return instance;
    };
  }
  attachStaticFromMethod(Graph);
  attachStaticFromMethod(DirectedGraph);
  attachStaticFromMethod(UndirectedGraph);
  attachStaticFromMethod(MultiGraph);
  attachStaticFromMethod(MultiDirectedGraph);
  attachStaticFromMethod(MultiUndirectedGraph);
  Graph.Graph = Graph;
  Graph.DirectedGraph = DirectedGraph;
  Graph.UndirectedGraph = UndirectedGraph;
  Graph.MultiGraph = MultiGraph;
  Graph.MultiDirectedGraph = MultiDirectedGraph;
  Graph.MultiUndirectedGraph = MultiUndirectedGraph;
  Graph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;
  Graph.NotFoundGraphError = NotFoundGraphError;
  Graph.UsageGraphError = UsageGraphError;
  var graphologyShortestPath = {};
  var unweighted = {};
  var isGraph;
  var hasRequiredIsGraph;
  function requireIsGraph() {
    if (hasRequiredIsGraph) return isGraph;
    hasRequiredIsGraph = 1;
    isGraph = function isGraph2(value) {
      return value !== null && typeof value === "object" && typeof value.addUndirectedEdgeWithKey === "function" && typeof value.dropNode === "function" && typeof value.multi === "boolean";
    };
    return isGraph;
  }
  var foreach;
  var hasRequiredForeach;
  function requireForeach() {
    if (hasRequiredForeach) return foreach;
    hasRequiredForeach = 1;
    var support2 = requireSupport();
    var ARRAY_BUFFER_SUPPORT = support2.ARRAY_BUFFER_SUPPORT;
    var SYMBOL_SUPPORT = support2.SYMBOL_SUPPORT;
    foreach = function forEach(iterable, callback) {
      var iterator2, k, i, l, s;
      if (!iterable) throw new Error("obliterator/forEach: invalid iterable.");
      if (typeof callback !== "function")
        throw new Error("obliterator/forEach: expecting a callback.");
      if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === "string" || iterable.toString() === "[object Arguments]") {
        for (i = 0, l = iterable.length; i < l; i++) callback(iterable[i], i);
        return;
      }
      if (typeof iterable.forEach === "function") {
        iterable.forEach(callback);
        return;
      }
      if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== "function") {
        iterable = iterable[Symbol.iterator]();
      }
      if (typeof iterable.next === "function") {
        iterator2 = iterable;
        i = 0;
        while (s = iterator2.next(), s.done !== true) {
          callback(s.value, i);
          i++;
        }
        return;
      }
      for (k in iterable) {
        if (iterable.hasOwnProperty(k)) {
          callback(iterable[k], k);
        }
      }
      return;
    };
    return foreach;
  }
  var queue;
  var hasRequiredQueue;
  function requireQueue() {
    if (hasRequiredQueue) return queue;
    hasRequiredQueue = 1;
    var Iterator2 = requireIterator(), forEach = requireForeach();
    function Queue() {
      this.clear();
    }
    Queue.prototype.clear = function() {
      this.items = [];
      this.offset = 0;
      this.size = 0;
    };
    Queue.prototype.enqueue = function(item) {
      this.items.push(item);
      return ++this.size;
    };
    Queue.prototype.dequeue = function() {
      if (!this.size)
        return;
      var item = this.items[this.offset];
      if (++this.offset * 2 >= this.items.length) {
        this.items = this.items.slice(this.offset);
        this.offset = 0;
      }
      this.size--;
      return item;
    };
    Queue.prototype.peek = function() {
      if (!this.size)
        return;
      return this.items[this.offset];
    };
    Queue.prototype.forEach = function(callback, scope) {
      scope = arguments.length > 1 ? scope : this;
      for (var i = this.offset, j = 0, l = this.items.length; i < l; i++, j++)
        callback.call(scope, this.items[i], j, this);
    };
    Queue.prototype.toArray = function() {
      return this.items.slice(this.offset);
    };
    Queue.prototype.values = function() {
      var items = this.items, i = this.offset;
      return new Iterator2(function() {
        if (i >= items.length)
          return {
            done: true
          };
        var value = items[i];
        i++;
        return {
          value,
          done: false
        };
      });
    };
    Queue.prototype.entries = function() {
      var items = this.items, i = this.offset, j = 0;
      return new Iterator2(function() {
        if (i >= items.length)
          return {
            done: true
          };
        var value = items[i];
        i++;
        return {
          value: [j++, value],
          done: false
        };
      });
    };
    if (typeof Symbol !== "undefined")
      Queue.prototype[Symbol.iterator] = Queue.prototype.values;
    Queue.prototype.toString = function() {
      return this.toArray().join(",");
    };
    Queue.prototype.toJSON = function() {
      return this.toArray();
    };
    Queue.prototype.inspect = function() {
      var array = this.toArray();
      Object.defineProperty(array, "constructor", {
        value: Queue,
        enumerable: false
      });
      return array;
    };
    if (typeof Symbol !== "undefined")
      Queue.prototype[Symbol.for("nodejs.util.inspect.custom")] = Queue.prototype.inspect;
    Queue.from = function(iterable) {
      var queue2 = new Queue();
      forEach(iterable, function(value) {
        queue2.enqueue(value);
      });
      return queue2;
    };
    Queue.of = function() {
      return Queue.from(arguments);
    };
    queue = Queue;
    return queue;
  }
  var extend;
  var hasRequiredExtend;
  function requireExtend() {
    if (hasRequiredExtend) return extend;
    hasRequiredExtend = 1;
    extend = function extend2(array, values) {
      var l2 = values.length;
      if (l2 === 0)
        return;
      var l1 = array.length;
      array.length += l2;
      for (var i = 0; i < l2; i++)
        array[l1 + i] = values[i];
    };
    return extend;
  }
  var hasRequiredUnweighted;
  function requireUnweighted() {
    if (hasRequiredUnweighted) return unweighted;
    hasRequiredUnweighted = 1;
    var isGraph2 = requireIsGraph();
    var Queue = requireQueue();
    var extend2 = requireExtend();
    function bidirectional(graph, source, target) {
      if (!isGraph2(graph))
        throw new Error("graphology-shortest-path: invalid graphology instance.");
      if (arguments.length < 3)
        throw new Error(
          "graphology-shortest-path: invalid number of arguments. Expecting at least 3."
        );
      if (!graph.hasNode(source))
        throw new Error(
          'graphology-shortest-path: the "' + source + '" source node does not exist in the given graph.'
        );
      if (!graph.hasNode(target))
        throw new Error(
          'graphology-shortest-path: the "' + target + '" target node does not exist in the given graph.'
        );
      source = "" + source;
      target = "" + target;
      if (source === target) {
        return [source];
      }
      var getPredecessors = graph.inboundNeighbors.bind(graph), getSuccessors = graph.outboundNeighbors.bind(graph);
      var predecessor = {}, successor = {};
      predecessor[source] = null;
      successor[target] = null;
      var forwardFringe = [source], reverseFringe = [target], currentFringe, node, neighbors, neighbor, i, j, l, m;
      var found = false;
      outer: while (forwardFringe.length && reverseFringe.length) {
        if (forwardFringe.length <= reverseFringe.length) {
          currentFringe = forwardFringe;
          forwardFringe = [];
          for (i = 0, l = currentFringe.length; i < l; i++) {
            node = currentFringe[i];
            neighbors = getSuccessors(node);
            for (j = 0, m = neighbors.length; j < m; j++) {
              neighbor = neighbors[j];
              if (!(neighbor in predecessor)) {
                forwardFringe.push(neighbor);
                predecessor[neighbor] = node;
              }
              if (neighbor in successor) {
                found = true;
                break outer;
              }
            }
          }
        } else {
          currentFringe = reverseFringe;
          reverseFringe = [];
          for (i = 0, l = currentFringe.length; i < l; i++) {
            node = currentFringe[i];
            neighbors = getPredecessors(node);
            for (j = 0, m = neighbors.length; j < m; j++) {
              neighbor = neighbors[j];
              if (!(neighbor in successor)) {
                reverseFringe.push(neighbor);
                successor[neighbor] = node;
              }
              if (neighbor in predecessor) {
                found = true;
                break outer;
              }
            }
          }
        }
      }
      if (!found) return null;
      var path = [];
      while (neighbor) {
        path.unshift(neighbor);
        neighbor = predecessor[neighbor];
      }
      neighbor = successor[path[path.length - 1]];
      while (neighbor) {
        path.push(neighbor);
        neighbor = successor[neighbor];
      }
      return path.length ? path : null;
    }
    function singleSource(graph, source) {
      if (!isGraph2(graph))
        throw new Error("graphology-shortest-path: invalid graphology instance.");
      if (arguments.length < 2)
        throw new Error(
          "graphology-shortest-path: invalid number of arguments. Expecting at least 2."
        );
      if (!graph.hasNode(source))
        throw new Error(
          'graphology-shortest-path: the "' + source + '" source node does not exist in the given graph.'
        );
      source = "" + source;
      var nextLevel = {}, paths = {}, currentLevel, neighbors, v, w, i, l;
      nextLevel[source] = true;
      paths[source] = [source];
      while (Object.keys(nextLevel).length) {
        currentLevel = nextLevel;
        nextLevel = {};
        for (v in currentLevel) {
          neighbors = graph.outboundNeighbors(v);
          for (i = 0, l = neighbors.length; i < l; i++) {
            w = neighbors[i];
            if (!paths[w]) {
              paths[w] = paths[v].concat(w);
              nextLevel[w] = true;
            }
          }
        }
      }
      return paths;
    }
    function asbtractSingleSourceLength(method, graph, source) {
      if (!isGraph2(graph))
        throw new Error("graphology-shortest-path: invalid graphology instance.");
      if (!graph.hasNode(source))
        throw new Error(
          'graphology-shortest-path: the "' + source + '" source node does not exist in the given graph.'
        );
      source = "" + source;
      var seen = /* @__PURE__ */ new Set();
      var lengths = {}, level = 0;
      lengths[source] = 0;
      var currentLevel = [source];
      var i, l, node;
      while (currentLevel.length !== 0) {
        var nextLevel = [];
        for (i = 0, l = currentLevel.length; i < l; i++) {
          node = currentLevel[i];
          if (seen.has(node)) continue;
          seen.add(node);
          extend2(nextLevel, graph[method](node));
          lengths[node] = level;
        }
        level++;
        currentLevel = nextLevel;
      }
      return lengths;
    }
    var singleSourceLength = asbtractSingleSourceLength.bind(
      null,
      "outboundNeighbors"
    );
    var undirectedSingleSourceLength = asbtractSingleSourceLength.bind(
      null,
      "neighbors"
    );
    function brandes(graph, source) {
      source = "" + source;
      var S = [], P = {}, sigma = {};
      var nodes = graph.nodes(), Dv, sigmav, neighbors, v, w, i, j, l, m;
      for (i = 0, l = nodes.length; i < l; i++) {
        v = nodes[i];
        P[v] = [];
        sigma[v] = 0;
      }
      var D = {};
      sigma[source] = 1;
      D[source] = 0;
      var queue2 = Queue.of(source);
      while (queue2.size) {
        v = queue2.dequeue();
        S.push(v);
        Dv = D[v];
        sigmav = sigma[v];
        neighbors = graph.outboundNeighbors(v);
        for (j = 0, m = neighbors.length; j < m; j++) {
          w = neighbors[j];
          if (!(w in D)) {
            queue2.enqueue(w);
            D[w] = Dv + 1;
          }
          if (D[w] === Dv + 1) {
            sigma[w] += sigmav;
            P[w].push(v);
          }
        }
      }
      return [S, P, sigma];
    }
    unweighted.bidirectional = bidirectional;
    unweighted.singleSource = singleSource;
    unweighted.singleSourceLength = singleSourceLength;
    unweighted.undirectedSingleSourceLength = undirectedSingleSourceLength;
    unweighted.brandes = brandes;
    return unweighted;
  }
  var utils = {};
  var hasRequiredUtils;
  function requireUtils() {
    if (hasRequiredUtils) return utils;
    hasRequiredUtils = 1;
    var returnTrue = function() {
      return true;
    };
    utils.edgePathFromNodePath = function(graph, nodePath) {
      var l = nodePath.length;
      var i, source, target, edge;
      if (l < 2) {
        source = nodePath[0];
        edge = graph.multi ? graph.findEdge(source, source, returnTrue) : graph.edge(source, source);
        if (edge) return [edge];
        return [];
      }
      l--;
      var edgePath = new Array(l);
      for (i = 0; i < l; i++) {
        source = nodePath[i];
        target = nodePath[i + 1];
        edge = graph.multi ? graph.findOutboundEdge(source, target, returnTrue) : graph.edge(source, target);
        if (edge === void 0)
          throw new Error(
            "graphology-shortest-path: given path is impossible in given graph."
          );
        edgePath[i] = edge;
      }
      return edgePath;
    };
    return utils;
  }
  var dijkstra = {};
  var getters = {};
  var hasRequiredGetters;
  function requireGetters() {
    if (hasRequiredGetters) return getters;
    hasRequiredGetters = 1;
    function coerceWeight(value) {
      if (typeof value !== "number" || isNaN(value)) return 1;
      return value;
    }
    function createNodeValueGetter(nameOrFunction, defaultValue) {
      var getter = {};
      var coerceToDefault = function(v) {
        if (typeof v === "undefined") return defaultValue;
        return v;
      };
      if (typeof defaultValue === "function") coerceToDefault = defaultValue;
      var get2 = function(attributes) {
        return coerceToDefault(attributes[nameOrFunction]);
      };
      var returnDefault = function() {
        return coerceToDefault(void 0);
      };
      if (typeof nameOrFunction === "string") {
        getter.fromAttributes = get2;
        getter.fromGraph = function(graph, node) {
          return get2(graph.getNodeAttributes(node));
        };
        getter.fromEntry = function(node, attributes) {
          return get2(attributes);
        };
      } else if (typeof nameOrFunction === "function") {
        getter.fromAttributes = function() {
          throw new Error(
            "graphology-utils/getters/createNodeValueGetter: irrelevant usage."
          );
        };
        getter.fromGraph = function(graph, node) {
          return coerceToDefault(
            nameOrFunction(node, graph.getNodeAttributes(node))
          );
        };
        getter.fromEntry = function(node, attributes) {
          return coerceToDefault(nameOrFunction(node, attributes));
        };
      } else {
        getter.fromAttributes = returnDefault;
        getter.fromGraph = returnDefault;
        getter.fromEntry = returnDefault;
      }
      return getter;
    }
    function createEdgeValueGetter(nameOrFunction, defaultValue) {
      var getter = {};
      var coerceToDefault = function(v) {
        if (typeof v === "undefined") return defaultValue;
        return v;
      };
      if (typeof defaultValue === "function") coerceToDefault = defaultValue;
      var get2 = function(attributes) {
        return coerceToDefault(attributes[nameOrFunction]);
      };
      var returnDefault = function() {
        return coerceToDefault(void 0);
      };
      if (typeof nameOrFunction === "string") {
        getter.fromAttributes = get2;
        getter.fromGraph = function(graph, edge) {
          return get2(graph.getEdgeAttributes(edge));
        };
        getter.fromEntry = function(edge, attributes) {
          return get2(attributes);
        };
        getter.fromPartialEntry = getter.fromEntry;
        getter.fromMinimalEntry = getter.fromEntry;
      } else if (typeof nameOrFunction === "function") {
        getter.fromAttributes = function() {
          throw new Error(
            "graphology-utils/getters/createEdgeValueGetter: irrelevant usage."
          );
        };
        getter.fromGraph = function(graph, edge) {
          var extremities = graph.extremities(edge);
          return coerceToDefault(
            nameOrFunction(
              edge,
              graph.getEdgeAttributes(edge),
              extremities[0],
              extremities[1],
              graph.getNodeAttributes(extremities[0]),
              graph.getNodeAttributes(extremities[1]),
              graph.isUndirected(edge)
            )
          );
        };
        getter.fromEntry = function(e, a, s, t, sa, ta, u) {
          return coerceToDefault(nameOrFunction(e, a, s, t, sa, ta, u));
        };
        getter.fromPartialEntry = function(e, a, s, t) {
          return coerceToDefault(nameOrFunction(e, a, s, t));
        };
        getter.fromMinimalEntry = function(e, a) {
          return coerceToDefault(nameOrFunction(e, a));
        };
      } else {
        getter.fromAttributes = returnDefault;
        getter.fromGraph = returnDefault;
        getter.fromEntry = returnDefault;
        getter.fromMinimalEntry = returnDefault;
      }
      return getter;
    }
    getters.createNodeValueGetter = createNodeValueGetter;
    getters.createEdgeValueGetter = createEdgeValueGetter;
    getters.createEdgeWeightGetter = function(name) {
      return createEdgeValueGetter(name, coerceWeight);
    };
    return getters;
  }
  var comparators = {};
  var hasRequiredComparators;
  function requireComparators() {
    if (hasRequiredComparators) return comparators;
    hasRequiredComparators = 1;
    var DEFAULT_COMPARATOR = function(a, b) {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    };
    var DEFAULT_REVERSE_COMPARATOR = function(a, b) {
      if (a < b)
        return 1;
      if (a > b)
        return -1;
      return 0;
    };
    function reverseComparator(comparator) {
      return function(a, b) {
        return comparator(b, a);
      };
    }
    function createTupleComparator(size) {
      if (size === 2) {
        return function(a, b) {
          if (a[0] < b[0])
            return -1;
          if (a[0] > b[0])
            return 1;
          if (a[1] < b[1])
            return -1;
          if (a[1] > b[1])
            return 1;
          return 0;
        };
      }
      return function(a, b) {
        var i = 0;
        while (i < size) {
          if (a[i] < b[i])
            return -1;
          if (a[i] > b[i])
            return 1;
          i++;
        }
        return 0;
      };
    }
    comparators.DEFAULT_COMPARATOR = DEFAULT_COMPARATOR;
    comparators.DEFAULT_REVERSE_COMPARATOR = DEFAULT_REVERSE_COMPARATOR;
    comparators.reverseComparator = reverseComparator;
    comparators.createTupleComparator = createTupleComparator;
    return comparators;
  }
  var iterables = {};
  var typedArrays = {};
  var hasRequiredTypedArrays;
  function requireTypedArrays() {
    if (hasRequiredTypedArrays) return typedArrays;
    hasRequiredTypedArrays = 1;
    (function(exports$1) {
      var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1, MAX_16BIT_INTEGER = Math.pow(2, 16) - 1, MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;
      var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1, MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1, MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
      exports$1.getPointerArray = function(size) {
        var maxIndex = size - 1;
        if (maxIndex <= MAX_8BIT_INTEGER)
          return Uint8Array;
        if (maxIndex <= MAX_16BIT_INTEGER)
          return Uint16Array;
        if (maxIndex <= MAX_32BIT_INTEGER)
          return Uint32Array;
        throw new Error("mnemonist: Pointer Array of size > 4294967295 is not supported.");
      };
      exports$1.getSignedPointerArray = function(size) {
        var maxIndex = size - 1;
        if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
          return Int8Array;
        if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
          return Int16Array;
        if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
          return Int32Array;
        return Float64Array;
      };
      exports$1.getNumberType = function(value) {
        if (value === (value | 0)) {
          if (Math.sign(value) === -1) {
            if (value <= 127 && value >= -128)
              return Int8Array;
            if (value <= 32767 && value >= -32768)
              return Int16Array;
            return Int32Array;
          } else {
            if (value <= 255)
              return Uint8Array;
            if (value <= 65535)
              return Uint16Array;
            return Uint32Array;
          }
        }
        return Float64Array;
      };
      var TYPE_PRIORITY = {
        Uint8Array: 1,
        Int8Array: 2,
        Uint16Array: 3,
        Int16Array: 4,
        Uint32Array: 5,
        Int32Array: 6,
        Float32Array: 7,
        Float64Array: 8
      };
      exports$1.getMinimalRepresentation = function(array, getter) {
        var maxType = null, maxPriority = 0, p, t, v, i, l;
        for (i = 0, l = array.length; i < l; i++) {
          v = getter ? getter(array[i]) : array[i];
          t = exports$1.getNumberType(v);
          p = TYPE_PRIORITY[t.name];
          if (p > maxPriority) {
            maxPriority = p;
            maxType = t;
          }
        }
        return maxType;
      };
      exports$1.isTypedArray = function(value) {
        return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
      };
      exports$1.concat = function() {
        var length = 0, i, o, l;
        for (i = 0, l = arguments.length; i < l; i++)
          length += arguments[i].length;
        var array = new arguments[0].constructor(length);
        for (i = 0, o = 0; i < l; i++) {
          array.set(arguments[i], o);
          o += arguments[i].length;
        }
        return array;
      };
      exports$1.indices = function(length) {
        var PointerArray = exports$1.getPointerArray(length);
        var array = new PointerArray(length);
        for (var i = 0; i < length; i++)
          array[i] = i;
        return array;
      };
    })(typedArrays);
    return typedArrays;
  }
  var hasRequiredIterables;
  function requireIterables() {
    if (hasRequiredIterables) return iterables;
    hasRequiredIterables = 1;
    var forEach = requireForeach();
    var typed = requireTypedArrays();
    function isArrayLike(target) {
      return Array.isArray(target) || typed.isTypedArray(target);
    }
    function guessLength(target) {
      if (typeof target.length === "number")
        return target.length;
      if (typeof target.size === "number")
        return target.size;
      return;
    }
    function toArray2(target) {
      var l = guessLength(target);
      var array = typeof l === "number" ? new Array(l) : [];
      var i = 0;
      forEach(target, function(value) {
        array[i++] = value;
      });
      return array;
    }
    function toArrayWithIndices(target) {
      var l = guessLength(target);
      var IndexArray = typeof l === "number" ? typed.getPointerArray(l) : Array;
      var array = typeof l === "number" ? new Array(l) : [];
      var indices = typeof l === "number" ? new IndexArray(l) : [];
      var i = 0;
      forEach(target, function(value) {
        array[i] = value;
        indices[i] = i++;
      });
      return [array, indices];
    }
    iterables.isArrayLike = isArrayLike;
    iterables.guessLength = guessLength;
    iterables.toArray = toArray2;
    iterables.toArrayWithIndices = toArrayWithIndices;
    return iterables;
  }
  var heap$2;
  var hasRequiredHeap$2;
  function requireHeap$2() {
    if (hasRequiredHeap$2) return heap$2;
    hasRequiredHeap$2 = 1;
    var forEach = requireForeach(), comparators2 = requireComparators(), iterables2 = requireIterables();
    var DEFAULT_COMPARATOR = comparators2.DEFAULT_COMPARATOR, reverseComparator = comparators2.reverseComparator;
    function siftDown(compare, heap2, startIndex, i) {
      var item = heap2[i], parentIndex, parent;
      while (i > startIndex) {
        parentIndex = i - 1 >> 1;
        parent = heap2[parentIndex];
        if (compare(item, parent) < 0) {
          heap2[i] = parent;
          i = parentIndex;
          continue;
        }
        break;
      }
      heap2[i] = item;
    }
    function siftUp(compare, heap2, i) {
      var endIndex = heap2.length, startIndex = i, item = heap2[i], childIndex = 2 * i + 1, rightIndex;
      while (childIndex < endIndex) {
        rightIndex = childIndex + 1;
        if (rightIndex < endIndex && compare(heap2[childIndex], heap2[rightIndex]) >= 0) {
          childIndex = rightIndex;
        }
        heap2[i] = heap2[childIndex];
        i = childIndex;
        childIndex = 2 * i + 1;
      }
      heap2[i] = item;
      siftDown(compare, heap2, startIndex, i);
    }
    function push(compare, heap2, item) {
      heap2.push(item);
      siftDown(compare, heap2, 0, heap2.length - 1);
    }
    function pop(compare, heap2) {
      var lastItem = heap2.pop();
      if (heap2.length !== 0) {
        var item = heap2[0];
        heap2[0] = lastItem;
        siftUp(compare, heap2, 0);
        return item;
      }
      return lastItem;
    }
    function replace(compare, heap2, item) {
      if (heap2.length === 0)
        throw new Error("mnemonist/heap.replace: cannot pop an empty heap.");
      var popped = heap2[0];
      heap2[0] = item;
      siftUp(compare, heap2, 0);
      return popped;
    }
    function pushpop(compare, heap2, item) {
      var tmp;
      if (heap2.length !== 0 && compare(heap2[0], item) < 0) {
        tmp = heap2[0];
        heap2[0] = item;
        item = tmp;
        siftUp(compare, heap2, 0);
      }
      return item;
    }
    function heapify(compare, array) {
      var n = array.length, l = n >> 1, i = l;
      while (--i >= 0)
        siftUp(compare, array, i);
    }
    function consume(compare, heap2) {
      var l = heap2.length, i = 0;
      var array = new Array(l);
      while (i < l)
        array[i++] = pop(compare, heap2);
      return array;
    }
    function nsmallest(compare, n, iterable) {
      if (arguments.length === 2) {
        iterable = n;
        n = compare;
        compare = DEFAULT_COMPARATOR;
      }
      var reverseCompare = reverseComparator(compare);
      var i, l, v;
      var min = Infinity;
      var result2;
      if (n === 1) {
        if (iterables2.isArrayLike(iterable)) {
          for (i = 0, l = iterable.length; i < l; i++) {
            v = iterable[i];
            if (min === Infinity || compare(v, min) < 0)
              min = v;
          }
          result2 = new iterable.constructor(1);
          result2[0] = min;
          return result2;
        }
        forEach(iterable, function(value) {
          if (min === Infinity || compare(value, min) < 0)
            min = value;
        });
        return [min];
      }
      if (iterables2.isArrayLike(iterable)) {
        if (n >= iterable.length)
          return iterable.slice().sort(compare);
        result2 = iterable.slice(0, n);
        heapify(reverseCompare, result2);
        for (i = n, l = iterable.length; i < l; i++)
          if (reverseCompare(iterable[i], result2[0]) > 0)
            replace(reverseCompare, result2, iterable[i]);
        return result2.sort(compare);
      }
      var size = iterables2.guessLength(iterable);
      if (size !== null && size < n)
        n = size;
      result2 = new Array(n);
      i = 0;
      forEach(iterable, function(value) {
        if (i < n) {
          result2[i] = value;
        } else {
          if (i === n)
            heapify(reverseCompare, result2);
          if (reverseCompare(value, result2[0]) > 0)
            replace(reverseCompare, result2, value);
        }
        i++;
      });
      if (result2.length > i)
        result2.length = i;
      return result2.sort(compare);
    }
    function nlargest(compare, n, iterable) {
      if (arguments.length === 2) {
        iterable = n;
        n = compare;
        compare = DEFAULT_COMPARATOR;
      }
      var reverseCompare = reverseComparator(compare);
      var i, l, v;
      var max = -Infinity;
      var result2;
      if (n === 1) {
        if (iterables2.isArrayLike(iterable)) {
          for (i = 0, l = iterable.length; i < l; i++) {
            v = iterable[i];
            if (max === -Infinity || compare(v, max) > 0)
              max = v;
          }
          result2 = new iterable.constructor(1);
          result2[0] = max;
          return result2;
        }
        forEach(iterable, function(value) {
          if (max === -Infinity || compare(value, max) > 0)
            max = value;
        });
        return [max];
      }
      if (iterables2.isArrayLike(iterable)) {
        if (n >= iterable.length)
          return iterable.slice().sort(reverseCompare);
        result2 = iterable.slice(0, n);
        heapify(compare, result2);
        for (i = n, l = iterable.length; i < l; i++)
          if (compare(iterable[i], result2[0]) > 0)
            replace(compare, result2, iterable[i]);
        return result2.sort(reverseCompare);
      }
      var size = iterables2.guessLength(iterable);
      if (size !== null && size < n)
        n = size;
      result2 = new Array(n);
      i = 0;
      forEach(iterable, function(value) {
        if (i < n) {
          result2[i] = value;
        } else {
          if (i === n)
            heapify(compare, result2);
          if (compare(value, result2[0]) > 0)
            replace(compare, result2, value);
        }
        i++;
      });
      if (result2.length > i)
        result2.length = i;
      return result2.sort(reverseCompare);
    }
    function Heap(comparator) {
      this.clear();
      this.comparator = comparator || DEFAULT_COMPARATOR;
      if (typeof this.comparator !== "function")
        throw new Error("mnemonist/Heap.constructor: given comparator should be a function.");
    }
    Heap.prototype.clear = function() {
      this.items = [];
      this.size = 0;
    };
    Heap.prototype.push = function(item) {
      push(this.comparator, this.items, item);
      return ++this.size;
    };
    Heap.prototype.peek = function() {
      return this.items[0];
    };
    Heap.prototype.pop = function() {
      if (this.size !== 0)
        this.size--;
      return pop(this.comparator, this.items);
    };
    Heap.prototype.replace = function(item) {
      return replace(this.comparator, this.items, item);
    };
    Heap.prototype.pushpop = function(item) {
      return pushpop(this.comparator, this.items, item);
    };
    Heap.prototype.consume = function() {
      this.size = 0;
      return consume(this.comparator, this.items);
    };
    Heap.prototype.toArray = function() {
      return consume(this.comparator, this.items.slice());
    };
    Heap.prototype.inspect = function() {
      var proxy = this.toArray();
      Object.defineProperty(proxy, "constructor", {
        value: Heap,
        enumerable: false
      });
      return proxy;
    };
    if (typeof Symbol !== "undefined")
      Heap.prototype[Symbol.for("nodejs.util.inspect.custom")] = Heap.prototype.inspect;
    function MaxHeap(comparator) {
      this.clear();
      this.comparator = comparator || DEFAULT_COMPARATOR;
      if (typeof this.comparator !== "function")
        throw new Error("mnemonist/MaxHeap.constructor: given comparator should be a function.");
      this.comparator = reverseComparator(this.comparator);
    }
    MaxHeap.prototype = Heap.prototype;
    Heap.from = function(iterable, comparator) {
      var heap2 = new Heap(comparator);
      var items;
      if (iterables2.isArrayLike(iterable))
        items = iterable.slice();
      else
        items = iterables2.toArray(iterable);
      heapify(heap2.comparator, items);
      heap2.items = items;
      heap2.size = items.length;
      return heap2;
    };
    MaxHeap.from = function(iterable, comparator) {
      var heap2 = new MaxHeap(comparator);
      var items;
      if (iterables2.isArrayLike(iterable))
        items = iterable.slice();
      else
        items = iterables2.toArray(iterable);
      heapify(heap2.comparator, items);
      heap2.items = items;
      heap2.size = items.length;
      return heap2;
    };
    Heap.siftUp = siftUp;
    Heap.siftDown = siftDown;
    Heap.push = push;
    Heap.pop = pop;
    Heap.replace = replace;
    Heap.pushpop = pushpop;
    Heap.heapify = heapify;
    Heap.consume = consume;
    Heap.nsmallest = nsmallest;
    Heap.nlargest = nlargest;
    Heap.MinHeap = Heap;
    Heap.MaxHeap = MaxHeap;
    heap$2 = Heap;
    return heap$2;
  }
  var hasRequiredDijkstra;
  function requireDijkstra() {
    if (hasRequiredDijkstra) return dijkstra;
    hasRequiredDijkstra = 1;
    var isGraph2 = requireIsGraph();
    var createEdgeWeightGetter = requireGetters().createEdgeWeightGetter;
    var Heap = requireHeap$2();
    var DEFAULT_WEIGHT_ATTRIBUTE = "weight";
    function DIJKSTRA_HEAP_COMPARATOR(a, b) {
      if (a[0] > b[0]) return 1;
      if (a[0] < b[0]) return -1;
      if (a[1] > b[1]) return 1;
      if (a[1] < b[1]) return -1;
      if (a[2] > b[2]) return 1;
      if (a[2] < b[2]) return -1;
      return 0;
    }
    function BRANDES_DIJKSTRA_HEAP_COMPARATOR(a, b) {
      if (a[0] > b[0]) return 1;
      if (a[0] < b[0]) return -1;
      if (a[1] > b[1]) return 1;
      if (a[1] < b[1]) return -1;
      if (a[2] > b[2]) return 1;
      if (a[2] < b[2]) return -1;
      if (a[3] > b[3]) return 1;
      if (a[3] < b[3]) return -1;
      return 0;
    }
    function abstractBidirectionalDijkstra(graph, source, target, getEdgeWeight) {
      source = "" + source;
      target = "" + target;
      if (!isGraph2(graph))
        throw new Error(
          "graphology-shortest-path/dijkstra: invalid graphology instance."
        );
      if (source && !graph.hasNode(source))
        throw new Error(
          'graphology-shortest-path/dijkstra: the "' + source + '" source node does not exist in the given graph.'
        );
      if (target && !graph.hasNode(target))
        throw new Error(
          'graphology-shortest-path/dijkstra: the "' + target + '" target node does not exist in the given graph.'
        );
      getEdgeWeight = createEdgeWeightGetter(
        getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE
      ).fromMinimalEntry;
      if (source === target) return [0, [source]];
      var distances = [{}, {}], paths = [{}, {}], fringe = [
        new Heap(DIJKSTRA_HEAP_COMPARATOR),
        new Heap(DIJKSTRA_HEAP_COMPARATOR)
      ], seen = [{}, {}];
      paths[0][source] = [source];
      paths[1][target] = [target];
      seen[0][source] = 0;
      seen[1][target] = 0;
      var finalPath = [], finalDistance = Infinity;
      var count = 0, dir = 1, item, edges, cost, d, v, u, e, i, l;
      fringe[0].push([0, count++, source]);
      fringe[1].push([0, count++, target]);
      while (fringe[0].size && fringe[1].size) {
        dir = 1 - dir;
        item = fringe[dir].pop();
        d = item[0];
        v = item[2];
        if (v in distances[dir]) continue;
        distances[dir][v] = d;
        if (v in distances[1 - dir]) return [finalDistance, finalPath];
        edges = dir === 1 ? graph.inboundEdges(v) : graph.outboundEdges(v);
        for (i = 0, l = edges.length; i < l; i++) {
          e = edges[i];
          u = graph.opposite(v, e);
          cost = distances[dir][v] + getEdgeWeight(e, graph.getEdgeAttributes(e));
          if (u in distances[dir] && cost < distances[dir][u]) {
            throw Error(
              "graphology-shortest-path/dijkstra: contradictory paths found. Do some of your edges have a negative weight?"
            );
          } else if (!(u in seen[dir]) || cost < seen[dir][u]) {
            seen[dir][u] = cost;
            fringe[dir].push([cost, count++, u]);
            paths[dir][u] = paths[dir][v].concat(u);
            if (u in seen[0] && u in seen[1]) {
              d = seen[0][u] + seen[1][u];
              if (finalPath.length === 0 || finalDistance > d) {
                finalDistance = d;
                finalPath = paths[0][u].concat(paths[1][u].slice(0, -1).reverse());
              }
            }
          }
        }
      }
      return [Infinity, null];
    }
    function abstractDijkstraMultisource(graph, sources, getEdgeWeight, cutoff, target, paths) {
      if (!isGraph2(graph))
        throw new Error(
          "graphology-shortest-path/dijkstra: invalid graphology instance."
        );
      getEdgeWeight = createEdgeWeightGetter(
        getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE
      ).fromMinimalEntry;
      var distances = {}, seen = {}, fringe = new Heap(DIJKSTRA_HEAP_COMPARATOR);
      var count = 0, edges, item, cost, v, u, e, d, i, j, l, m;
      for (i = 0, l = sources.length; i < l; i++) {
        v = sources[i];
        seen[v] = 0;
        fringe.push([0, count++, v]);
        if (paths) paths[v] = [v];
      }
      while (fringe.size) {
        item = fringe.pop();
        d = item[0];
        v = item[2];
        if (v in distances) continue;
        distances[v] = d;
        if (v === target) break;
        edges = graph.outboundEdges(v);
        for (j = 0, m = edges.length; j < m; j++) {
          e = edges[j];
          u = graph.opposite(v, e);
          cost = getEdgeWeight(e, graph.getEdgeAttributes(e)) + distances[v];
          if (u in distances && cost < distances[u]) {
            throw Error(
              "graphology-shortest-path/dijkstra: contradictory paths found. Do some of your edges have a negative weight?"
            );
          } else if (!(u in seen) || cost < seen[u]) {
            seen[u] = cost;
            fringe.push([cost, count++, u]);
            if (paths) paths[u] = paths[v].concat(u);
          }
        }
      }
      return distances;
    }
    function singleSourceDijkstra(graph, source, getEdgeWeight) {
      var paths = {};
      abstractDijkstraMultisource(graph, [source], getEdgeWeight, 0, null, paths);
      return paths;
    }
    function bidirectionalDijkstra(graph, source, target, getEdgeWeight) {
      return abstractBidirectionalDijkstra(graph, source, target, getEdgeWeight)[1];
    }
    function brandes(graph, source, getEdgeWeight) {
      source = "" + source;
      getEdgeWeight = createEdgeWeightGetter(
        getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE
      ).fromMinimalEntry;
      var S = [], P = {}, sigma = {};
      var nodes = graph.nodes(), edges, item, pred, dist, cost, v, w, e, i, l;
      for (i = 0, l = nodes.length; i < l; i++) {
        v = nodes[i];
        P[v] = [];
        sigma[v] = 0;
      }
      var D = {};
      sigma[source] = 1;
      var seen = {};
      seen[source] = 0;
      var count = 0;
      var Q = new Heap(BRANDES_DIJKSTRA_HEAP_COMPARATOR);
      Q.push([0, count++, source, source]);
      while (Q.size) {
        item = Q.pop();
        dist = item[0];
        pred = item[2];
        v = item[3];
        if (v in D) continue;
        sigma[v] += sigma[pred];
        S.push(v);
        D[v] = dist;
        edges = graph.outboundEdges(v);
        for (i = 0, l = edges.length; i < l; i++) {
          e = edges[i];
          w = graph.opposite(v, e);
          cost = dist + getEdgeWeight(e, graph.getEdgeAttributes(e));
          if (!(w in D) && (!(w in seen) || cost < seen[w])) {
            seen[w] = cost;
            Q.push([cost, count++, v, w]);
            sigma[w] = 0;
            P[w] = [v];
          } else if (cost === seen[w]) {
            sigma[w] += sigma[v];
            P[w].push(v);
          }
        }
      }
      return [S, P, sigma];
    }
    dijkstra.bidirectional = bidirectionalDijkstra;
    dijkstra.singleSource = singleSourceDijkstra;
    dijkstra.brandes = brandes;
    return dijkstra;
  }
  var astar = {};
  var hasRequiredAstar;
  function requireAstar() {
    if (hasRequiredAstar) return astar;
    hasRequiredAstar = 1;
    var isGraph2 = requireIsGraph();
    var createEdgeWeightGetter = requireGetters().createEdgeWeightGetter;
    var Heap = requireHeap$2();
    var DEFAULT_WEIGHT_ATTRIBUTE = "weight";
    function ASTAR_HEAP_COMPARATOR(a, b) {
      if (a[0] > b[0]) return 1;
      if (a[0] < b[0]) return -1;
      if (a[1] > b[1]) return 1;
      if (a[1] < b[1]) return -1;
      return 0;
    }
    function bidirectionalAstar(graph, source, target, getEdgeWeight, heuristic, options) {
      if (!isGraph2(graph))
        throw new Error(
          "graphology-shortest-path/astar: invalid graphology instance."
        );
      if (source && !graph.hasNode(source))
        throw new Error(
          'graphology-shortest-path/astar: the "' + source + '" source node does not exist in the given graph.'
        );
      if (target && !graph.hasNode(target))
        throw new Error(
          'graphology-shortest-path/astar: the "' + target + '" target node does not exist in the given graph.'
        );
      getEdgeWeight = createEdgeWeightGetter(
        getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE
      ).fromMinimalEntry;
      if (source === target) return [source];
      heuristic = heuristic || function() {
        return 0;
      };
      options = options || {};
      var count = 0;
      var queue2 = new Heap(ASTAR_HEAP_COMPARATOR);
      queue2.push([0, count++, source, 0, null]);
      var enqueued = {};
      var explored = {};
      var item;
      var curnode;
      var entry;
      var dist;
      var parent;
      var path;
      var node;
      var qcost;
      var h;
      var cost;
      var ncost;
      var neighbor;
      function edgeCallback(edge, attr, s, t) {
        neighbor = curnode === s ? t : s;
        cost = getEdgeWeight(edge, attr);
        if (cost === null) return;
        ncost = dist + cost;
        if (enqueued.hasOwnProperty(neighbor)) {
          entry = enqueued[neighbor];
          qcost = entry[0];
          h = entry[1];
          if (qcost <= ncost) return;
        } else {
          h = heuristic(neighbor, target);
        }
        if (options.cutoff && ncost + h > options.cutoff) return;
        enqueued[neighbor] = [ncost, h];
        queue2.push([ncost + h, count++, neighbor, ncost, curnode]);
      }
      while (queue2.size !== 0) {
        item = queue2.pop();
        curnode = item[2];
        dist = item[3];
        parent = item[4];
        if (curnode === target) {
          path = [curnode];
          node = parent;
          while (node !== null) {
            path.push(node);
            node = explored[node];
          }
          path.reverse();
          return path;
        }
        if (explored.hasOwnProperty(curnode)) {
          if (explored[curnode] === null) continue;
          qcost = enqueued[curnode][0];
          if (qcost < dist) continue;
        }
        explored[curnode] = parent;
        graph.forEachOutboundEdge(curnode, edgeCallback);
      }
      return null;
    }
    astar.bidirectional = bidirectionalAstar;
    return astar;
  }
  var hasRequiredGraphologyShortestPath;
  function requireGraphologyShortestPath() {
    if (hasRequiredGraphologyShortestPath) return graphologyShortestPath;
    hasRequiredGraphologyShortestPath = 1;
    var unweighted2 = requireUnweighted();
    var utils2 = requireUtils();
    graphologyShortestPath.unweighted = unweighted2;
    graphologyShortestPath.dijkstra = requireDijkstra();
    graphologyShortestPath.astar = requireAstar();
    graphologyShortestPath.bidirectional = unweighted2.bidirectional;
    graphologyShortestPath.singleSource = unweighted2.singleSource;
    graphologyShortestPath.singleSourceLength = unweighted2.singleSourceLength;
    graphologyShortestPath.undirectedSingleSourceLength = unweighted2.undirectedSingleSourceLength;
    graphologyShortestPath.brandes = unweighted2.brandes;
    graphologyShortestPath.edgePathFromNodePath = utils2.edgePathFromNodePath;
    return graphologyShortestPath;
  }
  var graphologyShortestPathExports = requireGraphologyShortestPath();
  function findShortestPath(graph, sourceId, targetId) {
    try {
      const path = graphologyShortestPathExports.bidirectional(graph, sourceId, targetId);
      return path;
    } catch (error) {
      console.error("Shortest path error:", error);
      return null;
    }
  }
  content;
  var minPriorityQueue = {};
  var priorityQueue$1 = {};
  var heap$1 = {};
  var heap = {};
  /**
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   *
   * @class
   */
  var hasRequiredHeap$1;
  function requireHeap$1() {
    if (hasRequiredHeap$1) return heap;
    hasRequiredHeap$1 = 1;
    class Heap {
      /**
       * @param {function} compare
       * @param {array} [values]
       * @param {number|string|object} [_leaf]
       */
      constructor(compare, values, _leaf) {
        if (typeof compare !== "function") {
          throw new Error("Heap constructor expects a compare function");
        }
        this._compare = compare;
        this._nodes = Array.isArray(values) ? values : [];
        this._leaf = _leaf || null;
        if (this._nodes.length > 0) {
          this.fix();
        }
      }
      /**
       * Converts the heap to a cloned array without sorting.
       * @public
       * @returns {Array}
       */
      toArray() {
        return Array.from(this._nodes);
      }
      /**
       * Checks if a parent has a left child
       * @private
       */
      _hasLeftChild(parentIndex) {
        const leftChildIndex = parentIndex * 2 + 1;
        return leftChildIndex < this.size();
      }
      /**
       * Checks if a parent has a right child
       * @private
       */
      _hasRightChild(parentIndex) {
        const rightChildIndex = parentIndex * 2 + 2;
        return rightChildIndex < this.size();
      }
      /**
       * Compares two nodes
       * @private
       */
      _compareAt(i, j) {
        return this._compare(this._nodes[i], this._nodes[j]);
      }
      /**
       * Swaps two nodes in the heap
       * @private
       */
      _swap(i, j) {
        const temp = this._nodes[i];
        this._nodes[i] = this._nodes[j];
        this._nodes[j] = temp;
      }
      /**
       * Checks if parent and child should be swapped
       * @private
       */
      _shouldSwap(parentIndex, childIndex) {
        if (parentIndex < 0 || parentIndex >= this.size()) {
          return false;
        }
        if (childIndex < 0 || childIndex >= this.size()) {
          return false;
        }
        return this._compareAt(parentIndex, childIndex) > 0;
      }
      /**
       * Compares children of a parent
       * @private
       */
      _compareChildrenOf(parentIndex) {
        if (!this._hasLeftChild(parentIndex) && !this._hasRightChild(parentIndex)) {
          return -1;
        }
        const leftChildIndex = parentIndex * 2 + 1;
        const rightChildIndex = parentIndex * 2 + 2;
        if (!this._hasLeftChild(parentIndex)) {
          return rightChildIndex;
        }
        if (!this._hasRightChild(parentIndex)) {
          return leftChildIndex;
        }
        const compare = this._compareAt(leftChildIndex, rightChildIndex);
        return compare > 0 ? rightChildIndex : leftChildIndex;
      }
      /**
       * Compares two children before a position
       * @private
       */
      _compareChildrenBefore(index2, leftChildIndex, rightChildIndex) {
        const compare = this._compareAt(rightChildIndex, leftChildIndex);
        if (compare <= 0 && rightChildIndex < index2) {
          return rightChildIndex;
        }
        return leftChildIndex;
      }
      /**
       * Recursively bubbles up a node if it's in a wrong position
       * @private
       */
      _heapifyUp(startIndex) {
        let childIndex = startIndex;
        let parentIndex = Math.floor((childIndex - 1) / 2);
        while (this._shouldSwap(parentIndex, childIndex)) {
          this._swap(parentIndex, childIndex);
          childIndex = parentIndex;
          parentIndex = Math.floor((childIndex - 1) / 2);
        }
      }
      /**
       * Recursively bubbles down a node if it's in a wrong position
       * @private
       */
      _heapifyDown(startIndex) {
        let parentIndex = startIndex;
        let childIndex = this._compareChildrenOf(parentIndex);
        while (this._shouldSwap(parentIndex, childIndex)) {
          this._swap(parentIndex, childIndex);
          parentIndex = childIndex;
          childIndex = this._compareChildrenOf(parentIndex);
        }
      }
      /**
       * Recursively bubbles down a node before a given index
       * @private
       */
      _heapifyDownUntil(index2) {
        let parentIndex = 0;
        let leftChildIndex = 1;
        let rightChildIndex = 2;
        let childIndex;
        while (leftChildIndex < index2) {
          childIndex = this._compareChildrenBefore(
            index2,
            leftChildIndex,
            rightChildIndex
          );
          if (this._shouldSwap(parentIndex, childIndex)) {
            this._swap(parentIndex, childIndex);
          }
          parentIndex = childIndex;
          leftChildIndex = parentIndex * 2 + 1;
          rightChildIndex = parentIndex * 2 + 2;
        }
      }
      /**
       * Inserts a new value into the heap
       * @public
       * @param {number|string|object} value
       * @returns {Heap}
       */
      insert(value) {
        this._nodes.push(value);
        this._heapifyUp(this.size() - 1);
        if (this._leaf === null || this._compare(value, this._leaf) > 0) {
          this._leaf = value;
        }
        return this;
      }
      /**
       * Inserts a new value into the heap
       * @public
       * @param {number|string|object} value
       * @returns {Heap}
       */
      push(value) {
        return this.insert(value);
      }
      /**
       * Removes and returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      extractRoot() {
        if (this.isEmpty()) {
          return null;
        }
        const root = this.root();
        this._nodes[0] = this._nodes[this.size() - 1];
        this._nodes.pop();
        this._heapifyDown(0);
        if (root === this._leaf) {
          this._leaf = null;
        }
        return root;
      }
      /**
       * Removes and returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      pop() {
        return this.extractRoot();
      }
      /**
       * Applies heap sort and return the values sorted by priority
       * @public
       * @returns {array}
       */
      sort() {
        for (let i = this.size() - 1; i > 0; i -= 1) {
          this._swap(0, i);
          this._heapifyDownUntil(i);
        }
        return this._nodes;
      }
      /**
       * Fixes node positions in the heap
       * @public
       * @returns {Heap}
       */
      fix() {
        for (let i = Math.floor(this.size() / 2) - 1; i >= 0; i -= 1) {
          this._heapifyDown(i);
        }
        for (let i = Math.floor(this.size() / 2); i < this.size(); i += 1) {
          const value = this._nodes[i];
          if (this._leaf === null || this._compare(value, this._leaf) > 0) {
            this._leaf = value;
          }
        }
        return this;
      }
      /**
       * Verifies that all heap nodes are in the right position
       * @public
       * @returns {boolean}
       */
      isValid() {
        const isValidRecursive = (parentIndex) => {
          let isValidLeft = true;
          let isValidRight = true;
          if (this._hasLeftChild(parentIndex)) {
            const leftChildIndex = parentIndex * 2 + 1;
            if (this._compareAt(parentIndex, leftChildIndex) > 0) {
              return false;
            }
            isValidLeft = isValidRecursive(leftChildIndex);
          }
          if (this._hasRightChild(parentIndex)) {
            const rightChildIndex = parentIndex * 2 + 2;
            if (this._compareAt(parentIndex, rightChildIndex) > 0) {
              return false;
            }
            isValidRight = isValidRecursive(rightChildIndex);
          }
          return isValidLeft && isValidRight;
        };
        return isValidRecursive(0);
      }
      /**
       * Returns a shallow copy of the heap
       * @public
       * @returns {Heap}
       */
      clone() {
        return new Heap(this._compare, this._nodes.slice(), this._leaf);
      }
      /**
       * Returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      root() {
        if (this.isEmpty()) {
          return null;
        }
        return this._nodes[0];
      }
      /**
       * Returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      top() {
        return this.root();
      }
      /**
       * Returns a leaf node in the heap
       * @public
       * @returns {number|string|object}
       */
      leaf() {
        return this._leaf;
      }
      /**
       * Returns the number of nodes in the heap
       * @public
       * @returns {number}
       */
      size() {
        return this._nodes.length;
      }
      /**
       * Checks if the heap is empty
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this.size() === 0;
      }
      /**
       * Clears the heap
       * @public
       */
      clear() {
        this._nodes = [];
        this._leaf = null;
      }
      /**
       * Implements an iterable on the heap
       * @public
       */
      [Symbol.iterator]() {
        let size = this.size();
        return {
          next: () => {
            size -= 1;
            return {
              value: this.pop(),
              done: size === -1
            };
          }
        };
      }
      /**
       * Builds a heap from a array of values
       * @public
       * @static
       * @param {array} values
       * @param {function} compare
       * @returns {Heap}
       */
      static heapify(values, compare) {
        if (!Array.isArray(values)) {
          throw new Error("Heap.heapify expects an array of values");
        }
        if (typeof compare !== "function") {
          throw new Error("Heap.heapify expects a compare function");
        }
        return new Heap(compare, values).fix();
      }
      /**
       * Checks if a list of values is a valid heap
       * @public
       * @static
       * @param {array} values
       * @param {function} compare
       * @returns {boolean}
       */
      static isHeapified(values, compare) {
        return new Heap(compare, values).isValid();
      }
    }
    heap.Heap = Heap;
    return heap;
  }
  var minHeap = {};
  /**
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   */
  var hasRequiredMinHeap;
  function requireMinHeap() {
    if (hasRequiredMinHeap) return minHeap;
    hasRequiredMinHeap = 1;
    const { Heap } = requireHeap$1();
    const getMinCompare = (getCompareValue) => (a, b) => {
      const aVal = typeof getCompareValue === "function" ? getCompareValue(a) : a;
      const bVal = typeof getCompareValue === "function" ? getCompareValue(b) : b;
      return aVal <= bVal ? -1 : 1;
    };
    class MinHeap extends Heap {
      /**
       * @param {function} [getCompareValue]
       * @param {array} [values]
       */
      constructor(getCompareValue, values) {
        super(getMinCompare(getCompareValue), values);
        this._getCompareValue = getCompareValue;
      }
      /**
       * Inserts a new value into the heap
       * @public
       * @param {number|string|object} value
       * @returns {MinHeap}
       */
      insert(value) {
        super.insert(value);
        return this;
      }
      /**
       * Inserts a new value into the heap
       * @public
       * @param {number|string|object} value
       * @returns {MinHeap}
       */
      push(value) {
        return this.insert(value);
      }
      /**
       * Fixes node positions in the heap
       * @public
       * @returns {MinHeap}
       */
      fix() {
        super.fix();
        return this;
      }
      /**
       * Returns a shallow copy of the MinHeap
       * @public
       * @returns {MinHeap}
       */
      clone() {
        return new MinHeap(this._getCompareValue, this._nodes.slice());
      }
      /**
       * Builds a MinHeap from an array
       * @public
       * @static
       * @param {array} values
       * @param {function} [getCompareValue]
       * @returns {MinHeap}
       */
      static heapify(values, getCompareValue) {
        if (!Array.isArray(values)) {
          throw new Error("MinHeap.heapify expects an array");
        }
        return new MinHeap(getCompareValue, values);
      }
      /**
       * Checks if a list of values is a valid min heap
       * @public
       * @static
       * @param {array} values
       * @param {function} [getCompareValue]
       * @returns {boolean}
       */
      static isHeapified(values, getCompareValue) {
        return new MinHeap(getCompareValue, values).isValid();
      }
    }
    minHeap.MinHeap = MinHeap;
    return minHeap;
  }
  var maxHeap = {};
  /**
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   */
  var hasRequiredMaxHeap;
  function requireMaxHeap() {
    if (hasRequiredMaxHeap) return maxHeap;
    hasRequiredMaxHeap = 1;
    const { Heap } = requireHeap$1();
    const getMaxCompare = (getCompareValue) => (a, b) => {
      const aVal = typeof getCompareValue === "function" ? getCompareValue(a) : a;
      const bVal = typeof getCompareValue === "function" ? getCompareValue(b) : b;
      return aVal < bVal ? 1 : -1;
    };
    class MaxHeap extends Heap {
      /**
       * @param {function} [getCompareValue]
       * @param {array} [values]
       */
      constructor(getCompareValue, values) {
        super(getMaxCompare(getCompareValue), values);
        this._getCompareValue = getCompareValue;
      }
      /**
       * Inserts a new value into the heap
       * @public
       * @param {number|string|object} value
       * @returns {MaxHeap}
       */
      insert(value) {
        super.insert(value);
        return this;
      }
      /**
       * Inserts a new value into the heap
       * @public
       * @param {number|string|object} value
       * @returns {MaxHeap}
       */
      push(value) {
        return this.insert(value);
      }
      /**
       * Fixes node positions in the heap
       * @public
       * @returns {MaxHeap}
       */
      fix() {
        super.fix();
        return this;
      }
      /**
       * Returns a shallow copy of the MaxHeap
       * @public
       * @returns {MaxHeap}
       */
      clone() {
        return new MaxHeap(this._getCompareValue, this._nodes.slice());
      }
      /**
       * Builds a MaxHeap from an array
       * @public
       * @static
       * @param {array} values
       * @param {function} [getCompareValue]
       * @returns {MaxHeap}
       */
      static heapify(values, getCompareValue) {
        if (!Array.isArray(values)) {
          throw new Error("MaxHeap.heapify expects an array");
        }
        return new MaxHeap(getCompareValue, values);
      }
      /**
       * Checks if a list of values is a valid max heap
       * @public
       * @static
       * @param {array} values
       * @param {function} [getCompareValue]
       * @returns {boolean}
       */
      static isHeapified(values, getCompareValue) {
        return new MaxHeap(getCompareValue, values).isValid();
      }
    }
    maxHeap.MaxHeap = MaxHeap;
    return maxHeap;
  }
  var hasRequiredHeap;
  function requireHeap() {
    if (hasRequiredHeap) return heap$1;
    hasRequiredHeap = 1;
    const { Heap } = requireHeap$1();
    const { MinHeap } = requireMinHeap();
    const { MaxHeap } = requireMaxHeap();
    heap$1.Heap = Heap;
    heap$1.MinHeap = MinHeap;
    heap$1.MaxHeap = MaxHeap;
    return heap$1;
  }
  /**
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   */
  var hasRequiredPriorityQueue$1;
  function requirePriorityQueue$1() {
    if (hasRequiredPriorityQueue$1) return priorityQueue$1;
    hasRequiredPriorityQueue$1 = 1;
    const { Heap } = requireHeap();
    class PriorityQueue {
      /**
       * Creates a priority queue
       * @params {function} compare
       * @params {array} [values]
       */
      constructor(compare, values) {
        if (typeof compare !== "function") {
          throw new Error("PriorityQueue constructor expects a compare function");
        }
        this._heap = new Heap(compare, values);
      }
      /**
       * Returns an element with highest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      front() {
        return this._heap.root();
      }
      /**
       * Returns an element with lowest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      back() {
        return this._heap.leaf();
      }
      /**
       * Adds a value to the queue
       * @public
       * @param {number|string|object} value
       * @returns {PriorityQueue}
       */
      enqueue(value) {
        this._heap.insert(value);
        return this;
      }
      /**
       * Adds a value to the queue
       * @public
       * @param {number|string|object} value
       * @returns {PriorityQueue}
       */
      push(value) {
        return this.enqueue(value);
      }
      /**
       * Removes and returns an element with highest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      dequeue() {
        return this._heap.extractRoot();
      }
      /**
       * Removes and returns an element with highest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      pop() {
        return this.dequeue();
      }
      /**
       * Removes all elements that match a criteria in the callback
       * @public
       * @param {function} cb
       * @returns {array}
       */
      remove(cb) {
        if (typeof cb !== "function") {
          throw new Error("PriorityQueue remove expects a callback");
        }
        const removed = [];
        const dequeued = [];
        while (!this.isEmpty()) {
          const popped = this.pop();
          if (cb(popped)) {
            removed.push(popped);
          } else {
            dequeued.push(popped);
          }
        }
        dequeued.forEach((val) => this.push(val));
        return removed;
      }
      /**
       * Checks if the queue contains an element that matches a criteria
       * @public
       * @param {function} cb
       * @returns {boolean}
       */
      contains(cb) {
        if (typeof cb !== "function") {
          throw new Error("PriorityQueue contains expects a callback");
        }
        let found = false;
        const dequeued = [];
        while (!this.isEmpty()) {
          const popped = this.pop();
          dequeued.push(popped);
          if (cb(popped)) {
            found = true;
            break;
          }
        }
        dequeued.forEach((val) => this.push(val));
        return found;
      }
      /**
       * Returns the number of elements in the queue
       * @public
       * @returns {number}
       */
      size() {
        return this._heap.size();
      }
      /**
       * Checks if the queue is empty
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this._heap.isEmpty();
      }
      /**
       * Clears the queue
       * @public
       */
      clear() {
        this._heap.clear();
      }
      /**
       * Returns a sorted list of elements from highest to lowest priority
       * @public
       * @returns {array}
       */
      toArray() {
        return this._heap.clone().sort().reverse();
      }
      /**
       * Implements an iterable on the priority queue
       * @public
       */
      [Symbol.iterator]() {
        let size = this.size();
        return {
          next: () => {
            size -= 1;
            return {
              value: this.pop(),
              done: size === -1
            };
          }
        };
      }
    }
    PriorityQueue.fromArray = function fromArray(values, compare) {
      return new PriorityQueue(compare, values);
    };
    priorityQueue$1.PriorityQueue = PriorityQueue;
    return priorityQueue$1;
  }
  /**
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   */
  var hasRequiredMinPriorityQueue;
  function requireMinPriorityQueue() {
    if (hasRequiredMinPriorityQueue) return minPriorityQueue;
    hasRequiredMinPriorityQueue = 1;
    const { PriorityQueue } = requirePriorityQueue$1();
    class MinPriorityQueue extends PriorityQueue {
      constructor(options, values) {
        if (options && typeof options === "object" && typeof options.compare === "function") {
          const compareFunction = (a, b) => options.compare(a, b) <= 0 ? -1 : 1;
          super(compareFunction, values);
        } else {
          const getCompareValue = options;
          if (getCompareValue && typeof getCompareValue !== "function") {
            throw new Error("MinPriorityQueue constructor requires a callback for object values");
          }
          const compare = (a, b) => {
            const aVal = typeof getCompareValue === "function" ? getCompareValue(a) : a;
            const bVal = typeof getCompareValue === "function" ? getCompareValue(b) : b;
            return aVal <= bVal ? -1 : 1;
          };
          super(compare, values);
        }
      }
      /**
       * Adds a value to the queue
       * @public
       * @param {number|string|object} value
       * @returns {MinPriorityQueue}
       */
      enqueue(value) {
        super.enqueue(value);
        return this;
      }
      /**
       * Adds a value to the queue
       * @public
       * @param {number|string|object} value
       * @returns {MinPriorityQueue}
       */
      push(value) {
        return this.enqueue(value);
      }
    }
    MinPriorityQueue.fromArray = function fromArray(values, options) {
      return new MinPriorityQueue(options, values);
    };
    minPriorityQueue.MinPriorityQueue = MinPriorityQueue;
    return minPriorityQueue;
  }
  var maxPriorityQueue = {};
  /**
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   */
  var hasRequiredMaxPriorityQueue;
  function requireMaxPriorityQueue() {
    if (hasRequiredMaxPriorityQueue) return maxPriorityQueue;
    hasRequiredMaxPriorityQueue = 1;
    const { PriorityQueue } = requirePriorityQueue$1();
    class MaxPriorityQueue extends PriorityQueue {
      constructor(options, values) {
        if (options && typeof options === "object" && typeof options.compare === "function") {
          const compareFunction = (a, b) => options.compare(a, b) <= 0 ? -1 : 1;
          super(compareFunction, values);
        } else {
          const getCompareValue = options;
          if (getCompareValue && typeof getCompareValue !== "function") {
            throw new Error("MaxPriorityQueue constructor requires a callback for object values");
          }
          const compare = (a, b) => {
            const aVal = typeof getCompareValue === "function" ? getCompareValue(a) : a;
            const bVal = typeof getCompareValue === "function" ? getCompareValue(b) : b;
            return aVal < bVal ? 1 : -1;
          };
          super(compare, values);
        }
      }
      /**
       * Adds a value to the queue
       * @public
       * @param {number|string|object} value
       * @returns {MaxPriorityQueue}
       */
      enqueue(value) {
        super.enqueue(value);
        return this;
      }
      /**
       * Adds a value to the queue
       * @public
       * @param {number|string|object} value
       * @returns {MaxPriorityQueue}
       */
      push(value) {
        return this.enqueue(value);
      }
    }
    MaxPriorityQueue.fromArray = function fromArray(values, options) {
      return new MaxPriorityQueue(options, values);
    };
    maxPriorityQueue.MaxPriorityQueue = MaxPriorityQueue;
    return maxPriorityQueue;
  }
  var priorityQueue;
  var hasRequiredPriorityQueue;
  function requirePriorityQueue() {
    if (hasRequiredPriorityQueue) return priorityQueue;
    hasRequiredPriorityQueue = 1;
    const { MinPriorityQueue } = requireMinPriorityQueue();
    const { MaxPriorityQueue } = requireMaxPriorityQueue();
    const { PriorityQueue } = requirePriorityQueue$1();
    priorityQueue = { MinPriorityQueue, MaxPriorityQueue, PriorityQueue };
    return priorityQueue;
  }
  var priorityQueueExports = requirePriorityQueue();
  function calculateSuccessProbability(edges) {
    if (edges.length === 0) return 100;
    const hopCount = edges.length;
    switch (hopCount) {
      case 1:
        return 85;
      // Direct connection
      case 2:
        return 65;
      // One mutual
      case 3:
        return 45;
      // Two mutuals
      default: {
        console.warn(`[Uproot] Unexpected path length: ${hopCount} hops (maxHops should be 3)`);
        const avgWeight = edges.reduce((sum, e) => sum + e.weight, 0) / edges.length;
        const weightBasedProb = 100 - avgWeight * 80;
        return Math.max(20, Math.min(30, weightBasedProb));
      }
    }
  }
  function findWeightedPath(graph, sourceId, targetId, maxHops = 3) {
    try {
      const distances = /* @__PURE__ */ new Map();
      const previous = /* @__PURE__ */ new Map();
      const visited = /* @__PURE__ */ new Set();
      const hopCounts = /* @__PURE__ */ new Map();
      graph.forEachNode((node) => {
        distances.set(node, Infinity);
        hopCounts.set(node, Infinity);
      });
      distances.set(sourceId, 0);
      hopCounts.set(sourceId, 0);
      const queue2 = new priorityQueueExports.MinPriorityQueue(
        (item) => item.distance
      );
      queue2.enqueue({ node: sourceId, distance: 0 });
      while (queue2.size() > 0) {
        const current2 = queue2.dequeue();
        if (!current2) break;
        const currentNode = current2.node;
        if (visited.has(currentNode)) continue;
        visited.add(currentNode);
        if (currentNode === targetId) break;
        const currentHops = hopCounts.get(currentNode) ?? 0;
        if (currentHops >= maxHops) continue;
        graph.forEachOutNeighbor(currentNode, (neighbor) => {
          if (visited.has(neighbor)) return;
          const edge = graph.getEdgeAttributes(currentNode, neighbor);
          const weight = edge.weight || 1;
          const currentDistance = distances.get(currentNode) ?? Infinity;
          const neighborDistance = distances.get(neighbor) ?? Infinity;
          const newDistance = currentDistance + weight;
          const newHops = currentHops + 1;
          if (newHops <= maxHops && newDistance < neighborDistance) {
            distances.set(neighbor, newDistance);
            hopCounts.set(neighbor, newHops);
            previous.set(neighbor, currentNode);
            queue2.enqueue({ node: neighbor, distance: newDistance });
          }
        });
      }
      if (!previous.has(targetId)) {
        return null;
      }
      const path = [];
      let current = targetId;
      while (current !== sourceId) {
        path.unshift(current);
        current = previous.get(current);
      }
      path.unshift(sourceId);
      const nodes = path.map(
        (id) => graph.getNodeAttributes(id)
      );
      const edges = [];
      for (let i = 0; i < path.length - 1; i++) {
        edges.push(
          graph.getEdgeAttributes(path[i], path[i + 1])
        );
      }
      const totalWeight = distances.get(targetId) || 0;
      const successProbability = calculateSuccessProbability(edges);
      return {
        targetId,
        nodes,
        edges,
        totalWeight,
        successProbability,
        computedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      console.error("Dijkstra error:", error);
      return null;
    }
  }
  content;
  content;
  content;
  class NetworkGraph {
    constructor() {
      __publicField(this, "graph");
      this.graph = new Graph({ type: "directed" });
    }
    /**
     * Add a node to the graph
     */
    addNode(node) {
      if (!this.graph.hasNode(node.id)) {
        this.graph.addNode(node.id, node);
      } else {
        this.graph.replaceNodeAttributes(node.id, node);
      }
    }
    /**
     * Add an edge to the graph
     */
    addEdge(edge) {
      if (!this.graph.hasEdge(edge.from, edge.to)) {
        this.graph.addEdge(edge.from, edge.to, edge);
      }
    }
    /**
     * Find shortest path using bidirectional BFS
     */
    findShortestPath(sourceId, targetId) {
      return findShortestPath(this.graph, sourceId, targetId);
    }
    /**
     * Find weighted shortest path using Dijkstra's algorithm
     */
    findWeightedPath(sourceId, targetId) {
      return findWeightedPath(this.graph, sourceId, targetId);
    }
    /**
     * Get all nodes
     */
    getAllNodes() {
      const nodes = [];
      this.graph.forEachNode((_, attrs) => {
        nodes.push(attrs);
      });
      return nodes;
    }
    /**
     * Export graph for storage
     */
    export() {
      const nodes = [];
      const edges = [];
      this.graph.forEachNode((_, attrs) => {
        nodes.push(attrs);
      });
      this.graph.forEachEdge((_, attrs) => {
        edges.push(attrs);
      });
      return { nodes, edges };
    }
    /**
     * Import graph from storage
     */
    import(data) {
      this.graph.clear();
      data.nodes.forEach((node) => this.addNode(node));
      data.edges.forEach((edge) => this.addEdge(edge));
    }
    /**
     * Get all connections for a user
     * Required by universal pathfinder for intermediary matching
     */
    getConnections(userId) {
      const connections = [];
      try {
        this.graph.forEachOutNeighbor(userId, (neighborId) => {
          const node = this.graph.getNodeAttributes(neighborId);
          if (node) {
            connections.push(node);
          }
        });
      } catch (error) {
        console.error(`Error getting connections for ${userId}:`, error);
      }
      return connections;
    }
    /**
     * Get mutual connections between two users
     * Used by universal pathfinder to calculate connection strength
     */
    getMutualConnections(userId1, userId2) {
      const connections1 = new Set(
        this.getConnections(userId1).map((n) => n.id)
      );
      const connections2 = this.getConnections(userId2);
      return connections2.filter((n) => connections1.has(n.id));
    }
    /**
     * Bidirectional BFS adapter for universal pathfinder compatibility
     * Returns format expected by universal-pathfinder.ts
     */
    async bidirectionalBFS(sourceId, targetId) {
      const route = this.findWeightedPath(sourceId, targetId);
      if (!route) return null;
      const mutuals = this.getMutualConnections(sourceId, targetId);
      return {
        path: route.nodes,
        probability: route.successProbability / 100,
        // Convert percentage to 0-1
        mutualConnections: mutuals.length
      };
    }
    /**
     * Get a single node by ID
     */
    getNode(nodeId) {
      try {
        if (!this.graph.hasNode(nodeId)) return null;
        return this.graph.getNodeAttributes(nodeId);
      } catch (error) {
        console.error(`Error getting node ${nodeId}:`, error);
        return null;
      }
    }
  }
  content;
  content;
  function scrapeCompanyJobs(companyUrl) {
    if (typeof document === "undefined") {
      console.warn("[Uproot] scrapeCompanyJobs() cannot be called in service worker context");
      return [];
    }
    const jobs = [];
    try {
      const jobCards = document.querySelectorAll(".jobs-search__results-list li, .scaffold-layout__list-item");
      jobCards.forEach((card, _index) => {
        try {
          const job = extractJobFromCard(card, companyUrl);
          if (job) {
            jobs.push(job);
          }
        } catch (error) {
          console.error("[Uproot] Error extracting job from card:", error instanceof Error ? error.message : String(error), error);
        }
      });
      console.log(`[Uproot] Scraped ${jobs.length} jobs from company page`);
    } catch (error) {
      console.error("[Uproot] Error scraping company jobs:", error instanceof Error ? error.message : String(error), error);
    }
    return jobs;
  }
  function extractJobFromCard(card, companyUrl) {
    try {
      const titleLink = card.querySelector("a.job-card-list__title, a.job-card-container__link");
      if (!titleLink) return null;
      const title = titleLink.textContent?.trim() || "";
      const jobUrl = titleLink.href;
      const jobId = extractJobIdFromUrl(jobUrl);
      const companyElement = card.querySelector(".job-card-container__company-name, .artdeco-entity-lockup__subtitle");
      const company = companyElement?.textContent?.trim() || "";
      const locationElement = card.querySelector(".job-card-container__metadata-item, .artdeco-entity-lockup__caption");
      const location2 = locationElement?.textContent?.trim() || "";
      const postedElement = card.querySelector("time");
      const postedDate = postedElement?.textContent?.trim() || "";
      const postedTimestamp = estimateTimestamp(postedDate);
      const isEasyApply = card.querySelector(".job-card-container__apply-method")?.textContent?.includes("Easy Apply") || false;
      const applicantElement = card.querySelector(".job-card-container__footer-item");
      const applicantCount = applicantElement?.textContent?.trim();
      const workLocation = inferWorkLocationType(location2);
      const experienceLevel = inferExperienceLevel(title);
      return {
        id: jobId,
        title,
        company,
        companyUrl,
        location: location2,
        workLocation,
        experienceLevel,
        postedDate,
        postedTimestamp,
        jobUrl,
        isEasyApply,
        applicantCount
      };
    } catch (error) {
      console.error("[Uproot] Error extracting job from card:", error instanceof Error ? error.message : String(error), error);
      return null;
    }
  }
  function extractJobIdFromUrl(url) {
    const match = url.match(/jobs\/view\/(\d+)/);
    return match ? match[1] : url;
  }
  function estimateTimestamp(postedDate) {
    const now = Date.now();
    const text = postedDate.toLowerCase();
    if (text.includes("just now") || text.includes("now")) {
      return now;
    }
    const minutesMatch = text.match(/(\d+)\s*minute/);
    if (minutesMatch) {
      return now - parseInt(minutesMatch[1]) * 60 * 1e3;
    }
    const hoursMatch = text.match(/(\d+)\s*hour/);
    if (hoursMatch) {
      return now - parseInt(hoursMatch[1]) * 60 * 60 * 1e3;
    }
    const daysMatch = text.match(/(\d+)\s*day/);
    if (daysMatch) {
      return now - parseInt(daysMatch[1]) * 24 * 60 * 60 * 1e3;
    }
    const weeksMatch = text.match(/(\d+)\s*week/);
    if (weeksMatch) {
      return now - parseInt(weeksMatch[1]) * 7 * 24 * 60 * 60 * 1e3;
    }
    const monthsMatch = text.match(/(\d+)\s*month/);
    if (monthsMatch) {
      return now - parseInt(monthsMatch[1]) * 30 * 24 * 60 * 60 * 1e3;
    }
    return now - 24 * 60 * 60 * 1e3;
  }
  function inferWorkLocationType(location2) {
    const lower = location2.toLowerCase();
    if (lower.includes("remote")) return "remote";
    if (lower.includes("hybrid")) return "hybrid";
    if (lower.includes("on-site") || lower.includes("onsite") || lower.includes("in-office")) return "onsite";
    return void 0;
  }
  function inferExperienceLevel(title) {
    const lower = title.toLowerCase();
    if (lower.includes("intern")) return "internship";
    if (lower.includes("entry") || lower.includes("junior") || lower.includes("associate")) return "entry";
    if (lower.includes("senior") || lower.includes("sr.")) return "senior";
    if (lower.includes("director") || lower.includes("head of")) return "director";
    if (lower.includes("vp") || lower.includes("vice president") || lower.includes("chief") || lower.includes("ceo") || lower.includes("cto") || lower.includes("cfo")) return "executive";
    return "mid";
  }
  content;
  const CURRENT_USER_PROFILE_KEY = "uproot_current_user";
  const PROFILE_CACHE_TTL = 7 * 24 * 60 * 60 * 1e3;
  function getCurrentLinkedInUser(retryCount = 0, maxRetries = 3) {
    try {
      let profileUrl = "";
      let name = "";
      let headline = "";
      let photoUrl;
      const navProfileLink = document.querySelector('a[href*="/in/me/"], a[data-control-name="identity_profile_photo"]');
      if (navProfileLink) {
        let href = navProfileLink.href;
        if (href.startsWith("/")) {
          href = window.location.origin + href;
        } else if (!href.startsWith("http")) {
          href = `${window.location.origin}/in/${href}`;
        }
        profileUrl = href.replace("/in/me/", "/in/").replace(/\/$/, "");
      }
      const navPhoto = document.querySelector(".global-nav__me-photo, img.global-nav__me-photo");
      if (navPhoto) {
        photoUrl = navPhoto.src;
        if (navPhoto.alt && navPhoto.alt !== "Photo") {
          name = navPhoto.alt.trim();
        }
      }
      const menuTrigger = document.querySelector('.global-nav__primary-link-me-menu-trigger span.t-12.break-words, [data-control-name="identity_profile_photo"] + span');
      if (menuTrigger && !name) {
        const menuText = menuTrigger.textContent?.trim();
        if (menuText && menuText !== "Me") {
          name = menuText;
        }
      }
      const jsonLdScripts = document.querySelectorAll('script[type="application/ld+json"]');
      for (const script of jsonLdScripts) {
        try {
          const data = JSON.parse(script.textContent || "");
          if (data["@type"] === "Person" || data["@type"] === "ProfilePage") {
            if (data.name && !name) name = data.name;
            if (data.image && !photoUrl) photoUrl = data.image;
            if (data.jobTitle && !headline) headline = data.jobTitle;
            if (data.url && !profileUrl) profileUrl = data.url;
          }
        } catch (e) {
        }
      }
      if (!name) {
        const ogTitle = document.querySelector('meta[property="og:title"]');
        if (ogTitle && ogTitle.content) {
          name = ogTitle.content.split("|")[0].trim();
        }
      }
      if (!photoUrl) {
        const ogImage = document.querySelector('meta[property="og:image"]');
        if (ogImage && ogImage.content) {
          photoUrl = ogImage.content;
        }
      }
      const expandedMenu = document.querySelector(".global-nav__me-content");
      if (expandedMenu) {
        const menuNameElement = expandedMenu.querySelector(".text-heading-xlarge, .t-16.t-black.t-bold");
        if (menuNameElement && !name) {
          name = menuNameElement.textContent?.trim() || "";
        }
        const menuHeadlineElement = expandedMenu.querySelector(".text-body-small.t-black--light, .t-12.t-black--light.t-normal");
        if (menuHeadlineElement && !headline) {
          headline = menuHeadlineElement.textContent?.trim() || "";
        }
      }
      try {
        const windowAny = window;
        if (windowAny.__RELAY_BOOTSTRAP_DATA__) {
          const relayData = windowAny.__RELAY_BOOTSTRAP_DATA__;
          for (const key in relayData) {
            const entry = relayData[key];
            if (entry?.data?.me || entry?.data?.currentUser) {
              const userData = entry.data.me || entry.data.currentUser;
              if (userData.miniProfile) {
                if (userData.miniProfile.firstName && userData.miniProfile.lastName && !name) {
                  name = `${userData.miniProfile.firstName} ${userData.miniProfile.lastName}`;
                }
                if (userData.miniProfile.headline && !headline) {
                  headline = userData.miniProfile.headline;
                }
                if (userData.miniProfile.picture && !photoUrl) {
                  photoUrl = userData.miniProfile.picture.rootUrl;
                }
              }
            }
          }
        }
      } catch (e) {
      }
      if (!name && !profileUrl) {
        if (retryCount < maxRetries) {
          const delay = Math.pow(2, retryCount) * 200;
          if (retryCount === 0) {
            console.debug("[Uproot] LinkedIn user detection attempt failed, will retry...", {
              retryCount: retryCount + 1,
              maxRetries,
              delayMs: delay
            });
          }
          return null;
        }
        if (retryCount >= maxRetries) {
          console.warn("[Uproot] Could not detect current LinkedIn user after retries - user may not be logged in or page not fully loaded");
        }
        return null;
      }
      return {
        profileUrl: profileUrl || window.location.origin + "/in/me/",
        name: name || "LinkedIn User",
        headline: headline || "",
        currentRole: {
          title: headline || "",
          company: ""
        },
        location: "",
        photoUrl
      };
    } catch (error) {
      console.error("[Uproot] Error detecting current LinkedIn user:", error instanceof Error ? error.message : String(error), error);
      return null;
    }
  }
  function scrapePersonProfile() {
    if (typeof window === "undefined" || typeof document === "undefined") {
      console.warn("[Uproot] scrapePersonProfile() cannot be called in service worker context");
      return null;
    }
    try {
      const profileUrl = window.location.href;
      const nameElement = document.querySelector("h1.text-heading-xlarge, h1.inline");
      const name = nameElement?.textContent?.trim() || "";
      const headlineElement = document.querySelector(".text-body-medium.break-words, .pv-text-details__left-panel h2");
      const headline = headlineElement?.textContent?.trim() || "";
      const photoElement = document.querySelector("img.pv-top-card-profile-picture__image");
      const photoUrl = photoElement?.src;
      const locationElement = document.querySelector(".text-body-small.inline.t-black--light.break-words, .pv-text-details__left-panel span.text-body-small");
      const location2 = locationElement?.textContent?.trim() || "";
      const currentRoleElement = document.querySelector(".pvs-list__item--line-separated:first-child, .experience-item:first-child");
      let currentRole = {
        title: "",
        company: "",
        companyUrl: void 0,
        startDate: void 0
      };
      if (currentRoleElement) {
        const titleEl = currentRoleElement.querySelector('.mr1.hoverable-link-text.t-bold span[aria-hidden="true"]');
        const companyEl = currentRoleElement.querySelector('.t-14.t-normal span[aria-hidden="true"]');
        const companyLinkEl = currentRoleElement.querySelector('a[href*="/company/"]');
        const dateEl = currentRoleElement.querySelector('.t-14.t-normal.t-black--light span[aria-hidden="true"]');
        currentRole = {
          title: titleEl?.textContent?.trim() || "",
          company: companyEl?.textContent?.trim().split("Â·")[0]?.trim() || "",
          companyUrl: companyLinkEl?.href,
          startDate: dateEl?.textContent?.trim().split("Â·")[0]?.trim()
        };
      }
      return {
        profileUrl,
        name,
        headline,
        currentRole,
        location: location2,
        photoUrl
      };
    } catch (error) {
      console.error("[Uproot] Error scraping person profile:", error instanceof Error ? error.message : String(error), error);
      return null;
    }
  }
  function scrapeMutualConnections() {
    if (typeof document === "undefined") {
      console.warn("[Uproot] scrapeMutualConnections() cannot be called in service worker context");
      return [];
    }
    const mutuals = [];
    try {
      console.log("[Uproot] Scraping mutual connections...");
      const mutualLinkSelectors = [
        'a[href*="/search/results/people/?facetNetwork=%5B%22F%22%5D"]',
        'a[href*="facetNetwork"]',
        'button[aria-label*="mutual"]',
        '.pv-top-card--list-bullet a[href*="mutual"]'
      ];
      let mutualElement = null;
      for (const selector of mutualLinkSelectors) {
        mutualElement = document.querySelector(selector);
        if (mutualElement) break;
      }
      if (mutualElement) {
        const mutualText = mutualElement.textContent?.trim() || "";
        const mutualCount = parseInt(mutualText.match(/(\d+)/)?.[1] || "0");
        console.log(`[Uproot] Found ${mutualCount} mutual connections mentioned`);
        const mutualCards = document.querySelectorAll('[data-view-name="profile-card"], .org-people-profile-card');
        mutualCards.forEach((card) => {
          try {
            const linkEl = card.querySelector('a[href*="/in/"]');
            const nameEl = card.querySelector('.org-people-profile-card__profile-title, [data-anonymize="person-name"]');
            const headlineEl = card.querySelector(".artdeco-entity-lockup__subtitle, .org-people-profile-card__profile-info");
            const photoEl = card.querySelector("img");
            if (linkEl && nameEl) {
              let profileUrl = linkEl.href;
              if (profileUrl.startsWith("/")) {
                profileUrl = window.location.origin + profileUrl;
              }
              profileUrl = profileUrl.replace(/\/$/, "");
              mutuals.push({
                profileUrl,
                name: nameEl.textContent?.trim() || "",
                headline: headlineEl?.textContent?.trim() || "",
                currentRole: {
                  title: headlineEl?.textContent?.trim() || "",
                  company: ""
                },
                location: "",
                photoUrl: photoEl?.src
              });
            }
          } catch (err) {
            console.warn("[Uproot] Error extracting mutual connection card:", err instanceof Error ? err.message : String(err), err);
          }
        });
      }
      console.log(`[Uproot] Scraped ${mutuals.length} mutual connection profiles`);
      return mutuals;
    } catch (error) {
      console.error("[Uproot] Error scraping mutual connections:", error instanceof Error ? error.message : String(error), error);
      return [];
    }
  }
  function getMinimalProfile() {
    return {
      name: "LinkedIn User",
      title: "",
      workExperience: [],
      education: [],
      projects: [],
      skills: [],
      metadata: {
        totalYearsExperience: 0,
        domains: [],
        seniority: "entry",
        careerStage: "professional"
      }
    };
  }
  async function getCachedProfile() {
    try {
      const result2 = await chrome.storage.local.get(CURRENT_USER_PROFILE_KEY);
      const cached = result2[CURRENT_USER_PROFILE_KEY];
      if (!cached) {
        console.log("[Uproot] No cached profile found");
        return null;
      }
      const now = Date.now();
      if (now >= cached.expiresAt) {
        console.log("[Uproot] Cached profile expired");
        return null;
      }
      console.log("[Uproot] Using cached profile (expires in", Math.round((cached.expiresAt - now) / (1e3 * 60 * 60)), "hours)");
      return cached.profile;
    } catch (error) {
      if (isContextInvalidatedError(error)) {
        return null;
      }
      console.error("[Uproot] Error reading cached profile:", error instanceof Error ? error.message : String(error), error);
      return null;
    }
  }
  async function cacheProfile(profile) {
    try {
      const now = Date.now();
      const cached = {
        profile,
        cachedAt: now,
        expiresAt: now + PROFILE_CACHE_TTL
      };
      await chrome.storage.local.set({ [CURRENT_USER_PROFILE_KEY]: cached });
      console.log("[Uproot] Profile cached successfully (TTL: 7 days)");
    } catch (error) {
      if (isContextInvalidatedError(error)) {
        return;
      }
      console.error("[Uproot] Error caching profile:", error instanceof Error ? error.message : String(error), error);
    }
  }
  function convertLinkedInProfileToUserProfile(linkedInProfile) {
    const workExperience = [];
    if (linkedInProfile.currentRole && linkedInProfile.currentRole.title) {
      workExperience.push({
        id: "current-role",
        company: linkedInProfile.currentRole.company || "",
        title: linkedInProfile.currentRole.title,
        startDate: linkedInProfile.currentRole.startDate || (/* @__PURE__ */ new Date()).toISOString(),
        endDate: null,
        // Current role
        location: linkedInProfile.location,
        achievements: [],
        skills: [],
        domains: [],
        responsibilities: []
      });
    }
    const metadata = {
      totalYearsExperience: 0,
      // Would need more data to calculate
      domains: [],
      seniority: inferSeniority(linkedInProfile.currentRole?.title || ""),
      careerStage: "professional"
    };
    return {
      name: linkedInProfile.name,
      title: linkedInProfile.headline || linkedInProfile.currentRole?.title || "",
      location: linkedInProfile.location,
      avatarUrl: linkedInProfile.photoUrl,
      url: linkedInProfile.profileUrl,
      workExperience,
      education: [],
      projects: [],
      skills: [],
      metadata
    };
  }
  function inferSeniority(title) {
    const lower = title.toLowerCase();
    if (lower.includes("principal") || lower.includes("distinguished")) return "principal";
    if (lower.includes("staff") || lower.includes("lead")) return "staff";
    if (lower.includes("senior") || lower.includes("sr.")) return "senior";
    if (lower.includes("junior") || lower.includes("jr.") || lower.includes("associate")) return "entry";
    return "mid";
  }
  async function scrapeOwnProfile() {
    try {
      console.log("[Uproot] Fetching current user profile...");
      const cachedProfile = await getCachedProfile();
      if (cachedProfile) {
        return cachedProfile;
      }
      console.log("[Uproot] Cache miss, scraping fresh profile...");
      const currentUrl = window.location.href;
      const isOnOwnProfile = currentUrl.includes("/in/") && (currentUrl.includes("/me") || document.querySelector(".pv-top-card__edit-profile-button") !== null);
      let linkedInProfile = null;
      if (isOnOwnProfile) {
        console.log("[Uproot] Already on own profile, scraping...");
        linkedInProfile = scrapePersonProfile();
      } else {
        console.log("[Uproot] Navigating to /me...");
        const returnUrl = window.location.href;
        window.location.href = "https://www.linkedin.com/in/me/";
        await new Promise((resolve) => {
          const checkReady = setInterval(() => {
            if (window.location.href.includes("/in/") && document.querySelector(".pv-top-card")) {
              clearInterval(checkReady);
              resolve();
            }
          }, 500);
          setTimeout(() => {
            clearInterval(checkReady);
            resolve();
          }, 1e4);
        });
        linkedInProfile = scrapePersonProfile();
        if (returnUrl !== "https://www.linkedin.com/in/me/" && !returnUrl.includes("/in/me")) {
          window.location.href = returnUrl;
        }
      }
      if (linkedInProfile) {
        console.log("[Uproot] Successfully scraped profile:", linkedInProfile.name);
        const userProfile = convertLinkedInProfileToUserProfile(linkedInProfile);
        await cacheProfile(userProfile);
        return userProfile;
      } else {
        throw new Error("Failed to scrape profile data");
      }
    } catch (error) {
      console.error("[Uproot] Error scraping own profile:", error instanceof Error ? error.message : String(error), error);
      console.log("[Uproot] Returning minimal profile due to error");
      return getMinimalProfile();
    }
  }
  content;
  function scrapeCompanyUpdates(companyUrl) {
    if (typeof document === "undefined") {
      console.warn("[Uproot] scrapeCompanyUpdates() cannot be called in service worker context");
      return [];
    }
    const updates = [];
    try {
      const postCards = document.querySelectorAll(".feed-shared-update-v2, .occludable-update");
      postCards.forEach((card, _index) => {
        try {
          const update = extractUpdateFromCard(card);
          if (update) {
            updates.push(update);
          }
        } catch (error) {
          console.error("[Uproot] Error extracting update from card:", error instanceof Error ? error.message : String(error), error);
        }
      });
      console.log(`[Uproot] Scraped ${updates.length} updates from company page`);
    } catch (error) {
      console.error("[Uproot] Error scraping company updates:", error instanceof Error ? error.message : String(error), error);
    }
    return updates;
  }
  function extractUpdateFromCard(card) {
    try {
      const linkElement = card.querySelector('a[href*="/feed/update/"]');
      const url = linkElement?.href || "";
      const id = url.match(/urn:li:activity:(\d+)/)?.[1] || `update_${Date.now()}`;
      const textElement = card.querySelector('.feed-shared-text__text-view span[dir="ltr"]');
      const preview = textElement?.textContent?.trim().slice(0, 200) || "";
      const imageElement = card.querySelector("img.feed-shared-image__image");
      const imageUrl = imageElement?.src;
      const timeElement = card.querySelector("time");
      const timestamp = timeElement?.dateTime ? new Date(timeElement.dateTime).getTime() : Date.now();
      let type = "post";
      if (preview.toLowerCase().includes("hiring") || preview.toLowerCase().includes("join our team")) {
        type = "hiring";
      } else if (card.querySelector(".feed-shared-article")) {
        type = "article";
      } else if (preview.toLowerCase().includes("event")) {
        type = "event";
      }
      return {
        id,
        type,
        timestamp,
        url,
        preview,
        imageUrl
      };
    } catch (error) {
      console.error("[Uproot] Error extracting update from card:", error instanceof Error ? error.message : String(error), error);
      return null;
    }
  }
  content;
  function getCompanyIdFromUrl(url) {
    const match = url.match(/\/company\/([^/]+)/);
    return match ? match[1] : null;
  }
  function getProfileUsernameFromUrl(url) {
    const match = url.match(/\/in\/([^/]+)/);
    return match ? match[1] : null;
  }
  content;
  content;
  content;
  const CACHE_KEY$1 = "uproot_current_user";
  const CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1e3;
  const MAX_RETRY_ATTEMPTS = 3;
  const RETRY_DELAY_MS = 1e3;
  function sleep$2(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  function isCacheValid(cachedData) {
    if (!cachedData) {
      return false;
    }
    const now = Date.now();
    const isValid2 = now < cachedData.expiresAt;
    log$1.debug(
      LogCategory.SERVICE,
      "Cache validity check",
      {
        isValid: isValid2,
        cachedAt: new Date(cachedData.cachedAt).toISOString(),
        expiresAt: new Date(cachedData.expiresAt).toISOString(),
        ageInDays: ((now - cachedData.cachedAt) / (24 * 60 * 60 * 1e3)).toFixed(2)
      }
    );
    return isValid2;
  }
  async function scrapeCurrentUserWithRetry(attemptNumber = 1) {
    log$1.info(
      LogCategory.SERVICE,
      `Getting current logged-in user profile (attempt ${attemptNumber}/${MAX_RETRY_ATTEMPTS})`
    );
    try {
      const profileData = getCurrentLinkedInUser();
      if (!profileData || !profileData.profileUrl) {
        throw new Error("Could not detect logged-in user from nav bar");
      }
      const linkedInProfile = {
        id: profileData.profileUrl,
        publicId: profileData.profileUrl.match(/\/in\/([^\/]+)/)?.[1],
        name: profileData.name,
        headline: profileData.headline,
        location: profileData.location,
        avatarUrl: profileData.photoUrl,
        experience: profileData.currentRole?.title ? [{
          company: profileData.currentRole.company || "",
          title: profileData.currentRole.title,
          duration: void 0,
          location: profileData.location
        }] : [],
        education: [],
        skills: [],
        scrapedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      log$1.info(
        LogCategory.SERVICE,
        "Successfully detected current logged-in user",
        {
          profileId: linkedInProfile.id,
          name: linkedInProfile.name,
          headline: linkedInProfile.headline
        }
      );
      return linkedInProfile;
    } catch (error) {
      log$1.error(
        LogCategory.SERVICE,
        `Failed to scrape current user profile (attempt ${attemptNumber}/${MAX_RETRY_ATTEMPTS})`,
        error,
        { attemptNumber }
      );
      if (attemptNumber < MAX_RETRY_ATTEMPTS) {
        log$1.info(
          LogCategory.SERVICE,
          `Retrying in ${RETRY_DELAY_MS}ms...`
        );
        await sleep$2(RETRY_DELAY_MS);
        return scrapeCurrentUserWithRetry(attemptNumber + 1);
      }
      log$1.error(
        LogCategory.SERVICE,
        "All retry attempts exhausted for current user scraping",
        error
      );
      return null;
    }
  }
  async function getCachedData() {
    try {
      const result2 = await chrome.storage.local.get(CACHE_KEY$1);
      const cachedData = result2[CACHE_KEY$1];
      if (!cachedData) {
        log$1.debug(LogCategory.STORAGE, "No cached user data found");
        return null;
      }
      log$1.debug(
        LogCategory.STORAGE,
        "Retrieved cached user data",
        {
          profileId: cachedData.profile.id,
          name: cachedData.profile.name,
          cachedAt: new Date(cachedData.cachedAt).toISOString()
        }
      );
      return cachedData;
    } catch (error) {
      log$1.error(
        LogCategory.STORAGE,
        "Error retrieving cached user data",
        error
      );
      return null;
    }
  }
  async function saveCachedData(profile) {
    const now = Date.now();
    const cachedData = {
      profile,
      cachedAt: now,
      expiresAt: now + CACHE_TTL_MS
    };
    try {
      await chrome.storage.local.set({ [CACHE_KEY$1]: cachedData });
      log$1.info(
        LogCategory.STORAGE,
        "Cached current user data",
        {
          profileId: profile.id,
          name: profile.name,
          cachedAt: new Date(cachedData.cachedAt).toISOString(),
          expiresAt: new Date(cachedData.expiresAt).toISOString(),
          ttlDays: CACHE_TTL_MS / (24 * 60 * 60 * 1e3)
        }
      );
    } catch (error) {
      log$1.error(
        LogCategory.STORAGE,
        "Error caching user data",
        error
      );
      throw error;
    }
  }
  async function getCurrentUser$1() {
    const timer = log$1.startTimer(LogCategory.SERVICE, "getCurrentUser");
    try {
      log$1.debug(LogCategory.SERVICE, "Getting current user profile");
      const cachedData = await getCachedData();
      if (isCacheValid(cachedData)) {
        log$1.info(
          LogCategory.SERVICE,
          "Returning cached current user profile",
          {
            profileId: cachedData.profile.id,
            name: cachedData.profile.name,
            cacheAge: ((Date.now() - cachedData.cachedAt) / (60 * 60 * 1e3)).toFixed(2) + " hours"
          }
        );
        timer();
        return cachedData.profile;
      }
      log$1.info(
        LogCategory.SERVICE,
        cachedData ? "Cache expired, refreshing current user profile" : "No cache found, fetching current user profile"
      );
      return await refreshCurrentUser();
    } catch (error) {
      log$1.error(
        LogCategory.SERVICE,
        "Error getting current user",
        error
      );
      timer();
      return null;
    }
  }
  async function refreshCurrentUser() {
    const timer = log$1.startTimer(LogCategory.SERVICE, "refreshCurrentUser");
    try {
      log$1.info(LogCategory.SERVICE, "Force refreshing current user profile");
      const profileData = await scrapeCurrentUserWithRetry();
      if (!profileData || !profileData.id) {
        log$1.warn(
          LogCategory.SERVICE,
          "Failed to scrape current user profile after all retry attempts"
        );
        timer();
        return null;
      }
      const completeProfile = {
        id: profileData.id,
        publicId: profileData.publicId,
        name: profileData.name || "Unknown User",
        headline: profileData.headline,
        location: profileData.location,
        industry: profileData.industry,
        avatarUrl: profileData.avatarUrl,
        about: profileData.about,
        experience: profileData.experience || [],
        education: profileData.education || [],
        skills: profileData.skills || [],
        connections: profileData.connections,
        mutualConnections: profileData.mutualConnections || [],
        recentPosts: profileData.recentPosts || [],
        certifications: profileData.certifications || [],
        userPosts: profileData.userPosts || [],
        engagedPosts: profileData.engagedPosts || [],
        recentActivity: profileData.recentActivity || [],
        scrapedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      await saveCachedData(completeProfile);
      log$1.info(
        LogCategory.SERVICE,
        "Successfully refreshed current user profile",
        {
          profileId: completeProfile.id,
          name: completeProfile.name
        }
      );
      timer();
      return completeProfile;
    } catch (error) {
      log$1.error(
        LogCategory.SERVICE,
        "Error refreshing current user",
        error
      );
      timer();
      return null;
    }
  }
  content;
  function ProfileHeader({ name, headline, profileImage }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          padding: "20px",
          borderBottom: "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: "rgba(0, 119, 181, 0.03)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: "12px", marginBottom: "8px" }, children: [
          profileImage ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: profileImage,
              alt: name,
              style: {
                width: "56px",
                height: "56px",
                borderRadius: "50%",
                objectFit: "cover",
                border: "2px solid rgba(0, 119, 181, 0.2)",
                flexShrink: 0
              },
              onError: (e) => {
                e.target.style.display = "none";
              }
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                width: "56px",
                height: "56px",
                borderRadius: "50%",
                background: "linear-gradient(135deg, #0077B5 0%, #00A0DC 100%)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                color: "white",
                fontSize: "20px",
                fontWeight: "bold",
                flexShrink: 0
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 28, strokeWidth: 2 })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "h2",
              {
                style: {
                  fontSize: "18px",
                  fontWeight: "600",
                  margin: "0 0 6px 0",
                  color: "#1d1d1f",
                  wordBreak: "break-word"
                },
                children: name
              }
            ),
            headline && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "p",
              {
                style: {
                  fontSize: "13px",
                  color: "#6e6e73",
                  margin: 0,
                  display: "flex",
                  alignItems: "flex-start",
                  gap: "6px",
                  lineHeight: "1.4",
                  wordBreak: "break-word",
                  whiteSpace: "normal"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: 14, style: { marginTop: "2px", flexShrink: 0 } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { flex: 1 }, children: headline })
                ]
              }
            )
          ] })
        ] })
      }
    );
  }
  content;
  function ActionCard$1({
    icon: Icon2,
    title,
    description,
    buttonText,
    buttonColor,
    isLoading,
    onClick
  }) {
    const [isHovered, setIsHovered] = reactExports.useState(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "16px",
          borderRadius: "12px",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: "#FFFFFF",
          boxShadow: isHovered ? "0 4px 12px rgba(0, 0, 0, 0.08)" : "0 2px 4px rgba(0, 0, 0, 0.04)",
          transition: "all 200ms cubic-bezier(0.4, 0.0, 0.2, 1)",
          transform: isHovered ? "translateY(-2px)" : "translateY(0)"
        },
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: "12px", marginBottom: "12px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  width: "40px",
                  height: "40px",
                  borderRadius: "10px",
                  backgroundColor: `${buttonColor}15`,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  flexShrink: 0
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: 20, color: buttonColor, strokeWidth: 2 })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "h3",
                {
                  style: {
                    fontSize: "15px",
                    fontWeight: "600",
                    margin: "0 0 4px 0",
                    color: "#1d1d1f"
                  },
                  children: title
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  style: {
                    fontSize: "13px",
                    color: "#6e6e73",
                    margin: 0,
                    lineHeight: "1.4"
                  },
                  children: description
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick,
              disabled: isLoading,
              style: {
                width: "100%",
                padding: "10px 16px",
                backgroundColor: isLoading ? "#8e8e93" : buttonColor,
                color: "#FFFFFF",
                border: "none",
                borderRadius: "8px",
                fontSize: "14px",
                fontWeight: "600",
                cursor: isLoading ? "not-allowed" : "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "8px",
                transition: "all 150ms cubic-bezier(0.4, 0.0, 0.2, 1)",
                opacity: isLoading ? 0.7 : 1
              },
              onMouseEnter: (e) => {
                if (!isLoading) {
                  e.currentTarget.style.transform = "scale(1.02)";
                }
              },
              onMouseLeave: (e) => {
                e.currentTarget.style.transform = "scale(1)";
              },
              children: [
                isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  LoaderCircle,
                  {
                    size: 16,
                    style: {
                      animation: "spin 1s linear infinite"
                    }
                  }
                ),
                buttonText,
                /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
            @keyframes spin {
              from { transform: rotate(0deg); }
              to { transform: rotate(360deg); }
            }
          ` })
              ]
            }
          )
        ]
      }
    );
  }
  content;
  function ErrorDisplay({
    error,
    isRefreshingProfile,
    onRetry,
    onRefresh
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "16px",
          backgroundColor: "#FEE2E2",
          border: "1px solid #F87171",
          borderRadius: "12px",
          marginTop: "12px"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "p",
            {
              style: {
                fontSize: "13px",
                color: "#991B1B",
                margin: "0 0 12px 0"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Error:" }),
                " ",
                error
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                gap: "8px"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    onClick: onRetry,
                    disabled: isRefreshingProfile,
                    style: {
                      flex: 1,
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      gap: "8px",
                      padding: "8px 12px",
                      backgroundColor: isRefreshingProfile ? "#8e8e93" : "#991B1B",
                      color: "white",
                      border: "none",
                      borderRadius: "8px",
                      fontSize: "13px",
                      fontWeight: "600",
                      cursor: isRefreshingProfile ? "not-allowed" : "pointer",
                      transition: "background-color 150ms",
                      opacity: isRefreshingProfile ? 0.7 : 1
                    },
                    onMouseEnter: (e) => {
                      if (!isRefreshingProfile) {
                        e.currentTarget.style.backgroundColor = "#7F1D1D";
                      }
                    },
                    onMouseLeave: (e) => {
                      if (!isRefreshingProfile) {
                        e.currentTarget.style.backgroundColor = "#991B1B";
                      }
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 14 }),
                      "Try Again"
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: onRefresh,
                    disabled: isRefreshingProfile,
                    style: {
                      flex: 1,
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      gap: "8px",
                      padding: "8px 12px",
                      backgroundColor: isRefreshingProfile ? "#8e8e93" : "#0077B5",
                      color: "white",
                      border: "none",
                      borderRadius: "8px",
                      fontSize: "13px",
                      fontWeight: "600",
                      cursor: isRefreshingProfile ? "not-allowed" : "pointer",
                      transition: "background-color 150ms",
                      opacity: isRefreshingProfile ? 0.7 : 1
                    },
                    onMouseEnter: (e) => {
                      if (!isRefreshingProfile) {
                        e.currentTarget.style.backgroundColor = "#005582";
                      }
                    },
                    onMouseLeave: (e) => {
                      if (!isRefreshingProfile) {
                        e.currentTarget.style.backgroundColor = "#0077B5";
                      }
                    },
                    children: isRefreshingProfile ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        LoaderCircle,
                        {
                          size: 14,
                          style: {
                            animation: "spin 1s linear infinite"
                          }
                        }
                      ),
                      "Refreshing..."
                    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 14 }),
                      "Refresh Profile"
                    ] })
                  }
                )
              ]
            }
          )
        ]
      }
    );
  }
  content;
  const SPACING = {
    xxs: 4,
    // 4px - Tiny gaps
    xs: 8,
    // 8px - Small gaps, tight padding
    sm: 12,
    // 12px - Default gaps
    md: 16,
    // 16px - Medium padding, margins
    lg: 20,
    // 20px - Large padding
    xl: 24
  };
  const TYPOGRAPHY = {
    fontSize: {
      xs: 10,
      // 10px - Micro text
      sm: 11,
      // 11px - Small text, labels
      base: 13,
      // 13px - Body text (default)
      md: 14,
      // 14px - Slightly larger body
      lg: 16
    },
    fontWeight: {
      medium: 500,
      semibold: 600
    },
    lineHeight: {
      relaxed: 1.75
    }
  };
  const COLORS = {
    // Primary text colors
    text: {
      primary: "#1d1d1f",
      secondary: "rgba(29, 29, 31, 0.7)",
      // 70% opacity
      tertiary: "rgba(29, 29, 31, 0.5)",
      // 30% opacity
      inverse: "#FFFFFF"
    },
    // Background colors
    background: {
      primary: "#FFFFFF",
      secondary: "rgba(29, 29, 31, 0.05)",
      // 5% gray
      tertiary: "rgba(29, 29, 31, 0.08)",
      // 8% gray
      hover: "rgba(29, 29, 31, 0.04)"
      // 4% gray
    },
    // Accent color (LinkedIn blue)
    accent: {
      default: "#0077B5",
      hover: "#005582",
      // 36% darker
      light: "rgba(0, 119, 181, 0.1)",
      // 10% opacity
      lighter: "rgba(0, 119, 181, 0.05)"
      // 5% opacity
    },
    // Border colors
    border: {
      default: "rgba(29, 29, 31, 0.15)",
      // 15% opacity
      light: "rgba(29, 29, 31, 0.1)"
    },
    // Status colors
    status: {
      success: "#2E7D32",
      error: "#C62828",
      errorBg: "#FFEBEE"
    }
  };
  const RADIUS = {
    sm: 6,
    // 6px - Small elements (badges, chips)
    md: 8,
    // 8px - Buttons, inputs
    lg: 12
  };
  const SHADOWS = {
    sm: "0 1px 2px rgba(0, 0, 0, 0.05)",
    md: "0 2px 8px rgba(0, 0, 0, 0.06)"
  };
  const TRANSITIONS = {
    duration: {
      // 100ms - Micro-interactions (toggles, checkboxes)
      normal: 150,
      // 150ms - Buttons, hover states (STANDARD)
      slow: 300
      // 300ms - Modals, panels, large movements
    },
    easing: {
      standardStr: "ease-in-out"
    }
  };
  const BUTTON = {
    size: {
      sm: {
        padding: `${SPACING.xs}px ${SPACING.sm}px`,
        // 8px 12px
        fontSize: TYPOGRAPHY.fontSize.sm,
        // 11px
        height: 32
      },
      md: {
        padding: `${SPACING.xs + 2}px ${SPACING.md}px`,
        // 10px 16px
        fontSize: TYPOGRAPHY.fontSize.base,
        // 13px
        height: 36
      },
      lg: {
        padding: `${SPACING.sm}px ${SPACING.lg}px`,
        // 12px 20px
        fontSize: TYPOGRAPHY.fontSize.md,
        // 14px
        height: 40
      }
    }
  };
  const ICON = {
    size: {
      sm: 16
    }
  };
  content;
  function ProgressBar({
    value,
    max = 100,
    variant = "linear",
    steps = 3,
    currentStep = 0,
    height = 6,
    showLabel = false,
    label,
    color = COLORS.accent.default,
    completeColor = "#30D158",
    isComplete = false
  }) {
    const percentage = Math.min(100, Math.max(0, value / max * 100));
    const activeColor = isComplete ? completeColor : color;
    if (variant === "stepped") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "100%" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              display: "flex",
              gap: `${SPACING.xs}px`,
              marginBottom: showLabel ? `${SPACING.sm}px` : 0
            },
            children: Array.from({ length: steps }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  flex: 1,
                  height: `${height}px`,
                  backgroundColor: index2 <= currentStep ? activeColor : COLORS.background.tertiary,
                  borderRadius: `${height / 2}px`,
                  transition: `background-color ${TRANSITIONS.duration.slow}ms ${TRANSITIONS.easing.standardStr}`
                }
              },
              index2
            ))
          }
        ),
        showLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              fontSize: "11px",
              fontWeight: 500,
              color: COLORS.text.secondary,
              textAlign: "center"
            },
            children: label || `Step ${currentStep + 1} of ${steps}`
          }
        )
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: `${SPACING.sm}px` }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            flex: 1,
            height: `${height}px`,
            backgroundColor: COLORS.background.tertiary,
            borderRadius: `${height / 2}px`,
            overflow: "hidden"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                width: `${percentage}%`,
                height: "100%",
                backgroundColor: activeColor,
                transition: `width ${TRANSITIONS.duration.slow}ms ${TRANSITIONS.easing.standardStr}`,
                borderRadius: `${height / 2}px`
              }
            }
          )
        }
      ),
      showLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            fontSize: "11px",
            fontWeight: 600,
            color: COLORS.text.primary,
            minWidth: "45px",
            textAlign: "right"
          },
          children: label || `${Math.round(percentage)}%`
        }
      )
    ] }) });
  }
  content;
  function Button({
    children,
    onClick,
    variant = "primary",
    size = "md",
    disabled = false,
    fullWidth = false,
    icon,
    className = "",
    type = "button"
  }) {
    const sizeConfig = BUTTON.size[size];
    const variants = {
      primary: {
        background: disabled ? COLORS.accent.light : COLORS.accent.default,
        color: COLORS.text.inverse,
        hoverBg: COLORS.accent.hover,
        border: "none"
      },
      secondary: {
        background: "transparent",
        color: COLORS.accent.default,
        hoverBg: COLORS.accent.lighter,
        border: `1px solid ${COLORS.accent.default}`
      },
      ghost: {
        background: "transparent",
        color: COLORS.text.primary,
        hoverBg: COLORS.background.hover,
        border: "none"
      },
      danger: {
        background: disabled ? COLORS.status.errorBg : COLORS.status.error,
        color: COLORS.text.inverse,
        hoverBg: "#A02020",
        border: "none"
      }
    };
    const variantStyles = variants[variant];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        type,
        onClick,
        disabled,
        className,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          gap: icon ? `${SPACING.xs}px` : "0",
          padding: sizeConfig.padding,
          fontSize: `${sizeConfig.fontSize}px`,
          fontWeight: TYPOGRAPHY.fontWeight.semibold,
          backgroundColor: variantStyles.background,
          color: variantStyles.color,
          border: variantStyles.border,
          borderRadius: `${RADIUS.md}px`,
          cursor: disabled ? "not-allowed" : "pointer",
          transition: `all ${TRANSITIONS.duration.normal}ms ${TRANSITIONS.easing.standardStr}`,
          width: fullWidth ? "100%" : "auto",
          opacity: disabled ? 0.6 : 1,
          fontFamily: "inherit"
        },
        onMouseEnter: (e) => {
          if (!disabled) {
            e.currentTarget.style.backgroundColor = variantStyles.hoverBg;
          }
        },
        onMouseLeave: (e) => {
          if (!disabled) {
            e.currentTarget.style.backgroundColor = variantStyles.background;
          }
        },
        children: [
          icon && icon,
          children
        ]
      }
    );
  }
  content;
  const VERSION = "0.27.3";
  let auto = false;
  let kind = void 0;
  let fetch$1 = void 0;
  let File$1 = void 0;
  let ReadableStream$1 = void 0;
  let getDefaultAgent = void 0;
  let fileFromPath = void 0;
  function setShims(shims2, options = { auto: false }) {
    if (auto) {
      throw new Error(`you must \`import '@anthropic-ai/sdk/shims/${shims2.kind}'\` before importing anything else from @anthropic-ai/sdk`);
    }
    if (kind) {
      throw new Error(`can't \`import '@anthropic-ai/sdk/shims/${shims2.kind}'\` after \`import '@anthropic-ai/sdk/shims/${kind}'\``);
    }
    auto = options.auto;
    kind = shims2.kind;
    fetch$1 = shims2.fetch;
    File$1 = shims2.File;
    ReadableStream$1 = shims2.ReadableStream;
    getDefaultAgent = shims2.getDefaultAgent;
    fileFromPath = shims2.fileFromPath;
  }
  class MultipartBody {
    constructor(body) {
      this.body = body;
    }
    get [Symbol.toStringTag]() {
      return "MultipartBody";
    }
  }
  function getRuntime({ manuallyImported } = {}) {
    const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import â€¦ from '@anthropic-ai/sdk'\`:
- \`import '@anthropic-ai/sdk/shims/node'\` (if you're running on Node)
- \`import '@anthropic-ai/sdk/shims/web'\` (otherwise)
`;
    let _fetch, _Request, _Response, _Headers;
    try {
      _fetch = fetch;
      _Request = Request;
      _Response = Response;
      _Headers = Headers;
    } catch (error) {
      throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
    }
    return {
      kind: "web",
      fetch: _fetch,
      Request: _Request,
      Response: _Response,
      Headers: _Headers,
      FormData: (
        // @ts-ignore
        typeof FormData !== "undefined" ? FormData : class FormData {
          // @ts-ignore
          constructor() {
            throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
          }
        }
      ),
      Blob: typeof Blob !== "undefined" ? Blob : class Blob {
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
        }
      },
      File: (
        // @ts-ignore
        typeof File !== "undefined" ? File : class File {
          // @ts-ignore
          constructor() {
            throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
          }
        }
      ),
      ReadableStream: (
        // @ts-ignore
        typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
          // @ts-ignore
          constructor() {
            throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
          }
        }
      ),
      getMultipartRequestOptions: async (form, opts) => ({
        ...opts,
        body: new MultipartBody(form)
      }),
      getDefaultAgent: (url) => void 0,
      fileFromPath: () => {
        throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/anthropics/anthropic-sdk-typescript#file-uploads");
      },
      isFsReadStream: (value) => false
    };
  }
  if (!kind) setShims(getRuntime(), { auto: true });
  class Stream {
    constructor(iterator2, controller) {
      this.iterator = iterator2;
      this.controller = controller;
    }
    static fromSSEResponse(response, controller) {
      let consumed = false;
      async function* iterator2() {
        if (consumed) {
          throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed = true;
        let done = false;
        try {
          for await (const sse of _iterSSEMessages(response, controller)) {
            if (sse.event === "completion") {
              try {
                yield JSON.parse(sse.data);
              } catch (e) {
                console.error(`Could not parse message into JSON:`, sse.data);
                console.error(`From chunk:`, sse.raw);
                throw e;
              }
            }
            if (sse.event === "message_start" || sse.event === "message_delta" || sse.event === "message_stop" || sse.event === "content_block_start" || sse.event === "content_block_delta" || sse.event === "content_block_stop") {
              try {
                yield JSON.parse(sse.data);
              } catch (e) {
                console.error(`Could not parse message into JSON:`, sse.data);
                console.error(`From chunk:`, sse.raw);
                throw e;
              }
            }
            if (sse.event === "ping") {
              continue;
            }
            if (sse.event === "error") {
              throw APIError.generate(void 0, `SSE Error: ${sse.data}`, sse.data, createResponseHeaders(response.headers));
            }
          }
          done = true;
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError")
            return;
          throw e;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream(iterator2, controller);
    }
    /**
     * Generates a Stream from a newline-separated ReadableStream
     * where each item is a JSON value.
     */
    static fromReadableStream(readableStream, controller) {
      let consumed = false;
      async function* iterLines() {
        const lineDecoder = new LineDecoder();
        const iter2 = readableStreamAsyncIterable(readableStream);
        for await (const chunk of iter2) {
          for (const line of lineDecoder.decode(chunk)) {
            yield line;
          }
        }
        for (const line of lineDecoder.flush()) {
          yield line;
        }
      }
      async function* iterator2() {
        if (consumed) {
          throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed = true;
        let done = false;
        try {
          for await (const line of iterLines()) {
            if (done)
              continue;
            if (line)
              yield JSON.parse(line);
          }
          done = true;
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError")
            return;
          throw e;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream(iterator2, controller);
    }
    [Symbol.asyncIterator]() {
      return this.iterator();
    }
    /**
     * Splits the stream into two streams which can be
     * independently read from at different speeds.
     */
    tee() {
      const left = [];
      const right = [];
      const iterator2 = this.iterator();
      const teeIterator = (queue2) => {
        return {
          next: () => {
            if (queue2.length === 0) {
              const result2 = iterator2.next();
              left.push(result2);
              right.push(result2);
            }
            return queue2.shift();
          }
        };
      };
      return [
        new Stream(() => teeIterator(left), this.controller),
        new Stream(() => teeIterator(right), this.controller)
      ];
    }
    /**
     * Converts this stream to a newline-separated ReadableStream of
     * JSON stringified values in the stream
     * which can be turned back into a Stream with `Stream.fromReadableStream()`.
     */
    toReadableStream() {
      const self2 = this;
      let iter2;
      const encoder = new TextEncoder();
      return new ReadableStream$1({
        async start() {
          iter2 = self2[Symbol.asyncIterator]();
        },
        async pull(ctrl) {
          try {
            const { value, done } = await iter2.next();
            if (done)
              return ctrl.close();
            const bytes = encoder.encode(JSON.stringify(value) + "\n");
            ctrl.enqueue(bytes);
          } catch (err) {
            ctrl.error(err);
          }
        },
        async cancel() {
          await iter2.return?.();
        }
      });
    }
  }
  async function* _iterSSEMessages(response, controller) {
    if (!response.body) {
      controller.abort();
      throw new AnthropicError(`Attempted to iterate over a response with no body`);
    }
    const sseDecoder = new SSEDecoder();
    const lineDecoder = new LineDecoder();
    const iter2 = readableStreamAsyncIterable(response.body);
    for await (const sseChunk of iterSSEChunks(iter2)) {
      for (const line of lineDecoder.decode(sseChunk)) {
        const sse = sseDecoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  async function* iterSSEChunks(iterator2) {
    let data = new Uint8Array();
    for await (const chunk of iterator2) {
      if (chunk == null) {
        continue;
      }
      const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
      let newData = new Uint8Array(data.length + binaryChunk.length);
      newData.set(data);
      newData.set(binaryChunk, data.length);
      data = newData;
      let patternIndex;
      while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
        yield data.slice(0, patternIndex);
        data = data.slice(patternIndex);
      }
    }
    if (data.length > 0) {
      yield data;
    }
  }
  function findDoubleNewlineIndex(buffer) {
    const newline = 10;
    const carriage = 13;
    for (let i = 0; i < buffer.length - 2; i++) {
      if (buffer[i] === newline && buffer[i + 1] === newline) {
        return i + 2;
      }
      if (buffer[i] === carriage && buffer[i + 1] === carriage) {
        return i + 2;
      }
      if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
        return i + 4;
      }
    }
    return -1;
  }
  class SSEDecoder {
    constructor() {
      this.event = null;
      this.data = [];
      this.chunks = [];
    }
    decode(line) {
      if (line.endsWith("\r")) {
        line = line.substring(0, line.length - 1);
      }
      if (!line) {
        if (!this.event && !this.data.length)
          return null;
        const sse = {
          event: this.event,
          data: this.data.join("\n"),
          raw: this.chunks
        };
        this.event = null;
        this.data = [];
        this.chunks = [];
        return sse;
      }
      this.chunks.push(line);
      if (line.startsWith(":")) {
        return null;
      }
      let [fieldname, _, value] = partition(line, ":");
      if (value.startsWith(" ")) {
        value = value.substring(1);
      }
      if (fieldname === "event") {
        this.event = value;
      } else if (fieldname === "data") {
        this.data.push(value);
      }
      return null;
    }
  }
  class LineDecoder {
    constructor() {
      this.buffer = [];
      this.trailingCR = false;
    }
    decode(chunk) {
      let text = this.decodeText(chunk);
      if (this.trailingCR) {
        text = "\r" + text;
        this.trailingCR = false;
      }
      if (text.endsWith("\r")) {
        this.trailingCR = true;
        text = text.slice(0, -1);
      }
      if (!text) {
        return [];
      }
      const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
      let lines = text.split(LineDecoder.NEWLINE_REGEXP);
      if (trailingNewline) {
        lines.pop();
      }
      if (lines.length === 1 && !trailingNewline) {
        this.buffer.push(lines[0]);
        return [];
      }
      if (this.buffer.length > 0) {
        lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
        this.buffer = [];
      }
      if (!trailingNewline) {
        this.buffer = [lines.pop() || ""];
      }
      return lines;
    }
    decodeText(bytes) {
      if (bytes == null)
        return "";
      if (typeof bytes === "string")
        return bytes;
      if (typeof Buffer !== "undefined") {
        if (bytes instanceof Buffer) {
          return bytes.toString();
        }
        if (bytes instanceof Uint8Array) {
          return Buffer.from(bytes).toString();
        }
        throw new AnthropicError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
      }
      if (typeof TextDecoder !== "undefined") {
        if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
          this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
          return this.textDecoder.decode(bytes);
        }
        throw new AnthropicError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
      }
      throw new AnthropicError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
    }
    flush() {
      if (!this.buffer.length && !this.trailingCR) {
        return [];
      }
      const lines = [this.buffer.join("")];
      this.buffer = [];
      this.trailingCR = false;
      return lines;
    }
  }
  LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
  LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
  function partition(str, delimiter) {
    const index2 = str.indexOf(delimiter);
    if (index2 !== -1) {
      return [str.substring(0, index2), delimiter, str.substring(index2 + delimiter.length)];
    }
    return [str, "", ""];
  }
  function readableStreamAsyncIterable(stream) {
    if (stream[Symbol.asyncIterator])
      return stream;
    const reader = stream.getReader();
    return {
      async next() {
        try {
          const result2 = await reader.read();
          if (result2?.done)
            reader.releaseLock();
          return result2;
        } catch (e) {
          reader.releaseLock();
          throw e;
        }
      },
      async return() {
        const cancelPromise = reader.cancel();
        reader.releaseLock();
        await cancelPromise;
        return { done: true, value: void 0 };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  const isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
  const isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
  const isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
  async function toFile(value, name, options) {
    value = await value;
    if (isFileLike(value)) {
      return value;
    }
    if (isResponseLike(value)) {
      const blob = await value.blob();
      name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
      const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
      return new File$1(data, name, options);
    }
    const bits = await getBytes(value);
    name || (name = getName(value) ?? "unknown_file");
    if (!options?.type) {
      const type = bits[0]?.type;
      if (typeof type === "string") {
        options = { ...options, type };
      }
    }
    return new File$1(bits, name, options);
  }
  async function getBytes(value) {
    let parts = [];
    if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
    value instanceof ArrayBuffer) {
      parts.push(value);
    } else if (isBlobLike(value)) {
      parts.push(await value.arrayBuffer());
    } else if (isAsyncIterableIterator(value)) {
      for await (const chunk of value) {
        parts.push(chunk);
      }
    } else {
      throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError(value)}`);
    }
    return parts;
  }
  function propsForError(value) {
    const props = Object.getOwnPropertyNames(value);
    return `[${props.map((p) => `"${p}"`).join(", ")}]`;
  }
  function getName(value) {
    return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
    getStringFromMaybeBuffer(value.path)?.split(/[\\/]/).pop();
  }
  const getStringFromMaybeBuffer = (x) => {
    if (typeof x === "string")
      return x;
    if (typeof Buffer !== "undefined" && x instanceof Buffer)
      return String(x);
    return void 0;
  };
  const isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
  const isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
  (function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  });
  (function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  });
  async function defaultParseResponse(props) {
    const { response } = props;
    if (props.options.stream) {
      debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller);
      }
      return Stream.fromSSEResponse(response, props.controller);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const isJSON = contentType?.includes("application/json") || contentType?.includes("application/vnd.api+json");
    if (isJSON) {
      const json = await response.json();
      debug("response", response.status, response.url, response.headers, json);
      return json;
    }
    const text = await response.text();
    debug("response", response.status, response.url, response.headers, text);
    return text;
  }
  class APIPromise extends Promise {
    constructor(responsePromise, parseResponse = defaultParseResponse) {
      super((resolve) => {
        resolve(null);
      });
      this.responsePromise = responsePromise;
      this.parseResponse = parseResponse;
    }
    _thenUnwrap(transform) {
      return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
    }
    /**
     * Gets the raw `Response` instance instead of parsing the response
     * data.
     *
     * If you want to parse the response body but still get the `Response`
     * instance, you can use {@link withResponse()}.
     *
     * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import â€¦ from '@anthropic-ai/sdk'`:
     * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
     * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
     */
    asResponse() {
      return this.responsePromise.then((p) => p.response);
    }
    /**
     * Gets the parsed response data and the raw `Response` instance.
     *
     * If you just want to get the raw `Response` instance without parsing it,
     * you can use {@link asResponse()}.
     *
     *
     * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import â€¦ from '@anthropic-ai/sdk'`:
     * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
     * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
     */
    async withResponse() {
      const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
      return { data, response };
    }
    parse() {
      if (!this.parsedPromise) {
        this.parsedPromise = this.responsePromise.then(this.parseResponse);
      }
      return this.parsedPromise;
    }
    then(onfulfilled, onrejected) {
      return this.parse().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
      return this.parse().catch(onrejected);
    }
    finally(onfinally) {
      return this.parse().finally(onfinally);
    }
  }
  class APIClient {
    constructor({
      baseURL,
      maxRetries = 2,
      timeout = 6e5,
      // 10 minutes
      httpAgent,
      fetch: overridenFetch
    }) {
      this.baseURL = baseURL;
      this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
      this.timeout = validatePositiveInteger("timeout", timeout);
      this.httpAgent = httpAgent;
      this.fetch = overridenFetch ?? fetch$1;
    }
    authHeaders(opts) {
      return {};
    }
    /**
     * Override this to add your own default headers, for example:
     *
     *  {
     *    ...super.defaultHeaders(),
     *    Authorization: 'Bearer 123',
     *  }
     */
    defaultHeaders(opts) {
      return {
        Accept: "application/json",
        "Content-Type": "application/json",
        "User-Agent": this.getUserAgent(),
        ...getPlatformHeaders(),
        ...this.authHeaders(opts)
      };
    }
    /**
     * Override this to add your own headers validation:
     */
    validateHeaders(headers, customHeaders) {
    }
    defaultIdempotencyKey() {
      return `stainless-node-retry-${uuid4()}`;
    }
    get(path, opts) {
      return this.methodRequest("get", path, opts);
    }
    post(path, opts) {
      return this.methodRequest("post", path, opts);
    }
    patch(path, opts) {
      return this.methodRequest("patch", path, opts);
    }
    put(path, opts) {
      return this.methodRequest("put", path, opts);
    }
    delete(path, opts) {
      return this.methodRequest("delete", path, opts);
    }
    methodRequest(method, path, opts) {
      return this.request(Promise.resolve(opts).then(async (opts2) => {
        const body = opts2 && isBlobLike(opts2?.body) ? new DataView(await opts2.body.arrayBuffer()) : opts2?.body instanceof DataView ? opts2.body : opts2?.body instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2?.body) ? new DataView(opts2.body.buffer) : opts2?.body;
        return { method, path, ...opts2, body };
      }));
    }
    getAPIList(path, Page, opts) {
      return this.requestAPIList(Page, { method: "get", path, ...opts });
    }
    calculateContentLength(body) {
      if (typeof body === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.byteLength(body, "utf8").toString();
        }
        if (typeof TextEncoder !== "undefined") {
          const encoder = new TextEncoder();
          const encoded = encoder.encode(body);
          return encoded.length.toString();
        }
      } else if (ArrayBuffer.isView(body)) {
        return body.byteLength.toString();
      }
      return null;
    }
    buildRequest(options) {
      const { method, path, query, headers = {} } = options;
      const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
      const contentLength = this.calculateContentLength(body);
      const url = this.buildURL(path, query);
      if ("timeout" in options)
        validatePositiveInteger("timeout", options.timeout);
      const timeout = options.timeout ?? this.timeout;
      const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
      const minAgentTimeout = timeout + 1e3;
      if (typeof httpAgent?.options?.timeout === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
        httpAgent.options.timeout = minAgentTimeout;
      }
      if (this.idempotencyHeader && method !== "get") {
        if (!options.idempotencyKey)
          options.idempotencyKey = this.defaultIdempotencyKey();
        headers[this.idempotencyHeader] = options.idempotencyKey;
      }
      const reqHeaders = this.buildHeaders({ options, headers, contentLength });
      const req = {
        method,
        ...body && { body },
        headers: reqHeaders,
        ...httpAgent && { agent: httpAgent },
        // @ts-ignore node-fetch uses a custom AbortSignal type that is
        // not compatible with standard web types
        signal: options.signal ?? null
      };
      return { req, url, timeout };
    }
    buildHeaders({ options, headers, contentLength }) {
      const reqHeaders = {};
      if (contentLength) {
        reqHeaders["content-length"] = contentLength;
      }
      const defaultHeaders = this.defaultHeaders(options);
      applyHeadersMut(reqHeaders, defaultHeaders);
      applyHeadersMut(reqHeaders, headers);
      if (isMultipartBody(options.body) && kind !== "node") {
        delete reqHeaders["content-type"];
      }
      this.validateHeaders(reqHeaders, headers);
      return reqHeaders;
    }
    /**
     * Used as a callback for mutating the given `FinalRequestOptions` object.
     */
    async prepareOptions(options) {
    }
    /**
     * Used as a callback for mutating the given `RequestInit` object.
     *
     * This is useful for cases where you want to add certain headers based off of
     * the request properties, e.g. `method` or `url`.
     */
    async prepareRequest(request, { url, options }) {
    }
    parseHeaders(headers) {
      return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
    }
    makeStatusError(status, error, message, headers) {
      return APIError.generate(status, error, message, headers);
    }
    request(options, remainingRetries = null) {
      return new APIPromise(this.makeRequest(options, remainingRetries));
    }
    async makeRequest(optionsInput, retriesRemaining) {
      const options = await optionsInput;
      if (retriesRemaining == null) {
        retriesRemaining = options.maxRetries ?? this.maxRetries;
      }
      await this.prepareOptions(options);
      const { req, url, timeout } = this.buildRequest(options);
      await this.prepareRequest(req, { url, options });
      debug("request", url, options, req.headers);
      if (options.signal?.aborted) {
        throw new APIUserAbortError();
      }
      const controller = new AbortController();
      const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
      if (response instanceof Error) {
        if (options.signal?.aborted) {
          throw new APIUserAbortError();
        }
        if (retriesRemaining) {
          return this.retryRequest(options, retriesRemaining);
        }
        if (response.name === "AbortError") {
          throw new APIConnectionTimeoutError();
        }
        throw new APIConnectionError({ cause: response });
      }
      const responseHeaders = createResponseHeaders(response.headers);
      if (!response.ok) {
        if (retriesRemaining && this.shouldRetry(response)) {
          const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
          debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
          return this.retryRequest(options, retriesRemaining, responseHeaders);
        }
        const errText = await response.text().catch((e) => castToError(e).message);
        const errJSON = safeJSON(errText);
        const errMessage = errJSON ? void 0 : errText;
        const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
        debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
        const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
        throw err;
      }
      return { response, options, controller };
    }
    requestAPIList(Page, options) {
      const request = this.makeRequest(options, null);
      return new PagePromise(this, request, Page);
    }
    buildURL(path, query) {
      const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
      const defaultQuery = this.defaultQuery();
      if (!isEmptyObj(defaultQuery)) {
        query = { ...defaultQuery, ...query };
      }
      if (typeof query === "object" && query && !Array.isArray(query)) {
        url.search = this.stringifyQuery(query);
      }
      return url.toString();
    }
    stringifyQuery(query) {
      return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
        }
        if (value === null) {
          return `${encodeURIComponent(key)}=`;
        }
        throw new AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
      }).join("&");
    }
    async fetchWithTimeout(url, init, ms, controller) {
      const { signal, ...options } = init || {};
      if (signal)
        signal.addEventListener("abort", () => controller.abort());
      const timeout = setTimeout(() => controller.abort(), ms);
      return this.getRequestClient().fetch.call(void 0, url, { signal: controller.signal, ...options }).finally(() => {
        clearTimeout(timeout);
      });
    }
    getRequestClient() {
      return { fetch: this.fetch };
    }
    shouldRetry(response) {
      const shouldRetryHeader = response.headers.get("x-should-retry");
      if (shouldRetryHeader === "true")
        return true;
      if (shouldRetryHeader === "false")
        return false;
      if (response.status === 408)
        return true;
      if (response.status === 409)
        return true;
      if (response.status === 429)
        return true;
      if (response.status >= 500)
        return true;
      return false;
    }
    async retryRequest(options, retriesRemaining, responseHeaders) {
      let timeoutMillis;
      const retryAfterMillisHeader = responseHeaders?.["retry-after-ms"];
      if (retryAfterMillisHeader) {
        const timeoutMs = parseFloat(retryAfterMillisHeader);
        if (!Number.isNaN(timeoutMs)) {
          timeoutMillis = timeoutMs;
        }
      }
      const retryAfterHeader = responseHeaders?.["retry-after"];
      if (retryAfterHeader && !timeoutMillis) {
        const timeoutSeconds = parseFloat(retryAfterHeader);
        if (!Number.isNaN(timeoutSeconds)) {
          timeoutMillis = timeoutSeconds * 1e3;
        } else {
          timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
        }
      }
      if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
        const maxRetries = options.maxRetries ?? this.maxRetries;
        timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
      }
      await sleep$1(timeoutMillis);
      return this.makeRequest(options, retriesRemaining - 1);
    }
    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
      const initialRetryDelay = 0.5;
      const maxRetryDelay = 8;
      const numRetries = maxRetries - retriesRemaining;
      const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
      const jitter = 1 - Math.random() * 0.25;
      return sleepSeconds * jitter * 1e3;
    }
    getUserAgent() {
      return `${this.constructor.name}/JS ${VERSION}`;
    }
  }
  class PagePromise extends APIPromise {
    constructor(client2, request, Page) {
      super(request, async (props) => new Page(client2, props.response, await defaultParseResponse(props), props.options));
    }
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    async *[Symbol.asyncIterator]() {
      const page = await this;
      for await (const item of page) {
        yield item;
      }
    }
  }
  const createResponseHeaders = (headers) => {
    return new Proxy(Object.fromEntries(
      // @ts-ignore
      headers.entries()
    ), {
      get(target, name) {
        const key = name.toString();
        return target[key.toLowerCase()] || target[key];
      }
    });
  };
  const getPlatformProperties = () => {
    if (typeof Deno !== "undefined" && Deno.build != null) {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": normalizePlatform(Deno.build.os),
        "X-Stainless-Arch": normalizeArch(Deno.build.arch),
        "X-Stainless-Runtime": "deno",
        "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
      };
    }
    if (typeof EdgeRuntime !== "undefined") {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": `other:${EdgeRuntime}`,
        "X-Stainless-Runtime": "edge",
        "X-Stainless-Runtime-Version": process.version
      };
    }
    if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": normalizePlatform(process.platform),
        "X-Stainless-Arch": normalizeArch(process.arch),
        "X-Stainless-Runtime": "node",
        "X-Stainless-Runtime-Version": process.version
      };
    }
    const browserInfo = getBrowserInfo();
    if (browserInfo) {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
        "X-Stainless-Runtime-Version": browserInfo.version
      };
    }
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": "unknown",
      "X-Stainless-Runtime-Version": "unknown"
    };
  };
  function getBrowserInfo() {
    if (typeof navigator === "undefined" || !navigator) {
      return null;
    }
    const browserPatterns = [
      { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
    ];
    for (const { key, pattern } of browserPatterns) {
      const match = pattern.exec(navigator.userAgent);
      if (match) {
        const major = match[1] || 0;
        const minor = match[2] || 0;
        const patch = match[3] || 0;
        return { browser: key, version: `${major}.${minor}.${patch}` };
      }
    }
    return null;
  }
  const normalizeArch = (arch) => {
    if (arch === "x32")
      return "x32";
    if (arch === "x86_64" || arch === "x64")
      return "x64";
    if (arch === "arm")
      return "arm";
    if (arch === "aarch64" || arch === "arm64")
      return "arm64";
    if (arch)
      return `other:${arch}`;
    return "unknown";
  };
  const normalizePlatform = (platform) => {
    platform = platform.toLowerCase();
    if (platform.includes("ios"))
      return "iOS";
    if (platform === "android")
      return "Android";
    if (platform === "darwin")
      return "MacOS";
    if (platform === "win32")
      return "Windows";
    if (platform === "freebsd")
      return "FreeBSD";
    if (platform === "openbsd")
      return "OpenBSD";
    if (platform === "linux")
      return "Linux";
    if (platform)
      return `Other:${platform}`;
    return "Unknown";
  };
  let _platformHeaders;
  const getPlatformHeaders = () => {
    return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
  };
  const safeJSON = (text) => {
    try {
      return JSON.parse(text);
    } catch (err) {
      return void 0;
    }
  };
  const startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
  const isAbsoluteURL = (url) => {
    return startsWithSchemeRegexp.test(url);
  };
  const sleep$1 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  const validatePositiveInteger = (name, n) => {
    if (typeof n !== "number" || !Number.isInteger(n)) {
      throw new AnthropicError(`${name} must be an integer`);
    }
    if (n < 0) {
      throw new AnthropicError(`${name} must be a positive integer`);
    }
    return n;
  };
  const castToError = (err) => {
    if (err instanceof Error)
      return err;
    return new Error(err);
  };
  const readEnv = (env) => {
    if (typeof process !== "undefined") {
      return process.env?.[env]?.trim() ?? void 0;
    }
    if (typeof Deno !== "undefined") {
      return Deno.env?.get?.(env)?.trim();
    }
    return void 0;
  };
  function isEmptyObj(obj) {
    if (!obj)
      return true;
    for (const _k in obj)
      return false;
    return true;
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function applyHeadersMut(targetHeaders, newHeaders) {
    for (const k in newHeaders) {
      if (!hasOwn(newHeaders, k))
        continue;
      const lowerKey = k.toLowerCase();
      if (!lowerKey)
        continue;
      const val = newHeaders[k];
      if (val === null) {
        delete targetHeaders[lowerKey];
      } else if (val !== void 0) {
        targetHeaders[lowerKey] = val;
      }
    }
  }
  function debug(action, ...args) {
    if (typeof process !== "undefined" && process?.env?.["DEBUG"] === "true") {
      console.log(`Anthropic:DEBUG:${action}`, ...args);
    }
  }
  const uuid4 = () => {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r2 = Math.random() * 16 | 0;
      const v = c === "x" ? r2 : r2 & 3 | 8;
      return v.toString(16);
    });
  };
  const isRunningInBrowser = () => {
    return (
      // @ts-ignore
      typeof window !== "undefined" && // @ts-ignore
      typeof window.document !== "undefined" && // @ts-ignore
      typeof navigator !== "undefined"
    );
  };
  class AnthropicError extends Error {
  }
  class APIError extends AnthropicError {
    constructor(status, error, message, headers) {
      super(`${APIError.makeMessage(status, error, message)}`);
      this.status = status;
      this.headers = headers;
      this.request_id = headers?.["request-id"];
      this.error = error;
    }
    static makeMessage(status, error, message) {
      const msg = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
      if (status && msg) {
        return `${status} ${msg}`;
      }
      if (status) {
        return `${status} status code (no body)`;
      }
      if (msg) {
        return msg;
      }
      return "(no status code or body)";
    }
    static generate(status, errorResponse, message, headers) {
      if (!status) {
        return new APIConnectionError({ message, cause: castToError(errorResponse) });
      }
      const error = errorResponse;
      if (status === 400) {
        return new BadRequestError(status, error, message, headers);
      }
      if (status === 401) {
        return new AuthenticationError(status, error, message, headers);
      }
      if (status === 403) {
        return new PermissionDeniedError(status, error, message, headers);
      }
      if (status === 404) {
        return new NotFoundError(status, error, message, headers);
      }
      if (status === 409) {
        return new ConflictError(status, error, message, headers);
      }
      if (status === 422) {
        return new UnprocessableEntityError(status, error, message, headers);
      }
      if (status === 429) {
        return new RateLimitError(status, error, message, headers);
      }
      if (status >= 500) {
        return new InternalServerError(status, error, message, headers);
      }
      return new APIError(status, error, message, headers);
    }
  }
  class APIUserAbortError extends APIError {
    constructor({ message } = {}) {
      super(void 0, void 0, message || "Request was aborted.", void 0);
      this.status = void 0;
    }
  }
  class APIConnectionError extends APIError {
    constructor({ message, cause }) {
      super(void 0, void 0, message || "Connection error.", void 0);
      this.status = void 0;
      if (cause)
        this.cause = cause;
    }
  }
  class APIConnectionTimeoutError extends APIConnectionError {
    constructor({ message } = {}) {
      super({ message: message ?? "Request timed out." });
    }
  }
  class BadRequestError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 400;
    }
  }
  class AuthenticationError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 401;
    }
  }
  class PermissionDeniedError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 403;
    }
  }
  class NotFoundError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 404;
    }
  }
  class ConflictError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 409;
    }
  }
  class UnprocessableEntityError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 422;
    }
  }
  class RateLimitError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 429;
    }
  }
  class InternalServerError extends APIError {
  }
  class APIResource {
    constructor(client2) {
      this._client = client2;
    }
  }
  const tokenize = (input) => {
    let current = 0;
    let tokens = [];
    while (current < input.length) {
      let char = input[current];
      if (char === "\\") {
        current++;
        continue;
      }
      if (char === "{") {
        tokens.push({
          type: "brace",
          value: "{"
        });
        current++;
        continue;
      }
      if (char === "}") {
        tokens.push({
          type: "brace",
          value: "}"
        });
        current++;
        continue;
      }
      if (char === "[") {
        tokens.push({
          type: "paren",
          value: "["
        });
        current++;
        continue;
      }
      if (char === "]") {
        tokens.push({
          type: "paren",
          value: "]"
        });
        current++;
        continue;
      }
      if (char === ":") {
        tokens.push({
          type: "separator",
          value: ":"
        });
        current++;
        continue;
      }
      if (char === ",") {
        tokens.push({
          type: "delimiter",
          value: ","
        });
        current++;
        continue;
      }
      if (char === '"') {
        let value = "";
        let danglingQuote = false;
        char = input[++current];
        while (char !== '"') {
          if (current === input.length) {
            danglingQuote = true;
            break;
          }
          if (char === "\\") {
            current++;
            if (current === input.length) {
              danglingQuote = true;
              break;
            }
            value += char + input[current];
            char = input[++current];
          } else {
            value += char;
            char = input[++current];
          }
        }
        char = input[++current];
        if (!danglingQuote) {
          tokens.push({
            type: "string",
            value
          });
        }
        continue;
      }
      let WHITESPACE = /\s/;
      if (char && WHITESPACE.test(char)) {
        current++;
        continue;
      }
      let NUMBERS = /[0-9]/;
      if (char && NUMBERS.test(char) || char === "-" || char === ".") {
        let value = "";
        if (char === "-") {
          value += char;
          char = input[++current];
        }
        while (char && NUMBERS.test(char) || char === ".") {
          value += char;
          char = input[++current];
        }
        tokens.push({
          type: "number",
          value
        });
        continue;
      }
      let LETTERS = /[a-z]/i;
      if (char && LETTERS.test(char)) {
        let value = "";
        while (char && LETTERS.test(char)) {
          if (current === input.length) {
            break;
          }
          value += char;
          char = input[++current];
        }
        if (value == "true" || value == "false" || value === "null") {
          tokens.push({
            type: "name",
            value
          });
        } else {
          current++;
          continue;
        }
        continue;
      }
      current++;
    }
    return tokens;
  }, strip = (tokens) => {
    if (tokens.length === 0) {
      return tokens;
    }
    let lastToken = tokens[tokens.length - 1];
    switch (lastToken.type) {
      case "separator":
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      case "number":
        let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
        if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
        }
      case "string":
        let tokenBeforeTheLastToken = tokens[tokens.length - 2];
        if (tokenBeforeTheLastToken?.type === "delimiter") {
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
        } else if (tokenBeforeTheLastToken?.type === "brace" && tokenBeforeTheLastToken.value === "{") {
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
        }
        break;
      case "delimiter":
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
    }
    return tokens;
  }, unstrip = (tokens) => {
    let tail = [];
    tokens.map((token) => {
      if (token.type === "brace") {
        if (token.value === "{") {
          tail.push("}");
        } else {
          tail.splice(tail.lastIndexOf("}"), 1);
        }
      }
      if (token.type === "paren") {
        if (token.value === "[") {
          tail.push("]");
        } else {
          tail.splice(tail.lastIndexOf("]"), 1);
        }
      }
    });
    if (tail.length > 0) {
      tail.reverse().map((item) => {
        if (item === "}") {
          tokens.push({
            type: "brace",
            value: "}"
          });
        } else if (item === "]") {
          tokens.push({
            type: "paren",
            value: "]"
          });
        }
      });
    }
    return tokens;
  }, generate = (tokens) => {
    let output = "";
    tokens.map((token) => {
      switch (token.type) {
        case "string":
          output += '"' + token.value + '"';
          break;
        default:
          output += token.value;
          break;
      }
    });
    return output;
  }, partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));
  var __classPrivateFieldSet$2 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$2 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _PromptCachingBetaMessageStream_instances, _PromptCachingBetaMessageStream_currentMessageSnapshot, _PromptCachingBetaMessageStream_connectedPromise, _PromptCachingBetaMessageStream_resolveConnectedPromise, _PromptCachingBetaMessageStream_rejectConnectedPromise, _PromptCachingBetaMessageStream_endPromise, _PromptCachingBetaMessageStream_resolveEndPromise, _PromptCachingBetaMessageStream_rejectEndPromise, _PromptCachingBetaMessageStream_listeners, _PromptCachingBetaMessageStream_ended, _PromptCachingBetaMessageStream_errored, _PromptCachingBetaMessageStream_aborted, _PromptCachingBetaMessageStream_catchingPromiseCreated, _PromptCachingBetaMessageStream_getFinalMessage, _PromptCachingBetaMessageStream_getFinalText, _PromptCachingBetaMessageStream_handleError, _PromptCachingBetaMessageStream_beginRequest, _PromptCachingBetaMessageStream_addStreamEvent, _PromptCachingBetaMessageStream_endRequest, _PromptCachingBetaMessageStream_accumulateMessage;
  const JSON_BUF_PROPERTY$1 = "__json_buf";
  class PromptCachingBetaMessageStream {
    constructor() {
      _PromptCachingBetaMessageStream_instances.add(this);
      this.messages = [];
      this.receivedMessages = [];
      _PromptCachingBetaMessageStream_currentMessageSnapshot.set(this, void 0);
      this.controller = new AbortController();
      _PromptCachingBetaMessageStream_connectedPromise.set(this, void 0);
      _PromptCachingBetaMessageStream_resolveConnectedPromise.set(this, () => {
      });
      _PromptCachingBetaMessageStream_rejectConnectedPromise.set(this, () => {
      });
      _PromptCachingBetaMessageStream_endPromise.set(this, void 0);
      _PromptCachingBetaMessageStream_resolveEndPromise.set(this, () => {
      });
      _PromptCachingBetaMessageStream_rejectEndPromise.set(this, () => {
      });
      _PromptCachingBetaMessageStream_listeners.set(this, {});
      _PromptCachingBetaMessageStream_ended.set(this, false);
      _PromptCachingBetaMessageStream_errored.set(this, false);
      _PromptCachingBetaMessageStream_aborted.set(this, false);
      _PromptCachingBetaMessageStream_catchingPromiseCreated.set(this, false);
      _PromptCachingBetaMessageStream_handleError.set(this, (error) => {
        __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_errored, true, "f");
        if (error instanceof Error && error.name === "AbortError") {
          error = new APIUserAbortError();
        }
        if (error instanceof APIUserAbortError) {
          __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_aborted, true, "f");
          return this._emit("abort", error);
        }
        if (error instanceof AnthropicError) {
          return this._emit("error", error);
        }
        if (error instanceof Error) {
          const anthropicError = new AnthropicError(error.message);
          anthropicError.cause = error;
          return this._emit("error", anthropicError);
        }
        return this._emit("error", new AnthropicError(String(error)));
      });
      __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_connectedPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_resolveConnectedPromise, resolve, "f");
        __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_rejectConnectedPromise, reject, "f");
      }), "f");
      __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_endPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_resolveEndPromise, resolve, "f");
        __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_rejectEndPromise, reject, "f");
      }), "f");
      __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_connectedPromise, "f").catch(() => {
      });
      __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_endPromise, "f").catch(() => {
      });
    }
    /**
     * Intended for use on the frontend, consuming a stream produced with
     * `.toReadableStream()` on the backend.
     *
     * Note that messages sent to the model do not appear in `.on('message')`
     * in this context.
     */
    static fromReadableStream(stream) {
      const runner = new PromptCachingBetaMessageStream();
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    static createMessage(messages, params, options) {
      const runner = new PromptCachingBetaMessageStream();
      for (const message of params.messages) {
        runner._addPromptCachingBetaMessageParam(message);
      }
      runner._run(() => runner._createPromptCachingBetaMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
      return runner;
    }
    _run(executor) {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_handleError, "f"));
    }
    _addPromptCachingBetaMessageParam(message) {
      this.messages.push(message);
    }
    _addPromptCachingBetaMessage(message, emit = true) {
      this.receivedMessages.push(message);
      if (emit) {
        this._emit("message", message);
      }
    }
    async _createPromptCachingBetaMessage(messages, params, options) {
      const signal = options?.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_beginRequest).call(this);
      const stream = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_addStreamEvent).call(this, event);
      }
      if (stream.controller.signal?.aborted) {
        throw new APIUserAbortError();
      }
      __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_endRequest).call(this);
    }
    _connected() {
      if (this.ended)
        return;
      __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_resolveConnectedPromise, "f").call(this);
      this._emit("connect");
    }
    get ended() {
      return __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_ended, "f");
    }
    get errored() {
      return __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_errored, "f");
    }
    get aborted() {
      return __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_aborted, "f");
    }
    abort() {
      this.controller.abort();
    }
    /**
     * Adds the listener function to the end of the listeners array for the event.
     * No checks are made to see if the listener has already been added. Multiple calls passing
     * the same combination of event and listener will result in the listener being added, and
     * called, multiple times.
     * @returns this PromptCachingBetaMessageStream, so that calls can be chained
     */
    on(event, listener) {
      const listeners = __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_listeners, "f")[event] = []);
      listeners.push({ listener });
      return this;
    }
    /**
     * Removes the specified listener from the listener array for the event.
     * off() will remove, at most, one instance of a listener from the listener array. If any single
     * listener has been added multiple times to the listener array for the specified event, then
     * off() must be called multiple times to remove each instance.
     * @returns this PromptCachingBetaMessageStream, so that calls can be chained
     */
    off(event, listener) {
      const listeners = __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_listeners, "f")[event];
      if (!listeners)
        return this;
      const index2 = listeners.findIndex((l) => l.listener === listener);
      if (index2 >= 0)
        listeners.splice(index2, 1);
      return this;
    }
    /**
     * Adds a one-time listener function for the event. The next time the event is triggered,
     * this listener is removed and then invoked.
     * @returns this PromptCachingBetaMessageStream, so that calls can be chained
     */
    once(event, listener) {
      const listeners = __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_listeners, "f")[event] = []);
      listeners.push({ listener, once: true });
      return this;
    }
    /**
     * This is similar to `.once()`, but returns a Promise that resolves the next time
     * the event is triggered, instead of calling a listener callback.
     * @returns a Promise that resolves the next time given event is triggered,
     * or rejects if an error is emitted.  (If you request the 'error' event,
     * returns a promise that resolves with the error).
     *
     * Example:
     *
     *   const message = await stream.emitted('message') // rejects if the stream errors
     */
    emitted(event) {
      return new Promise((resolve, reject) => {
        __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_catchingPromiseCreated, true, "f");
        if (event !== "error")
          this.once("error", reject);
        this.once(event, resolve);
      });
    }
    async done() {
      __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_catchingPromiseCreated, true, "f");
      await __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_endPromise, "f");
    }
    get currentMessage() {
      return __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, "f");
    }
    /**
     * @returns a promise that resolves with the the final assistant PromptCachingBetaMessage response,
     * or rejects if an error occurred or the stream ended prematurely without producing a PromptCachingBetaMessage.
     */
    async finalMessage() {
      await this.done();
      return __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_getFinalMessage).call(this);
    }
    /**
     * @returns a promise that resolves with the the final assistant PromptCachingBetaMessage's text response, concatenated
     * together if there are more than one text blocks.
     * Rejects if an error occurred or the stream ended prematurely without producing a PromptCachingBetaMessage.
     */
    async finalText() {
      await this.done();
      return __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_getFinalText).call(this);
    }
    _emit(event, ...args) {
      if (__classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_ended, "f"))
        return;
      if (event === "end") {
        __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_ended, true, "f");
        __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_resolveEndPromise, "f").call(this);
      }
      const listeners = __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_listeners, "f")[event];
      if (listeners) {
        __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
        listeners.forEach(({ listener }) => listener(...args));
      }
      if (event === "abort") {
        const error = args[0];
        if (!__classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
        return;
      }
      if (event === "error") {
        const error = args[0];
        if (!__classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
      }
    }
    _emitFinal() {
      const finalPromptCachingBetaMessage = this.receivedMessages.at(-1);
      if (finalPromptCachingBetaMessage) {
        this._emit("finalPromptCachingBetaMessage", __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_getFinalMessage).call(this));
      }
    }
    async _fromReadableStream(readableStream, options) {
      const signal = options?.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_beginRequest).call(this);
      this._connected();
      const stream = Stream.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_addStreamEvent).call(this, event);
      }
      if (stream.controller.signal?.aborted) {
        throw new APIUserAbortError();
      }
      __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_endRequest).call(this);
    }
    [(_PromptCachingBetaMessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_listeners = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_ended = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_errored = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_aborted = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_handleError = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_instances = /* @__PURE__ */ new WeakSet(), _PromptCachingBetaMessageStream_getFinalMessage = function _PromptCachingBetaMessageStream_getFinalMessage2() {
      if (this.receivedMessages.length === 0) {
        throw new AnthropicError("stream ended without producing a PromptCachingBetaMessage with role=assistant");
      }
      return this.receivedMessages.at(-1);
    }, _PromptCachingBetaMessageStream_getFinalText = function _PromptCachingBetaMessageStream_getFinalText2() {
      if (this.receivedMessages.length === 0) {
        throw new AnthropicError("stream ended without producing a PromptCachingBetaMessage with role=assistant");
      }
      const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
      if (textBlocks.length === 0) {
        throw new AnthropicError("stream ended without producing a content block with type=text");
      }
      return textBlocks.join(" ");
    }, _PromptCachingBetaMessageStream_beginRequest = function _PromptCachingBetaMessageStream_beginRequest2() {
      if (this.ended)
        return;
      __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, void 0, "f");
    }, _PromptCachingBetaMessageStream_addStreamEvent = function _PromptCachingBetaMessageStream_addStreamEvent2(event) {
      if (this.ended)
        return;
      const messageSnapshot = __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_accumulateMessage).call(this, event);
      this._emit("streamEvent", event, messageSnapshot);
      switch (event.type) {
        case "content_block_delta": {
          const content2 = messageSnapshot.content.at(-1);
          if (event.delta.type === "text_delta" && content2.type === "text") {
            this._emit("text", event.delta.text, content2.text || "");
          } else if (event.delta.type === "input_json_delta" && content2.type === "tool_use") {
            if (content2.input) {
              this._emit("inputJson", event.delta.partial_json, content2.input);
            }
          }
          break;
        }
        case "message_stop": {
          this._addPromptCachingBetaMessageParam(messageSnapshot);
          this._addPromptCachingBetaMessage(messageSnapshot, true);
          break;
        }
        case "content_block_stop": {
          this._emit("contentBlock", messageSnapshot.content.at(-1));
          break;
        }
        case "message_start": {
          __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, messageSnapshot, "f");
          break;
        }
      }
    }, _PromptCachingBetaMessageStream_endRequest = function _PromptCachingBetaMessageStream_endRequest2() {
      if (this.ended) {
        throw new AnthropicError(`stream has ended, this shouldn't happen`);
      }
      const snapshot = __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, "f");
      if (!snapshot) {
        throw new AnthropicError(`request ended without sending any chunks`);
      }
      __classPrivateFieldSet$2(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, void 0, "f");
      return snapshot;
    }, _PromptCachingBetaMessageStream_accumulateMessage = function _PromptCachingBetaMessageStream_accumulateMessage2(event) {
      let snapshot = __classPrivateFieldGet$2(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, "f");
      if (event.type === "message_start") {
        if (snapshot) {
          throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
        }
        return event.message;
      }
      if (!snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
      }
      switch (event.type) {
        case "message_stop":
          return snapshot;
        case "message_delta":
          snapshot.stop_reason = event.delta.stop_reason;
          snapshot.stop_sequence = event.delta.stop_sequence;
          snapshot.usage.output_tokens = event.usage.output_tokens;
          return snapshot;
        case "content_block_start":
          snapshot.content.push(event.content_block);
          return snapshot;
        case "content_block_delta": {
          const snapshotContent = snapshot.content.at(event.index);
          if (snapshotContent?.type === "text" && event.delta.type === "text_delta") {
            snapshotContent.text += event.delta.text;
          } else if (snapshotContent?.type === "tool_use" && event.delta.type === "input_json_delta") {
            let jsonBuf = snapshotContent[JSON_BUF_PROPERTY$1] || "";
            jsonBuf += event.delta.partial_json;
            Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY$1, {
              value: jsonBuf,
              enumerable: false,
              writable: true
            });
            if (jsonBuf) {
              snapshotContent.input = partialParse(jsonBuf);
            }
          }
          return snapshot;
        }
        case "content_block_stop":
          return snapshot;
      }
    }, Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("streamEvent", (event) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(event);
        } else {
          pushQueue.push(event);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(void 0);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: void 0, done: true };
            }
            return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: void 0, done: true };
        }
      };
    }
    toReadableStream() {
      const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
  }
  let Messages$1 = class Messages extends APIResource {
    create(body, options) {
      return this._client.post("/v1/messages?beta=prompt_caching", {
        body,
        timeout: this._client._options.timeout ?? 6e5,
        ...options,
        headers: { "anthropic-beta": "prompt-caching-2024-07-31", ...options?.headers },
        stream: body.stream ?? false
      });
    }
    /**
     * Create a Message stream
     */
    stream(body, options) {
      return PromptCachingBetaMessageStream.createMessage(this, body, options);
    }
  };
  /* @__PURE__ */ (function(Messages2) {
  })(Messages$1 || (Messages$1 = {}));
  class PromptCaching extends APIResource {
    constructor() {
      super(...arguments);
      this.messages = new Messages$1(this._client);
    }
  }
  (function(PromptCaching2) {
    PromptCaching2.Messages = Messages$1;
  })(PromptCaching || (PromptCaching = {}));
  class Beta extends APIResource {
    constructor() {
      super(...arguments);
      this.promptCaching = new PromptCaching(this._client);
    }
  }
  (function(Beta2) {
    Beta2.PromptCaching = PromptCaching;
  })(Beta || (Beta = {}));
  class Completions extends APIResource {
    create(body, options) {
      return this._client.post("/v1/complete", {
        body,
        timeout: this._client._options.timeout ?? 6e5,
        ...options,
        stream: body.stream ?? false
      });
    }
  }
  /* @__PURE__ */ (function(Completions2) {
  })(Completions || (Completions = {}));
  var __classPrivateFieldSet$1 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$1 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _MessageStream_instances, _MessageStream_currentMessageSnapshot, _MessageStream_connectedPromise, _MessageStream_resolveConnectedPromise, _MessageStream_rejectConnectedPromise, _MessageStream_endPromise, _MessageStream_resolveEndPromise, _MessageStream_rejectEndPromise, _MessageStream_listeners, _MessageStream_ended, _MessageStream_errored, _MessageStream_aborted, _MessageStream_catchingPromiseCreated, _MessageStream_getFinalMessage, _MessageStream_getFinalText, _MessageStream_handleError, _MessageStream_beginRequest, _MessageStream_addStreamEvent, _MessageStream_endRequest, _MessageStream_accumulateMessage;
  const JSON_BUF_PROPERTY = "__json_buf";
  class MessageStream {
    constructor() {
      _MessageStream_instances.add(this);
      this.messages = [];
      this.receivedMessages = [];
      _MessageStream_currentMessageSnapshot.set(this, void 0);
      this.controller = new AbortController();
      _MessageStream_connectedPromise.set(this, void 0);
      _MessageStream_resolveConnectedPromise.set(this, () => {
      });
      _MessageStream_rejectConnectedPromise.set(this, () => {
      });
      _MessageStream_endPromise.set(this, void 0);
      _MessageStream_resolveEndPromise.set(this, () => {
      });
      _MessageStream_rejectEndPromise.set(this, () => {
      });
      _MessageStream_listeners.set(this, {});
      _MessageStream_ended.set(this, false);
      _MessageStream_errored.set(this, false);
      _MessageStream_aborted.set(this, false);
      _MessageStream_catchingPromiseCreated.set(this, false);
      _MessageStream_handleError.set(this, (error) => {
        __classPrivateFieldSet$1(this, _MessageStream_errored, true, "f");
        if (error instanceof Error && error.name === "AbortError") {
          error = new APIUserAbortError();
        }
        if (error instanceof APIUserAbortError) {
          __classPrivateFieldSet$1(this, _MessageStream_aborted, true, "f");
          return this._emit("abort", error);
        }
        if (error instanceof AnthropicError) {
          return this._emit("error", error);
        }
        if (error instanceof Error) {
          const anthropicError = new AnthropicError(error.message);
          anthropicError.cause = error;
          return this._emit("error", anthropicError);
        }
        return this._emit("error", new AnthropicError(String(error)));
      });
      __classPrivateFieldSet$1(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$1(this, _MessageStream_resolveConnectedPromise, resolve, "f");
        __classPrivateFieldSet$1(this, _MessageStream_rejectConnectedPromise, reject, "f");
      }), "f");
      __classPrivateFieldSet$1(this, _MessageStream_endPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$1(this, _MessageStream_resolveEndPromise, resolve, "f");
        __classPrivateFieldSet$1(this, _MessageStream_rejectEndPromise, reject, "f");
      }), "f");
      __classPrivateFieldGet$1(this, _MessageStream_connectedPromise, "f").catch(() => {
      });
      __classPrivateFieldGet$1(this, _MessageStream_endPromise, "f").catch(() => {
      });
    }
    /**
     * Intended for use on the frontend, consuming a stream produced with
     * `.toReadableStream()` on the backend.
     *
     * Note that messages sent to the model do not appear in `.on('message')`
     * in this context.
     */
    static fromReadableStream(stream) {
      const runner = new MessageStream();
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    static createMessage(messages, params, options) {
      const runner = new MessageStream();
      for (const message of params.messages) {
        runner._addMessageParam(message);
      }
      runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
      return runner;
    }
    _run(executor) {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet$1(this, _MessageStream_handleError, "f"));
    }
    _addMessageParam(message) {
      this.messages.push(message);
    }
    _addMessage(message, emit = true) {
      this.receivedMessages.push(message);
      if (emit) {
        this._emit("message", message);
      }
    }
    async _createMessage(messages, params, options) {
      const signal = options?.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$1(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
      const stream = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet$1(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
      }
      if (stream.controller.signal?.aborted) {
        throw new APIUserAbortError();
      }
      __classPrivateFieldGet$1(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
    }
    _connected() {
      if (this.ended)
        return;
      __classPrivateFieldGet$1(this, _MessageStream_resolveConnectedPromise, "f").call(this);
      this._emit("connect");
    }
    get ended() {
      return __classPrivateFieldGet$1(this, _MessageStream_ended, "f");
    }
    get errored() {
      return __classPrivateFieldGet$1(this, _MessageStream_errored, "f");
    }
    get aborted() {
      return __classPrivateFieldGet$1(this, _MessageStream_aborted, "f");
    }
    abort() {
      this.controller.abort();
    }
    /**
     * Adds the listener function to the end of the listeners array for the event.
     * No checks are made to see if the listener has already been added. Multiple calls passing
     * the same combination of event and listener will result in the listener being added, and
     * called, multiple times.
     * @returns this MessageStream, so that calls can be chained
     */
    on(event, listener) {
      const listeners = __classPrivateFieldGet$1(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet$1(this, _MessageStream_listeners, "f")[event] = []);
      listeners.push({ listener });
      return this;
    }
    /**
     * Removes the specified listener from the listener array for the event.
     * off() will remove, at most, one instance of a listener from the listener array. If any single
     * listener has been added multiple times to the listener array for the specified event, then
     * off() must be called multiple times to remove each instance.
     * @returns this MessageStream, so that calls can be chained
     */
    off(event, listener) {
      const listeners = __classPrivateFieldGet$1(this, _MessageStream_listeners, "f")[event];
      if (!listeners)
        return this;
      const index2 = listeners.findIndex((l) => l.listener === listener);
      if (index2 >= 0)
        listeners.splice(index2, 1);
      return this;
    }
    /**
     * Adds a one-time listener function for the event. The next time the event is triggered,
     * this listener is removed and then invoked.
     * @returns this MessageStream, so that calls can be chained
     */
    once(event, listener) {
      const listeners = __classPrivateFieldGet$1(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet$1(this, _MessageStream_listeners, "f")[event] = []);
      listeners.push({ listener, once: true });
      return this;
    }
    /**
     * This is similar to `.once()`, but returns a Promise that resolves the next time
     * the event is triggered, instead of calling a listener callback.
     * @returns a Promise that resolves the next time given event is triggered,
     * or rejects if an error is emitted.  (If you request the 'error' event,
     * returns a promise that resolves with the error).
     *
     * Example:
     *
     *   const message = await stream.emitted('message') // rejects if the stream errors
     */
    emitted(event) {
      return new Promise((resolve, reject) => {
        __classPrivateFieldSet$1(this, _MessageStream_catchingPromiseCreated, true, "f");
        if (event !== "error")
          this.once("error", reject);
        this.once(event, resolve);
      });
    }
    async done() {
      __classPrivateFieldSet$1(this, _MessageStream_catchingPromiseCreated, true, "f");
      await __classPrivateFieldGet$1(this, _MessageStream_endPromise, "f");
    }
    get currentMessage() {
      return __classPrivateFieldGet$1(this, _MessageStream_currentMessageSnapshot, "f");
    }
    /**
     * @returns a promise that resolves with the the final assistant Message response,
     * or rejects if an error occurred or the stream ended prematurely without producing a Message.
     */
    async finalMessage() {
      await this.done();
      return __classPrivateFieldGet$1(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this);
    }
    /**
     * @returns a promise that resolves with the the final assistant Message's text response, concatenated
     * together if there are more than one text blocks.
     * Rejects if an error occurred or the stream ended prematurely without producing a Message.
     */
    async finalText() {
      await this.done();
      return __classPrivateFieldGet$1(this, _MessageStream_instances, "m", _MessageStream_getFinalText).call(this);
    }
    _emit(event, ...args) {
      if (__classPrivateFieldGet$1(this, _MessageStream_ended, "f"))
        return;
      if (event === "end") {
        __classPrivateFieldSet$1(this, _MessageStream_ended, true, "f");
        __classPrivateFieldGet$1(this, _MessageStream_resolveEndPromise, "f").call(this);
      }
      const listeners = __classPrivateFieldGet$1(this, _MessageStream_listeners, "f")[event];
      if (listeners) {
        __classPrivateFieldGet$1(this, _MessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
        listeners.forEach(({ listener }) => listener(...args));
      }
      if (event === "abort") {
        const error = args[0];
        if (!__classPrivateFieldGet$1(this, _MessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$1(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$1(this, _MessageStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
        return;
      }
      if (event === "error") {
        const error = args[0];
        if (!__classPrivateFieldGet$1(this, _MessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$1(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$1(this, _MessageStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
      }
    }
    _emitFinal() {
      const finalMessage = this.receivedMessages.at(-1);
      if (finalMessage) {
        this._emit("finalMessage", __classPrivateFieldGet$1(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this));
      }
    }
    async _fromReadableStream(readableStream, options) {
      const signal = options?.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$1(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
      this._connected();
      const stream = Stream.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet$1(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
      }
      if (stream.controller.signal?.aborted) {
        throw new APIUserAbortError();
      }
      __classPrivateFieldGet$1(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
    }
    [(_MessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _MessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_listeners = /* @__PURE__ */ new WeakMap(), _MessageStream_ended = /* @__PURE__ */ new WeakMap(), _MessageStream_errored = /* @__PURE__ */ new WeakMap(), _MessageStream_aborted = /* @__PURE__ */ new WeakMap(), _MessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _MessageStream_handleError = /* @__PURE__ */ new WeakMap(), _MessageStream_instances = /* @__PURE__ */ new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage2() {
      if (this.receivedMessages.length === 0) {
        throw new AnthropicError("stream ended without producing a Message with role=assistant");
      }
      return this.receivedMessages.at(-1);
    }, _MessageStream_getFinalText = function _MessageStream_getFinalText2() {
      if (this.receivedMessages.length === 0) {
        throw new AnthropicError("stream ended without producing a Message with role=assistant");
      }
      const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
      if (textBlocks.length === 0) {
        throw new AnthropicError("stream ended without producing a content block with type=text");
      }
      return textBlocks.join(" ");
    }, _MessageStream_beginRequest = function _MessageStream_beginRequest2() {
      if (this.ended)
        return;
      __classPrivateFieldSet$1(this, _MessageStream_currentMessageSnapshot, void 0, "f");
    }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent2(event) {
      if (this.ended)
        return;
      const messageSnapshot = __classPrivateFieldGet$1(this, _MessageStream_instances, "m", _MessageStream_accumulateMessage).call(this, event);
      this._emit("streamEvent", event, messageSnapshot);
      switch (event.type) {
        case "content_block_delta": {
          const content2 = messageSnapshot.content.at(-1);
          if (event.delta.type === "text_delta" && content2.type === "text") {
            this._emit("text", event.delta.text, content2.text || "");
          } else if (event.delta.type === "input_json_delta" && content2.type === "tool_use") {
            if (content2.input) {
              this._emit("inputJson", event.delta.partial_json, content2.input);
            }
          }
          break;
        }
        case "message_stop": {
          this._addMessageParam(messageSnapshot);
          this._addMessage(messageSnapshot, true);
          break;
        }
        case "content_block_stop": {
          this._emit("contentBlock", messageSnapshot.content.at(-1));
          break;
        }
        case "message_start": {
          __classPrivateFieldSet$1(this, _MessageStream_currentMessageSnapshot, messageSnapshot, "f");
          break;
        }
      }
    }, _MessageStream_endRequest = function _MessageStream_endRequest2() {
      if (this.ended) {
        throw new AnthropicError(`stream has ended, this shouldn't happen`);
      }
      const snapshot = __classPrivateFieldGet$1(this, _MessageStream_currentMessageSnapshot, "f");
      if (!snapshot) {
        throw new AnthropicError(`request ended without sending any chunks`);
      }
      __classPrivateFieldSet$1(this, _MessageStream_currentMessageSnapshot, void 0, "f");
      return snapshot;
    }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage2(event) {
      let snapshot = __classPrivateFieldGet$1(this, _MessageStream_currentMessageSnapshot, "f");
      if (event.type === "message_start") {
        if (snapshot) {
          throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
        }
        return event.message;
      }
      if (!snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
      }
      switch (event.type) {
        case "message_stop":
          return snapshot;
        case "message_delta":
          snapshot.stop_reason = event.delta.stop_reason;
          snapshot.stop_sequence = event.delta.stop_sequence;
          snapshot.usage.output_tokens = event.usage.output_tokens;
          return snapshot;
        case "content_block_start":
          snapshot.content.push(event.content_block);
          return snapshot;
        case "content_block_delta": {
          const snapshotContent = snapshot.content.at(event.index);
          if (snapshotContent?.type === "text" && event.delta.type === "text_delta") {
            snapshotContent.text += event.delta.text;
          } else if (snapshotContent?.type === "tool_use" && event.delta.type === "input_json_delta") {
            let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || "";
            jsonBuf += event.delta.partial_json;
            Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {
              value: jsonBuf,
              enumerable: false,
              writable: true
            });
            if (jsonBuf) {
              snapshotContent.input = partialParse(jsonBuf);
            }
          }
          return snapshot;
        }
        case "content_block_stop":
          return snapshot;
      }
    }, Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("streamEvent", (event) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(event);
        } else {
          pushQueue.push(event);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(void 0);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: void 0, done: true };
            }
            return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: void 0, done: true };
        }
      };
    }
    toReadableStream() {
      const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
  }
  class Messages extends APIResource {
    create(body, options) {
      if (body.model in DEPRECATED_MODELS) {
        console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
      }
      return this._client.post("/v1/messages", {
        body,
        timeout: this._client._options.timeout ?? 6e5,
        ...options,
        stream: body.stream ?? false
      });
    }
    /**
     * Create a Message stream
     */
    stream(body, options) {
      return MessageStream.createMessage(this, body, options);
    }
  }
  const DEPRECATED_MODELS = {
    "claude-1.3": "November 6th, 2024",
    "claude-1.3-100k": "November 6th, 2024",
    "claude-instant-1.1": "November 6th, 2024",
    "claude-instant-1.1-100k": "November 6th, 2024",
    "claude-instant-1.2": "November 6th, 2024"
  };
  /* @__PURE__ */ (function(Messages2) {
  })(Messages || (Messages = {}));
  var _a$1;
  class Anthropic extends APIClient {
    /**
     * API Client for interfacing with the Anthropic API.
     *
     * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
     * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
     * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
     */
    constructor({ baseURL = readEnv("ANTHROPIC_BASE_URL"), apiKey = readEnv("ANTHROPIC_API_KEY") ?? null, authToken = readEnv("ANTHROPIC_AUTH_TOKEN") ?? null, ...opts } = {}) {
      const options = {
        apiKey,
        authToken,
        ...opts,
        baseURL: baseURL || `https://api.anthropic.com`
      };
      if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
        throw new AnthropicError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\n\nTODO: link!\n");
      }
      super({
        baseURL: options.baseURL,
        timeout: options.timeout ?? 6e5,
        httpAgent: options.httpAgent,
        maxRetries: options.maxRetries,
        fetch: options.fetch
      });
      this.completions = new Completions(this);
      this.messages = new Messages(this);
      this.beta = new Beta(this);
      this._options = options;
      this.apiKey = apiKey;
      this.authToken = authToken;
    }
    defaultQuery() {
      return this._options.defaultQuery;
    }
    defaultHeaders(opts) {
      return {
        ...super.defaultHeaders(opts),
        ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
        "anthropic-version": "2023-06-01",
        ...this._options.defaultHeaders
      };
    }
    validateHeaders(headers, customHeaders) {
      if (this.apiKey && headers["x-api-key"]) {
        return;
      }
      if (customHeaders["x-api-key"] === null) {
        return;
      }
      if (this.authToken && headers["authorization"]) {
        return;
      }
      if (customHeaders["authorization"] === null) {
        return;
      }
      throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
    }
    authHeaders(opts) {
      const apiKeyAuth = this.apiKeyAuth(opts);
      const bearerAuth = this.bearerAuth(opts);
      if (apiKeyAuth != null && !isEmptyObj(apiKeyAuth)) {
        return apiKeyAuth;
      }
      if (bearerAuth != null && !isEmptyObj(bearerAuth)) {
        return bearerAuth;
      }
      return {};
    }
    apiKeyAuth(opts) {
      if (this.apiKey == null) {
        return {};
      }
      return { "X-Api-Key": this.apiKey };
    }
    bearerAuth(opts) {
      if (this.authToken == null) {
        return {};
      }
      return { Authorization: `Bearer ${this.authToken}` };
    }
  }
  _a$1 = Anthropic;
  Anthropic.Anthropic = _a$1;
  Anthropic.HUMAN_PROMPT = "\n\nHuman:";
  Anthropic.AI_PROMPT = "\n\nAssistant:";
  Anthropic.DEFAULT_TIMEOUT = 6e5;
  Anthropic.AnthropicError = AnthropicError;
  Anthropic.APIError = APIError;
  Anthropic.APIConnectionError = APIConnectionError;
  Anthropic.APIConnectionTimeoutError = APIConnectionTimeoutError;
  Anthropic.APIUserAbortError = APIUserAbortError;
  Anthropic.NotFoundError = NotFoundError;
  Anthropic.ConflictError = ConflictError;
  Anthropic.RateLimitError = RateLimitError;
  Anthropic.BadRequestError = BadRequestError;
  Anthropic.AuthenticationError = AuthenticationError;
  Anthropic.InternalServerError = InternalServerError;
  Anthropic.PermissionDeniedError = PermissionDeniedError;
  Anthropic.UnprocessableEntityError = UnprocessableEntityError;
  Anthropic.toFile = toFile;
  Anthropic.fileFromPath = fileFromPath;
  const { HUMAN_PROMPT, AI_PROMPT } = Anthropic;
  (function(Anthropic2) {
    Anthropic2.Completions = Completions;
    Anthropic2.Messages = Messages;
    Anthropic2.Beta = Beta;
  })(Anthropic || (Anthropic = {}));
  async function generateLinkedInMessage(context) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "generateLinkedInMessage", {
      recipient: context.recipientProfile.name,
      degree: context.degreeOfSeparation
    });
    try {
      log$1.info(LogCategory.SERVICE, "Generating personalized LinkedIn message", {
        recipient: context.recipientProfile.name,
        isDirectConnection: context.isDirectConnection,
        hasMutualConnections: (context.mutualConnections?.length || 0) > 0
      });
      const apiKey = process.env.VITE_ANTHROPIC_API_KEY;
      if (!apiKey) {
        throw new Error("VITE_ANTHROPIC_API_KEY environment variable not set");
      }
      const anthropic = new Anthropic({ apiKey });
      const prompt = buildMessagePrompt(context);
      log$1.debug(LogCategory.SERVICE, "Sending request to Claude API");
      const message = await anthropic.messages.create({
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 500,
        temperature: 0.6,
        // Slightly higher for natural variation
        messages: [
          {
            role: "user",
            content: prompt
          }
        ]
      });
      const responseText = message.content[0].type === "text" ? message.content[0].text : "";
      const personalizationPoints = extractPersonalizationPoints(context);
      const confidence = calculateConfidence$1(context);
      const result2 = {
        message: responseText.trim(),
        characterCount: responseText.trim().length,
        personalizationPoints,
        confidence
      };
      log$1.info(LogCategory.SERVICE, "Message generation complete", {
        characterCount: result2.characterCount,
        confidence: result2.confidence,
        personalizationPoints: result2.personalizationPoints.length
      });
      endTrace();
      return result2;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Message generation failed", error);
      endTrace();
      throw error;
    }
  }
  function buildMessagePrompt(context) {
    const { senderProfile, recipientProfile, mutualConnections, degreeOfSeparation, referralFrom, targetGoal } = context;
    const commonSkills = findCommonSkills(senderProfile, recipientProfile);
    const commonEducation = findCommonEducation(senderProfile, recipientProfile);
    const commonCompanies = findCommonCompanies(senderProfile, recipientProfile);
    const industryConnection = findIndustryConnection(senderProfile, recipientProfile);
    let contextSections = "";
    if (mutualConnections && mutualConnections.length > 0) {
      const mutualNames = mutualConnections.slice(0, 3).filter((m) => m && m.name).map((m) => m.name).join(", ");
      contextSections += `
MUTUAL CONNECTIONS: ${mutualNames}${mutualConnections.length > 3 ? ` and ${mutualConnections.length - 3} others` : ""}`;
    }
    if (commonSkills.length > 0) {
      contextSections += `
COMMON SKILLS: ${commonSkills.slice(0, 3).join(", ")}`;
    }
    if (commonEducation.length > 0) {
      contextSections += `
COMMON EDUCATION: ${commonEducation.join(", ")}`;
    }
    if (commonCompanies.length > 0) {
      contextSections += `
COMMON COMPANIES: ${commonCompanies.join(", ")}`;
    }
    if (industryConnection) {
      contextSections += `
INDUSTRY CONNECTION: ${industryConnection}`;
    }
    if (recipientProfile.recentPosts && recipientProfile.recentPosts.length > 0) {
      const recentPost = recipientProfile.recentPosts[0];
      contextSections += `
RECENT ACTIVITY: Recently posted about "${recentPost.content.substring(0, 100)}..."`;
    }
    const prompt = `You are writing a personalized LinkedIn connection request or introduction message.

STRICT RULES:
1. ONLY use information provided below - DO NOT invent details
2. Keep it under 300 characters for connection requests (LinkedIn limit)
3. For introduction requests, keep it under 1000 characters
4. Be genuine and specific - reference REAL commonalities
5. DO NOT use generic phrases like "I'd love to connect" or "expand my network"
6. DO NOT mention "mutual connections" unless there are specific names
7. Focus on ONE specific commonality or reason
8. End with a clear, soft call-to-action

YOUR PROFILE (SENDER):
- Name: ${senderProfile.name}
- Headline: ${senderProfile.headline || "Professional"}
- Industry: ${senderProfile.industry || "Not specified"}
- Current Role: ${senderProfile.experience?.[0]?.title || "Not specified"}
- Location: ${senderProfile.location || "Not specified"}

RECIPIENT PROFILE:
- Name: ${recipientProfile.name}
- Headline: ${recipientProfile.headline || "Professional"}
- Industry: ${recipientProfile.industry || "Not specified"}
- Current Role: ${recipientProfile.experience?.[0]?.title || "Not specified"} at ${recipientProfile.experience?.[0]?.company || "company"}
- Location: ${recipientProfile.location || "Not specified"}
${contextSections}

${referralFrom ? `
REFERRAL CONTEXT:
Asking ${referralFrom.name} to introduce you to ${recipientProfile.name}` : ""}

${targetGoal ? `
GOAL: ${targetGoal}` : ""}

MESSAGE TYPE: ${referralFrom ? "Introduction request to mutual connection" : degreeOfSeparation === 1 ? "Direct connection request" : "Connection request with path context"}

Write ONLY the message text. Be conversational, specific, and authentic.

Begin:`;
    return prompt;
  }
  function extractPersonalizationPoints(context) {
    const points = [];
    if (context.mutualConnections && context.mutualConnections.length > 0) {
      points.push(`${context.mutualConnections.length} mutual connection${context.mutualConnections.length > 1 ? "s" : ""}`);
    }
    const commonSkills = findCommonSkills(context.senderProfile, context.recipientProfile);
    if (commonSkills.length > 0) {
      points.push(`${commonSkills.length} shared skill${commonSkills.length > 1 ? "s" : ""}`);
    }
    const commonEducation = findCommonEducation(context.senderProfile, context.recipientProfile);
    if (commonEducation.length > 0) {
      points.push("Same school");
    }
    const commonCompanies = findCommonCompanies(context.senderProfile, context.recipientProfile);
    if (commonCompanies.length > 0) {
      points.push("Same company");
    }
    if (context.recipientProfile.industry && context.senderProfile.industry && context.recipientProfile.industry === context.senderProfile.industry) {
      points.push("Same industry");
    }
    if (context.recipientProfile.recentPosts && context.recipientProfile.recentPosts.length > 0) {
      points.push("Recent activity");
    }
    return points;
  }
  function calculateConfidence$1(context) {
    let confidence = 0.5;
    if (context.mutualConnections && context.mutualConnections.length > 0) {
      confidence += 0.2;
    }
    const commonSkills = findCommonSkills(context.senderProfile, context.recipientProfile);
    const commonEducation = findCommonEducation(context.senderProfile, context.recipientProfile);
    const commonCompanies = findCommonCompanies(context.senderProfile, context.recipientProfile);
    if (commonEducation.length > 0) confidence += 0.15;
    if (commonCompanies.length > 0) confidence += 0.1;
    if (commonSkills.length >= 3) confidence += 0.05;
    if (context.recipientProfile.recentPosts && context.recipientProfile.recentPosts.length > 0) {
      confidence += 0.1;
    }
    return Math.min(1, confidence);
  }
  function findCommonSkills(profile1, profile2) {
    const skills2 = new Set(profile2.skills.map((s) => s.name.toLowerCase()));
    return profile1.skills.filter((s) => skills2.has(s.name.toLowerCase())).map((s) => s.name);
  }
  function findCommonEducation(profile1, profile2) {
    const schools2 = new Set(profile2.education.map((e) => e.school.toLowerCase()));
    return profile1.education.filter((e) => schools2.has(e.school.toLowerCase())).map((e) => e.school);
  }
  function findCommonCompanies(profile1, profile2) {
    const companies2 = new Set(profile2.experience.map((e) => e.company.toLowerCase()));
    return profile1.experience.filter((e) => companies2.has(e.company.toLowerCase())).map((e) => e.company);
  }
  function findIndustryConnection(profile1, profile2) {
    if (!profile1.industry || !profile2.industry) return null;
    if (profile1.industry.toLowerCase() === profile2.industry.toLowerCase()) {
      return `Both in ${profile1.industry}`;
    }
    return null;
  }
  content;
  function MessageGenerator({
    senderProfile,
    recipientProfile,
    degreeOfSeparation,
    mutualConnections = [],
    isDirectConnection = false,
    referralFrom,
    targetGoal,
    variant = "compact"
  }) {
    const [isGenerating, setIsGenerating] = reactExports.useState(false);
    const [generatedMessage, setGeneratedMessage] = reactExports.useState(null);
    const [personalizationPoints, setPersonalizationPoints] = reactExports.useState([]);
    const [confidence, setConfidence] = reactExports.useState(0);
    const [error, setError] = reactExports.useState(null);
    const [isCopied, setIsCopied] = reactExports.useState(false);
    const handleGenerate = async () => {
      setIsGenerating(true);
      setError(null);
      try {
        const context = {
          senderProfile,
          recipientProfile,
          isDirectConnection,
          mutualConnections: mutualConnections.length > 0 ? mutualConnections : void 0,
          degreeOfSeparation,
          referralFrom,
          targetGoal
        };
        const result2 = await generateLinkedInMessage(context);
        setGeneratedMessage(result2.message);
        setPersonalizationPoints(result2.personalizationPoints);
        setConfidence(result2.confidence);
      } catch (err) {
        console.error("Failed to generate message:", err);
        setError(err instanceof Error ? err.message : "Failed to generate message");
      } finally {
        setIsGenerating(false);
      }
    };
    const handleCopy = async () => {
      if (!generatedMessage) return;
      try {
        await navigator.clipboard.writeText(generatedMessage);
        setIsCopied(true);
        setTimeout(() => setIsCopied(false), 2e3);
      } catch (err) {
        console.error("Failed to copy:", err);
      }
    };
    const handleReset = () => {
      setGeneratedMessage(null);
      setPersonalizationPoints([]);
      setConfidence(0);
      setError(null);
      setIsCopied(false);
    };
    if (variant === "compact" && !generatedMessage) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick: handleGenerate,
          disabled: isGenerating,
          variant: "secondary",
          size: "sm",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 14 }),
          children: isGenerating ? "Generating..." : "Generate Message"
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: `${SPACING.md}px`,
          backgroundColor: COLORS.background.secondary,
          borderRadius: `${RADIUS.md}px`,
          border: `1px solid ${COLORS.border.light}`
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                marginBottom: `${SPACING.sm}px`
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: `${SPACING.xs}px` }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: ICON.size.sm, color: COLORS.accent.default }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      style: {
                        fontSize: `${TYPOGRAPHY.fontSize.sm}px`,
                        fontWeight: TYPOGRAPHY.fontWeight.semibold,
                        color: COLORS.text.primary
                      },
                      children: "AI-Generated Message"
                    }
                  )
                ] }),
                generatedMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: handleReset,
                    style: {
                      fontSize: `${TYPOGRAPHY.fontSize.xs}px`,
                      color: COLORS.text.tertiary,
                      background: "none",
                      border: "none",
                      cursor: "pointer",
                      padding: `${SPACING.xxs}px ${SPACING.xs}px`
                    },
                    children: "Regenerate"
                  }
                )
              ]
            }
          ),
          !generatedMessage && variant === "full" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: `${SPACING.md}px` }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: handleGenerate,
              disabled: isGenerating,
              fullWidth: true,
              variant: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 16 }),
              children: isGenerating ? "Generating Message..." : "Generate Personalized Message"
            }
          ) }),
          error && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "flex-start",
                gap: `${SPACING.xs}px`,
                padding: `${SPACING.sm}px`,
                backgroundColor: COLORS.status.errorBg,
                borderRadius: `${RADIUS.sm}px`,
                marginTop: `${SPACING.sm}px`
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: ICON.size.sm, color: COLORS.status.error }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        fontSize: `${TYPOGRAPHY.fontSize.sm}px`,
                        fontWeight: TYPOGRAPHY.fontWeight.semibold,
                        color: COLORS.status.error
                      },
                      children: "Generation Failed"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        fontSize: `${TYPOGRAPHY.fontSize.xs}px`,
                        color: COLORS.text.secondary,
                        marginTop: "2px"
                      },
                      children: error
                    }
                  )
                ] })
              ]
            }
          ),
          generatedMessage && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  padding: `${SPACING.sm}px`,
                  backgroundColor: COLORS.background.primary,
                  borderRadius: `${RADIUS.sm}px`,
                  border: `1px solid ${COLORS.border.light}`,
                  marginBottom: `${SPACING.sm}px`,
                  position: "relative"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        fontSize: `${TYPOGRAPHY.fontSize.sm}px`,
                        color: COLORS.text.primary,
                        lineHeight: TYPOGRAPHY.lineHeight.relaxed,
                        whiteSpace: "pre-wrap",
                        wordBreak: "break-word"
                      },
                      children: generatedMessage
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        fontSize: `${TYPOGRAPHY.fontSize.xs}px`,
                        color: COLORS.text.tertiary,
                        marginTop: `${SPACING.xs}px`,
                        textAlign: "right"
                      },
                      children: [
                        generatedMessage.length,
                        " characters"
                      ]
                    }
                  )
                ]
              }
            ),
            personalizationPoints.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  display: "flex",
                  flexWrap: "wrap",
                  gap: `${SPACING.xxs}px`,
                  marginBottom: `${SPACING.sm}px`
                },
                children: personalizationPoints.map((point, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      fontSize: `${TYPOGRAPHY.fontSize.xs}px`,
                      color: COLORS.accent.default,
                      backgroundColor: COLORS.accent.lighter,
                      padding: "2px 8px",
                      borderRadius: `${RADIUS.sm}px`
                    },
                    children: point
                  },
                  index2
                ))
              }
            ),
            confidence > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  fontSize: `${TYPOGRAPHY.fontSize.xs}px`,
                  color: COLORS.text.secondary,
                  marginBottom: `${SPACING.sm}px`
                },
                children: [
                  "Personalization quality:",
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "span",
                    {
                      style: {
                        fontWeight: TYPOGRAPHY.fontWeight.semibold,
                        color: confidence >= 0.7 ? COLORS.status.success : confidence >= 0.5 ? COLORS.accent.default : COLORS.text.tertiary
                      },
                      children: [
                        Math.round(confidence * 100),
                        "%"
                      ]
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                onClick: handleCopy,
                disabled: isCopied,
                fullWidth: true,
                variant: "secondary",
                icon: isCopied ? /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 16 }),
                children: isCopied ? "Copied!" : "Copy to Clipboard"
              }
            )
          ] })
        ]
      }
    );
  }
  content;
  function RouteResultCard({
    route,
    onSaveToWatchlist,
    onClose,
    isSaving = false
  }) {
    const validNodes = (route.nodes || []).filter(
      (node) => node != null && node.profile != null && typeof node.profile.name === "string"
    );
    if (validNodes.length !== route.nodes?.length) {
      console.warn("[Uproot] [RouteResultCard] Filtered invalid nodes:", {
        original: route.nodes?.length || 0,
        valid: validNodes.length,
        filtered: (route.nodes?.length || 0) - validNodes.length
      });
    }
    console.log("[Uproot] [RouteResultCard] Rendering with nodes:", {
      count: validNodes.length,
      hasAllProfiles: validNodes.every((n) => n.profile != null),
      hasAllNames: validNodes.every((n) => n.profile?.name != null),
      hasAllAvatars: validNodes.every((n) => n.profile?.avatarUrl != null),
      nodes: validNodes.map((n, i) => ({
        index: i,
        name: n.profile?.name,
        hasAvatar: !!n.profile?.avatarUrl,
        avatarUrl: n.profile?.avatarUrl?.substring(0, 50) + "..."
      }))
    });
    const totalSteps = validNodes.length - 1;
    const degreeOfSeparation = validNodes.length - 1;
    const [expandedMessages, setExpandedMessages] = reactExports.useState(/* @__PURE__ */ new Set());
    const toggleMessageGenerator = (index2) => {
      setExpandedMessages((prev) => {
        const newSet = new Set(prev);
        if (newSet.has(index2)) {
          newSet.delete(index2);
        } else {
          newSet.add(index2);
        }
        return newSet;
      });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: `${SPACING.lg}px`,
          backgroundColor: COLORS.accent.lighter,
          border: `1px solid ${COLORS.accent.light}`,
          borderRadius: `${RADIUS.lg}px`,
          boxShadow: SHADOWS.md,
          marginTop: `${SPACING.md}px`
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", justifyContent: "space-between", marginBottom: `${SPACING.md}px` }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "h3",
                {
                  style: {
                    fontSize: `${TYPOGRAPHY.fontSize.lg}px`,
                    fontWeight: TYPOGRAPHY.fontWeight.semibold,
                    color: COLORS.text.primary,
                    margin: `0 0 ${SPACING.xs}px 0`
                  },
                  children: "Connection Path Found! ðŸŽ¯"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  style: {
                    fontSize: `${TYPOGRAPHY.fontSize.sm}px`,
                    color: COLORS.text.secondary,
                    margin: 0
                  },
                  children: degreeOfSeparation === 1 ? "You're 1st degree connections" : degreeOfSeparation === 2 ? "You're 2nd degree connections" : `You're ${degreeOfSeparation}${degreeOfSeparation === 3 ? "rd" : "th"} degree connections`
                }
              )
            ] }),
            onClose && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: onClose,
                style: {
                  background: "none",
                  border: "none",
                  cursor: "pointer",
                  padding: `${SPACING.xs}px`,
                  borderRadius: `${RADIUS.sm}px`,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  transition: `background-color 150ms ease-out`
                },
                onMouseEnter: (e) => {
                  e.currentTarget.style.backgroundColor = COLORS.background.hover;
                },
                onMouseLeave: (e) => {
                  e.currentTarget.style.backgroundColor = "transparent";
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: ICON.size.sm, color: COLORS.text.tertiary })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "center",
                gap: `${SPACING.xs}px`,
                padding: `${SPACING.sm}px ${SPACING.md}px`,
                backgroundColor: COLORS.background.primary,
                borderRadius: `${RADIUS.md}px`,
                marginBottom: `${SPACING.lg}px`
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      fontSize: `${TYPOGRAPHY.fontSize.sm}px`,
                      fontWeight: TYPOGRAPHY.fontWeight.medium,
                      color: COLORS.text.secondary,
                      marginBottom: "4px"
                    },
                    children: "Success Probability"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ProgressBar,
                  {
                    value: route.successProbability,
                    max: 100,
                    variant: "linear",
                    height: 6,
                    showLabel: true,
                    isComplete: route.successProbability >= 80
                  }
                )
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: `${SPACING.lg}px` }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  fontSize: `${TYPOGRAPHY.fontSize.sm}px`,
                  fontWeight: TYPOGRAPHY.fontWeight.semibold,
                  color: COLORS.text.primary,
                  marginBottom: `${SPACING.sm}px`
                },
                children: [
                  "Connection Path (",
                  totalSteps,
                  " step",
                  totalSteps !== 1 ? "s" : "",
                  "):"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: `${SPACING.xs}px` }, children: validNodes.map((node, index2) => {
              const isFirst = index2 === 0;
              const isLast = index2 === validNodes.length - 1;
              const showConnector = !isLast;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      display: "flex",
                      alignItems: "center",
                      gap: `${SPACING.sm}px`,
                      padding: `${SPACING.sm}px`,
                      backgroundColor: COLORS.background.primary,
                      borderRadius: `${RADIUS.md}px`,
                      border: isFirst || isLast ? `2px solid ${COLORS.accent.default}` : `1px solid ${COLORS.border.light}`
                    },
                    children: [
                      node.profile?.avatarUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "img",
                        {
                          src: node.profile.avatarUrl,
                          alt: node.profile.name || "Profile",
                          style: {
                            width: "32px",
                            height: "32px",
                            borderRadius: "50%",
                            objectFit: "cover",
                            flexShrink: 0
                          },
                          onError: (e) => {
                            const target = e.target;
                            target.style.display = "none";
                            const fallback = target.nextElementSibling;
                            if (fallback) {
                              fallback.style.display = "flex";
                            }
                          }
                        }
                      ) : null,
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          style: {
                            width: "32px",
                            height: "32px",
                            borderRadius: "50%",
                            background: isFirst ? "linear-gradient(135deg, #0077B5 0%, #00A0DC 100%)" : "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
                            display: node.profile?.avatarUrl ? "none" : "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            flexShrink: 0,
                            color: "white",
                            fontSize: "14px",
                            fontWeight: 600
                          },
                          children: node.profile?.name ? node.profile.name.charAt(0).toUpperCase() : /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 16, color: "white" })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            style: {
                              fontSize: `${TYPOGRAPHY.fontSize.base}px`,
                              fontWeight: TYPOGRAPHY.fontWeight.semibold,
                              color: COLORS.text.primary,
                              whiteSpace: "nowrap",
                              overflow: "hidden",
                              textOverflow: "ellipsis"
                            },
                            children: isFirst ? "You" : node.profile?.name || "Unknown Connection"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            style: {
                              fontSize: `${TYPOGRAPHY.fontSize.xs}px`,
                              color: COLORS.text.tertiary
                            },
                            children: isFirst ? "Start here" : isLast ? "Your target" : `${node.degree}${node.degree === 1 ? "st" : node.degree === 2 ? "nd" : "rd"} degree`
                          }
                        )
                      ] }),
                      !isFirst && node.matchScore !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "div",
                        {
                          style: {
                            fontSize: `${TYPOGRAPHY.fontSize.xs}px`,
                            fontWeight: TYPOGRAPHY.fontWeight.semibold,
                            color: node.matchScore >= 70 ? "#30D158" : node.matchScore >= 40 ? COLORS.accent.default : COLORS.text.tertiary,
                            backgroundColor: node.matchScore >= 70 ? "#E8F5E9" : node.matchScore >= 40 ? COLORS.accent.lighter : COLORS.background.tertiary,
                            padding: "4px 8px",
                            borderRadius: `${RADIUS.sm}px`,
                            whiteSpace: "nowrap"
                          },
                          children: [
                            node.matchScore,
                            "% match"
                          ]
                        }
                      )
                    ]
                  }
                ),
                !isFirst && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      marginTop: `${SPACING.xs}px`,
                      marginBottom: `${SPACING.xs}px`,
                      display: "flex",
                      justifyContent: "center",
                      width: "100%"
                    },
                    children: expandedMessages.has(index2) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      MessageGenerator,
                      {
                        senderProfile: validNodes[index2 - 1].profile,
                        recipientProfile: node.profile,
                        degreeOfSeparation: node.degree || index2,
                        mutualConnections: [],
                        isDirectConnection: index2 === 1,
                        referralFrom: index2 > 1 ? validNodes[index2 - 1]?.profile : void 0,
                        targetGoal: "networking",
                        variant: "full"
                      }
                    ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "button",
                      {
                        onClick: () => toggleMessageGenerator(index2),
                        style: {
                          background: "none",
                          border: `1px solid ${COLORS.border.light}`,
                          borderRadius: `${RADIUS.sm}px`,
                          padding: `${SPACING.xs}px ${SPACING.sm}px`,
                          fontSize: `${TYPOGRAPHY.fontSize.xs}px`,
                          color: COLORS.accent.default,
                          cursor: "pointer",
                          display: "flex",
                          alignItems: "center",
                          gap: "4px",
                          transition: "all 150ms ease-out"
                        },
                        onMouseEnter: (e) => {
                          e.currentTarget.style.backgroundColor = COLORS.accent.lighter;
                          e.currentTarget.style.borderColor = COLORS.accent.default;
                        },
                        onMouseLeave: (e) => {
                          e.currentTarget.style.backgroundColor = "transparent";
                          e.currentTarget.style.borderColor = COLORS.border.light;
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "12px" }, children: "âœ¨" }),
                          "Generate Message"
                        ]
                      }
                    )
                  }
                ),
                showConnector && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      padding: `${SPACING.xs}px 0`
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { size: ICON.size.sm, color: COLORS.text.tertiary })
                  }
                )
              ] }, node.id);
            }) })
          ] }),
          onSaveToWatchlist && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: onSaveToWatchlist,
              disabled: isSaving,
              fullWidth: true,
              variant: "primary",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BookmarkPlus, { size: 16 }),
              children: isSaving ? "Saving..." : "Save Path to Watchlist"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                marginTop: `${SPACING.md}px`,
                padding: `${SPACING.sm}px ${SPACING.md}px`,
                backgroundColor: "rgba(255, 149, 0, 0.05)",
                borderLeft: `3px solid #FF9500`,
                borderRadius: `${RADIUS.sm}px`
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    fontSize: `${TYPOGRAPHY.fontSize.sm}px`,
                    color: COLORS.text.secondary,
                    lineHeight: TYPOGRAPHY.lineHeight.relaxed
                  },
                  children: [
                    "ðŸ’¡ ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Tip:" }),
                    " Start by connecting with the closest person in your path. Once connected, ask them for an introduction to the next person."
                  ]
                }
              )
            }
          )
        ]
      }
    );
  }
  content;
  function userProfileToNetworkNode(profile, index2 = 0) {
    const profileId = profile.email || profile.url || profile.name || `profile-${index2}`;
    return {
      id: profileId,
      profile: {
        id: profileId,
        publicId: profileId,
        name: profile.name || "Unknown",
        headline: profile.title || "",
        location: profile.location || "",
        industry: profile.metadata?.domains?.[0] || "",
        avatarUrl: profile.avatarUrl,
        about: "",
        experience: (profile.workExperience || []).map((exp) => ({
          company: exp.company || "",
          title: exp.title || "",
          duration: exp.startDate && exp.endDate ? `${exp.startDate} - ${exp.endDate}` : "",
          location: exp.location || ""
        })),
        education: (profile.education || []).map((edu) => ({
          school: edu.school || "",
          degree: edu.degree || "",
          field: edu.field || ""
        })),
        skills: (profile.skills || []).map((s) => ({
          name: s.name || "",
          endorsementCount: 0,
          endorsedBy: []
        })),
        connections: 0,
        mutualConnections: [],
        recentPosts: [],
        certifications: [],
        userPosts: [],
        engagedPosts: [],
        recentActivity: [],
        scrapedAt: (/* @__PURE__ */ new Date()).toISOString()
      },
      status: "not_contacted",
      degree: index2 === 0 ? 1 : index2 + 1,
      matchScore: 0
    };
  }
  function connectionPathToRoute(path, targetId) {
    console.log("[Uproot] [TRANSFORM] Converting ConnectionPath to ConnectionRoute", {
      inputNodesCount: path.nodes?.length || 0,
      hasNodes: !!path.nodes
    });
    const validNodes = (path.nodes || []).filter((node) => node != null).map((profile, index2) => userProfileToNetworkNode(profile, index2));
    console.log("[Uproot] [TRANSFORM] Conversion complete", {
      outputNodesCount: validNodes.length,
      allNodesHaveProfile: validNodes.every((n) => n.profile != null),
      allNodesHaveName: validNodes.every((n) => n.profile?.name != null),
      allNodesHaveAvatar: validNodes.every((n) => n.profile?.avatarUrl != null),
      avatarUrls: validNodes.map((n) => ({ name: n.profile?.name, hasAvatar: !!n.profile?.avatarUrl }))
    });
    return {
      targetId,
      nodes: validNodes,
      edges: path.edges || [],
      totalWeight: path.totalWeight || 0,
      successProbability: path.successProbability * 100,
      // Convert 0-1 to 0-100
      computedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  function transformConnectionStrategyForUI(strategy) {
    if (!strategy.path) {
      console.log("[Uproot] [TRANSFORM] Strategy has no path, cannot create route");
      return null;
    }
    const targetId = strategy.path.nodes?.[strategy.path.nodes.length - 1]?.email || strategy.path.nodes?.[strategy.path.nodes.length - 1]?.url || "unknown-target";
    return connectionPathToRoute(strategy.path, targetId);
  }
  content;
  function ConnectionResult({ connectionPath, onSaveToWatchlist, isSaving }) {
    if (connectionPath.path) {
      const route = transformConnectionStrategyForUI(connectionPath);
      if (!route) {
        console.error("[Uproot] Failed to transform connection path to route");
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "16px", padding: "16px", backgroundColor: "#FEE", borderRadius: "8px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "#C00", margin: 0 }, children: "Error displaying connection path" }) });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        RouteResultCard,
        {
          route,
          onSaveToWatchlist,
          isSaving
        }
      ) });
    }
    const isLowConfidence = connectionPath.lowConfidence || false;
    const isColdOutreach = connectionPath.type === "cold-outreach";
    const backgroundColor = isColdOutreach || isLowConfidence ? "#FEF3C7" : "#F0F9FF";
    const borderColor = isColdOutreach || isLowConfidence ? "#F59E0B" : "#3B82F6";
    const textColor = isColdOutreach || isLowConfidence ? "#92400E" : "#1E3A8A";
    const headingColor = isColdOutreach || isLowConfidence ? "#92400E" : "#1E40AF";
    const badgeColor = isColdOutreach || isLowConfidence ? "#FEF3C7" : "#DBEAFE";
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "16px",
          backgroundColor,
          border: `1px solid ${borderColor}`,
          borderRadius: "12px",
          boxShadow: "0 2px 8px rgba(0, 0, 0, 0.1)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "h4",
            {
              style: {
                margin: "0 0 8px 0",
                color: headingColor,
                fontSize: "15px",
                fontWeight: "600"
              },
              children: [
                "Connection Strategy: ",
                connectionPath.type.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase()),
                isLowConfidence && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      marginLeft: "8px",
                      fontSize: "11px",
                      fontWeight: "500",
                      padding: "2px 6px",
                      backgroundColor: "#FCD34D",
                      color: "#78350F",
                      borderRadius: "4px"
                    },
                    children: "Limited Data"
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                margin: "0 0 12px 0",
                fontSize: "14px",
                color: textColor,
                lineHeight: "1.5"
              },
              children: connectionPath.reasoning
            }
          ),
          (connectionPath.candidate || connectionPath.intermediary) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: "12px",
                backgroundColor: badgeColor,
                borderRadius: "8px",
                marginBottom: "12px",
                border: `1px solid ${borderColor}`
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "12px", color: headingColor, fontWeight: "600", marginBottom: "6px" }, children: connectionPath.candidate ? "Suggested Gateway:" : "Recommended Intermediary:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "14px", color: textColor, fontWeight: "500" }, children: (connectionPath.candidate || connectionPath.intermediary)?.person.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "12px", color: textColor, marginTop: "4px" }, children: (connectionPath.candidate || connectionPath.intermediary)?.reasoning })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: "10px 12px",
                backgroundColor: badgeColor,
                borderRadius: "8px",
                marginBottom: "12px"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "12px", color: headingColor, marginBottom: "4px" }, children: "Estimated Acceptance Rate" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "18px", fontWeight: "600", color: headingColor }, children: [
                  (connectionPath.estimatedAcceptanceRate * 100).toFixed(0),
                  "%"
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "13px", color: textColor }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { style: { display: "block", marginBottom: "8px" }, children: "Next Steps:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { style: { margin: "0", paddingLeft: "20px" }, children: connectionPath.nextSteps.map((step, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { style: { marginBottom: "6px", lineHeight: "1.4" }, children: step }, i)) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: onSaveToWatchlist,
              disabled: isSaving,
              style: {
                width: "100%",
                padding: "10px 16px",
                marginTop: "16px",
                backgroundColor: isSaving ? "#10B981" : "#3B82F6",
                color: "white",
                border: "none",
                borderRadius: "8px",
                fontSize: "14px",
                fontWeight: "600",
                cursor: isSaving ? "default" : "pointer",
                opacity: isSaving ? 0.9 : 1,
                transition: "all 150ms"
              },
              onMouseEnter: (e) => {
                if (!isSaving) {
                  e.currentTarget.style.backgroundColor = "#2563EB";
                }
              },
              onMouseLeave: (e) => {
                if (!isSaving) {
                  e.currentTarget.style.backgroundColor = "#3B82F6";
                }
              },
              children: isSaving ? "âœ“ Saved to Watchlist" : "Save to Watchlist"
            }
          )
        ]
      }
    ) });
  }
  content;
  function convertLinkedInToUserProfile(linkedInProfile) {
    return {
      id: linkedInProfile.profileUrl,
      // CRITICAL: Use full URL as ID to match graph nodes
      name: linkedInProfile.name || "LinkedIn User",
      email: linkedInProfile.profileUrl,
      location: linkedInProfile.location || "",
      title: linkedInProfile.headline || linkedInProfile.currentRole?.title || "",
      avatarUrl: linkedInProfile.photoUrl,
      publicId: linkedInProfile.publicId,
      url: linkedInProfile.profileUrl,
      workExperience: linkedInProfile.currentRole?.title ? [
        {
          id: "current-role",
          company: linkedInProfile.currentRole.company || "",
          title: linkedInProfile.currentRole.title,
          startDate: linkedInProfile.currentRole.startDate || (/* @__PURE__ */ new Date()).toISOString(),
          endDate: null,
          location: linkedInProfile.location || "",
          description: "",
          industry: "",
          achievements: [],
          skills: [],
          domains: [],
          responsibilities: []
        }
      ] : [],
      education: [],
      projects: [],
      skills: [],
      metadata: {
        totalYearsExperience: 0,
        domains: [],
        seniority: "entry",
        careerStage: "professional"
      }
    };
  }
  async function getCurrentUser() {
    try {
      const currentUserData = await chrome.storage.local.get(["userProfile"]);
      if (currentUserData.userProfile) {
        const profile = currentUserData.userProfile;
        if (profile.email && !profile.email.startsWith("http")) {
          console.warn("[Uproot] Normalizing old profile format:", profile.email);
          profile.email = `https://www.linkedin.com/in/${profile.email}`;
          await chrome.storage.local.set({ userProfile: profile });
        }
        console.log("[Uproot] Using current user from Resume tab:", profile.email);
        return profile;
      }
      console.log("[Uproot] No Resume tab data, trying LinkedIn detection...");
      const linkedInUser = getCurrentLinkedInUser();
      if (linkedInUser) {
        console.log("[Uproot] Detected LinkedIn user from page:", linkedInUser.name);
        return convertLinkedInToUserProfile(linkedInUser);
      }
      console.log("[Uproot] LinkedIn detection failed, trying profile scraping...");
      const scrapedProfile = await scrapeOwnProfile();
      if (scrapedProfile && scrapedProfile.name !== "LinkedIn User") {
        console.log("[Uproot] Scraped own profile:", scrapedProfile.name);
        return scrapedProfile;
      }
      console.error("[Uproot] All profile detection methods failed");
      return null;
    } catch (error) {
      console.error("[Uproot] Error getting current user:", error);
      return null;
    }
  }
  content;
  const DEFAULT_SIMILARITY_WEIGHTS = {
    industry: 0.3,
    skills: 0.25,
    education: 0.2,
    location: 0.15,
    companies: 0.1
  };
  content;
  function calculateSkillJaccardSimilarity(p1, p2, config) {
    if (!p1.skills || !p2.skills || p1.skills.length === 0 || p2.skills.length === 0) {
      return 0;
    }
    const skills1 = new Set(
      p1.skills.filter((s) => s && s.name).map(
        (s) => s.name.toLowerCase()
      )
    );
    const skills2 = new Set(
      p2.skills.filter((s) => s && s.name).map(
        (s) => s.name.toLowerCase()
      )
    );
    const intersection = new Set([...skills1].filter((s) => skills2.has(s)));
    const union = /* @__PURE__ */ new Set([...skills1, ...skills2]);
    return union.size === 0 ? 0 : intersection.size / union.size;
  }
  function calculateCompanyHistoryJaccard(p1, p2, config) {
    if (!p1.workExperience || !p2.workExperience || p1.workExperience.length === 0 || p2.workExperience.length === 0) {
      return 0;
    }
    const companies1 = new Set(
      p1.workExperience.filter((e) => e && e.company).map(
        (e) => e.company.toLowerCase()
      )
    );
    const companies2 = new Set(
      p2.workExperience.filter((e) => e && e.company).map(
        (e) => e.company.toLowerCase()
      )
    );
    const intersection = new Set([...companies1].filter((c) => companies2.has(c)));
    const union = /* @__PURE__ */ new Set([...companies1, ...companies2]);
    return union.size === 0 ? 0 : intersection.size / union.size;
  }
  content;
  var GeographicRegion = /* @__PURE__ */ ((GeographicRegion2) => {
    GeographicRegion2["NORTH_AMERICA"] = "North America";
    GeographicRegion2["SOUTH_AMERICA"] = "South America";
    GeographicRegion2["EUROPE"] = "Europe";
    GeographicRegion2["ASIA"] = "Asia";
    GeographicRegion2["AFRICA"] = "Africa";
    GeographicRegion2["OCEANIA"] = "Oceania";
    GeographicRegion2["MIDDLE_EAST"] = "Middle East";
    GeographicRegion2["UNKNOWN"] = "Unknown";
    return GeographicRegion2;
  })(GeographicRegion || {});
  const DEFAULT_LOCATION_THRESHOLDS = {
    sameCity: 1,
    sameState: 0.7,
    sameCountry: 0.4,
    sameRegion: 0.2,
    differentRegions: 0
  };
  const DEFAULT_EDUCATION_THRESHOLDS = {
    sameSchool: 1,
    sameField: 0.5,
    noOverlap: 0
  };
  const DEFAULT_INDUSTRY_THRESHOLDS = {
    exactMatch: 1,
    relatedIndustries: 0.6,
    noOverlap: 0
  };
  content;
  function calculateEducationOverlap(p1, p2, config) {
    if (!p1.education || !p2.education || p1.education.length === 0 || p2.education.length === 0) {
      return 0;
    }
    const thresholds = {
      ...DEFAULT_EDUCATION_THRESHOLDS,
      ...config?.educationThresholds
    };
    const schoolMatch = p1.education.some(
      (e1) => p2.education.some((e2) => e1.school.toLowerCase() === e2.school.toLowerCase())
    );
    if (schoolMatch) {
      return thresholds.sameSchool;
    }
    const fieldMatch = p1.education.some(
      (e1) => p2.education.some(
        (e2) => e1.field && e2.field && e1.field.toLowerCase() === e2.field.toLowerCase()
      )
    );
    if (fieldMatch) {
      return thresholds.sameField;
    }
    return thresholds.noOverlap;
  }
  content;
  content;
  content;
  content;
  const INDUSTRY_RELATIONSHIPS = {
    // Technology & Software
    "Software Development": [
      "Information Technology",
      "Computer Software",
      "Internet",
      "SaaS",
      "Cloud Computing",
      "IT Services",
      "Telecommunications",
      "Computer Networking"
    ],
    "Information Technology": [
      "Software Development",
      "IT Services",
      "Computer Networking",
      "Cybersecurity",
      "Cloud Computing",
      "Telecommunications",
      "Computer Software"
    ],
    "Computer Software": [
      "Software Development",
      "Information Technology",
      "SaaS",
      "Internet",
      "Cloud Computing",
      "Gaming",
      "Mobile Applications"
    ],
    "SaaS": [
      "Software Development",
      "Computer Software",
      "Cloud Computing",
      "Internet",
      "Information Technology",
      "IT Services"
    ],
    "Cloud Computing": [
      "Software Development",
      "Information Technology",
      "SaaS",
      "Computer Software",
      "IT Services",
      "Data Infrastructure"
    ],
    "Cybersecurity": [
      "Information Technology",
      "IT Services",
      "Computer Networking",
      "Software Development",
      "Risk Management",
      "Consulting"
    ],
    "IT Services": [
      "Information Technology",
      "Software Development",
      "Consulting",
      "Business Consulting",
      "Cloud Computing",
      "Managed Services"
    ],
    // Data & Analytics
    "Data Science": [
      "Machine Learning",
      "Artificial Intelligence",
      "Analytics",
      "Big Data",
      "Research",
      "Statistics",
      "Software Development"
    ],
    "Machine Learning": [
      "Data Science",
      "Artificial Intelligence",
      "Research",
      "Software Development",
      "Robotics",
      "Computer Vision"
    ],
    "Artificial Intelligence": [
      "Machine Learning",
      "Data Science",
      "Research",
      "Robotics",
      "Computer Vision",
      "Natural Language Processing",
      "Software Development"
    ],
    "Analytics": [
      "Data Science",
      "Business Intelligence",
      "Consulting",
      "Market Research",
      "Statistics",
      "Big Data"
    ],
    "Big Data": [
      "Data Science",
      "Analytics",
      "Cloud Computing",
      "Software Development",
      "Data Infrastructure"
    ],
    // Finance & Banking
    "Investment Banking": [
      "Finance",
      "Private Equity",
      "Venture Capital",
      "Corporate Finance",
      "Consulting",
      "Hedge Funds",
      "Asset Management"
    ],
    "Finance": [
      "Investment Banking",
      "Accounting",
      "Financial Services",
      "Corporate Finance",
      "Private Equity",
      "Asset Management"
    ],
    "Accounting": [
      "Finance",
      "Consulting",
      "Audit",
      "Tax Services",
      "Financial Services",
      "Corporate Finance"
    ],
    "Financial Services": [
      "Finance",
      "Banking",
      "Investment Banking",
      "Insurance",
      "Asset Management",
      "Wealth Management"
    ],
    "Private Equity": [
      "Investment Banking",
      "Venture Capital",
      "Finance",
      "Corporate Finance",
      "Hedge Funds",
      "Asset Management"
    ],
    "Venture Capital": [
      "Private Equity",
      "Investment Banking",
      "Startups",
      "Technology",
      "Finance",
      "Angel Investing"
    ],
    // Consulting & Professional Services
    "Consulting": [
      "Management Consulting",
      "Business Consulting",
      "Strategy",
      "IT Services",
      "Accounting",
      "Investment Banking",
      "Advisory"
    ],
    "Management Consulting": [
      "Consulting",
      "Strategy",
      "Business Consulting",
      "Investment Banking",
      "Operations",
      "Organizational Development"
    ],
    "Business Consulting": [
      "Consulting",
      "Management Consulting",
      "Strategy",
      "IT Services",
      "Advisory",
      "Professional Services"
    ],
    "Strategy": [
      "Management Consulting",
      "Consulting",
      "Business Development",
      "Corporate Development",
      "Investment Banking"
    ],
    // Marketing & Advertising
    "Marketing": [
      "Digital Marketing",
      "Advertising",
      "Brand Management",
      "Public Relations",
      "Social Media",
      "Content Marketing",
      "Market Research"
    ],
    "Digital Marketing": [
      "Marketing",
      "Advertising",
      "Social Media",
      "SEO/SEM",
      "Content Marketing",
      "E-commerce",
      "Growth Marketing"
    ],
    "Advertising": [
      "Marketing",
      "Digital Marketing",
      "Brand Management",
      "Public Relations",
      "Media",
      "Creative Services"
    ],
    "Public Relations": [
      "Marketing",
      "Advertising",
      "Communications",
      "Media Relations",
      "Brand Management",
      "Corporate Communications"
    ],
    // Healthcare & Life Sciences
    "Healthcare": [
      "Pharmaceuticals",
      "Biotechnology",
      "Medical Devices",
      "Hospital & Health Care",
      "Health & Wellness",
      "Telemedicine"
    ],
    "Pharmaceuticals": [
      "Healthcare",
      "Biotechnology",
      "Life Sciences",
      "Medical Devices",
      "Research",
      "Clinical Research"
    ],
    "Biotechnology": [
      "Pharmaceuticals",
      "Healthcare",
      "Life Sciences",
      "Research",
      "Genomics",
      "Medical Devices"
    ],
    "Medical Devices": [
      "Healthcare",
      "Biotechnology",
      "Pharmaceuticals",
      "Manufacturing",
      "Engineering"
    ],
    // Education & Research
    "Education": [
      "Higher Education",
      "E-Learning",
      "EdTech",
      "Research",
      "Training & Development",
      "Academic"
    ],
    "Higher Education": [
      "Education",
      "Research",
      "Academic",
      "E-Learning",
      "EdTech"
    ],
    "EdTech": [
      "Education",
      "E-Learning",
      "Software Development",
      "SaaS",
      "Higher Education"
    ],
    "Research": [
      "Education",
      "Higher Education",
      "Data Science",
      "Biotechnology",
      "Pharmaceuticals",
      "Academic"
    ],
    // Manufacturing & Engineering
    "Manufacturing": [
      "Engineering",
      "Industrial Manufacturing",
      "Automotive",
      "Aerospace",
      "Supply Chain",
      "Operations"
    ],
    "Engineering": [
      "Manufacturing",
      "Mechanical Engineering",
      "Electrical Engineering",
      "Civil Engineering",
      "Aerospace",
      "Automotive"
    ],
    "Aerospace": [
      "Engineering",
      "Manufacturing",
      "Defense",
      "Aviation",
      "Mechanical Engineering"
    ],
    "Automotive": [
      "Engineering",
      "Manufacturing",
      "Transportation",
      "Supply Chain",
      "Electric Vehicles"
    ],
    // Retail & E-commerce
    "Retail": [
      "E-commerce",
      "Consumer Goods",
      "Fashion",
      "Wholesale",
      "Supply Chain",
      "Merchandising"
    ],
    "E-commerce": [
      "Retail",
      "Internet",
      "Digital Marketing",
      "Supply Chain",
      "Software Development",
      "Logistics"
    ],
    "Consumer Goods": [
      "Retail",
      "Manufacturing",
      "Brand Management",
      "Marketing",
      "Supply Chain",
      "CPG"
    ],
    // Real Estate & Construction
    "Real Estate": [
      "Construction",
      "Property Management",
      "Architecture",
      "Urban Planning",
      "Finance",
      "Investment"
    ],
    "Construction": [
      "Real Estate",
      "Engineering",
      "Architecture",
      "Civil Engineering",
      "Project Management",
      "Manufacturing"
    ],
    "Architecture": [
      "Construction",
      "Real Estate",
      "Urban Planning",
      "Engineering",
      "Design"
    ],
    // Media & Entertainment
    "Media": [
      "Entertainment",
      "Publishing",
      "Broadcasting",
      "Journalism",
      "Digital Media",
      "Content Production"
    ],
    "Entertainment": [
      "Media",
      "Film",
      "Music",
      "Gaming",
      "Broadcasting",
      "Content Production"
    ],
    "Gaming": [
      "Entertainment",
      "Software Development",
      "Computer Software",
      "Digital Media",
      "Esports"
    ],
    // Energy & Utilities
    "Energy": [
      "Oil & Gas",
      "Renewable Energy",
      "Utilities",
      "Sustainability",
      "Engineering",
      "Environmental Services"
    ],
    "Renewable Energy": [
      "Energy",
      "Sustainability",
      "Utilities",
      "Engineering",
      "Environmental Services",
      "Clean Tech"
    ],
    "Oil & Gas": [
      "Energy",
      "Utilities",
      "Engineering",
      "Petroleum",
      "Chemical"
    ],
    // Legal & Government
    "Legal": [
      "Law",
      "Corporate Law",
      "Intellectual Property",
      "Compliance",
      "Regulatory Affairs",
      "Government"
    ],
    "Government": [
      "Public Policy",
      "Legal",
      "Non-Profit",
      "Public Administration",
      "Defense"
    ],
    "Non-Profit": [
      "Government",
      "Social Impact",
      "Education",
      "Healthcare",
      "Philanthropy",
      "NGO"
    ],
    // Hospitality & Travel
    "Hospitality": [
      "Travel",
      "Tourism",
      "Hotels",
      "Restaurants",
      "Events",
      "Leisure"
    ],
    "Travel": [
      "Hospitality",
      "Tourism",
      "Transportation",
      "Aviation",
      "Leisure"
    ],
    // Transportation & Logistics
    "Transportation": [
      "Logistics",
      "Supply Chain",
      "Aviation",
      "Automotive",
      "Shipping",
      "Freight"
    ],
    "Logistics": [
      "Transportation",
      "Supply Chain",
      "E-commerce",
      "Retail",
      "Manufacturing",
      "Warehousing"
    ],
    "Supply Chain": [
      "Logistics",
      "Transportation",
      "Manufacturing",
      "Retail",
      "Operations",
      "Procurement"
    ],
    // Human Resources & Recruiting
    "Human Resources": [
      "Recruiting",
      "Talent Acquisition",
      "Training & Development",
      "Organizational Development",
      "Compensation & Benefits",
      "HR Tech"
    ],
    "Recruiting": [
      "Human Resources",
      "Talent Acquisition",
      "Staffing",
      "HR Tech",
      "Executive Search"
    ],
    // Sales & Business Development
    "Sales": [
      "Business Development",
      "Account Management",
      "SaaS",
      "Marketing",
      "Enterprise Sales",
      "Retail"
    ],
    "Business Development": [
      "Sales",
      "Strategy",
      "Corporate Development",
      "Partnerships",
      "Marketing",
      "Venture Capital"
    ]
  };
  function areIndustriesRelated(industry1, industry2) {
    if (!industry1 || !industry2) {
      return false;
    }
    const norm1 = normalizeIndustryName(industry1);
    const norm2 = normalizeIndustryName(industry2);
    if (norm1.toLowerCase() === norm2.toLowerCase()) {
      return true;
    }
    const related1 = INDUSTRY_RELATIONSHIPS[norm1];
    if (related1?.some((r2) => r2.toLowerCase() === norm2.toLowerCase())) {
      return true;
    }
    const related2 = INDUSTRY_RELATIONSHIPS[norm2];
    if (related2?.some((r2) => r2.toLowerCase() === norm1.toLowerCase())) {
      return true;
    }
    return false;
  }
  function normalizeIndustryName(industry) {
    const trimmed = industry.trim();
    if (INDUSTRY_RELATIONSHIPS[trimmed]) {
      return trimmed;
    }
    for (const key of Object.keys(INDUSTRY_RELATIONSHIPS)) {
      if (key.toLowerCase() === trimmed.toLowerCase()) {
        return key;
      }
    }
    return trimmed;
  }
  const COUNTRY_TO_REGION = {
    // North America
    "United States": GeographicRegion.NORTH_AMERICA,
    "USA": GeographicRegion.NORTH_AMERICA,
    "US": GeographicRegion.NORTH_AMERICA,
    "Canada": GeographicRegion.NORTH_AMERICA,
    "Mexico": GeographicRegion.NORTH_AMERICA,
    // South America
    "Brazil": GeographicRegion.SOUTH_AMERICA,
    "Argentina": GeographicRegion.SOUTH_AMERICA,
    "Chile": GeographicRegion.SOUTH_AMERICA,
    "Colombia": GeographicRegion.SOUTH_AMERICA,
    "Peru": GeographicRegion.SOUTH_AMERICA,
    "Venezuela": GeographicRegion.SOUTH_AMERICA,
    "Ecuador": GeographicRegion.SOUTH_AMERICA,
    "Bolivia": GeographicRegion.SOUTH_AMERICA,
    "Paraguay": GeographicRegion.SOUTH_AMERICA,
    "Uruguay": GeographicRegion.SOUTH_AMERICA,
    // Europe
    "United Kingdom": GeographicRegion.EUROPE,
    "UK": GeographicRegion.EUROPE,
    "England": GeographicRegion.EUROPE,
    "Scotland": GeographicRegion.EUROPE,
    "Wales": GeographicRegion.EUROPE,
    "Ireland": GeographicRegion.EUROPE,
    "France": GeographicRegion.EUROPE,
    "Germany": GeographicRegion.EUROPE,
    "Italy": GeographicRegion.EUROPE,
    "Spain": GeographicRegion.EUROPE,
    "Portugal": GeographicRegion.EUROPE,
    "Netherlands": GeographicRegion.EUROPE,
    "Belgium": GeographicRegion.EUROPE,
    "Switzerland": GeographicRegion.EUROPE,
    "Austria": GeographicRegion.EUROPE,
    "Sweden": GeographicRegion.EUROPE,
    "Norway": GeographicRegion.EUROPE,
    "Denmark": GeographicRegion.EUROPE,
    "Finland": GeographicRegion.EUROPE,
    "Poland": GeographicRegion.EUROPE,
    "Czech Republic": GeographicRegion.EUROPE,
    "Hungary": GeographicRegion.EUROPE,
    "Romania": GeographicRegion.EUROPE,
    "Greece": GeographicRegion.EUROPE,
    "Russia": GeographicRegion.EUROPE,
    // Asia
    "China": GeographicRegion.ASIA,
    "Japan": GeographicRegion.ASIA,
    "South Korea": GeographicRegion.ASIA,
    "India": GeographicRegion.ASIA,
    "Singapore": GeographicRegion.ASIA,
    "Hong Kong": GeographicRegion.ASIA,
    "Taiwan": GeographicRegion.ASIA,
    "Thailand": GeographicRegion.ASIA,
    "Vietnam": GeographicRegion.ASIA,
    "Malaysia": GeographicRegion.ASIA,
    "Indonesia": GeographicRegion.ASIA,
    "Philippines": GeographicRegion.ASIA,
    "Pakistan": GeographicRegion.ASIA,
    "Bangladesh": GeographicRegion.ASIA,
    // Middle East
    "Israel": GeographicRegion.MIDDLE_EAST,
    "Saudi Arabia": GeographicRegion.MIDDLE_EAST,
    "United Arab Emirates": GeographicRegion.MIDDLE_EAST,
    "UAE": GeographicRegion.MIDDLE_EAST,
    "Dubai": GeographicRegion.MIDDLE_EAST,
    "Qatar": GeographicRegion.MIDDLE_EAST,
    "Kuwait": GeographicRegion.MIDDLE_EAST,
    "Bahrain": GeographicRegion.MIDDLE_EAST,
    "Oman": GeographicRegion.MIDDLE_EAST,
    "Jordan": GeographicRegion.MIDDLE_EAST,
    "Lebanon": GeographicRegion.MIDDLE_EAST,
    "Turkey": GeographicRegion.MIDDLE_EAST,
    // Africa
    "South Africa": GeographicRegion.AFRICA,
    "Nigeria": GeographicRegion.AFRICA,
    "Kenya": GeographicRegion.AFRICA,
    "Egypt": GeographicRegion.AFRICA,
    "Morocco": GeographicRegion.AFRICA,
    "Ethiopia": GeographicRegion.AFRICA,
    "Ghana": GeographicRegion.AFRICA,
    // Oceania
    "Australia": GeographicRegion.OCEANIA,
    "New Zealand": GeographicRegion.OCEANIA
  };
  function getGeographicRegion(country) {
    if (!country) {
      return GeographicRegion.UNKNOWN;
    }
    const normalized = country.trim();
    return COUNTRY_TO_REGION[normalized] || GeographicRegion.UNKNOWN;
  }
  const US_STATE_ABBREVIATIONS = {
    "AL": "Alabama",
    "AK": "Alaska",
    "AZ": "Arizona",
    "AR": "Arkansas",
    "CA": "California",
    "CO": "Colorado",
    "CT": "Connecticut",
    "DE": "Delaware",
    "FL": "Florida",
    "GA": "Georgia",
    "HI": "Hawaii",
    "ID": "Idaho",
    "IL": "Illinois",
    "IN": "Indiana",
    "IA": "Iowa",
    "KS": "Kansas",
    "KY": "Kentucky",
    "LA": "Louisiana",
    "ME": "Maine",
    "MD": "Maryland",
    "MA": "Massachusetts",
    "MI": "Michigan",
    "MN": "Minnesota",
    "MS": "Mississippi",
    "MO": "Missouri",
    "MT": "Montana",
    "NE": "Nebraska",
    "NV": "Nevada",
    "NH": "New Hampshire",
    "NJ": "New Jersey",
    "NM": "New Mexico",
    "NY": "New York",
    "NC": "North Carolina",
    "ND": "North Dakota",
    "OH": "Ohio",
    "OK": "Oklahoma",
    "OR": "Oregon",
    "PA": "Pennsylvania",
    "RI": "Rhode Island",
    "SC": "South Carolina",
    "SD": "South Dakota",
    "TN": "Tennessee",
    "TX": "Texas",
    "UT": "Utah",
    "VT": "Vermont",
    "VA": "Virginia",
    "WA": "Washington",
    "WV": "West Virginia",
    "WI": "Wisconsin",
    "WY": "Wyoming",
    "DC": "District of Columbia"
  };
  content;
  function calculateLocationSimilarity(p1, p2, config) {
    if (!p1.location || !p2.location) {
      return 0;
    }
    const thresholds = {
      ...DEFAULT_LOCATION_THRESHOLDS,
      ...config?.locationThresholds
    };
    if (p1.location === p2.location) {
      return thresholds.sameCity;
    }
    const loc1 = parseLocation(p1.location);
    const loc2 = parseLocation(p2.location);
    if (loc1.city.toLowerCase() === loc2.city.toLowerCase() && loc1.city !== "Unknown") {
      return thresholds.sameCity;
    }
    if (loc1.state && loc2.state && loc1.state === loc2.state) {
      return thresholds.sameState;
    }
    if (loc1.country.toLowerCase() === loc2.country.toLowerCase() && loc1.country !== "Unknown") {
      return thresholds.sameCountry;
    }
    if (loc1.region === loc2.region && loc1.region !== "Unknown") {
      return thresholds.sameRegion;
    }
    return thresholds.differentRegions;
  }
  function parseLocation(location2) {
    if (!location2 || location2.trim() === "") {
      return {
        city: "Unknown",
        country: "Unknown",
        region: "Unknown"
      };
    }
    const parts = location2.split(",").map((p) => p.trim());
    if (parts.length === 1) {
      const region2 = getGeographicRegion(parts[0]);
      if (region2 !== "Unknown") {
        return {
          city: "Unknown",
          country: parts[0],
          region: region2
        };
      }
      return {
        city: parts[0],
        country: "Unknown",
        region: "Unknown"
      };
    }
    if (parts.length === 2) {
      const [city2, secondPart] = parts;
      if (US_STATE_ABBREVIATIONS[secondPart.toUpperCase()]) {
        return {
          city: city2,
          state: secondPart.toUpperCase(),
          country: "United States",
          region: "North America"
        };
      }
      const stateAbbrev = Object.entries(US_STATE_ABBREVIATIONS).find(
        ([_, fullName]) => fullName.toLowerCase() === secondPart.toLowerCase()
      );
      if (stateAbbrev) {
        return {
          city: city2,
          state: stateAbbrev[0],
          country: "United States",
          region: "North America"
        };
      }
      const region2 = getGeographicRegion(secondPart);
      return {
        city: city2,
        country: secondPart,
        region: region2 !== "Unknown" ? region2 : "Unknown"
      };
    }
    const city = parts[0];
    const state = parts[1];
    const country = parts[2];
    const region = getGeographicRegion(country);
    return {
      city,
      state,
      country,
      region: region !== "Unknown" ? region : "Unknown"
    };
  }
  content;
  function calculateIndustryOverlap(p1, p2, config) {
    if (!p1.workExperience || !p2.workExperience || p1.workExperience.length === 0 || p2.workExperience.length === 0) {
      return 0;
    }
    const thresholds = {
      ...DEFAULT_INDUSTRY_THRESHOLDS,
      ...config?.industryThresholds
    };
    const industries1 = new Set(
      p1.workExperience.map((e) => e.industry).filter(Boolean).map((i) => i)
    );
    const industries2 = new Set(
      p2.workExperience.map((e) => e.industry).filter(Boolean).map((i) => i)
    );
    if (industries1.size === 0 || industries2.size === 0) {
      return 0;
    }
    const exactMatch = [...industries1].some(
      (i1) => [...industries2].some((i2) => i1.toLowerCase() === i2.toLowerCase())
    );
    if (exactMatch) {
      return thresholds.exactMatch;
    }
    const relatedMatch = [...industries1].some(
      (i1) => [...industries2].some((i2) => areIndustriesRelated(i1, i2))
    );
    if (relatedMatch) {
      return thresholds.relatedIndustries;
    }
    return thresholds.noOverlap;
  }
  content;
  content;
  content;
  function calculateProfileSimilarity(profile1, profile2, config) {
    if (!profile1 || !profile2) {
      return createEmptySimilarity();
    }
    const weights = {
      ...DEFAULT_SIMILARITY_WEIGHTS,
      ...config?.weights
    };
    const industryMatch = calculateIndustryOverlap(profile1, profile2, config);
    const skillMatch = calculateSkillJaccardSimilarity(profile1, profile2);
    const educationMatch = calculateEducationOverlap(profile1, profile2, config);
    const locationMatch = calculateLocationSimilarity(profile1, profile2, config);
    const companyMatch = calculateCompanyHistoryJaccard(profile1, profile2);
    const overall = industryMatch * weights.industry + skillMatch * weights.skills + educationMatch * weights.education + locationMatch * weights.location + companyMatch * weights.companies;
    const clampedOverall = Math.min(Math.max(overall, 0), 1);
    return {
      overall: clampedOverall,
      breakdown: {
        industry: industryMatch,
        skills: skillMatch,
        education: educationMatch,
        location: locationMatch,
        companies: companyMatch
      }
    };
  }
  function createEmptySimilarity() {
    return {
      overall: 0,
      breakdown: {
        industry: 0,
        skills: 0,
        education: 0,
        location: 0,
        companies: 0
      }
    };
  }
  content;
  content;
  function sampleConnections(connections, maxConnections = 500) {
    if (connections.length <= maxConnections) {
      return {
        sampled: connections,
        strategy: "all",
        originalCount: connections.length,
        sampledCount: connections.length
      };
    }
    const halfSize = Math.floor(maxConnections / 2);
    const byRecent = [...connections].sort((_a2, _b) => {
      return 0;
    });
    const byActive = [...connections].sort((_a2, _b) => {
      return 0;
    });
    const recentSet = new Set(byRecent.slice(0, halfSize).map((c) => c.email || c.name));
    const sampled = [
      ...byRecent.slice(0, halfSize),
      ...byActive.slice(0, halfSize).filter((c) => !recentSet.has(c.email || c.name))
    ];
    return {
      sampled: sampled.slice(0, maxConnections),
      strategy: "mixed",
      originalCount: connections.length,
      sampledCount: Math.min(sampled.length, maxConnections)
    };
  }
  content;
  function scoreIntermediary(source, intermediary, target, direction, simFromSource, simToTarget) {
    const simFrom = simFromSource ?? calculateProfileSimilarity(source, intermediary).overall;
    const simTo = simToTarget ?? calculateProfileSimilarity(intermediary, target).overall;
    const pathStrength = Math.sqrt(simFrom * simTo);
    const directionMultiplier = direction === "outbound" ? 0.8 : 0.6;
    const score = pathStrength * directionMultiplier;
    const estimatedAcceptance = estimateAcceptanceRate(pathStrength, direction);
    const reasoning = direction === "outbound" ? `${intermediary.name} is similar to ${target.name} (${(simTo * 100).toFixed(0)}% match). You can introduce them!` : `${intermediary.name} is similar to you (${(simFrom * 100).toFixed(0)}% match) and connected to ${target.name}. Connect with them first!`;
    return {
      person: intermediary,
      score,
      pathStrength,
      bridgeQuality: 0,
      // Future enhancement: betweenness centrality
      estimatedAcceptance,
      reasoning,
      direction,
      sourceToIntermediary: simFrom,
      intermediaryToTarget: simTo
    };
  }
  function estimateAcceptanceRate(pathStrength, direction) {
    let baseRate;
    if (pathStrength >= 0.75) {
      baseRate = 0.4;
    } else if (pathStrength >= 0.6) {
      baseRate = 0.32;
    } else if (pathStrength >= 0.5) {
      baseRate = 0.25;
    } else {
      baseRate = 0.18;
    }
    if (direction === "inbound") {
      baseRate *= 0.75;
    }
    return baseRate;
  }
  content;
  content;
  content;
  function findBestIntermediaries(sourceUser, targetUser, sourceConnections, targetConnections) {
    const goodCandidates = [];
    const allCandidates = [];
    const sampledSourceConnections = sampleConnections(sourceConnections, 500);
    const sampledTargetConnections = sampleConnections(targetConnections, 500);
    for (const yourConnection of sampledSourceConnections.sampled) {
      const simToTarget = calculateProfileSimilarity(yourConnection, targetUser);
      const simFromYou = calculateProfileSimilarity(sourceUser, yourConnection);
      const candidate = scoreIntermediary(
        sourceUser,
        yourConnection,
        targetUser,
        "outbound",
        simFromYou.overall,
        simToTarget.overall
      );
      allCandidates.push(candidate);
      if (simToTarget.overall > 0.35) {
        goodCandidates.push(candidate);
      }
    }
    for (const theirConnection of sampledTargetConnections.sampled) {
      const simToYou = calculateProfileSimilarity(theirConnection, sourceUser);
      const simToTarget = calculateProfileSimilarity(theirConnection, targetUser);
      const candidate = scoreIntermediary(
        sourceUser,
        theirConnection,
        targetUser,
        "inbound",
        simToYou.overall,
        simToTarget.overall
      );
      allCandidates.push(candidate);
      if (simToYou.overall > 0.35) {
        goodCandidates.push(candidate);
      }
    }
    goodCandidates.sort((a, b) => b.score - a.score);
    allCandidates.sort((a, b) => b.score - a.score);
    if (goodCandidates.length > 0) {
      return goodCandidates.slice(0, 5);
    }
    if (allCandidates.length > 0) {
      console.log("[IntermediaryScorer] No strong candidates found, returning best available (low confidence)");
      return [allCandidates[0]];
    }
    return [];
  }
  content;
  content;
  function calculateMutualConnectionAcceptanceRate(hopCount) {
    switch (hopCount) {
      case 1:
        return 0.85;
      // Direct connection (1st degree)
      case 2:
        return 0.65;
      // One mutual connection (2nd degree)
      case 3:
        return 0.45;
      // Two mutual connections (3rd degree)
      case 4:
        return 0.3;
      // Three mutuals (rare, lower confidence)
      default:
        return 0.25;
    }
  }
  content;
  function findNodeIdInGraph$2(graph, user) {
    const possibleIds = [
      user.id,
      user.email,
      user.name,
      user.publicId
      // Some profiles may have publicId
    ].filter(Boolean);
    for (const id of possibleIds) {
      if (id && graph.getNode?.(id)) {
        return id;
      }
    }
    return user.id || user.email || user.name || null;
  }
  function generateMutualNextSteps(path, target) {
    if (path.length < 2) {
      return ["Error: Invalid path"];
    }
    const firstIntermediary = path[1];
    const steps = [];
    steps.push(
      `Message ${firstIntermediary.name} (mutual connection)`
    );
    steps.push(`Ask for introduction to ${target.name}`);
    steps.push(`Mention shared connections in your outreach`);
    if (path.length > 2) {
      steps.push(`Consider multiple paths to increase success probability`);
    }
    return steps;
  }
  async function tryMutualConnectionStrategy(sourceUser, targetUser, graph) {
    if (!graph.bidirectionalBFS) {
      return null;
    }
    try {
      const sourceId = findNodeIdInGraph$2(graph, sourceUser);
      const targetId = findNodeIdInGraph$2(graph, targetUser);
      if (!sourceId || !targetId) {
        throw new Error(
          "Unable to find profile in your network. Please visit some LinkedIn profiles to build your network graph, then try again."
        );
      }
      const astarResult = await graph.bidirectionalBFS(sourceId, targetId);
      if (astarResult && astarResult.path.length > 0) {
        const intermediaryCount = astarResult.path.length - 2;
        const hopCount = astarResult.path.length - 1;
        const acceptanceRate = calculateMutualConnectionAcceptanceRate(hopCount);
        console.log(
          `[Uproot] [PATH] Found ${hopCount}-hop mutual connection path with ${(acceptanceRate * 100).toFixed(0)}% estimated acceptance`
        );
        return {
          type: "mutual",
          confidence: astarResult.probability,
          path: {
            nodes: astarResult.path,
            edges: [],
            // Would be populated by actual graph
            totalWeight: 1 - astarResult.probability,
            successProbability: astarResult.probability,
            mutualConnections: astarResult.mutualConnections
          },
          estimatedAcceptanceRate: acceptanceRate,
          // Hop-based: 85% (1-hop), 65% (2-hop), 45% (3-hop)
          reasoning: `Found path via ${intermediaryCount} ${intermediaryCount === 1 ? "intermediary" : "intermediaries"} with ${astarResult.mutualConnections} mutual connections`,
          nextSteps: generateMutualNextSteps(astarResult.path, targetUser)
        };
      }
    } catch (error) {
      console.warn("A* pathfinding failed, falling back to similarity-based strategies:", error);
    }
    return null;
  }
  content;
  function getTopSimilarities(breakdown) {
    const sorted = Object.entries(breakdown).filter(([_, score]) => score > 0.5).sort(([_, a], [__, b]) => b - a).map(([attr]) => attr);
    if (sorted.length === 0) return "background";
    if (sorted.length === 1) return sorted[0];
    return `${sorted[0]} and ${sorted[1]}`;
  }
  function generateDirectSimilarityNextSteps(target, similarity) {
    const topSims = getTopSimilarities(similarity.breakdown);
    return [
      `Direct message ${target.name}`,
      `Mention shared ${topSims} in your message`,
      `Reference specific recent posts or achievements`,
      `Keep message concise (200-250 characters)`,
      `Include clear value proposition`
    ];
  }
  function tryDirectSimilarityStrategy(_sourceUser, targetUser, directSimilarity) {
    if (directSimilarity.overall < 0.65) {
      return null;
    }
    const acceptanceRate = 0.35 + (directSimilarity.overall - 0.65) * (0.07 / 0.35);
    return {
      type: "direct-similarity",
      confidence: directSimilarity.overall,
      directSimilarity,
      estimatedAcceptanceRate: acceptanceRate,
      reasoning: `Very high profile similarity (${(directSimilarity.overall * 100).toFixed(1)}%): ${getTopSimilarities(directSimilarity.breakdown)}`,
      nextSteps: generateDirectSimilarityNextSteps(
        targetUser,
        directSimilarity
      )
    };
  }
  content;
  var dexie_min$1 = { exports: {} };
  var dexie_min = dexie_min$1.exports;
  var hasRequiredDexie_min;
  function requireDexie_min() {
    if (hasRequiredDexie_min) return dexie_min$1.exports;
    hasRequiredDexie_min = 1;
    (function(module, exports$1) {
      (function(e, t) {
        module.exports = t();
      })(dexie_min, function() {
        var s = function(e2, t2) {
          return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var n2 in t3) Object.prototype.hasOwnProperty.call(t3, n2) && (e3[n2] = t3[n2]);
          })(e2, t2);
        };
        var _ = function() {
          return (_ = Object.assign || function(e2) {
            for (var t2, n2 = 1, r3 = arguments.length; n2 < r3; n2++) for (var i2 in t2 = arguments[n2]) Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
            return e2;
          }).apply(this, arguments);
        };
        function i(e2, t2, n2) {
          for (var r3, i2 = 0, o2 = t2.length; i2 < o2; i2++) !r3 && i2 in t2 || ((r3 = r3 || Array.prototype.slice.call(t2, 0, i2))[i2] = t2[i2]);
          return e2.concat(r3 || Array.prototype.slice.call(t2));
        }
        var f = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : commonjsGlobal, O = Object.keys, x = Array.isArray;
        function a(t2, n2) {
          return "object" != typeof n2 || O(n2).forEach(function(e2) {
            t2[e2] = n2[e2];
          }), t2;
        }
        "undefined" == typeof Promise || f.Promise || (f.Promise = Promise);
        var c = Object.getPrototypeOf, n = {}.hasOwnProperty;
        function m(e2, t2) {
          return n.call(e2, t2);
        }
        function r2(t2, n2) {
          "function" == typeof n2 && (n2 = n2(c(t2))), ("undefined" == typeof Reflect ? O : Reflect.ownKeys)(n2).forEach(function(e2) {
            l(t2, e2, n2[e2]);
          });
        }
        var u = Object.defineProperty;
        function l(e2, t2, n2, r3) {
          u(e2, t2, a(n2 && m(n2, "get") && "function" == typeof n2.get ? { get: n2.get, set: n2.set, configurable: true } : { value: n2, configurable: true, writable: true }, r3));
        }
        function o(t2) {
          return { from: function(e2) {
            return t2.prototype = Object.create(e2.prototype), l(t2.prototype, "constructor", t2), { extend: r2.bind(null, t2.prototype) };
          } };
        }
        var h = Object.getOwnPropertyDescriptor;
        var d = [].slice;
        function b(e2, t2, n2) {
          return d.call(e2, t2, n2);
        }
        function p(e2, t2) {
          return t2(e2);
        }
        function y(e2) {
          if (!e2) throw new Error("Assertion Failed");
        }
        function v(e2) {
          f.setImmediate ? setImmediate(e2) : setTimeout(e2, 0);
        }
        function g(e2, t2) {
          if ("string" == typeof t2 && m(e2, t2)) return e2[t2];
          if (!t2) return e2;
          if ("string" != typeof t2) {
            for (var n2 = [], r3 = 0, i2 = t2.length; r3 < i2; ++r3) {
              var o2 = g(e2, t2[r3]);
              n2.push(o2);
            }
            return n2;
          }
          var a2 = t2.indexOf(".");
          if (-1 !== a2) {
            var u2 = e2[t2.substr(0, a2)];
            return null == u2 ? void 0 : g(u2, t2.substr(a2 + 1));
          }
        }
        function w(e2, t2, n2) {
          if (e2 && void 0 !== t2 && !("isFrozen" in Object && Object.isFrozen(e2))) if ("string" != typeof t2 && "length" in t2) {
            y("string" != typeof n2 && "length" in n2);
            for (var r3 = 0, i2 = t2.length; r3 < i2; ++r3) w(e2, t2[r3], n2[r3]);
          } else {
            var o2, a2, u2 = t2.indexOf(".");
            -1 !== u2 ? (o2 = t2.substr(0, u2), "" === (a2 = t2.substr(u2 + 1)) ? void 0 === n2 ? x(e2) && !isNaN(parseInt(o2)) ? e2.splice(o2, 1) : delete e2[o2] : e2[o2] = n2 : w(u2 = !(u2 = e2[o2]) || !m(e2, o2) ? e2[o2] = {} : u2, a2, n2)) : void 0 === n2 ? x(e2) && !isNaN(parseInt(t2)) ? e2.splice(t2, 1) : delete e2[t2] : e2[t2] = n2;
          }
        }
        function k(e2) {
          var t2, n2 = {};
          for (t2 in e2) m(e2, t2) && (n2[t2] = e2[t2]);
          return n2;
        }
        var t = [].concat;
        function P(e2) {
          return t.apply([], e2);
        }
        var e = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(P([8, 16, 32, 64].map(function(t2) {
          return ["Int", "Uint", "Float"].map(function(e2) {
            return e2 + t2 + "Array";
          });
        }))).filter(function(e2) {
          return f[e2];
        }), K = new Set(e.map(function(e2) {
          return f[e2];
        }));
        var E = null;
        function S(e2) {
          E = /* @__PURE__ */ new WeakMap();
          e2 = (function e3(t2) {
            if (!t2 || "object" != typeof t2) return t2;
            var n2 = E.get(t2);
            if (n2) return n2;
            if (x(t2)) {
              n2 = [], E.set(t2, n2);
              for (var r3 = 0, i2 = t2.length; r3 < i2; ++r3) n2.push(e3(t2[r3]));
            } else if (K.has(t2.constructor)) n2 = t2;
            else {
              var o2, a2 = c(t2);
              for (o2 in n2 = a2 === Object.prototype ? {} : Object.create(a2), E.set(t2, n2), t2) m(t2, o2) && (n2[o2] = e3(t2[o2]));
            }
            return n2;
          })(e2);
          return E = null, e2;
        }
        var j = {}.toString;
        function A(e2) {
          return j.call(e2).slice(8, -1);
        }
        var C = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator", T = "symbol" == typeof C ? function(e2) {
          var t2;
          return null != e2 && (t2 = e2[C]) && t2.apply(e2);
        } : function() {
          return null;
        };
        function I(e2, t2) {
          t2 = e2.indexOf(t2);
          return 0 <= t2 && e2.splice(t2, 1), 0 <= t2;
        }
        var q = {};
        function D(e2) {
          var t2, n2, r3, i2;
          if (1 === arguments.length) {
            if (x(e2)) return e2.slice();
            if (this === q && "string" == typeof e2) return [e2];
            if (i2 = T(e2)) {
              for (n2 = []; !(r3 = i2.next()).done; ) n2.push(r3.value);
              return n2;
            }
            if (null == e2) return [e2];
            if ("number" != typeof (t2 = e2.length)) return [e2];
            for (n2 = new Array(t2); t2--; ) n2[t2] = e2[t2];
            return n2;
          }
          for (t2 = arguments.length, n2 = new Array(t2); t2--; ) n2[t2] = arguments[t2];
          return n2;
        }
        var B = "undefined" != typeof Symbol ? function(e2) {
          return "AsyncFunction" === e2[Symbol.toStringTag];
        } : function() {
          return false;
        }, R = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], F = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(R), M = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
        function N(e2, t2) {
          this.name = e2, this.message = t2;
        }
        function L(e2, t2) {
          return e2 + ". Errors: " + Object.keys(t2).map(function(e3) {
            return t2[e3].toString();
          }).filter(function(e3, t3, n2) {
            return n2.indexOf(e3) === t3;
          }).join("\n");
        }
        function U(e2, t2, n2, r3) {
          this.failures = t2, this.failedKeys = r3, this.successCount = n2, this.message = L(e2, t2);
        }
        function V(e2, t2) {
          this.name = "BulkError", this.failures = Object.keys(t2).map(function(e3) {
            return t2[e3];
          }), this.failuresByPos = t2, this.message = L(e2, this.failures);
        }
        o(N).from(Error).extend({ toString: function() {
          return this.name + ": " + this.message;
        } }), o(U).from(N), o(V).from(N);
        var z = F.reduce(function(e2, t2) {
          return e2[t2] = t2 + "Error", e2;
        }, {}), W = N, Y = F.reduce(function(e2, n2) {
          var r3 = n2 + "Error";
          function t2(e3, t3) {
            this.name = r3, e3 ? "string" == typeof e3 ? (this.message = "".concat(e3).concat(t3 ? "\n " + t3 : ""), this.inner = t3 || null) : "object" == typeof e3 && (this.message = "".concat(e3.name, " ").concat(e3.message), this.inner = e3) : (this.message = M[n2] || r3, this.inner = null);
          }
          return o(t2).from(W), e2[n2] = t2, e2;
        }, {});
        Y.Syntax = SyntaxError, Y.Type = TypeError, Y.Range = RangeError;
        var $ = R.reduce(function(e2, t2) {
          return e2[t2 + "Error"] = Y[t2], e2;
        }, {});
        var Q = F.reduce(function(e2, t2) {
          return -1 === ["Syntax", "Type", "Range"].indexOf(t2) && (e2[t2 + "Error"] = Y[t2]), e2;
        }, {});
        function G() {
        }
        function X2(e2) {
          return e2;
        }
        function H(t2, n2) {
          return null == t2 || t2 === X2 ? n2 : function(e2) {
            return n2(t2(e2));
          };
        }
        function J(e2, t2) {
          return function() {
            e2.apply(this, arguments), t2.apply(this, arguments);
          };
        }
        function Z(i2, o2) {
          return i2 === G ? o2 : function() {
            var e2 = i2.apply(this, arguments);
            void 0 !== e2 && (arguments[0] = e2);
            var t2 = this.onsuccess, n2 = this.onerror;
            this.onsuccess = null, this.onerror = null;
            var r3 = o2.apply(this, arguments);
            return t2 && (this.onsuccess = this.onsuccess ? J(t2, this.onsuccess) : t2), n2 && (this.onerror = this.onerror ? J(n2, this.onerror) : n2), void 0 !== r3 ? r3 : e2;
          };
        }
        function ee(n2, r3) {
          return n2 === G ? r3 : function() {
            n2.apply(this, arguments);
            var e2 = this.onsuccess, t2 = this.onerror;
            this.onsuccess = this.onerror = null, r3.apply(this, arguments), e2 && (this.onsuccess = this.onsuccess ? J(e2, this.onsuccess) : e2), t2 && (this.onerror = this.onerror ? J(t2, this.onerror) : t2);
          };
        }
        function te(i2, o2) {
          return i2 === G ? o2 : function(e2) {
            var t2 = i2.apply(this, arguments);
            a(e2, t2);
            var n2 = this.onsuccess, r3 = this.onerror;
            this.onsuccess = null, this.onerror = null;
            e2 = o2.apply(this, arguments);
            return n2 && (this.onsuccess = this.onsuccess ? J(n2, this.onsuccess) : n2), r3 && (this.onerror = this.onerror ? J(r3, this.onerror) : r3), void 0 === t2 ? void 0 === e2 ? void 0 : e2 : a(t2, e2);
          };
        }
        function ne(e2, t2) {
          return e2 === G ? t2 : function() {
            return false !== t2.apply(this, arguments) && e2.apply(this, arguments);
          };
        }
        function re(i2, o2) {
          return i2 === G ? o2 : function() {
            var e2 = i2.apply(this, arguments);
            if (e2 && "function" == typeof e2.then) {
              for (var t2 = this, n2 = arguments.length, r3 = new Array(n2); n2--; ) r3[n2] = arguments[n2];
              return e2.then(function() {
                return o2.apply(t2, r3);
              });
            }
            return o2.apply(this, arguments);
          };
        }
        Q.ModifyError = U, Q.DexieError = N, Q.BulkError = V;
        var ie = "undefined" != typeof location && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
        function oe(e2) {
          ie = e2;
        }
        var ae = {}, ue = 100, e = "undefined" == typeof Promise ? [] : (function() {
          var e2 = Promise.resolve();
          if ("undefined" == typeof crypto || !crypto.subtle) return [e2, c(e2), e2];
          var t2 = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
          return [t2, c(t2), e2];
        })(), R = e[0], F = e[1], e = e[2], F = F && F.then, se = R && R.constructor, ce = !!e;
        var le = function(e2, t2) {
          be.push([e2, t2]), he && (queueMicrotask(Se), he = false);
        }, fe = true, he = true, de = [], pe = [], ye = X2, ve = { id: "global", global: true, ref: 0, unhandleds: [], onunhandled: G, pgp: false, env: {}, finalize: G }, me = ve, be = [], ge = 0, we = [];
        function _e(e2) {
          if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
          this._listeners = [], this._lib = false;
          var t2 = this._PSD = me;
          if ("function" != typeof e2) {
            if (e2 !== ae) throw new TypeError("Not a function");
            return this._state = arguments[1], this._value = arguments[2], void (false === this._state && Oe(this, this._value));
          }
          this._state = null, this._value = null, ++t2.ref, (function t3(r3, e3) {
            try {
              e3(function(n2) {
                if (null === r3._state) {
                  if (n2 === r3) throw new TypeError("A promise cannot be resolved with itself.");
                  var e4 = r3._lib && je();
                  n2 && "function" == typeof n2.then ? t3(r3, function(e5, t4) {
                    n2 instanceof _e ? n2._then(e5, t4) : n2.then(e5, t4);
                  }) : (r3._state = true, r3._value = n2, Pe(r3)), e4 && Ae();
                }
              }, Oe.bind(null, r3));
            } catch (e4) {
              Oe(r3, e4);
            }
          })(this, e2);
        }
        var xe = { get: function() {
          var u2 = me, t2 = Fe;
          function e2(n2, r3) {
            var i2 = this, o2 = !u2.global && (u2 !== me || t2 !== Fe), a2 = o2 && !Ue(), e3 = new _e(function(e4, t3) {
              Ke(i2, new ke(Qe(n2, u2, o2, a2), Qe(r3, u2, o2, a2), e4, t3, u2));
            });
            return this._consoleTask && (e3._consoleTask = this._consoleTask), e3;
          }
          return e2.prototype = ae, e2;
        }, set: function(e2) {
          l(this, "then", e2 && e2.prototype === ae ? xe : { get: function() {
            return e2;
          }, set: xe.set });
        } };
        function ke(e2, t2, n2, r3, i2) {
          this.onFulfilled = "function" == typeof e2 ? e2 : null, this.onRejected = "function" == typeof t2 ? t2 : null, this.resolve = n2, this.reject = r3, this.psd = i2;
        }
        function Oe(e2, t2) {
          var n2, r3;
          pe.push(t2), null === e2._state && (n2 = e2._lib && je(), t2 = ye(t2), e2._state = false, e2._value = t2, r3 = e2, de.some(function(e3) {
            return e3._value === r3._value;
          }) || de.push(r3), Pe(e2), n2 && Ae());
        }
        function Pe(e2) {
          var t2 = e2._listeners;
          e2._listeners = [];
          for (var n2 = 0, r3 = t2.length; n2 < r3; ++n2) Ke(e2, t2[n2]);
          var i2 = e2._PSD;
          --i2.ref || i2.finalize(), 0 === ge && (++ge, le(function() {
            0 == --ge && Ce();
          }, []));
        }
        function Ke(e2, t2) {
          if (null !== e2._state) {
            var n2 = e2._state ? t2.onFulfilled : t2.onRejected;
            if (null === n2) return (e2._state ? t2.resolve : t2.reject)(e2._value);
            ++t2.psd.ref, ++ge, le(Ee, [n2, e2, t2]);
          } else e2._listeners.push(t2);
        }
        function Ee(e2, t2, n2) {
          try {
            var r3, i2 = t2._value;
            !t2._state && pe.length && (pe = []), r3 = ie && t2._consoleTask ? t2._consoleTask.run(function() {
              return e2(i2);
            }) : e2(i2), t2._state || -1 !== pe.indexOf(i2) || (function(e3) {
              var t3 = de.length;
              for (; t3; ) if (de[--t3]._value === e3._value) return de.splice(t3, 1);
            })(t2), n2.resolve(r3);
          } catch (e3) {
            n2.reject(e3);
          } finally {
            0 == --ge && Ce(), --n2.psd.ref || n2.psd.finalize();
          }
        }
        function Se() {
          $e(ve, function() {
            je() && Ae();
          });
        }
        function je() {
          var e2 = fe;
          return he = fe = false, e2;
        }
        function Ae() {
          var e2, t2, n2;
          do {
            for (; 0 < be.length; ) for (e2 = be, be = [], n2 = e2.length, t2 = 0; t2 < n2; ++t2) {
              var r3 = e2[t2];
              r3[0].apply(null, r3[1]);
            }
          } while (0 < be.length);
          he = fe = true;
        }
        function Ce() {
          var e2 = de;
          de = [], e2.forEach(function(e3) {
            e3._PSD.onunhandled.call(null, e3._value, e3);
          });
          for (var t2 = we.slice(0), n2 = t2.length; n2; ) t2[--n2]();
        }
        function Te(e2) {
          return new _e(ae, false, e2);
        }
        function Ie(n2, r3) {
          var i2 = me;
          return function() {
            var e2 = je(), t2 = me;
            try {
              return We(i2, true), n2.apply(this, arguments);
            } catch (e3) {
              r3 && r3(e3);
            } finally {
              We(t2, false), e2 && Ae();
            }
          };
        }
        r2(_e.prototype, { then: xe, _then: function(e2, t2) {
          Ke(this, new ke(null, null, e2, t2, me));
        }, catch: function(e2) {
          if (1 === arguments.length) return this.then(null, e2);
          var t2 = e2, n2 = arguments[1];
          return "function" == typeof t2 ? this.then(null, function(e3) {
            return (e3 instanceof t2 ? n2 : Te)(e3);
          }) : this.then(null, function(e3) {
            return (e3 && e3.name === t2 ? n2 : Te)(e3);
          });
        }, finally: function(t2) {
          return this.then(function(e2) {
            return _e.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return _e.resolve(t2()).then(function() {
              return Te(e2);
            });
          });
        }, timeout: function(r3, i2) {
          var o2 = this;
          return r3 < 1 / 0 ? new _e(function(e2, t2) {
            var n2 = setTimeout(function() {
              return t2(new Y.Timeout(i2));
            }, r3);
            o2.then(e2, t2).finally(clearTimeout.bind(null, n2));
          }) : this;
        } }), "undefined" != typeof Symbol && Symbol.toStringTag && l(_e.prototype, Symbol.toStringTag, "Dexie.Promise"), ve.env = Ye(), r2(_e, { all: function() {
          var o2 = D.apply(null, arguments).map(Ve);
          return new _e(function(n2, r3) {
            0 === o2.length && n2([]);
            var i2 = o2.length;
            o2.forEach(function(e2, t2) {
              return _e.resolve(e2).then(function(e3) {
                o2[t2] = e3, --i2 || n2(o2);
              }, r3);
            });
          });
        }, resolve: function(n2) {
          return n2 instanceof _e ? n2 : n2 && "function" == typeof n2.then ? new _e(function(e2, t2) {
            n2.then(e2, t2);
          }) : new _e(ae, true, n2);
        }, reject: Te, race: function() {
          var e2 = D.apply(null, arguments).map(Ve);
          return new _e(function(t2, n2) {
            e2.map(function(e3) {
              return _e.resolve(e3).then(t2, n2);
            });
          });
        }, PSD: { get: function() {
          return me;
        }, set: function(e2) {
          return me = e2;
        } }, totalEchoes: { get: function() {
          return Fe;
        } }, newPSD: Ne, usePSD: $e, scheduler: { get: function() {
          return le;
        }, set: function(e2) {
          le = e2;
        } }, rejectionMapper: { get: function() {
          return ye;
        }, set: function(e2) {
          ye = e2;
        } }, follow: function(i2, n2) {
          return new _e(function(e2, t2) {
            return Ne(function(n3, r3) {
              var e3 = me;
              e3.unhandleds = [], e3.onunhandled = r3, e3.finalize = J(function() {
                var t3, e4 = this;
                t3 = function() {
                  0 === e4.unhandleds.length ? n3() : r3(e4.unhandleds[0]);
                }, we.push(function e5() {
                  t3(), we.splice(we.indexOf(e5), 1);
                }), ++ge, le(function() {
                  0 == --ge && Ce();
                }, []);
              }, e3.finalize), i2();
            }, n2, e2, t2);
          });
        } }), se && (se.allSettled && l(_e, "allSettled", function() {
          var e2 = D.apply(null, arguments).map(Ve);
          return new _e(function(n2) {
            0 === e2.length && n2([]);
            var r3 = e2.length, i2 = new Array(r3);
            e2.forEach(function(e3, t2) {
              return _e.resolve(e3).then(function(e4) {
                return i2[t2] = { status: "fulfilled", value: e4 };
              }, function(e4) {
                return i2[t2] = { status: "rejected", reason: e4 };
              }).then(function() {
                return --r3 || n2(i2);
              });
            });
          });
        }), se.any && "undefined" != typeof AggregateError && l(_e, "any", function() {
          var e2 = D.apply(null, arguments).map(Ve);
          return new _e(function(n2, r3) {
            0 === e2.length && r3(new AggregateError([]));
            var i2 = e2.length, o2 = new Array(i2);
            e2.forEach(function(e3, t2) {
              return _e.resolve(e3).then(function(e4) {
                return n2(e4);
              }, function(e4) {
                o2[t2] = e4, --i2 || r3(new AggregateError(o2));
              });
            });
          });
        }), se.withResolvers && (_e.withResolvers = se.withResolvers));
        var qe = { awaits: 0, echoes: 0, id: 0 }, De = 0, Be = [], Re = 0, Fe = 0, Me = 0;
        function Ne(e2, t2, n2, r3) {
          var i2 = me, o2 = Object.create(i2);
          o2.parent = i2, o2.ref = 0, o2.global = false, o2.id = ++Me, ve.env, o2.env = ce ? { Promise: _e, PromiseProp: { value: _e, configurable: true, writable: true }, all: _e.all, race: _e.race, allSettled: _e.allSettled, any: _e.any, resolve: _e.resolve, reject: _e.reject } : {}, t2 && a(o2, t2), ++i2.ref, o2.finalize = function() {
            --this.parent.ref || this.parent.finalize();
          };
          r3 = $e(o2, e2, n2, r3);
          return 0 === o2.ref && o2.finalize(), r3;
        }
        function Le() {
          return qe.id || (qe.id = ++De), ++qe.awaits, qe.echoes += ue, qe.id;
        }
        function Ue() {
          return !!qe.awaits && (0 == --qe.awaits && (qe.id = 0), qe.echoes = qe.awaits * ue, true);
        }
        function Ve(e2) {
          return qe.echoes && e2 && e2.constructor === se ? (Le(), e2.then(function(e3) {
            return Ue(), e3;
          }, function(e3) {
            return Ue(), Xe(e3);
          })) : e2;
        }
        function ze() {
          var e2 = Be[Be.length - 1];
          Be.pop(), We(e2, false);
        }
        function We(e2, t2) {
          var n2, r3 = me;
          (t2 ? !qe.echoes || Re++ && e2 === me : !Re || --Re && e2 === me) || queueMicrotask(t2 ? function(e3) {
            ++Fe, qe.echoes && 0 != --qe.echoes || (qe.echoes = qe.awaits = qe.id = 0), Be.push(me), We(e3, true);
          }.bind(null, e2) : ze), e2 !== me && (me = e2, r3 === ve && (ve.env = Ye()), ce && (n2 = ve.env.Promise, t2 = e2.env, (r3.global || e2.global) && (Object.defineProperty(f, "Promise", t2.PromiseProp), n2.all = t2.all, n2.race = t2.race, n2.resolve = t2.resolve, n2.reject = t2.reject, t2.allSettled && (n2.allSettled = t2.allSettled), t2.any && (n2.any = t2.any))));
        }
        function Ye() {
          var e2 = f.Promise;
          return ce ? { Promise: e2, PromiseProp: Object.getOwnPropertyDescriptor(f, "Promise"), all: e2.all, race: e2.race, allSettled: e2.allSettled, any: e2.any, resolve: e2.resolve, reject: e2.reject } : {};
        }
        function $e(e2, t2, n2, r3, i2) {
          var o2 = me;
          try {
            return We(e2, true), t2(n2, r3, i2);
          } finally {
            We(o2, false);
          }
        }
        function Qe(t2, n2, r3, i2) {
          return "function" != typeof t2 ? t2 : function() {
            var e2 = me;
            r3 && Le(), We(n2, true);
            try {
              return t2.apply(this, arguments);
            } finally {
              We(e2, false), i2 && queueMicrotask(Ue);
            }
          };
        }
        function Ge(e2) {
          Promise === se && 0 === qe.echoes ? 0 === Re ? e2() : enqueueNativeMicroTask(e2) : setTimeout(e2, 0);
        }
        -1 === ("" + F).indexOf("[native code]") && (Le = Ue = G);
        var Xe = _e.reject;
        var He = String.fromCharCode(65535), Je = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Ze = "String expected.", et = [], tt = "__dbnames", nt = "readonly", rt = "readwrite";
        function it(e2, t2) {
          return e2 ? t2 ? function() {
            return e2.apply(this, arguments) && t2.apply(this, arguments);
          } : e2 : t2;
        }
        var ot = { type: 3, lower: -1 / 0, lowerOpen: false, upper: [[]], upperOpen: false };
        function at(t2) {
          return "string" != typeof t2 || /\./.test(t2) ? function(e2) {
            return e2;
          } : function(e2) {
            return void 0 === e2[t2] && t2 in e2 && delete (e2 = S(e2))[t2], e2;
          };
        }
        function ut() {
          throw Y.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
        }
        function st(e2, t2) {
          try {
            var n2 = ct(e2), r3 = ct(t2);
            if (n2 !== r3) return "Array" === n2 ? 1 : "Array" === r3 ? -1 : "binary" === n2 ? 1 : "binary" === r3 ? -1 : "string" === n2 ? 1 : "string" === r3 ? -1 : "Date" === n2 ? 1 : "Date" !== r3 ? NaN : -1;
            switch (n2) {
              case "number":
              case "Date":
              case "string":
                return t2 < e2 ? 1 : e2 < t2 ? -1 : 0;
              case "binary":
                return (function(e3, t3) {
                  for (var n3 = e3.length, r4 = t3.length, i2 = n3 < r4 ? n3 : r4, o2 = 0; o2 < i2; ++o2) if (e3[o2] !== t3[o2]) return e3[o2] < t3[o2] ? -1 : 1;
                  return n3 === r4 ? 0 : n3 < r4 ? -1 : 1;
                })(lt(e2), lt(t2));
              case "Array":
                return (function(e3, t3) {
                  for (var n3 = e3.length, r4 = t3.length, i2 = n3 < r4 ? n3 : r4, o2 = 0; o2 < i2; ++o2) {
                    var a2 = st(e3[o2], t3[o2]);
                    if (0 !== a2) return a2;
                  }
                  return n3 === r4 ? 0 : n3 < r4 ? -1 : 1;
                })(e2, t2);
            }
          } catch (e3) {
          }
          return NaN;
        }
        function ct(e2) {
          var t2 = typeof e2;
          if ("object" != t2) return t2;
          if (ArrayBuffer.isView(e2)) return "binary";
          e2 = A(e2);
          return "ArrayBuffer" === e2 ? "binary" : e2;
        }
        function lt(e2) {
          return e2 instanceof Uint8Array ? e2 : ArrayBuffer.isView(e2) ? new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength) : new Uint8Array(e2);
        }
        function ft(t2, n2, r3) {
          var e2 = t2.schema.yProps;
          return e2 ? (n2 && 0 < r3.numFailures && (n2 = n2.filter(function(e3, t3) {
            return !r3.failures[t3];
          })), Promise.all(e2.map(function(e3) {
            e3 = e3.updatesTable;
            return n2 ? t2.db.table(e3).where("k").anyOf(n2).delete() : t2.db.table(e3).clear();
          })).then(function() {
            return r3;
          })) : r3;
        }
        var ht = (dt.prototype.execute = function(e2) {
          var t2 = this["@@propmod"];
          if (void 0 !== t2.add) {
            var n2 = t2.add;
            if (x(n2)) return i(i([], x(e2) ? e2 : [], true), n2).sort();
            if ("number" == typeof n2) return (Number(e2) || 0) + n2;
            if ("bigint" == typeof n2) try {
              return BigInt(e2) + n2;
            } catch (e3) {
              return BigInt(0) + n2;
            }
            throw new TypeError("Invalid term ".concat(n2));
          }
          if (void 0 !== t2.remove) {
            var r3 = t2.remove;
            if (x(r3)) return x(e2) ? e2.filter(function(e3) {
              return !r3.includes(e3);
            }).sort() : [];
            if ("number" == typeof r3) return Number(e2) - r3;
            if ("bigint" == typeof r3) try {
              return BigInt(e2) - r3;
            } catch (e3) {
              return BigInt(0) - r3;
            }
            throw new TypeError("Invalid subtrahend ".concat(r3));
          }
          n2 = null === (n2 = t2.replacePrefix) || void 0 === n2 ? void 0 : n2[0];
          return n2 && "string" == typeof e2 && e2.startsWith(n2) ? t2.replacePrefix[1] + e2.substring(n2.length) : e2;
        }, dt);
        function dt(e2) {
          this["@@propmod"] = e2;
        }
        function pt(e2, t2) {
          for (var n2 = O(t2), r3 = n2.length, i2 = false, o2 = 0; o2 < r3; ++o2) {
            var a2 = n2[o2], u2 = t2[a2], s2 = g(e2, a2);
            u2 instanceof ht ? (w(e2, a2, u2.execute(s2)), i2 = true) : s2 !== u2 && (w(e2, a2, u2), i2 = true);
          }
          return i2;
        }
        var yt = (vt.prototype._trans = function(e2, r3, t2) {
          var n2 = this._tx || me.trans, i2 = this.name, o2 = ie && "undefined" != typeof console && console.createTask && console.createTask("Dexie: ".concat("readonly" === e2 ? "read" : "write", " ").concat(this.name));
          function a2(e3, t3, n3) {
            if (!n3.schema[i2]) throw new Y.NotFound("Table " + i2 + " not part of transaction");
            return r3(n3.idbtrans, n3);
          }
          var u2 = je();
          try {
            var s2 = n2 && n2.db._novip === this.db._novip ? n2 === me.trans ? n2._promise(e2, a2, t2) : Ne(function() {
              return n2._promise(e2, a2, t2);
            }, { trans: n2, transless: me.transless || me }) : (function t3(n3, r4, i3, o3) {
              if (n3.idbdb && (n3._state.openComplete || me.letThrough || n3._vip)) {
                var a3 = n3._createTransaction(r4, i3, n3._dbSchema);
                try {
                  a3.create(), n3._state.PR1398_maxLoop = 3;
                } catch (e3) {
                  return e3.name === z.InvalidState && n3.isOpen() && 0 < --n3._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), n3.close({ disableAutoOpen: false }), n3.open().then(function() {
                    return t3(n3, r4, i3, o3);
                  })) : Xe(e3);
                }
                return a3._promise(r4, function(e3, t4) {
                  return Ne(function() {
                    return me.trans = a3, o3(e3, t4, a3);
                  });
                }).then(function(e3) {
                  if ("readwrite" === r4) try {
                    a3.idbtrans.commit();
                  } catch (e4) {
                  }
                  return "readonly" === r4 ? e3 : a3._completion.then(function() {
                    return e3;
                  });
                });
              }
              if (n3._state.openComplete) return Xe(new Y.DatabaseClosed(n3._state.dbOpenError));
              if (!n3._state.isBeingOpened) {
                if (!n3._state.autoOpen) return Xe(new Y.DatabaseClosed());
                n3.open().catch(G);
              }
              return n3._state.dbReadyPromise.then(function() {
                return t3(n3, r4, i3, o3);
              });
            })(this.db, e2, [this.name], a2);
            return o2 && (s2._consoleTask = o2, s2 = s2.catch(function(e3) {
              return console.trace(e3), Xe(e3);
            })), s2;
          } finally {
            u2 && Ae();
          }
        }, vt.prototype.get = function(t2, e2) {
          var n2 = this;
          return t2 && t2.constructor === Object ? this.where(t2).first(e2) : null == t2 ? Xe(new Y.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(e3) {
            return n2.core.get({ trans: e3, key: t2 }).then(function(e4) {
              return n2.hook.reading.fire(e4);
            });
          }).then(e2);
        }, vt.prototype.where = function(o2) {
          if ("string" == typeof o2) return new this.db.WhereClause(this, o2);
          if (x(o2)) return new this.db.WhereClause(this, "[".concat(o2.join("+"), "]"));
          var n2 = O(o2);
          if (1 === n2.length) return this.where(n2[0]).equals(o2[n2[0]]);
          var e2 = this.schema.indexes.concat(this.schema.primKey).filter(function(t3) {
            if (t3.compound && n2.every(function(e4) {
              return 0 <= t3.keyPath.indexOf(e4);
            })) {
              for (var e3 = 0; e3 < n2.length; ++e3) if (-1 === n2.indexOf(t3.keyPath[e3])) return false;
              return true;
            }
            return false;
          }).sort(function(e3, t3) {
            return e3.keyPath.length - t3.keyPath.length;
          })[0];
          if (e2 && this.db._maxKey !== He) {
            var t2 = e2.keyPath.slice(0, n2.length);
            return this.where(t2).equals(t2.map(function(e3) {
              return o2[e3];
            }));
          }
          !e2 && ie && console.warn("The query ".concat(JSON.stringify(o2), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(n2.join("+"), "]"));
          var a2 = this.schema.idxByName;
          function u2(e3, t3) {
            return 0 === st(e3, t3);
          }
          var r3 = n2.reduce(function(e3, t3) {
            var n3 = e3[0], r4 = e3[1], e3 = a2[t3], i2 = o2[t3];
            return [n3 || e3, n3 || !e3 ? it(r4, e3 && e3.multi ? function(e4) {
              e4 = g(e4, t3);
              return x(e4) && e4.some(function(e5) {
                return u2(i2, e5);
              });
            } : function(e4) {
              return u2(i2, g(e4, t3));
            }) : r4];
          }, [null, null]), t2 = r3[0], r3 = r3[1];
          return t2 ? this.where(t2.name).equals(o2[t2.keyPath]).filter(r3) : e2 ? this.filter(r3) : this.where(n2).equals("");
        }, vt.prototype.filter = function(e2) {
          return this.toCollection().and(e2);
        }, vt.prototype.count = function(e2) {
          return this.toCollection().count(e2);
        }, vt.prototype.offset = function(e2) {
          return this.toCollection().offset(e2);
        }, vt.prototype.limit = function(e2) {
          return this.toCollection().limit(e2);
        }, vt.prototype.each = function(e2) {
          return this.toCollection().each(e2);
        }, vt.prototype.toArray = function(e2) {
          return this.toCollection().toArray(e2);
        }, vt.prototype.toCollection = function() {
          return new this.db.Collection(new this.db.WhereClause(this));
        }, vt.prototype.orderBy = function(e2) {
          return new this.db.Collection(new this.db.WhereClause(this, x(e2) ? "[".concat(e2.join("+"), "]") : e2));
        }, vt.prototype.reverse = function() {
          return this.toCollection().reverse();
        }, vt.prototype.mapToClass = function(r3) {
          var e2, t2 = this.db, n2 = this.name;
          function i2() {
            return null !== e2 && e2.apply(this, arguments) || this;
          }
          (this.schema.mappedClass = r3).prototype instanceof ut && ((function(e3, t3) {
            if ("function" != typeof t3 && null !== t3) throw new TypeError("Class extends value " + String(t3) + " is not a constructor or null");
            function n3() {
              this.constructor = e3;
            }
            s(e3, t3), e3.prototype = null === t3 ? Object.create(t3) : (n3.prototype = t3.prototype, new n3());
          })(i2, e2 = r3), Object.defineProperty(i2.prototype, "db", { get: function() {
            return t2;
          }, enumerable: false, configurable: true }), i2.prototype.table = function() {
            return n2;
          }, r3 = i2);
          for (var o2 = /* @__PURE__ */ new Set(), a2 = r3.prototype; a2; a2 = c(a2)) Object.getOwnPropertyNames(a2).forEach(function(e3) {
            return o2.add(e3);
          });
          function u2(e3) {
            if (!e3) return e3;
            var t3, n3 = Object.create(r3.prototype);
            for (t3 in e3) if (!o2.has(t3)) try {
              n3[t3] = e3[t3];
            } catch (e4) {
            }
            return n3;
          }
          return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = u2, this.hook("reading", u2), r3;
        }, vt.prototype.defineClass = function() {
          return this.mapToClass(function(e2) {
            a(this, e2);
          });
        }, vt.prototype.add = function(t2, n2) {
          var r3 = this, e2 = this.schema.primKey, i2 = e2.auto, o2 = e2.keyPath, a2 = t2;
          return o2 && i2 && (a2 = at(o2)(t2)), this._trans("readwrite", function(e3) {
            return r3.core.mutate({ trans: e3, type: "add", keys: null != n2 ? [n2] : null, values: [a2] });
          }).then(function(e3) {
            return e3.numFailures ? _e.reject(e3.failures[0]) : e3.lastResult;
          }).then(function(e3) {
            if (o2) try {
              w(t2, o2, e3);
            } catch (e4) {
            }
            return e3;
          });
        }, vt.prototype.upsert = function(r3, i2) {
          var o2 = this, a2 = this.schema.primKey.keyPath;
          return this._trans("readwrite", function(n2) {
            return o2.core.get({ trans: n2, key: r3 }).then(function(t2) {
              var e2 = null != t2 ? t2 : {};
              return pt(e2, i2), a2 && w(e2, a2, r3), o2.core.mutate({ trans: n2, type: "put", values: [e2], keys: [r3], upsert: true, updates: { keys: [r3], changeSpecs: [i2] } }).then(function(e3) {
                return e3.numFailures ? _e.reject(e3.failures[0]) : !!t2;
              });
            });
          });
        }, vt.prototype.update = function(e2, t2) {
          if ("object" != typeof e2 || x(e2)) return this.where(":id").equals(e2).modify(t2);
          e2 = g(e2, this.schema.primKey.keyPath);
          return void 0 === e2 ? Xe(new Y.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e2).modify(t2);
        }, vt.prototype.put = function(t2, n2) {
          var r3 = this, e2 = this.schema.primKey, i2 = e2.auto, o2 = e2.keyPath, a2 = t2;
          return o2 && i2 && (a2 = at(o2)(t2)), this._trans("readwrite", function(e3) {
            return r3.core.mutate({ trans: e3, type: "put", values: [a2], keys: null != n2 ? [n2] : null });
          }).then(function(e3) {
            return e3.numFailures ? _e.reject(e3.failures[0]) : e3.lastResult;
          }).then(function(e3) {
            if (o2) try {
              w(t2, o2, e3);
            } catch (e4) {
            }
            return e3;
          });
        }, vt.prototype.delete = function(t2) {
          var n2 = this;
          return this._trans("readwrite", function(e2) {
            return n2.core.mutate({ trans: e2, type: "delete", keys: [t2] }).then(function(e3) {
              return ft(n2, [t2], e3);
            }).then(function(e3) {
              return e3.numFailures ? _e.reject(e3.failures[0]) : void 0;
            });
          });
        }, vt.prototype.clear = function() {
          var t2 = this;
          return this._trans("readwrite", function(e2) {
            return t2.core.mutate({ trans: e2, type: "deleteRange", range: ot }).then(function(e3) {
              return ft(t2, null, e3);
            });
          }).then(function(e2) {
            return e2.numFailures ? _e.reject(e2.failures[0]) : void 0;
          });
        }, vt.prototype.bulkGet = function(t2) {
          var n2 = this;
          return this._trans("readonly", function(e2) {
            return n2.core.getMany({ keys: t2, trans: e2 }).then(function(e3) {
              return e3.map(function(e4) {
                return n2.hook.reading.fire(e4);
              });
            });
          });
        }, vt.prototype.bulkAdd = function(r3, e2, t2) {
          var o2 = this, a2 = Array.isArray(e2) ? e2 : void 0, u2 = (t2 = t2 || (a2 ? void 0 : e2)) ? t2.allKeys : void 0;
          return this._trans("readwrite", function(e3) {
            var t3 = o2.schema.primKey, n2 = t3.auto, t3 = t3.keyPath;
            if (t3 && a2) throw new Y.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
            if (a2 && a2.length !== r3.length) throw new Y.InvalidArgument("Arguments objects and keys must have the same length");
            var i2 = r3.length, t3 = t3 && n2 ? r3.map(at(t3)) : r3;
            return o2.core.mutate({ trans: e3, type: "add", keys: a2, values: t3, wantResults: u2 }).then(function(e4) {
              var t4 = e4.numFailures, n3 = e4.results, r4 = e4.lastResult, e4 = e4.failures;
              if (0 === t4) return u2 ? n3 : r4;
              throw new V("".concat(o2.name, ".bulkAdd(): ").concat(t4, " of ").concat(i2, " operations failed"), e4);
            });
          });
        }, vt.prototype.bulkPut = function(r3, e2, t2) {
          var o2 = this, a2 = Array.isArray(e2) ? e2 : void 0, u2 = (t2 = t2 || (a2 ? void 0 : e2)) ? t2.allKeys : void 0;
          return this._trans("readwrite", function(e3) {
            var t3 = o2.schema.primKey, n2 = t3.auto, t3 = t3.keyPath;
            if (t3 && a2) throw new Y.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
            if (a2 && a2.length !== r3.length) throw new Y.InvalidArgument("Arguments objects and keys must have the same length");
            var i2 = r3.length, t3 = t3 && n2 ? r3.map(at(t3)) : r3;
            return o2.core.mutate({ trans: e3, type: "put", keys: a2, values: t3, wantResults: u2 }).then(function(e4) {
              var t4 = e4.numFailures, n3 = e4.results, r4 = e4.lastResult, e4 = e4.failures;
              if (0 === t4) return u2 ? n3 : r4;
              throw new V("".concat(o2.name, ".bulkPut(): ").concat(t4, " of ").concat(i2, " operations failed"), e4);
            });
          });
        }, vt.prototype.bulkUpdate = function(t2) {
          var h2 = this, n2 = this.core, r3 = t2.map(function(e2) {
            return e2.key;
          }), i2 = t2.map(function(e2) {
            return e2.changes;
          }), d2 = [];
          return this._trans("readwrite", function(e2) {
            return n2.getMany({ trans: e2, keys: r3, cache: "clone" }).then(function(c2) {
              var l2 = [], f2 = [];
              t2.forEach(function(e3, t3) {
                var n3 = e3.key, r4 = e3.changes, i3 = c2[t3];
                if (i3) {
                  for (var o2 = 0, a2 = Object.keys(r4); o2 < a2.length; o2++) {
                    var u2 = a2[o2], s3 = r4[u2];
                    if (u2 === h2.schema.primKey.keyPath) {
                      if (0 !== st(s3, n3)) throw new Y.Constraint("Cannot update primary key in bulkUpdate()");
                    } else w(i3, u2, s3);
                  }
                  d2.push(t3), l2.push(n3), f2.push(i3);
                }
              });
              var s2 = l2.length;
              return n2.mutate({ trans: e2, type: "put", keys: l2, values: f2, updates: { keys: r3, changeSpecs: i2 } }).then(function(e3) {
                var t3 = e3.numFailures, n3 = e3.failures;
                if (0 === t3) return s2;
                for (var r4 = 0, i3 = Object.keys(n3); r4 < i3.length; r4++) {
                  var o2, a2 = i3[r4], u2 = d2[Number(a2)];
                  null != u2 && (o2 = n3[a2], delete n3[a2], n3[u2] = o2);
                }
                throw new V("".concat(h2.name, ".bulkUpdate(): ").concat(t3, " of ").concat(s2, " operations failed"), n3);
              });
            });
          });
        }, vt.prototype.bulkDelete = function(t2) {
          var r3 = this, i2 = t2.length;
          return this._trans("readwrite", function(e2) {
            return r3.core.mutate({ trans: e2, type: "delete", keys: t2 }).then(function(e3) {
              return ft(r3, t2, e3);
            });
          }).then(function(e2) {
            var t3 = e2.numFailures, n2 = e2.lastResult, e2 = e2.failures;
            if (0 === t3) return n2;
            throw new V("".concat(r3.name, ".bulkDelete(): ").concat(t3, " of ").concat(i2, " operations failed"), e2);
          });
        }, vt);
        function vt() {
        }
        function mt(i2) {
          function t2(e3, t3) {
            if (t3) {
              for (var n3 = arguments.length, r3 = new Array(n3 - 1); --n3; ) r3[n3 - 1] = arguments[n3];
              return a2[e3].subscribe.apply(null, r3), i2;
            }
            if ("string" == typeof e3) return a2[e3];
          }
          var a2 = {};
          t2.addEventType = u2;
          for (var e2 = 1, n2 = arguments.length; e2 < n2; ++e2) u2(arguments[e2]);
          return t2;
          function u2(e3, n3, r3) {
            if ("object" != typeof e3) {
              var i3;
              n3 = n3 || ne;
              var o2 = { subscribers: [], fire: r3 = r3 || G, subscribe: function(e4) {
                -1 === o2.subscribers.indexOf(e4) && (o2.subscribers.push(e4), o2.fire = n3(o2.fire, e4));
              }, unsubscribe: function(t3) {
                o2.subscribers = o2.subscribers.filter(function(e4) {
                  return e4 !== t3;
                }), o2.fire = o2.subscribers.reduce(n3, r3);
              } };
              return a2[e3] = t2[e3] = o2;
            }
            O(i3 = e3).forEach(function(e4) {
              var t3 = i3[e4];
              if (x(t3)) u2(e4, i3[e4][0], i3[e4][1]);
              else {
                if ("asap" !== t3) throw new Y.InvalidArgument("Invalid event config");
                var n4 = u2(e4, X2, function() {
                  for (var e5 = arguments.length, t4 = new Array(e5); e5--; ) t4[e5] = arguments[e5];
                  n4.subscribers.forEach(function(e6) {
                    v(function() {
                      e6.apply(null, t4);
                    });
                  });
                });
              }
            });
          }
        }
        function bt(e2, t2) {
          return o(t2).from({ prototype: e2 }), t2;
        }
        function gt(e2, t2) {
          return !(e2.filter || e2.algorithm || e2.or) && (t2 ? e2.justLimit : !e2.replayFilter);
        }
        function wt(e2, t2) {
          e2.filter = it(e2.filter, t2);
        }
        function _t(e2, t2, n2) {
          var r3 = e2.replayFilter;
          e2.replayFilter = r3 ? function() {
            return it(r3(), t2());
          } : t2, e2.justLimit = n2 && !r3;
        }
        function xt(e2, t2) {
          if (e2.isPrimKey) return t2.primaryKey;
          var n2 = t2.getIndexByKeyPath(e2.index);
          if (!n2) throw new Y.Schema("KeyPath " + e2.index + " on object store " + t2.name + " is not indexed");
          return n2;
        }
        function kt(e2, t2, n2) {
          var r3 = xt(e2, t2.schema);
          return t2.openCursor({ trans: n2, values: !e2.keysOnly, reverse: "prev" === e2.dir, unique: !!e2.unique, query: { index: r3, range: e2.range } });
        }
        function Ot(e2, o2, t2, n2) {
          var a2 = e2.replayFilter ? it(e2.filter, e2.replayFilter()) : e2.filter;
          if (e2.or) {
            var u2 = {}, r3 = function(e3, t3, n3) {
              var r4, i2;
              a2 && !a2(t3, n3, function(e4) {
                return t3.stop(e4);
              }, function(e4) {
                return t3.fail(e4);
              }) || ("[object ArrayBuffer]" === (i2 = "" + (r4 = t3.primaryKey)) && (i2 = "" + new Uint8Array(r4)), m(u2, i2) || (u2[i2] = true, o2(e3, t3, n3)));
            };
            return Promise.all([e2.or._iterate(r3, t2), Pt(kt(e2, n2, t2), e2.algorithm, r3, !e2.keysOnly && e2.valueMapper)]);
          }
          return Pt(kt(e2, n2, t2), it(e2.algorithm, a2), o2, !e2.keysOnly && e2.valueMapper);
        }
        function Pt(e2, r3, i2, o2) {
          var a2 = Ie(o2 ? function(e3, t2, n2) {
            return i2(o2(e3), t2, n2);
          } : i2);
          return e2.then(function(n2) {
            if (n2) return n2.start(function() {
              var t2 = function() {
                return n2.continue();
              };
              r3 && !r3(n2, function(e3) {
                return t2 = e3;
              }, function(e3) {
                n2.stop(e3), t2 = G;
              }, function(e3) {
                n2.fail(e3), t2 = G;
              }) || a2(n2.value, n2, function(e3) {
                return t2 = e3;
              }), t2();
            });
          });
        }
        var Kt = (Et.prototype._read = function(e2, t2) {
          var n2 = this._ctx;
          return n2.error ? n2.table._trans(null, Xe.bind(null, n2.error)) : n2.table._trans("readonly", e2).then(t2);
        }, Et.prototype._write = function(e2) {
          var t2 = this._ctx;
          return t2.error ? t2.table._trans(null, Xe.bind(null, t2.error)) : t2.table._trans("readwrite", e2, "locked");
        }, Et.prototype._addAlgorithm = function(e2) {
          var t2 = this._ctx;
          t2.algorithm = it(t2.algorithm, e2);
        }, Et.prototype._iterate = function(e2, t2) {
          return Ot(this._ctx, e2, t2, this._ctx.table.core);
        }, Et.prototype.clone = function(e2) {
          var t2 = Object.create(this.constructor.prototype), n2 = Object.create(this._ctx);
          return e2 && a(n2, e2), t2._ctx = n2, t2;
        }, Et.prototype.raw = function() {
          return this._ctx.valueMapper = null, this;
        }, Et.prototype.each = function(t2) {
          var n2 = this._ctx;
          return this._read(function(e2) {
            return Ot(n2, t2, e2, n2.table.core);
          });
        }, Et.prototype.count = function(e2) {
          var i2 = this;
          return this._read(function(e3) {
            var t2 = i2._ctx, n2 = t2.table.core;
            if (gt(t2, true)) return n2.count({ trans: e3, query: { index: xt(t2, n2.schema), range: t2.range } }).then(function(e4) {
              return Math.min(e4, t2.limit);
            });
            var r3 = 0;
            return Ot(t2, function() {
              return ++r3, false;
            }, e3, n2).then(function() {
              return r3;
            });
          }).then(e2);
        }, Et.prototype.sortBy = function(e2, t2) {
          var n2 = e2.split(".").reverse(), r3 = n2[0], i2 = n2.length - 1;
          function o2(e3, t3) {
            return t3 ? o2(e3[n2[t3]], t3 - 1) : e3[r3];
          }
          var a2 = "next" === this._ctx.dir ? 1 : -1;
          function u2(e3, t3) {
            return st(o2(e3, i2), o2(t3, i2)) * a2;
          }
          return this.toArray(function(e3) {
            return e3.sort(u2);
          }).then(t2);
        }, Et.prototype.toArray = function(e2) {
          var o2 = this;
          return this._read(function(e3) {
            var t2 = o2._ctx;
            if ("next" === t2.dir && gt(t2, true) && 0 < t2.limit) {
              var n2 = t2.valueMapper, r3 = xt(t2, t2.table.core.schema);
              return t2.table.core.query({ trans: e3, limit: t2.limit, values: true, query: { index: r3, range: t2.range } }).then(function(e4) {
                e4 = e4.result;
                return n2 ? e4.map(n2) : e4;
              });
            }
            var i2 = [];
            return Ot(t2, function(e4) {
              return i2.push(e4);
            }, e3, t2.table.core).then(function() {
              return i2;
            });
          }, e2);
        }, Et.prototype.offset = function(t2) {
          var e2 = this._ctx;
          return t2 <= 0 || (e2.offset += t2, gt(e2) ? _t(e2, function() {
            var n2 = t2;
            return function(e3, t3) {
              return 0 === n2 || (1 === n2 ? --n2 : t3(function() {
                e3.advance(n2), n2 = 0;
              }), false);
            };
          }) : _t(e2, function() {
            var e3 = t2;
            return function() {
              return --e3 < 0;
            };
          })), this;
        }, Et.prototype.limit = function(e2) {
          return this._ctx.limit = Math.min(this._ctx.limit, e2), _t(this._ctx, function() {
            var r3 = e2;
            return function(e3, t2, n2) {
              return --r3 <= 0 && t2(n2), 0 <= r3;
            };
          }, true), this;
        }, Et.prototype.until = function(r3, i2) {
          return wt(this._ctx, function(e2, t2, n2) {
            return !r3(e2.value) || (t2(n2), i2);
          }), this;
        }, Et.prototype.first = function(e2) {
          return this.limit(1).toArray(function(e3) {
            return e3[0];
          }).then(e2);
        }, Et.prototype.last = function(e2) {
          return this.reverse().first(e2);
        }, Et.prototype.filter = function(t2) {
          var e2;
          return wt(this._ctx, function(e3) {
            return t2(e3.value);
          }), (e2 = this._ctx).isMatch = it(e2.isMatch, t2), this;
        }, Et.prototype.and = function(e2) {
          return this.filter(e2);
        }, Et.prototype.or = function(e2) {
          return new this.db.WhereClause(this._ctx.table, e2, this);
        }, Et.prototype.reverse = function() {
          return this._ctx.dir = "prev" === this._ctx.dir ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
        }, Et.prototype.desc = function() {
          return this.reverse();
        }, Et.prototype.eachKey = function(n2) {
          var e2 = this._ctx;
          return e2.keysOnly = !e2.isMatch, this.each(function(e3, t2) {
            n2(t2.key, t2);
          });
        }, Et.prototype.eachUniqueKey = function(e2) {
          return this._ctx.unique = "unique", this.eachKey(e2);
        }, Et.prototype.eachPrimaryKey = function(n2) {
          var e2 = this._ctx;
          return e2.keysOnly = !e2.isMatch, this.each(function(e3, t2) {
            n2(t2.primaryKey, t2);
          });
        }, Et.prototype.keys = function(e2) {
          var t2 = this._ctx;
          t2.keysOnly = !t2.isMatch;
          var n2 = [];
          return this.each(function(e3, t3) {
            n2.push(t3.key);
          }).then(function() {
            return n2;
          }).then(e2);
        }, Et.prototype.primaryKeys = function(e2) {
          var n2 = this._ctx;
          if ("next" === n2.dir && gt(n2, true) && 0 < n2.limit) return this._read(function(e3) {
            var t2 = xt(n2, n2.table.core.schema);
            return n2.table.core.query({ trans: e3, values: false, limit: n2.limit, query: { index: t2, range: n2.range } });
          }).then(function(e3) {
            return e3.result;
          }).then(e2);
          n2.keysOnly = !n2.isMatch;
          var r3 = [];
          return this.each(function(e3, t2) {
            r3.push(t2.primaryKey);
          }).then(function() {
            return r3;
          }).then(e2);
        }, Et.prototype.uniqueKeys = function(e2) {
          return this._ctx.unique = "unique", this.keys(e2);
        }, Et.prototype.firstKey = function(e2) {
          return this.limit(1).keys(function(e3) {
            return e3[0];
          }).then(e2);
        }, Et.prototype.lastKey = function(e2) {
          return this.reverse().firstKey(e2);
        }, Et.prototype.distinct = function() {
          var e2 = this._ctx, e2 = e2.index && e2.table.schema.idxByName[e2.index];
          if (!e2 || !e2.multi) return this;
          var n2 = {};
          return wt(this._ctx, function(e3) {
            var t2 = e3.primaryKey.toString(), e3 = m(n2, t2);
            return n2[t2] = true, !e3;
          }), this;
        }, Et.prototype.modify = function(x2) {
          var n2 = this, k2 = this._ctx;
          return this._write(function(p2) {
            var y2 = "function" == typeof x2 ? x2 : function(e3) {
              return pt(e3, x2);
            }, v2 = k2.table.core, e2 = v2.schema.primaryKey, m2 = e2.outbound, b2 = e2.extractKey, g2 = 200, e2 = n2.db._options.modifyChunkSize;
            e2 && (g2 = "object" == typeof e2 ? e2[v2.name] || e2["*"] || 200 : e2);
            function w2(e3, t3) {
              var n3 = t3.failures, t3 = t3.numFailures;
              u2 += e3 - t3;
              for (var r3 = 0, i2 = O(n3); r3 < i2.length; r3++) {
                var o2 = i2[r3];
                a2.push(n3[o2]);
              }
            }
            var a2 = [], u2 = 0, t2 = [], _2 = x2 === St;
            return n2.clone().primaryKeys().then(function(f2) {
              function h2(s2) {
                var c2 = Math.min(g2, f2.length - s2), l2 = f2.slice(s2, s2 + c2);
                return (_2 ? Promise.resolve([]) : v2.getMany({ trans: p2, keys: l2, cache: "immutable" })).then(function(e3) {
                  var n3 = [], t3 = [], r3 = m2 ? [] : null, i2 = _2 ? l2 : [];
                  if (!_2) for (var o2 = 0; o2 < c2; ++o2) {
                    var a3 = e3[o2], u3 = { value: S(a3), primKey: f2[s2 + o2] };
                    false !== y2.call(u3, u3.value, u3) && (null == u3.value ? i2.push(f2[s2 + o2]) : m2 || 0 === st(b2(a3), b2(u3.value)) ? (t3.push(u3.value), m2 && r3.push(f2[s2 + o2])) : (i2.push(f2[s2 + o2]), n3.push(u3.value)));
                  }
                  return Promise.resolve(0 < n3.length && v2.mutate({ trans: p2, type: "add", values: n3 }).then(function(e4) {
                    for (var t4 in e4.failures) i2.splice(parseInt(t4), 1);
                    w2(n3.length, e4);
                  })).then(function() {
                    return (0 < t3.length || d2 && "object" == typeof x2) && v2.mutate({ trans: p2, type: "put", keys: r3, values: t3, criteria: d2, changeSpec: "function" != typeof x2 && x2, isAdditionalChunk: 0 < s2 }).then(function(e4) {
                      return w2(t3.length, e4);
                    });
                  }).then(function() {
                    return (0 < i2.length || d2 && _2) && v2.mutate({ trans: p2, type: "delete", keys: i2, criteria: d2, isAdditionalChunk: 0 < s2 }).then(function(e4) {
                      return ft(k2.table, i2, e4);
                    }).then(function(e4) {
                      return w2(i2.length, e4);
                    });
                  }).then(function() {
                    return f2.length > s2 + c2 && h2(s2 + g2);
                  });
                });
              }
              var d2 = gt(k2) && k2.limit === 1 / 0 && ("function" != typeof x2 || _2) && { index: k2.index, range: k2.range };
              return h2(0).then(function() {
                if (0 < a2.length) throw new U("Error modifying one or more objects", a2, u2, t2);
                return f2.length;
              });
            });
          });
        }, Et.prototype.delete = function() {
          var i2 = this._ctx, n2 = i2.range;
          return !gt(i2) || i2.table.schema.yProps || !i2.isPrimKey && 3 !== n2.type ? this.modify(St) : this._write(function(e2) {
            var t2 = i2.table.core.schema.primaryKey, r3 = n2;
            return i2.table.core.count({ trans: e2, query: { index: t2, range: r3 } }).then(function(n3) {
              return i2.table.core.mutate({ trans: e2, type: "deleteRange", range: r3 }).then(function(e3) {
                var t3 = e3.failures, e3 = e3.numFailures;
                if (e3) throw new U("Could not delete some values", Object.keys(t3).map(function(e4) {
                  return t3[e4];
                }), n3 - e3);
                return n3 - e3;
              });
            });
          });
        }, Et);
        function Et() {
        }
        var St = function(e2, t2) {
          return t2.value = null;
        };
        function jt(e2, t2) {
          return e2 < t2 ? -1 : e2 === t2 ? 0 : 1;
        }
        function At(e2, t2) {
          return t2 < e2 ? -1 : e2 === t2 ? 0 : 1;
        }
        function Ct(e2, t2, n2) {
          e2 = e2 instanceof Bt ? new e2.Collection(e2) : e2;
          return e2._ctx.error = new (n2 || TypeError)(t2), e2;
        }
        function Tt(e2) {
          return new e2.Collection(e2, function() {
            return Dt("");
          }).limit(0);
        }
        function It(e2, s2, n2, r3) {
          var i2, c2, l2, f2, h2, d2, p2, y2 = n2.length;
          if (!n2.every(function(e3) {
            return "string" == typeof e3;
          })) return Ct(e2, Ze);
          function t2(e3) {
            i2 = "next" === e3 ? function(e4) {
              return e4.toUpperCase();
            } : function(e4) {
              return e4.toLowerCase();
            }, c2 = "next" === e3 ? function(e4) {
              return e4.toLowerCase();
            } : function(e4) {
              return e4.toUpperCase();
            }, l2 = "next" === e3 ? jt : At;
            var t3 = n2.map(function(e4) {
              return { lower: c2(e4), upper: i2(e4) };
            }).sort(function(e4, t4) {
              return l2(e4.lower, t4.lower);
            });
            f2 = t3.map(function(e4) {
              return e4.upper;
            }), h2 = t3.map(function(e4) {
              return e4.lower;
            }), p2 = "next" === (d2 = e3) ? "" : r3;
          }
          t2("next");
          e2 = new e2.Collection(e2, function() {
            return qt(f2[0], h2[y2 - 1] + r3);
          });
          e2._ondirectionchange = function(e3) {
            t2(e3);
          };
          var v2 = 0;
          return e2._addAlgorithm(function(e3, t3, n3) {
            var r4 = e3.key;
            if ("string" != typeof r4) return false;
            var i3 = c2(r4);
            if (s2(i3, h2, v2)) return true;
            for (var o2 = null, a2 = v2; a2 < y2; ++a2) {
              var u2 = (function(e4, t4, n4, r5, i4, o3) {
                for (var a3 = Math.min(e4.length, r5.length), u3 = -1, s3 = 0; s3 < a3; ++s3) {
                  var c3 = t4[s3];
                  if (c3 !== r5[s3]) return i4(e4[s3], n4[s3]) < 0 ? e4.substr(0, s3) + n4[s3] + n4.substr(s3 + 1) : i4(e4[s3], r5[s3]) < 0 ? e4.substr(0, s3) + r5[s3] + n4.substr(s3 + 1) : 0 <= u3 ? e4.substr(0, u3) + t4[u3] + n4.substr(u3 + 1) : null;
                  i4(e4[s3], c3) < 0 && (u3 = s3);
                }
                return a3 < r5.length && "next" === o3 ? e4 + n4.substr(e4.length) : a3 < e4.length && "prev" === o3 ? e4.substr(0, n4.length) : u3 < 0 ? null : e4.substr(0, u3) + r5[u3] + n4.substr(u3 + 1);
              })(r4, i3, f2[a2], h2[a2], l2, d2);
              null === u2 && null === o2 ? v2 = a2 + 1 : (null === o2 || 0 < l2(o2, u2)) && (o2 = u2);
            }
            return t3(null !== o2 ? function() {
              e3.continue(o2 + p2);
            } : n3), false;
          }), e2;
        }
        function qt(e2, t2, n2, r3) {
          return { type: 2, lower: e2, upper: t2, lowerOpen: n2, upperOpen: r3 };
        }
        function Dt(e2) {
          return { type: 1, lower: e2, upper: e2 };
        }
        var Bt = (Object.defineProperty(Rt.prototype, "Collection", { get: function() {
          return this._ctx.table.db.Collection;
        }, enumerable: false, configurable: true }), Rt.prototype.between = function(e2, t2, n2, r3) {
          n2 = false !== n2, r3 = true === r3;
          try {
            return 0 < this._cmp(e2, t2) || 0 === this._cmp(e2, t2) && (n2 || r3) && (!n2 || !r3) ? Tt(this) : new this.Collection(this, function() {
              return qt(e2, t2, !n2, !r3);
            });
          } catch (e3) {
            return Ct(this, Je);
          }
        }, Rt.prototype.equals = function(e2) {
          return null == e2 ? Ct(this, Je) : new this.Collection(this, function() {
            return Dt(e2);
          });
        }, Rt.prototype.above = function(e2) {
          return null == e2 ? Ct(this, Je) : new this.Collection(this, function() {
            return qt(e2, void 0, true);
          });
        }, Rt.prototype.aboveOrEqual = function(e2) {
          return null == e2 ? Ct(this, Je) : new this.Collection(this, function() {
            return qt(e2, void 0, false);
          });
        }, Rt.prototype.below = function(e2) {
          return null == e2 ? Ct(this, Je) : new this.Collection(this, function() {
            return qt(void 0, e2, false, true);
          });
        }, Rt.prototype.belowOrEqual = function(e2) {
          return null == e2 ? Ct(this, Je) : new this.Collection(this, function() {
            return qt(void 0, e2);
          });
        }, Rt.prototype.startsWith = function(e2) {
          return "string" != typeof e2 ? Ct(this, Ze) : this.between(e2, e2 + He, true, true);
        }, Rt.prototype.startsWithIgnoreCase = function(e2) {
          return "" === e2 ? this.startsWith(e2) : It(this, function(e3, t2) {
            return 0 === e3.indexOf(t2[0]);
          }, [e2], He);
        }, Rt.prototype.equalsIgnoreCase = function(e2) {
          return It(this, function(e3, t2) {
            return e3 === t2[0];
          }, [e2], "");
        }, Rt.prototype.anyOfIgnoreCase = function() {
          var e2 = D.apply(q, arguments);
          return 0 === e2.length ? Tt(this) : It(this, function(e3, t2) {
            return -1 !== t2.indexOf(e3);
          }, e2, "");
        }, Rt.prototype.startsWithAnyOfIgnoreCase = function() {
          var e2 = D.apply(q, arguments);
          return 0 === e2.length ? Tt(this) : It(this, function(t2, e3) {
            return e3.some(function(e4) {
              return 0 === t2.indexOf(e4);
            });
          }, e2, He);
        }, Rt.prototype.anyOf = function() {
          var t2 = this, i2 = D.apply(q, arguments), o2 = this._cmp;
          try {
            i2.sort(o2);
          } catch (e3) {
            return Ct(this, Je);
          }
          if (0 === i2.length) return Tt(this);
          var e2 = new this.Collection(this, function() {
            return qt(i2[0], i2[i2.length - 1]);
          });
          e2._ondirectionchange = function(e3) {
            o2 = "next" === e3 ? t2._ascending : t2._descending, i2.sort(o2);
          };
          var a2 = 0;
          return e2._addAlgorithm(function(e3, t3, n2) {
            for (var r3 = e3.key; 0 < o2(r3, i2[a2]); ) if (++a2 === i2.length) return t3(n2), false;
            return 0 === o2(r3, i2[a2]) || (t3(function() {
              e3.continue(i2[a2]);
            }), false);
          }), e2;
        }, Rt.prototype.notEqual = function(e2) {
          return this.inAnyRange([[-1 / 0, e2], [e2, this.db._maxKey]], { includeLowers: false, includeUppers: false });
        }, Rt.prototype.noneOf = function() {
          var e2 = D.apply(q, arguments);
          if (0 === e2.length) return new this.Collection(this);
          try {
            e2.sort(this._ascending);
          } catch (e3) {
            return Ct(this, Je);
          }
          var t2 = e2.reduce(function(e3, t3) {
            return e3 ? e3.concat([[e3[e3.length - 1][1], t3]]) : [[-1 / 0, t3]];
          }, null);
          return t2.push([e2[e2.length - 1], this.db._maxKey]), this.inAnyRange(t2, { includeLowers: false, includeUppers: false });
        }, Rt.prototype.inAnyRange = function(e2, t2) {
          var o2 = this, a2 = this._cmp, u2 = this._ascending, n2 = this._descending, s2 = this._min, c2 = this._max;
          if (0 === e2.length) return Tt(this);
          if (!e2.every(function(e3) {
            return void 0 !== e3[0] && void 0 !== e3[1] && u2(e3[0], e3[1]) <= 0;
          })) return Ct(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Y.InvalidArgument);
          var r3 = !t2 || false !== t2.includeLowers, i2 = t2 && true === t2.includeUppers;
          var l2, f2 = u2;
          function h2(e3, t3) {
            return f2(e3[0], t3[0]);
          }
          try {
            (l2 = e2.reduce(function(e3, t3) {
              for (var n3 = 0, r4 = e3.length; n3 < r4; ++n3) {
                var i3 = e3[n3];
                if (a2(t3[0], i3[1]) < 0 && 0 < a2(t3[1], i3[0])) {
                  i3[0] = s2(i3[0], t3[0]), i3[1] = c2(i3[1], t3[1]);
                  break;
                }
              }
              return n3 === r4 && e3.push(t3), e3;
            }, [])).sort(h2);
          } catch (e3) {
            return Ct(this, Je);
          }
          var d2 = 0, p2 = i2 ? function(e3) {
            return 0 < u2(e3, l2[d2][1]);
          } : function(e3) {
            return 0 <= u2(e3, l2[d2][1]);
          }, y2 = r3 ? function(e3) {
            return 0 < n2(e3, l2[d2][0]);
          } : function(e3) {
            return 0 <= n2(e3, l2[d2][0]);
          };
          var v2 = p2, e2 = new this.Collection(this, function() {
            return qt(l2[0][0], l2[l2.length - 1][1], !r3, !i2);
          });
          return e2._ondirectionchange = function(e3) {
            f2 = "next" === e3 ? (v2 = p2, u2) : (v2 = y2, n2), l2.sort(h2);
          }, e2._addAlgorithm(function(e3, t3, n3) {
            for (var r4, i3 = e3.key; v2(i3); ) if (++d2 === l2.length) return t3(n3), false;
            return !p2(r4 = i3) && !y2(r4) || (0 === o2._cmp(i3, l2[d2][1]) || 0 === o2._cmp(i3, l2[d2][0]) || t3(function() {
              f2 === u2 ? e3.continue(l2[d2][0]) : e3.continue(l2[d2][1]);
            }), false);
          }), e2;
        }, Rt.prototype.startsWithAnyOf = function() {
          var e2 = D.apply(q, arguments);
          return e2.every(function(e3) {
            return "string" == typeof e3;
          }) ? 0 === e2.length ? Tt(this) : this.inAnyRange(e2.map(function(e3) {
            return [e3, e3 + He];
          })) : Ct(this, "startsWithAnyOf() only works with strings");
        }, Rt);
        function Rt() {
        }
        function Ft(t2) {
          return Ie(function(e2) {
            return Mt(e2), t2(e2.target.error), false;
          });
        }
        function Mt(e2) {
          e2.stopPropagation && e2.stopPropagation(), e2.preventDefault && e2.preventDefault();
        }
        var Nt = "storagemutated", Lt = "x-storagemutated-1", Ut = mt(null, Nt), Vt = (zt.prototype._lock = function() {
          return y(!me.global), ++this._reculock, 1 !== this._reculock || me.global || (me.lockOwnerFor = this), this;
        }, zt.prototype._unlock = function() {
          if (y(!me.global), 0 == --this._reculock) for (me.global || (me.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
            var e2 = this._blockedFuncs.shift();
            try {
              $e(e2[1], e2[0]);
            } catch (e3) {
            }
          }
          return this;
        }, zt.prototype._locked = function() {
          return this._reculock && me.lockOwnerFor !== this;
        }, zt.prototype.create = function(t2) {
          var n2 = this;
          if (!this.mode) return this;
          var e2 = this.db.idbdb, r3 = this.db._state.dbOpenError;
          if (y(!this.idbtrans), !t2 && !e2) switch (r3 && r3.name) {
            case "DatabaseClosedError":
              throw new Y.DatabaseClosed(r3);
            case "MissingAPIError":
              throw new Y.MissingAPI(r3.message, r3);
            default:
              throw new Y.OpenFailed(r3);
          }
          if (!this.active) throw new Y.TransactionInactive();
          return y(null === this._completion._state), (t2 = this.idbtrans = t2 || (this.db.core || e2).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ie(function(e3) {
            Mt(e3), n2._reject(t2.error);
          }), t2.onabort = Ie(function(e3) {
            Mt(e3), n2.active && n2._reject(new Y.Abort(t2.error)), n2.active = false, n2.on("abort").fire(e3);
          }), t2.oncomplete = Ie(function() {
            n2.active = false, n2._resolve(), "mutatedParts" in t2 && Ut.storagemutated.fire(t2.mutatedParts);
          }), this;
        }, zt.prototype._promise = function(n2, r3, i2) {
          var o2 = this;
          if ("readwrite" === n2 && "readwrite" !== this.mode) return Xe(new Y.ReadOnly("Transaction is readonly"));
          if (!this.active) return Xe(new Y.TransactionInactive());
          if (this._locked()) return new _e(function(e3, t2) {
            o2._blockedFuncs.push([function() {
              o2._promise(n2, r3, i2).then(e3, t2);
            }, me]);
          });
          if (i2) return Ne(function() {
            var e3 = new _e(function(e4, t2) {
              o2._lock();
              var n3 = r3(e4, t2, o2);
              n3 && n3.then && n3.then(e4, t2);
            });
            return e3.finally(function() {
              return o2._unlock();
            }), e3._lib = true, e3;
          });
          var e2 = new _e(function(e3, t2) {
            var n3 = r3(e3, t2, o2);
            n3 && n3.then && n3.then(e3, t2);
          });
          return e2._lib = true, e2;
        }, zt.prototype._root = function() {
          return this.parent ? this.parent._root() : this;
        }, zt.prototype.waitFor = function(e2) {
          var t2, r3 = this._root(), i2 = _e.resolve(e2);
          r3._waitingFor ? r3._waitingFor = r3._waitingFor.then(function() {
            return i2;
          }) : (r3._waitingFor = i2, r3._waitingQueue = [], t2 = r3.idbtrans.objectStore(r3.storeNames[0]), (function e3() {
            for (++r3._spinCount; r3._waitingQueue.length; ) r3._waitingQueue.shift()();
            r3._waitingFor && (t2.get(-1 / 0).onsuccess = e3);
          })());
          var o2 = r3._waitingFor;
          return new _e(function(t3, n2) {
            i2.then(function(e3) {
              return r3._waitingQueue.push(Ie(t3.bind(null, e3)));
            }, function(e3) {
              return r3._waitingQueue.push(Ie(n2.bind(null, e3)));
            }).finally(function() {
              r3._waitingFor === o2 && (r3._waitingFor = null);
            });
          });
        }, zt.prototype.abort = function() {
          this.active && (this.active = false, this.idbtrans && this.idbtrans.abort(), this._reject(new Y.Abort()));
        }, zt.prototype.table = function(e2) {
          var t2 = this._memoizedTables || (this._memoizedTables = {});
          if (m(t2, e2)) return t2[e2];
          var n2 = this.schema[e2];
          if (!n2) throw new Y.NotFound("Table " + e2 + " not part of transaction");
          n2 = new this.db.Table(e2, n2, this);
          return n2.core = this.db.core.table(e2), t2[e2] = n2;
        }, zt);
        function zt() {
        }
        function Wt(e2, t2, n2, r3, i2, o2, a2, u2) {
          return { name: e2, keyPath: t2, unique: n2, multi: r3, auto: i2, compound: o2, src: (n2 && !a2 ? "&" : "") + (r3 ? "*" : "") + (i2 ? "++" : "") + Yt(t2), type: u2 };
        }
        function Yt(e2) {
          return "string" == typeof e2 ? e2 : e2 ? "[" + [].join.call(e2, "+") + "]" : "";
        }
        function $t(e2, t2, n2) {
          return { name: e2, primKey: t2, indexes: n2, mappedClass: null, idxByName: (r3 = function(e3) {
            return [e3.name, e3];
          }, n2.reduce(function(e3, t3, n3) {
            n3 = r3(t3, n3);
            return n3 && (e3[n3[0]] = n3[1]), e3;
          }, {})) };
          var r3;
        }
        var Qt = function(e2) {
          try {
            return e2.only([[]]), Qt = function() {
              return [[]];
            }, [[]];
          } catch (e3) {
            return Qt = function() {
              return He;
            }, He;
          }
        };
        function Gt(t2) {
          return null == t2 ? function() {
          } : "string" == typeof t2 ? 1 === (n2 = t2).split(".").length ? function(e2) {
            return e2[n2];
          } : function(e2) {
            return g(e2, n2);
          } : function(e2) {
            return g(e2, t2);
          };
          var n2;
        }
        function Xt(e2) {
          return [].slice.call(e2);
        }
        var Ht = 0;
        function Jt(e2) {
          return null == e2 ? ":id" : "string" == typeof e2 ? e2 : "[".concat(e2.join("+"), "]");
        }
        function Zt(e2, i2, t2) {
          function _2(e3) {
            if (3 === e3.type) return null;
            if (4 === e3.type) throw new Error("Cannot convert never type to IDBKeyRange");
            var t3 = e3.lower, n3 = e3.upper, r4 = e3.lowerOpen, e3 = e3.upperOpen;
            return void 0 === t3 ? void 0 === n3 ? null : i2.upperBound(n3, !!e3) : void 0 === n3 ? i2.lowerBound(t3, !!r4) : i2.bound(t3, n3, !!r4, !!e3);
          }
          function n2(e3) {
            var h2, w2 = e3.name;
            return { name: w2, schema: e3, mutate: function(e4) {
              var y2 = e4.trans, v2 = e4.type, m2 = e4.keys, b2 = e4.values, g2 = e4.range;
              return new Promise(function(t3, e5) {
                t3 = Ie(t3);
                var n3 = y2.objectStore(w2), r4 = null == n3.keyPath, i3 = "put" === v2 || "add" === v2;
                if (!i3 && "delete" !== v2 && "deleteRange" !== v2) throw new Error("Invalid operation type: " + v2);
                var o3, a3 = (m2 || b2 || { length: 1 }).length;
                if (m2 && b2 && m2.length !== b2.length) throw new Error("Given keys array must have same length as given values array.");
                if (0 === a3) return t3({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
                function u3(e6) {
                  ++l2, Mt(e6);
                }
                var s3 = [], c3 = [], l2 = 0;
                if ("deleteRange" === v2) {
                  if (4 === g2.type) return t3({ numFailures: l2, failures: c3, results: [], lastResult: void 0 });
                  3 === g2.type ? s3.push(o3 = n3.clear()) : s3.push(o3 = n3.delete(_2(g2)));
                } else {
                  var r4 = i3 ? r4 ? [b2, m2] : [b2, null] : [m2, null], f2 = r4[0], h3 = r4[1];
                  if (i3) for (var d2 = 0; d2 < a3; ++d2) s3.push(o3 = h3 && void 0 !== h3[d2] ? n3[v2](f2[d2], h3[d2]) : n3[v2](f2[d2])), o3.onerror = u3;
                  else for (d2 = 0; d2 < a3; ++d2) s3.push(o3 = n3[v2](f2[d2])), o3.onerror = u3;
                }
                function p2(e6) {
                  e6 = e6.target.result, s3.forEach(function(e7, t4) {
                    return null != e7.error && (c3[t4] = e7.error);
                  }), t3({ numFailures: l2, failures: c3, results: "delete" === v2 ? m2 : s3.map(function(e7) {
                    return e7.result;
                  }), lastResult: e6 });
                }
                o3.onerror = function(e6) {
                  u3(e6), p2(e6);
                }, o3.onsuccess = p2;
              });
            }, getMany: function(e4) {
              var f2 = e4.trans, h3 = e4.keys;
              return new Promise(function(t3, e5) {
                t3 = Ie(t3);
                for (var n3, r4 = f2.objectStore(w2), i3 = h3.length, o3 = new Array(i3), a3 = 0, u3 = 0, s3 = function(e6) {
                  e6 = e6.target;
                  o3[e6._pos] = e6.result, ++u3 === a3 && t3(o3);
                }, c3 = Ft(e5), l2 = 0; l2 < i3; ++l2) null != h3[l2] && ((n3 = r4.get(h3[l2]))._pos = l2, n3.onsuccess = s3, n3.onerror = c3, ++a3);
                0 === a3 && t3(o3);
              });
            }, get: function(e4) {
              var r4 = e4.trans, i3 = e4.key;
              return new Promise(function(t3, e5) {
                t3 = Ie(t3);
                var n3 = r4.objectStore(w2).get(i3);
                n3.onsuccess = function(e6) {
                  return t3(e6.target.result);
                }, n3.onerror = Ft(e5);
              });
            }, query: (h2 = s2, function(f2) {
              return new Promise(function(n3, e4) {
                n3 = Ie(n3);
                var r4, i3, o3, t3 = f2.trans, a3 = f2.values, u3 = f2.limit, s3 = f2.query, c3 = u3 === 1 / 0 ? void 0 : u3, l2 = s3.index, s3 = s3.range, t3 = t3.objectStore(w2), l2 = l2.isPrimaryKey ? t3 : t3.index(l2.name), s3 = _2(s3);
                if (0 === u3) return n3({ result: [] });
                h2 ? ((c3 = a3 ? l2.getAll(s3, c3) : l2.getAllKeys(s3, c3)).onsuccess = function(e5) {
                  return n3({ result: e5.target.result });
                }, c3.onerror = Ft(e4)) : (r4 = 0, i3 = !a3 && "openKeyCursor" in l2 ? l2.openKeyCursor(s3) : l2.openCursor(s3), o3 = [], i3.onsuccess = function(e5) {
                  var t4 = i3.result;
                  return t4 ? (o3.push(a3 ? t4.value : t4.primaryKey), ++r4 === u3 ? n3({ result: o3 }) : void t4.continue()) : n3({ result: o3 });
                }, i3.onerror = Ft(e4));
              });
            }), openCursor: function(e4) {
              var c3 = e4.trans, o3 = e4.values, a3 = e4.query, u3 = e4.reverse, l2 = e4.unique;
              return new Promise(function(t3, n3) {
                t3 = Ie(t3);
                var e5 = a3.index, r4 = a3.range, i3 = c3.objectStore(w2), i3 = e5.isPrimaryKey ? i3 : i3.index(e5.name), e5 = u3 ? l2 ? "prevunique" : "prev" : l2 ? "nextunique" : "next", s3 = !o3 && "openKeyCursor" in i3 ? i3.openKeyCursor(_2(r4), e5) : i3.openCursor(_2(r4), e5);
                s3.onerror = Ft(n3), s3.onsuccess = Ie(function(e6) {
                  var r5, i4, o4, a4, u4 = s3.result;
                  u4 ? (u4.___id = ++Ht, u4.done = false, r5 = u4.continue.bind(u4), i4 = (i4 = u4.continuePrimaryKey) && i4.bind(u4), o4 = u4.advance.bind(u4), a4 = function() {
                    throw new Error("Cursor not stopped");
                  }, u4.trans = c3, u4.stop = u4.continue = u4.continuePrimaryKey = u4.advance = function() {
                    throw new Error("Cursor not started");
                  }, u4.fail = Ie(n3), u4.next = function() {
                    var e7 = this, t4 = 1;
                    return this.start(function() {
                      return t4-- ? e7.continue() : e7.stop();
                    }).then(function() {
                      return e7;
                    });
                  }, u4.start = function(e7) {
                    function t4() {
                      if (s3.result) try {
                        e7();
                      } catch (e8) {
                        u4.fail(e8);
                      }
                      else u4.done = true, u4.start = function() {
                        throw new Error("Cursor behind last entry");
                      }, u4.stop();
                    }
                    var n4 = new Promise(function(t5, e8) {
                      t5 = Ie(t5), s3.onerror = Ft(e8), u4.fail = e8, u4.stop = function(e9) {
                        u4.stop = u4.continue = u4.continuePrimaryKey = u4.advance = a4, t5(e9);
                      };
                    });
                    return s3.onsuccess = Ie(function(e8) {
                      s3.onsuccess = t4, t4();
                    }), u4.continue = r5, u4.continuePrimaryKey = i4, u4.advance = o4, t4(), n4;
                  }, t3(u4)) : t3(null);
                }, n3);
              });
            }, count: function(e4) {
              var t3 = e4.query, i3 = e4.trans, o3 = t3.index, a3 = t3.range;
              return new Promise(function(t4, e5) {
                var n3 = i3.objectStore(w2), r4 = o3.isPrimaryKey ? n3 : n3.index(o3.name), n3 = _2(a3), r4 = n3 ? r4.count(n3) : r4.count();
                r4.onsuccess = Ie(function(e6) {
                  return t4(e6.target.result);
                }), r4.onerror = Ft(e5);
              });
            } };
          }
          var r3, o2, a2, u2 = (o2 = t2, a2 = Xt((r3 = e2).objectStoreNames), { schema: { name: r3.name, tables: a2.map(function(e3) {
            return o2.objectStore(e3);
          }).map(function(t3) {
            var e3 = t3.keyPath, n3 = t3.autoIncrement, r4 = x(e3), i3 = {}, n3 = { name: t3.name, primaryKey: { name: null, isPrimaryKey: true, outbound: null == e3, compound: r4, keyPath: e3, autoIncrement: n3, unique: true, extractKey: Gt(e3) }, indexes: Xt(t3.indexNames).map(function(e4) {
              return t3.index(e4);
            }).map(function(e4) {
              var t4 = e4.name, n4 = e4.unique, r5 = e4.multiEntry, e4 = e4.keyPath, r5 = { name: t4, compound: x(e4), keyPath: e4, unique: n4, multiEntry: r5, extractKey: Gt(e4) };
              return i3[Jt(e4)] = r5;
            }), getIndexByKeyPath: function(e4) {
              return i3[Jt(e4)];
            } };
            return i3[":id"] = n3.primaryKey, null != e3 && (i3[Jt(e3)] = n3.primaryKey), n3;
          }) }, hasGetAll: 0 < a2.length && "getAll" in o2.objectStore(a2[0]) && !("undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), t2 = u2.schema, s2 = u2.hasGetAll, u2 = t2.tables.map(n2), c2 = {};
          return u2.forEach(function(e3) {
            return c2[e3.name] = e3;
          }), { stack: "dbcore", transaction: e2.transaction.bind(e2), table: function(e3) {
            if (!c2[e3]) throw new Error("Table '".concat(e3, "' not found"));
            return c2[e3];
          }, MIN_KEY: -1 / 0, MAX_KEY: Qt(i2), schema: t2 };
        }
        function en(e2, t2, n2, r3) {
          var i2 = n2.IDBKeyRange;
          return n2.indexedDB, { dbcore: (r3 = Zt(t2, i2, r3), e2.dbcore.reduce(function(e3, t3) {
            t3 = t3.create;
            return _(_({}, e3), t3(e3));
          }, r3)) };
        }
        function tn(n2, e2) {
          var t2 = e2.db, e2 = en(n2._middlewares, t2, n2._deps, e2);
          n2.core = e2.dbcore, n2.tables.forEach(function(e3) {
            var t3 = e3.name;
            n2.core.schema.tables.some(function(e4) {
              return e4.name === t3;
            }) && (e3.core = n2.core.table(t3), n2[t3] instanceof n2.Table && (n2[t3].core = e3.core));
          });
        }
        function nn(i2, e2, t2, o2) {
          t2.forEach(function(n2) {
            var r3 = o2[n2];
            e2.forEach(function(e3) {
              var t3 = (function e4(t4, n3) {
                return h(t4, n3) || (t4 = c(t4)) && e4(t4, n3);
              })(e3, n2);
              (!t3 || "value" in t3 && void 0 === t3.value) && (e3 === i2.Transaction.prototype || e3 instanceof i2.Transaction ? l(e3, n2, { get: function() {
                return this.table(n2);
              }, set: function(e4) {
                u(this, n2, { value: e4, writable: true, configurable: true, enumerable: true });
              } }) : e3[n2] = new i2.Table(n2, r3));
            });
          });
        }
        function rn(n2, e2) {
          e2.forEach(function(e3) {
            for (var t2 in e3) e3[t2] instanceof n2.Table && delete e3[t2];
          });
        }
        function on(e2, t2) {
          return e2._cfg.version - t2._cfg.version;
        }
        function an(n2, r3, i2, e2) {
          var o2 = n2._dbSchema;
          i2.objectStoreNames.contains("$meta") && !o2.$meta && (o2.$meta = $t("$meta", pn("")[0], []), n2._storeNames.push("$meta"));
          var a2 = n2._createTransaction("readwrite", n2._storeNames, o2);
          a2.create(i2), a2._completion.catch(e2);
          var u2 = a2._reject.bind(a2), s2 = me.transless || me;
          Ne(function() {
            return me.trans = a2, me.transless = s2, 0 !== r3 ? (tn(n2, i2), t2 = r3, ((e3 = a2).storeNames.includes("$meta") ? e3.table("$meta").get("version").then(function(e4) {
              return null != e4 ? e4 : t2;
            }) : _e.resolve(t2)).then(function(e4) {
              return c2 = e4, l2 = a2, f2 = i2, t3 = [], e4 = (s3 = n2)._versions, h2 = s3._dbSchema = hn(0, s3.idbdb, f2), 0 !== (e4 = e4.filter(function(e5) {
                return e5._cfg.version >= c2;
              })).length ? (e4.forEach(function(u3) {
                t3.push(function() {
                  var t4 = h2, e5 = u3._cfg.dbschema;
                  dn(s3, t4, f2), dn(s3, e5, f2), h2 = s3._dbSchema = e5;
                  var n3 = sn(t4, e5);
                  n3.add.forEach(function(e6) {
                    cn(f2, e6[0], e6[1].primKey, e6[1].indexes);
                  }), n3.change.forEach(function(e6) {
                    if (e6.recreate) throw new Y.Upgrade("Not yet support for changing primary key");
                    var t5 = f2.objectStore(e6.name);
                    e6.add.forEach(function(e7) {
                      return fn(t5, e7);
                    }), e6.change.forEach(function(e7) {
                      t5.deleteIndex(e7.name), fn(t5, e7);
                    }), e6.del.forEach(function(e7) {
                      return t5.deleteIndex(e7);
                    });
                  });
                  var r4 = u3._cfg.contentUpgrade;
                  if (r4 && u3._cfg.version > c2) {
                    tn(s3, f2), l2._memoizedTables = {};
                    var i3 = k(e5);
                    n3.del.forEach(function(e6) {
                      i3[e6] = t4[e6];
                    }), rn(s3, [s3.Transaction.prototype]), nn(s3, [s3.Transaction.prototype], O(i3), i3), l2.schema = i3;
                    var o3, a3 = B(r4);
                    a3 && Le();
                    n3 = _e.follow(function() {
                      var e6;
                      (o3 = r4(l2)) && a3 && (e6 = Ue.bind(null, null), o3.then(e6, e6));
                    });
                    return o3 && "function" == typeof o3.then ? _e.resolve(o3) : n3.then(function() {
                      return o3;
                    });
                  }
                }), t3.push(function(e5) {
                  var t4, n3, r4 = u3._cfg.dbschema;
                  t4 = r4, n3 = e5, [].slice.call(n3.db.objectStoreNames).forEach(function(e6) {
                    return null == t4[e6] && n3.db.deleteObjectStore(e6);
                  }), rn(s3, [s3.Transaction.prototype]), nn(s3, [s3.Transaction.prototype], s3._storeNames, s3._dbSchema), l2.schema = s3._dbSchema;
                }), t3.push(function(e5) {
                  s3.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(s3.idbdb.version / 10) === u3._cfg.version ? (s3.idbdb.deleteObjectStore("$meta"), delete s3._dbSchema.$meta, s3._storeNames = s3._storeNames.filter(function(e6) {
                    return "$meta" !== e6;
                  })) : e5.objectStore("$meta").put(u3._cfg.version, "version"));
                });
              }), (function e5() {
                return t3.length ? _e.resolve(t3.shift()(l2.idbtrans)).then(e5) : _e.resolve();
              })().then(function() {
                ln(h2, f2);
              })) : _e.resolve();
              var s3, c2, l2, f2, t3, h2;
            }).catch(u2)) : (O(o2).forEach(function(e4) {
              cn(i2, e4, o2[e4].primKey, o2[e4].indexes);
            }), tn(n2, i2), void _e.follow(function() {
              return n2.on.populate.fire(a2);
            }).catch(u2));
            var e3, t2;
          });
        }
        function un(e2, r3) {
          ln(e2._dbSchema, r3), r3.db.version % 10 != 0 || r3.objectStoreNames.contains("$meta") || r3.db.createObjectStore("$meta").add(Math.ceil(r3.db.version / 10 - 1), "version");
          var t2 = hn(0, e2.idbdb, r3);
          dn(e2, e2._dbSchema, r3);
          for (var n2 = 0, i2 = sn(t2, e2._dbSchema).change; n2 < i2.length; n2++) {
            var o2 = (function(t3) {
              if (t3.change.length || t3.recreate) return console.warn("Unable to patch indexes of table ".concat(t3.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
              var n3 = r3.objectStore(t3.name);
              t3.add.forEach(function(e3) {
                ie && console.debug("Dexie upgrade patch: Creating missing index ".concat(t3.name, ".").concat(e3.src)), fn(n3, e3);
              });
            })(i2[n2]);
            if ("object" == typeof o2) return o2.value;
          }
        }
        function sn(e2, t2) {
          var n2, r3 = { del: [], add: [], change: [] };
          for (n2 in e2) t2[n2] || r3.del.push(n2);
          for (n2 in t2) {
            var i2 = e2[n2], o2 = t2[n2];
            if (i2) {
              var a2 = { name: n2, def: o2, recreate: false, del: [], add: [], change: [] };
              if ("" + (i2.primKey.keyPath || "") != "" + (o2.primKey.keyPath || "") || i2.primKey.auto !== o2.primKey.auto) a2.recreate = true, r3.change.push(a2);
              else {
                var u2 = i2.idxByName, s2 = o2.idxByName, c2 = void 0;
                for (c2 in u2) s2[c2] || a2.del.push(c2);
                for (c2 in s2) {
                  var l2 = u2[c2], f2 = s2[c2];
                  l2 ? l2.src !== f2.src && a2.change.push(f2) : a2.add.push(f2);
                }
                (0 < a2.del.length || 0 < a2.add.length || 0 < a2.change.length) && r3.change.push(a2);
              }
            } else r3.add.push([n2, o2]);
          }
          return r3;
        }
        function cn(e2, t2, n2, r3) {
          var i2 = e2.db.createObjectStore(t2, n2.keyPath ? { keyPath: n2.keyPath, autoIncrement: n2.auto } : { autoIncrement: n2.auto });
          return r3.forEach(function(e3) {
            return fn(i2, e3);
          }), i2;
        }
        function ln(t2, n2) {
          O(t2).forEach(function(e2) {
            n2.db.objectStoreNames.contains(e2) || (ie && console.debug("Dexie: Creating missing table", e2), cn(n2, e2, t2[e2].primKey, t2[e2].indexes));
          });
        }
        function fn(e2, t2) {
          e2.createIndex(t2.name, t2.keyPath, { unique: t2.unique, multiEntry: t2.multi });
        }
        function hn(e2, t2, u2) {
          var s2 = {};
          return b(t2.objectStoreNames, 0).forEach(function(e3) {
            for (var t3 = u2.objectStore(e3), n2 = Wt(Yt(a2 = t3.keyPath), a2 || "", true, false, !!t3.autoIncrement, a2 && "string" != typeof a2, true), r3 = [], i2 = 0; i2 < t3.indexNames.length; ++i2) {
              var o2 = t3.index(t3.indexNames[i2]), a2 = o2.keyPath, o2 = Wt(o2.name, a2, !!o2.unique, !!o2.multiEntry, false, a2 && "string" != typeof a2, false);
              r3.push(o2);
            }
            s2[e3] = $t(e3, n2, r3);
          }), s2;
        }
        function dn(e2, t2, n2) {
          for (var r3 = n2.db.objectStoreNames, i2 = 0; i2 < r3.length; ++i2) {
            var o2 = r3[i2], a2 = n2.objectStore(o2);
            e2._hasGetAll = "getAll" in a2;
            for (var u2 = 0; u2 < a2.indexNames.length; ++u2) {
              var s2 = a2.indexNames[u2], c2 = a2.index(s2).keyPath, l2 = "string" == typeof c2 ? c2 : "[" + b(c2).join("+") + "]";
              !t2[o2] || (c2 = t2[o2].idxByName[l2]) && (c2.name = s2, delete t2[o2].idxByName[l2], t2[o2].idxByName[s2] = c2);
            }
          }
          "undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && f.WorkerGlobalScope && f instanceof f.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e2._hasGetAll = false);
        }
        function pn(e2) {
          return e2.split(",").map(function(e3, t2) {
            var n2 = e3.split(":"), r3 = null === (i2 = n2[1]) || void 0 === i2 ? void 0 : i2.trim(), i2 = (e3 = n2[0].trim()).replace(/([&*]|\+\+)/g, ""), n2 = /^\[/.test(i2) ? i2.match(/^\[(.*)\]$/)[1].split("+") : i2;
            return Wt(i2, n2 || null, /\&/.test(e3), /\*/.test(e3), /\+\+/.test(e3), x(n2), 0 === t2, r3);
          });
        }
        var yn = (vn.prototype._createTableSchema = $t, vn.prototype._parseIndexSyntax = pn, vn.prototype._parseStoresSpec = function(r3, i2) {
          var o2 = this;
          O(r3).forEach(function(e2) {
            if (null !== r3[e2]) {
              var t2 = o2._parseIndexSyntax(r3[e2]), n2 = t2.shift();
              if (!n2) throw new Y.Schema("Invalid schema for table " + e2 + ": " + r3[e2]);
              if (n2.unique = true, n2.multi) throw new Y.Schema("Primary key cannot be multiEntry*");
              t2.forEach(function(e3) {
                if (e3.auto) throw new Y.Schema("Only primary key can be marked as autoIncrement (++)");
                if (!e3.keyPath) throw new Y.Schema("Index must have a name and cannot be an empty string");
              });
              t2 = o2._createTableSchema(e2, n2, t2);
              i2[e2] = t2;
            }
          });
        }, vn.prototype.stores = function(e2) {
          var t2 = this.db;
          this._cfg.storesSource = this._cfg.storesSource ? a(this._cfg.storesSource, e2) : e2;
          var e2 = t2._versions, n2 = {}, r3 = {};
          return e2.forEach(function(e3) {
            a(n2, e3._cfg.storesSource), r3 = e3._cfg.dbschema = {}, e3._parseStoresSpec(n2, r3);
          }), t2._dbSchema = r3, rn(t2, [t2._allTables, t2, t2.Transaction.prototype]), nn(t2, [t2._allTables, t2, t2.Transaction.prototype, this._cfg.tables], O(r3), r3), t2._storeNames = O(r3), this;
        }, vn.prototype.upgrade = function(e2) {
          return this._cfg.contentUpgrade = re(this._cfg.contentUpgrade || G, e2), this;
        }, vn);
        function vn() {
        }
        function mn(e2, t2) {
          var n2 = e2._dbNamesDB;
          return n2 || (n2 = e2._dbNamesDB = new nr(tt, { addons: [], indexedDB: e2, IDBKeyRange: t2 })).version(1).stores({ dbnames: "name" }), n2.table("dbnames");
        }
        function bn(e2) {
          return e2 && "function" == typeof e2.databases;
        }
        function gn(e2) {
          return Ne(function() {
            return me.letThrough = true, e2();
          });
        }
        function wn(e2) {
          return !("from" in e2);
        }
        var _n = function(e2, t2) {
          if (!this) {
            var n2 = new _n();
            return e2 && "d" in e2 && a(n2, e2), n2;
          }
          a(this, arguments.length ? { d: 1, from: e2, to: 1 < arguments.length ? t2 : e2 } : { d: 0 });
        };
        function xn(e2, t2, n2) {
          var r3 = st(t2, n2);
          if (!isNaN(r3)) {
            if (0 < r3) throw RangeError();
            if (wn(e2)) return a(e2, { from: t2, to: n2, d: 1 });
            var i2 = e2.l, r3 = e2.r;
            if (st(n2, e2.from) < 0) return i2 ? xn(i2, t2, n2) : e2.l = { from: t2, to: n2, d: 1, l: null, r: null }, Kn(e2);
            if (0 < st(t2, e2.to)) return r3 ? xn(r3, t2, n2) : e2.r = { from: t2, to: n2, d: 1, l: null, r: null }, Kn(e2);
            st(t2, e2.from) < 0 && (e2.from = t2, e2.l = null, e2.d = r3 ? r3.d + 1 : 1), 0 < st(n2, e2.to) && (e2.to = n2, e2.r = null, e2.d = e2.l ? e2.l.d + 1 : 1);
            n2 = !e2.r;
            i2 && !e2.l && kn(e2, i2), r3 && n2 && kn(e2, r3);
          }
        }
        function kn(e2, t2) {
          wn(t2) || (function e3(t3, n2) {
            var r3 = n2.from, i2 = n2.to, o2 = n2.l, n2 = n2.r;
            xn(t3, r3, i2), o2 && e3(t3, o2), n2 && e3(t3, n2);
          })(e2, t2);
        }
        function On(e2, t2) {
          var n2 = Pn(t2), r3 = n2.next();
          if (r3.done) return false;
          for (var i2 = r3.value, o2 = Pn(e2), a2 = o2.next(i2.from), u2 = a2.value; !r3.done && !a2.done; ) {
            if (st(u2.from, i2.to) <= 0 && 0 <= st(u2.to, i2.from)) return true;
            st(i2.from, u2.from) < 0 ? i2 = (r3 = n2.next(u2.from)).value : u2 = (a2 = o2.next(i2.from)).value;
          }
          return false;
        }
        function Pn(e2) {
          var n2 = wn(e2) ? null : { s: 0, n: e2 };
          return { next: function(e3) {
            for (var t2 = 0 < arguments.length; n2; ) switch (n2.s) {
              case 0:
                if (n2.s = 1, t2) for (; n2.n.l && st(e3, n2.n.from) < 0; ) n2 = { up: n2, n: n2.n.l, s: 1 };
                else for (; n2.n.l; ) n2 = { up: n2, n: n2.n.l, s: 1 };
              case 1:
                if (n2.s = 2, !t2 || st(e3, n2.n.to) <= 0) return { value: n2.n, done: false };
              case 2:
                if (n2.n.r) {
                  n2.s = 3, n2 = { up: n2, n: n2.n.r, s: 0 };
                  continue;
                }
              case 3:
                n2 = n2.up;
            }
            return { done: true };
          } };
        }
        function Kn(e2) {
          var t2, n2, r3 = ((null === (t2 = e2.r) || void 0 === t2 ? void 0 : t2.d) || 0) - ((null === (n2 = e2.l) || void 0 === n2 ? void 0 : n2.d) || 0), i2 = 1 < r3 ? "r" : r3 < -1 ? "l" : "";
          i2 && (t2 = "r" == i2 ? "l" : "r", n2 = _({}, e2), r3 = e2[i2], e2.from = r3.from, e2.to = r3.to, e2[i2] = r3[i2], n2[i2] = r3[t2], (e2[t2] = n2).d = En(n2)), e2.d = En(e2);
        }
        function En(e2) {
          var t2 = e2.r, e2 = e2.l;
          return (t2 ? e2 ? Math.max(t2.d, e2.d) : t2.d : e2 ? e2.d : 0) + 1;
        }
        function Sn(t2, n2) {
          return O(n2).forEach(function(e2) {
            t2[e2] ? kn(t2[e2], n2[e2]) : t2[e2] = (function e3(t3) {
              var n3, r3, i2 = {};
              for (n3 in t3) m(t3, n3) && (r3 = t3[n3], i2[n3] = !r3 || "object" != typeof r3 || K.has(r3.constructor) ? r3 : e3(r3));
              return i2;
            })(n2[e2]);
          }), t2;
        }
        function jn(t2, n2) {
          return t2.all || n2.all || Object.keys(t2).some(function(e2) {
            return n2[e2] && On(n2[e2], t2[e2]);
          });
        }
        r2(_n.prototype, ((F = { add: function(e2) {
          return kn(this, e2), this;
        }, addKey: function(e2) {
          return xn(this, e2, e2), this;
        }, addKeys: function(e2) {
          var t2 = this;
          return e2.forEach(function(e3) {
            return xn(t2, e3, e3);
          }), this;
        }, hasKey: function(e2) {
          var t2 = Pn(this).next(e2).value;
          return t2 && st(t2.from, e2) <= 0 && 0 <= st(t2.to, e2);
        } })[C] = function() {
          return Pn(this);
        }, F));
        var An = {}, Cn = {}, Tn = false;
        function In(e2) {
          Sn(Cn, e2), Tn || (Tn = true, setTimeout(function() {
            Tn = false, qn(Cn, !(Cn = {}));
          }, 0));
        }
        function qn(e2, t2) {
          void 0 === t2 && (t2 = false);
          var n2 = /* @__PURE__ */ new Set();
          if (e2.all) for (var r3 = 0, i2 = Object.values(An); r3 < i2.length; r3++) Dn(a2 = i2[r3], e2, n2, t2);
          else for (var o2 in e2) {
            var a2, u2 = /^idb\:\/\/(.*)\/(.*)\//.exec(o2);
            u2 && (o2 = u2[1], u2 = u2[2], (a2 = An["idb://".concat(o2, "/").concat(u2)]) && Dn(a2, e2, n2, t2));
          }
          n2.forEach(function(e3) {
            return e3();
          });
        }
        function Dn(e2, t2, n2, r3) {
          for (var i2 = [], o2 = 0, a2 = Object.entries(e2.queries.query); o2 < a2.length; o2++) {
            for (var u2 = a2[o2], s2 = u2[0], c2 = [], l2 = 0, f2 = u2[1]; l2 < f2.length; l2++) {
              var h2 = f2[l2];
              jn(t2, h2.obsSet) ? h2.subscribers.forEach(function(e3) {
                return n2.add(e3);
              }) : r3 && c2.push(h2);
            }
            r3 && i2.push([s2, c2]);
          }
          if (r3) for (var d2 = 0, p2 = i2; d2 < p2.length; d2++) {
            var y2 = p2[d2], s2 = y2[0], c2 = y2[1];
            e2.queries.query[s2] = c2;
          }
        }
        function Bn(f2) {
          var h2 = f2._state, r3 = f2._deps.indexedDB;
          if (h2.isBeingOpened || f2.idbdb) return h2.dbReadyPromise.then(function() {
            return h2.dbOpenError ? Xe(h2.dbOpenError) : f2;
          });
          h2.isBeingOpened = true, h2.dbOpenError = null, h2.openComplete = false;
          var t2 = h2.openCanceller, d2 = Math.round(10 * f2.verno), p2 = false;
          function e2() {
            if (h2.openCanceller !== t2) throw new Y.DatabaseClosed("db.open() was cancelled");
          }
          function y2() {
            return new _e(function(s2, n3) {
              if (e2(), !r3) throw new Y.MissingAPI();
              var c2 = f2.name, l2 = h2.autoSchema || !d2 ? r3.open(c2) : r3.open(c2, d2);
              if (!l2) throw new Y.MissingAPI();
              l2.onerror = Ft(n3), l2.onblocked = Ie(f2._fireOnBlocked), l2.onupgradeneeded = Ie(function(e3) {
                var t3;
                v2 = l2.transaction, h2.autoSchema && !f2._options.allowEmptyDB ? (l2.onerror = Mt, v2.abort(), l2.result.close(), (t3 = r3.deleteDatabase(c2)).onsuccess = t3.onerror = Ie(function() {
                  n3(new Y.NoSuchDatabase("Database ".concat(c2, " doesnt exist")));
                })) : (v2.onerror = Ft(n3), e3 = e3.oldVersion > Math.pow(2, 62) ? 0 : e3.oldVersion, m2 = e3 < 1, f2.idbdb = l2.result, p2 && un(f2, v2), an(f2, e3 / 10, v2, n3));
              }, n3), l2.onsuccess = Ie(function() {
                v2 = null;
                var e3, t3, n4, r4, i3, o2 = f2.idbdb = l2.result, a2 = b(o2.objectStoreNames);
                if (0 < a2.length) try {
                  var u2 = o2.transaction(1 === (r4 = a2).length ? r4[0] : r4, "readonly");
                  if (h2.autoSchema) t3 = o2, n4 = u2, (e3 = f2).verno = t3.version / 10, n4 = e3._dbSchema = hn(0, t3, n4), e3._storeNames = b(t3.objectStoreNames, 0), nn(e3, [e3._allTables], O(n4), n4);
                  else if (dn(f2, f2._dbSchema, u2), ((i3 = sn(hn(0, (i3 = f2).idbdb, u2), i3._dbSchema)).add.length || i3.change.some(function(e4) {
                    return e4.add.length || e4.change.length;
                  })) && !p2) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), o2.close(), d2 = o2.version + 1, p2 = true, s2(y2());
                  tn(f2, u2);
                } catch (e4) {
                }
                et.push(f2), o2.onversionchange = Ie(function(e4) {
                  h2.vcFired = true, f2.on("versionchange").fire(e4);
                }), o2.onclose = Ie(function() {
                  f2.close({ disableAutoOpen: false });
                }), m2 && (i3 = f2._deps, u2 = c2, o2 = i3.indexedDB, i3 = i3.IDBKeyRange, bn(o2) || u2 === tt || mn(o2, i3).put({ name: u2 }).catch(G)), s2();
              }, n3);
            }).catch(function(e3) {
              switch (null == e3 ? void 0 : e3.name) {
                case "UnknownError":
                  if (0 < h2.PR1398_maxLoop) return h2.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), y2();
                  break;
                case "VersionError":
                  if (0 < d2) return d2 = 0, y2();
              }
              return _e.reject(e3);
            });
          }
          var n2, i2 = h2.dbReadyResolve, v2 = null, m2 = false;
          return _e.race([t2, ("undefined" == typeof navigator ? _e.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(e3) {
            function t3() {
              return indexedDB.databases().finally(e3);
            }
            n2 = setInterval(t3, 100), t3();
          }).finally(function() {
            return clearInterval(n2);
          }) : Promise.resolve()).then(y2)]).then(function() {
            return e2(), h2.onReadyBeingFired = [], _e.resolve(gn(function() {
              return f2.on.ready.fire(f2.vip);
            })).then(function e3() {
              if (0 < h2.onReadyBeingFired.length) {
                var t3 = h2.onReadyBeingFired.reduce(re, G);
                return h2.onReadyBeingFired = [], _e.resolve(gn(function() {
                  return t3(f2.vip);
                })).then(e3);
              }
            });
          }).finally(function() {
            h2.openCanceller === t2 && (h2.onReadyBeingFired = null, h2.isBeingOpened = false);
          }).catch(function(e3) {
            h2.dbOpenError = e3;
            try {
              v2 && v2.abort();
            } catch (e4) {
            }
            return t2 === h2.openCanceller && f2._close(), Xe(e3);
          }).finally(function() {
            h2.openComplete = true, i2();
          }).then(function() {
            var n3;
            return m2 && (n3 = {}, f2.tables.forEach(function(t3) {
              t3.schema.indexes.forEach(function(e3) {
                e3.name && (n3["idb://".concat(f2.name, "/").concat(t3.name, "/").concat(e3.name)] = new _n(-1 / 0, [[[]]]));
              }), n3["idb://".concat(f2.name, "/").concat(t3.name, "/")] = n3["idb://".concat(f2.name, "/").concat(t3.name, "/:dels")] = new _n(-1 / 0, [[[]]]);
            }), Ut(Nt).fire(n3), qn(n3, true)), f2;
          });
        }
        function Rn(t2) {
          function e2(e3) {
            return t2.next(e3);
          }
          var r3 = n2(e2), i2 = n2(function(e3) {
            return t2.throw(e3);
          });
          function n2(n3) {
            return function(e3) {
              var t3 = n3(e3), e3 = t3.value;
              return t3.done ? e3 : e3 && "function" == typeof e3.then ? e3.then(r3, i2) : x(e3) ? Promise.all(e3).then(r3, i2) : r3(e3);
            };
          }
          return n2(e2)();
        }
        function Fn(e2, t2, n2) {
          for (var r3 = x(e2) ? e2.slice() : [e2], i2 = 0; i2 < n2; ++i2) r3.push(t2);
          return r3;
        }
        var Mn = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(f2) {
          return _(_({}, f2), { table: function(e2) {
            var a2 = f2.table(e2), t2 = a2.schema, u2 = {}, s2 = [];
            function c2(e3, t3, n3) {
              var r4 = Jt(e3), i3 = u2[r4] = u2[r4] || [], o2 = null == e3 ? 0 : "string" == typeof e3 ? 1 : e3.length, a3 = 0 < t3, a3 = _(_({}, n3), { name: a3 ? "".concat(r4, "(virtual-from:").concat(n3.name, ")") : n3.name, lowLevelIndex: n3, isVirtual: a3, keyTail: t3, keyLength: o2, extractKey: Gt(e3), unique: !a3 && n3.unique });
              return i3.push(a3), a3.isPrimaryKey || s2.push(a3), 1 < o2 && c2(2 === o2 ? e3[0] : e3.slice(0, o2 - 1), t3 + 1, n3), i3.sort(function(e4, t4) {
                return e4.keyTail - t4.keyTail;
              }), a3;
            }
            e2 = c2(t2.primaryKey.keyPath, 0, t2.primaryKey);
            u2[":id"] = [e2];
            for (var n2 = 0, r3 = t2.indexes; n2 < r3.length; n2++) {
              var i2 = r3[n2];
              c2(i2.keyPath, 0, i2);
            }
            function l2(e3) {
              var t3, n3 = e3.query.index;
              return n3.isVirtual ? _(_({}, e3), { query: { index: n3.lowLevelIndex, range: (t3 = e3.query.range, n3 = n3.keyTail, { type: 1 === t3.type ? 2 : t3.type, lower: Fn(t3.lower, t3.lowerOpen ? f2.MAX_KEY : f2.MIN_KEY, n3), lowerOpen: true, upper: Fn(t3.upper, t3.upperOpen ? f2.MIN_KEY : f2.MAX_KEY, n3), upperOpen: true }) } }) : e3;
            }
            return _(_({}, a2), { schema: _(_({}, t2), { primaryKey: e2, indexes: s2, getIndexByKeyPath: function(e3) {
              return (e3 = u2[Jt(e3)]) && e3[0];
            } }), count: function(e3) {
              return a2.count(l2(e3));
            }, query: function(e3) {
              return a2.query(l2(e3));
            }, openCursor: function(t3) {
              var e3 = t3.query.index, r4 = e3.keyTail, n3 = e3.isVirtual, i3 = e3.keyLength;
              return n3 ? a2.openCursor(l2(t3)).then(function(e4) {
                return e4 && o2(e4);
              }) : a2.openCursor(t3);
              function o2(n4) {
                return Object.create(n4, { continue: { value: function(e4) {
                  null != e4 ? n4.continue(Fn(e4, t3.reverse ? f2.MAX_KEY : f2.MIN_KEY, r4)) : t3.unique ? n4.continue(n4.key.slice(0, i3).concat(t3.reverse ? f2.MIN_KEY : f2.MAX_KEY, r4)) : n4.continue();
                } }, continuePrimaryKey: { value: function(e4, t4) {
                  n4.continuePrimaryKey(Fn(e4, f2.MAX_KEY, r4), t4);
                } }, primaryKey: { get: function() {
                  return n4.primaryKey;
                } }, key: { get: function() {
                  var e4 = n4.key;
                  return 1 === i3 ? e4[0] : e4.slice(0, i3);
                } }, value: { get: function() {
                  return n4.value;
                } } });
              }
            } });
          } });
        } };
        function Nn(i2, o2, a2, u2) {
          return a2 = a2 || {}, u2 = u2 || "", O(i2).forEach(function(e2) {
            var t2, n2, r3;
            m(o2, e2) ? (t2 = i2[e2], n2 = o2[e2], "object" == typeof t2 && "object" == typeof n2 && t2 && n2 ? (r3 = A(t2)) !== A(n2) ? a2[u2 + e2] = o2[e2] : "Object" === r3 ? Nn(t2, n2, a2, u2 + e2 + ".") : t2 !== n2 && (a2[u2 + e2] = o2[e2]) : t2 !== n2 && (a2[u2 + e2] = o2[e2])) : a2[u2 + e2] = void 0;
          }), O(o2).forEach(function(e2) {
            m(i2, e2) || (a2[u2 + e2] = o2[e2]);
          }), a2;
        }
        function Ln(e2, t2) {
          return "delete" === t2.type ? t2.keys : t2.keys || t2.values.map(e2.extractKey);
        }
        var Un = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e2) {
          return _(_({}, e2), { table: function(r3) {
            var y2 = e2.table(r3), v2 = y2.schema.primaryKey;
            return _(_({}, y2), { mutate: function(e3) {
              var t2 = me.trans, n2 = t2.table(r3).hook, h2 = n2.deleting, d2 = n2.creating, p2 = n2.updating;
              switch (e3.type) {
                case "add":
                  if (d2.fire === G) break;
                  return t2._promise("readwrite", function() {
                    return a2(e3);
                  }, true);
                case "put":
                  if (d2.fire === G && p2.fire === G) break;
                  return t2._promise("readwrite", function() {
                    return a2(e3);
                  }, true);
                case "delete":
                  if (h2.fire === G) break;
                  return t2._promise("readwrite", function() {
                    return a2(e3);
                  }, true);
                case "deleteRange":
                  if (h2.fire === G) break;
                  return t2._promise("readwrite", function() {
                    return (function n3(r4, i2, o2) {
                      return y2.query({ trans: r4, values: false, query: { index: v2, range: i2 }, limit: o2 }).then(function(e4) {
                        var t3 = e4.result;
                        return a2({ type: "delete", keys: t3, trans: r4 }).then(function(e5) {
                          return 0 < e5.numFailures ? Promise.reject(e5.failures[0]) : t3.length < o2 ? { failures: [], numFailures: 0, lastResult: void 0 } : n3(r4, _(_({}, i2), { lower: t3[t3.length - 1], lowerOpen: true }), o2);
                        });
                      });
                    })(e3.trans, e3.range, 1e4);
                  }, true);
              }
              return y2.mutate(e3);
              function a2(c2) {
                var e4, t3, n3, l2 = me.trans, f2 = c2.keys || Ln(v2, c2);
                if (!f2) throw new Error("Keys missing");
                return "delete" !== (c2 = "add" === c2.type || "put" === c2.type ? _(_({}, c2), { keys: f2 }) : _({}, c2)).type && (c2.values = i([], c2.values)), c2.keys && (c2.keys = i([], c2.keys)), e4 = y2, n3 = f2, ("add" === (t3 = c2).type ? Promise.resolve([]) : e4.getMany({ trans: t3.trans, keys: n3, cache: "immutable" })).then(function(u2) {
                  var s2 = f2.map(function(e5, t4) {
                    var n4, r4, i2, o2 = u2[t4], a3 = { onerror: null, onsuccess: null };
                    return "delete" === c2.type ? h2.fire.call(a3, e5, o2, l2) : "add" === c2.type || void 0 === o2 ? (n4 = d2.fire.call(a3, e5, c2.values[t4], l2), null == e5 && null != n4 && (c2.keys[t4] = e5 = n4, v2.outbound || w(c2.values[t4], v2.keyPath, e5))) : (n4 = Nn(o2, c2.values[t4]), (r4 = p2.fire.call(a3, n4, e5, o2, l2)) && (i2 = c2.values[t4], Object.keys(r4).forEach(function(e6) {
                      m(i2, e6) ? i2[e6] = r4[e6] : w(i2, e6, r4[e6]);
                    }))), a3;
                  });
                  return y2.mutate(c2).then(function(e5) {
                    for (var t4 = e5.failures, n4 = e5.results, r4 = e5.numFailures, e5 = e5.lastResult, i2 = 0; i2 < f2.length; ++i2) {
                      var o2 = (n4 || f2)[i2], a3 = s2[i2];
                      null == o2 ? a3.onerror && a3.onerror(t4[i2]) : a3.onsuccess && a3.onsuccess("put" === c2.type && u2[i2] ? c2.values[i2] : o2);
                    }
                    return { failures: t4, results: n4, numFailures: r4, lastResult: e5 };
                  }).catch(function(t4) {
                    return s2.forEach(function(e5) {
                      return e5.onerror && e5.onerror(t4);
                    }), Promise.reject(t4);
                  });
                });
              }
            } });
          } });
        } };
        function Vn(e2, t2, n2) {
          try {
            if (!t2) return null;
            if (t2.keys.length < e2.length) return null;
            for (var r3 = [], i2 = 0, o2 = 0; i2 < t2.keys.length && o2 < e2.length; ++i2) 0 === st(t2.keys[i2], e2[o2]) && (r3.push(n2 ? S(t2.values[i2]) : t2.values[i2]), ++o2);
            return r3.length === e2.length ? r3 : null;
          } catch (e3) {
            return null;
          }
        }
        var zn = { stack: "dbcore", level: -1, create: function(t2) {
          return { table: function(e2) {
            var n2 = t2.table(e2);
            return _(_({}, n2), { getMany: function(t3) {
              if (!t3.cache) return n2.getMany(t3);
              var e3 = Vn(t3.keys, t3.trans._cache, "clone" === t3.cache);
              return e3 ? _e.resolve(e3) : n2.getMany(t3).then(function(e4) {
                return t3.trans._cache = { keys: t3.keys, values: "clone" === t3.cache ? S(e4) : e4 }, e4;
              });
            }, mutate: function(e3) {
              return "add" !== e3.type && (e3.trans._cache = null), n2.mutate(e3);
            } });
          } };
        } };
        function Wn(e2, t2) {
          return "readonly" === e2.trans.mode && !!e2.subscr && !e2.trans.explicit && "disabled" !== e2.trans.db._options.cache && !t2.schema.primaryKey.outbound;
        }
        function Yn(e2, t2) {
          switch (e2) {
            case "query":
              return t2.values && !t2.unique;
            case "get":
            case "getMany":
            case "count":
            case "openCursor":
              return false;
          }
        }
        var $n = { stack: "dbcore", level: 0, name: "Observability", create: function(b2) {
          var g2 = b2.schema.name, w2 = new _n(b2.MIN_KEY, b2.MAX_KEY);
          return _(_({}, b2), { transaction: function(e2, t2, n2) {
            if (me.subscr && "readonly" !== t2) throw new Y.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(me.querier));
            return b2.transaction(e2, t2, n2);
          }, table: function(d2) {
            var p2 = b2.table(d2), y2 = p2.schema, v2 = y2.primaryKey, e2 = y2.indexes, c2 = v2.extractKey, l2 = v2.outbound, m2 = v2.autoIncrement && e2.filter(function(e3) {
              return e3.compound && e3.keyPath.includes(v2.keyPath);
            }), t2 = _(_({}, p2), { mutate: function(a2) {
              function u2(e4) {
                return e4 = "idb://".concat(g2, "/").concat(d2, "/").concat(e4), n2[e4] || (n2[e4] = new _n());
              }
              var e3, o2, s2, t3 = a2.trans, n2 = a2.mutatedParts || (a2.mutatedParts = {}), r3 = u2(""), i2 = u2(":dels"), c3 = a2.type, l3 = "deleteRange" === a2.type ? [a2.range] : "delete" === a2.type ? [a2.keys] : a2.values.length < 50 ? [Ln(v2, a2).filter(function(e4) {
                return e4;
              }), a2.values] : [], f3 = l3[0], h2 = l3[1], l3 = a2.trans._cache;
              return x(f3) ? (r3.addKeys(f3), (l3 = "delete" === c3 || f3.length === h2.length ? Vn(f3, l3) : null) || i2.addKeys(f3), (l3 || h2) && (e3 = u2, o2 = l3, s2 = h2, y2.indexes.forEach(function(t4) {
                var n3 = e3(t4.name || "");
                function r4(e4) {
                  return null != e4 ? t4.extractKey(e4) : null;
                }
                function i3(e4) {
                  return t4.multiEntry && x(e4) ? e4.forEach(function(e5) {
                    return n3.addKey(e5);
                  }) : n3.addKey(e4);
                }
                (o2 || s2).forEach(function(e4, t5) {
                  var n4 = o2 && r4(o2[t5]), t5 = s2 && r4(s2[t5]);
                  0 !== st(n4, t5) && (null != n4 && i3(n4), null != t5 && i3(t5));
                });
              }))) : f3 ? (h2 = { from: null !== (h2 = f3.lower) && void 0 !== h2 ? h2 : b2.MIN_KEY, to: null !== (h2 = f3.upper) && void 0 !== h2 ? h2 : b2.MAX_KEY }, i2.add(h2), r3.add(h2)) : (r3.add(w2), i2.add(w2), y2.indexes.forEach(function(e4) {
                return u2(e4.name).add(w2);
              })), p2.mutate(a2).then(function(o3) {
                return !f3 || "add" !== a2.type && "put" !== a2.type || (r3.addKeys(o3.results), m2 && m2.forEach(function(t4) {
                  for (var e4 = a2.values.map(function(e5) {
                    return t4.extractKey(e5);
                  }), n3 = t4.keyPath.findIndex(function(e5) {
                    return e5 === v2.keyPath;
                  }), r4 = 0, i3 = o3.results.length; r4 < i3; ++r4) e4[r4][n3] = o3.results[r4];
                  u2(t4.name).addKeys(e4);
                })), t3.mutatedParts = Sn(t3.mutatedParts || {}, n2), o3;
              });
            } }), e2 = function(e3) {
              var t3 = e3.query, e3 = t3.index, t3 = t3.range;
              return [e3, new _n(null !== (e3 = t3.lower) && void 0 !== e3 ? e3 : b2.MIN_KEY, null !== (t3 = t3.upper) && void 0 !== t3 ? t3 : b2.MAX_KEY)];
            }, f2 = { get: function(e3) {
              return [v2, new _n(e3.key)];
            }, getMany: function(e3) {
              return [v2, new _n().addKeys(e3.keys)];
            }, count: e2, query: e2, openCursor: e2 };
            return O(f2).forEach(function(s2) {
              t2[s2] = function(i2) {
                var e3 = me.subscr, t3 = !!e3, n2 = Wn(me, p2) && Yn(s2, i2) ? i2.obsSet = {} : e3;
                if (t3) {
                  var r3 = function(e4) {
                    e4 = "idb://".concat(g2, "/").concat(d2, "/").concat(e4);
                    return n2[e4] || (n2[e4] = new _n());
                  }, o2 = r3(""), a2 = r3(":dels"), e3 = f2[s2](i2), t3 = e3[0], e3 = e3[1];
                  if (("query" === s2 && t3.isPrimaryKey && !i2.values ? a2 : r3(t3.name || "")).add(e3), !t3.isPrimaryKey) {
                    if ("count" !== s2) {
                      var u2 = "query" === s2 && l2 && i2.values && p2.query(_(_({}, i2), { values: false }));
                      return p2[s2].apply(this, arguments).then(function(t4) {
                        if ("query" === s2) {
                          if (l2 && i2.values) return u2.then(function(e5) {
                            e5 = e5.result;
                            return o2.addKeys(e5), t4;
                          });
                          var e4 = i2.values ? t4.result.map(c2) : t4.result;
                          (i2.values ? o2 : a2).addKeys(e4);
                        } else if ("openCursor" === s2) {
                          var n3 = t4, r4 = i2.values;
                          return n3 && Object.create(n3, { key: { get: function() {
                            return a2.addKey(n3.primaryKey), n3.key;
                          } }, primaryKey: { get: function() {
                            var e5 = n3.primaryKey;
                            return a2.addKey(e5), e5;
                          } }, value: { get: function() {
                            return r4 && o2.addKey(n3.primaryKey), n3.value;
                          } } });
                        }
                        return t4;
                      });
                    }
                    a2.add(w2);
                  }
                }
                return p2[s2].apply(this, arguments);
              };
            }), t2;
          } });
        } };
        function Qn(e2, t2, n2) {
          if (0 === n2.numFailures) return t2;
          if ("deleteRange" === t2.type) return null;
          var r3 = t2.keys ? t2.keys.length : "values" in t2 && t2.values ? t2.values.length : 1;
          if (n2.numFailures === r3) return null;
          t2 = _({}, t2);
          return x(t2.keys) && (t2.keys = t2.keys.filter(function(e3, t3) {
            return !(t3 in n2.failures);
          })), "values" in t2 && x(t2.values) && (t2.values = t2.values.filter(function(e3, t3) {
            return !(t3 in n2.failures);
          })), t2;
        }
        function Gn(e2, t2) {
          return n2 = e2, (void 0 === (r3 = t2).lower || (r3.lowerOpen ? 0 < st(n2, r3.lower) : 0 <= st(n2, r3.lower))) && (e2 = e2, void 0 === (t2 = t2).upper || (t2.upperOpen ? st(e2, t2.upper) < 0 : st(e2, t2.upper) <= 0));
          var n2, r3;
        }
        function Xn(e2, d2, t2, n2, r3, i2) {
          if (!t2 || 0 === t2.length) return e2;
          var o2 = d2.query.index, p2 = o2.multiEntry, y2 = d2.query.range, v2 = n2.schema.primaryKey.extractKey, m2 = o2.extractKey, a2 = (o2.lowLevelIndex || o2).extractKey, t2 = t2.reduce(function(e3, t3) {
            var n3 = e3, r4 = [];
            if ("add" === t3.type || "put" === t3.type) for (var i3 = new _n(), o3 = t3.values.length - 1; 0 <= o3; --o3) {
              var a3, u2 = t3.values[o3], s2 = v2(u2);
              i3.hasKey(s2) || (a3 = m2(u2), (p2 && x(a3) ? a3.some(function(e4) {
                return Gn(e4, y2);
              }) : Gn(a3, y2)) && (i3.addKey(s2), r4.push(u2)));
            }
            switch (t3.type) {
              case "add":
                var c2 = new _n().addKeys(d2.values ? e3.map(function(e4) {
                  return v2(e4);
                }) : e3), n3 = e3.concat(d2.values ? r4.filter(function(e4) {
                  e4 = v2(e4);
                  return !c2.hasKey(e4) && (c2.addKey(e4), true);
                }) : r4.map(function(e4) {
                  return v2(e4);
                }).filter(function(e4) {
                  return !c2.hasKey(e4) && (c2.addKey(e4), true);
                }));
                break;
              case "put":
                var l2 = new _n().addKeys(t3.values.map(function(e4) {
                  return v2(e4);
                }));
                n3 = e3.filter(function(e4) {
                  return !l2.hasKey(d2.values ? v2(e4) : e4);
                }).concat(d2.values ? r4 : r4.map(function(e4) {
                  return v2(e4);
                }));
                break;
              case "delete":
                var f2 = new _n().addKeys(t3.keys);
                n3 = e3.filter(function(e4) {
                  return !f2.hasKey(d2.values ? v2(e4) : e4);
                });
                break;
              case "deleteRange":
                var h2 = t3.range;
                n3 = e3.filter(function(e4) {
                  return !Gn(v2(e4), h2);
                });
            }
            return n3;
          }, e2);
          return t2 === e2 ? e2 : (t2.sort(function(e3, t3) {
            return st(a2(e3), a2(t3)) || st(v2(e3), v2(t3));
          }), d2.limit && d2.limit < 1 / 0 && (t2.length > d2.limit ? t2.length = d2.limit : e2.length === d2.limit && t2.length < d2.limit && (r3.dirty = true)), i2 ? Object.freeze(t2) : t2);
        }
        function Hn(e2, t2) {
          return 0 === st(e2.lower, t2.lower) && 0 === st(e2.upper, t2.upper) && !!e2.lowerOpen == !!t2.lowerOpen && !!e2.upperOpen == !!t2.upperOpen;
        }
        function Jn(e2, t2) {
          return (function(e3, t3, n2, r3) {
            if (void 0 === e3) return void 0 !== t3 ? -1 : 0;
            if (void 0 === t3) return 1;
            if (0 === (t3 = st(e3, t3))) {
              if (n2 && r3) return 0;
              if (n2) return 1;
              if (r3) return -1;
            }
            return t3;
          })(e2.lower, t2.lower, e2.lowerOpen, t2.lowerOpen) <= 0 && 0 <= (function(e3, t3, n2, r3) {
            if (void 0 === e3) return void 0 !== t3 ? 1 : 0;
            if (void 0 === t3) return -1;
            if (0 === (t3 = st(e3, t3))) {
              if (n2 && r3) return 0;
              if (n2) return -1;
              if (r3) return 1;
            }
            return t3;
          })(e2.upper, t2.upper, e2.upperOpen, t2.upperOpen);
        }
        function Zn(n2, r3, i2, e2) {
          n2.subscribers.add(i2), e2.addEventListener("abort", function() {
            var e3, t2;
            n2.subscribers.delete(i2), 0 === n2.subscribers.size && (e3 = n2, t2 = r3, setTimeout(function() {
              0 === e3.subscribers.size && I(t2, e3);
            }, 3e3));
          });
        }
        var er = { stack: "dbcore", level: 0, name: "Cache", create: function(k2) {
          var O2 = k2.schema.name;
          return _(_({}, k2), { transaction: function(g2, w2, e2) {
            var _2, t2, x2 = k2.transaction(g2, w2, e2);
            return "readwrite" === w2 && (t2 = (_2 = new AbortController()).signal, e2 = function(b2) {
              return function() {
                if (_2.abort(), "readwrite" === w2) {
                  for (var t3 = /* @__PURE__ */ new Set(), e3 = 0, n2 = g2; e3 < n2.length; e3++) {
                    var r3 = n2[e3], i2 = An["idb://".concat(O2, "/").concat(r3)];
                    if (i2) {
                      var o2 = k2.table(r3), a2 = i2.optimisticOps.filter(function(e4) {
                        return e4.trans === x2;
                      });
                      if (x2._explicit && b2 && x2.mutatedParts) for (var u2 = 0, s2 = Object.values(i2.queries.query); u2 < s2.length; u2++) for (var c2 = 0, l2 = (d2 = s2[u2]).slice(); c2 < l2.length; c2++) jn((p2 = l2[c2]).obsSet, x2.mutatedParts) && (I(d2, p2), p2.subscribers.forEach(function(e4) {
                        return t3.add(e4);
                      }));
                      else if (0 < a2.length) {
                        i2.optimisticOps = i2.optimisticOps.filter(function(e4) {
                          return e4.trans !== x2;
                        });
                        for (var f2 = 0, h2 = Object.values(i2.queries.query); f2 < h2.length; f2++) for (var d2, p2, y2, v2 = 0, m2 = (d2 = h2[f2]).slice(); v2 < m2.length; v2++) null != (p2 = m2[v2]).res && x2.mutatedParts && (b2 && !p2.dirty ? (y2 = Object.isFrozen(p2.res), y2 = Xn(p2.res, p2.req, a2, o2, p2, y2), p2.dirty ? (I(d2, p2), p2.subscribers.forEach(function(e4) {
                          return t3.add(e4);
                        })) : y2 !== p2.res && (p2.res = y2, p2.promise = _e.resolve({ result: y2 }))) : (p2.dirty && I(d2, p2), p2.subscribers.forEach(function(e4) {
                          return t3.add(e4);
                        })));
                      }
                    }
                  }
                  t3.forEach(function(e4) {
                    return e4();
                  });
                }
              };
            }, x2.addEventListener("abort", e2(false), { signal: t2 }), x2.addEventListener("error", e2(false), { signal: t2 }), x2.addEventListener("complete", e2(true), { signal: t2 })), x2;
          }, table: function(c2) {
            var l2 = k2.table(c2), i2 = l2.schema.primaryKey;
            return _(_({}, l2), { mutate: function(t2) {
              var e2 = me.trans;
              if (i2.outbound || "disabled" === e2.db._options.cache || e2.explicit || "readwrite" !== e2.idbtrans.mode) return l2.mutate(t2);
              var n2 = An["idb://".concat(O2, "/").concat(c2)];
              if (!n2) return l2.mutate(t2);
              e2 = l2.mutate(t2);
              return "add" !== t2.type && "put" !== t2.type || !(50 <= t2.values.length || Ln(i2, t2).some(function(e3) {
                return null == e3;
              })) ? (n2.optimisticOps.push(t2), t2.mutatedParts && In(t2.mutatedParts), e2.then(function(e3) {
                0 < e3.numFailures && (I(n2.optimisticOps, t2), (e3 = Qn(0, t2, e3)) && n2.optimisticOps.push(e3), t2.mutatedParts && In(t2.mutatedParts));
              }), e2.catch(function() {
                I(n2.optimisticOps, t2), t2.mutatedParts && In(t2.mutatedParts);
              })) : e2.then(function(r3) {
                var e3 = Qn(0, _(_({}, t2), { values: t2.values.map(function(e4, t3) {
                  var n3;
                  if (r3.failures[t3]) return e4;
                  e4 = null !== (n3 = i2.keyPath) && void 0 !== n3 && n3.includes(".") ? S(e4) : _({}, e4);
                  return w(e4, i2.keyPath, r3.results[t3]), e4;
                }) }), r3);
                n2.optimisticOps.push(e3), queueMicrotask(function() {
                  return t2.mutatedParts && In(t2.mutatedParts);
                });
              }), e2;
            }, query: function(t2) {
              if (!Wn(me, l2) || !Yn("query", t2)) return l2.query(t2);
              var i3 = "immutable" === (null === (o2 = me.trans) || void 0 === o2 ? void 0 : o2.db._options.cache), e2 = me, n2 = e2.requery, r3 = e2.signal, o2 = (function(e3, t3, n3, r4) {
                var i4 = An["idb://".concat(e3, "/").concat(t3)];
                if (!i4) return [];
                if (!(t3 = i4.queries[n3])) return [null, false, i4, null];
                var o3 = t3[(r4.query ? r4.query.index.name : null) || ""];
                if (!o3) return [null, false, i4, null];
                switch (n3) {
                  case "query":
                    var a3 = o3.find(function(e4) {
                      return e4.req.limit === r4.limit && e4.req.values === r4.values && Hn(e4.req.query.range, r4.query.range);
                    });
                    return a3 ? [a3, true, i4, o3] : [o3.find(function(e4) {
                      return ("limit" in e4.req ? e4.req.limit : 1 / 0) >= r4.limit && (!r4.values || e4.req.values) && Jn(e4.req.query.range, r4.query.range);
                    }), false, i4, o3];
                  case "count":
                    a3 = o3.find(function(e4) {
                      return Hn(e4.req.query.range, r4.query.range);
                    });
                    return [a3, !!a3, i4, o3];
                }
              })(O2, c2, "query", t2), a2 = o2[0], e2 = o2[1], u2 = o2[2], s2 = o2[3];
              return a2 && e2 ? a2.obsSet = t2.obsSet : (e2 = l2.query(t2).then(function(e3) {
                var t3 = e3.result;
                if (a2 && (a2.res = t3), i3) {
                  for (var n3 = 0, r4 = t3.length; n3 < r4; ++n3) Object.freeze(t3[n3]);
                  Object.freeze(t3);
                } else e3.result = S(t3);
                return e3;
              }).catch(function(e3) {
                return s2 && a2 && I(s2, a2), Promise.reject(e3);
              }), a2 = { obsSet: t2.obsSet, promise: e2, subscribers: /* @__PURE__ */ new Set(), type: "query", req: t2, dirty: false }, s2 ? s2.push(a2) : (s2 = [a2], (u2 = u2 || (An["idb://".concat(O2, "/").concat(c2)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[t2.query.index.name || ""] = s2)), Zn(a2, s2, n2, r3), a2.promise.then(function(e3) {
                return { result: Xn(e3.result, t2, null == u2 ? void 0 : u2.optimisticOps, l2, a2, i3) };
              });
            } });
          } });
        } };
        function tr(e2, r3) {
          return new Proxy(e2, { get: function(e3, t2, n2) {
            return "db" === t2 ? r3 : Reflect.get(e3, t2, n2);
          } });
        }
        var nr = (rr.prototype.version = function(t2) {
          if (isNaN(t2) || t2 < 0.1) throw new Y.Type("Given version is not a positive number");
          if (t2 = Math.round(10 * t2) / 10, this.idbdb || this._state.isBeingOpened) throw new Y.Schema("Cannot add version when database is open");
          this.verno = Math.max(this.verno, t2);
          var e2 = this._versions, n2 = e2.filter(function(e3) {
            return e3._cfg.version === t2;
          })[0];
          return n2 || (n2 = new this.Version(t2), e2.push(n2), e2.sort(on), n2.stores({}), this._state.autoSchema = false, n2);
        }, rr.prototype._whenReady = function(e2) {
          var n2 = this;
          return this.idbdb && (this._state.openComplete || me.letThrough || this._vip) ? e2() : new _e(function(e3, t2) {
            if (n2._state.openComplete) return t2(new Y.DatabaseClosed(n2._state.dbOpenError));
            if (!n2._state.isBeingOpened) {
              if (!n2._state.autoOpen) return void t2(new Y.DatabaseClosed());
              n2.open().catch(G);
            }
            n2._state.dbReadyPromise.then(e3, t2);
          }).then(e2);
        }, rr.prototype.use = function(e2) {
          var t2 = e2.stack, n2 = e2.create, r3 = e2.level, i2 = e2.name;
          i2 && this.unuse({ stack: t2, name: i2 });
          e2 = this._middlewares[t2] || (this._middlewares[t2] = []);
          return e2.push({ stack: t2, create: n2, level: null == r3 ? 10 : r3, name: i2 }), e2.sort(function(e3, t3) {
            return e3.level - t3.level;
          }), this;
        }, rr.prototype.unuse = function(e2) {
          var t2 = e2.stack, n2 = e2.name, r3 = e2.create;
          return t2 && this._middlewares[t2] && (this._middlewares[t2] = this._middlewares[t2].filter(function(e3) {
            return r3 ? e3.create !== r3 : !!n2 && e3.name !== n2;
          })), this;
        }, rr.prototype.open = function() {
          var e2 = this;
          return $e(ve, function() {
            return Bn(e2);
          });
        }, rr.prototype._close = function() {
          this.on.close.fire(new CustomEvent("close"));
          var n2 = this._state, e2 = et.indexOf(this);
          if (0 <= e2 && et.splice(e2, 1), this.idbdb) {
            try {
              this.idbdb.close();
            } catch (e3) {
            }
            this.idbdb = null;
          }
          n2.isBeingOpened || (n2.dbReadyPromise = new _e(function(e3) {
            n2.dbReadyResolve = e3;
          }), n2.openCanceller = new _e(function(e3, t2) {
            n2.cancelOpen = t2;
          }));
        }, rr.prototype.close = function(e2) {
          var t2 = (void 0 === e2 ? { disableAutoOpen: true } : e2).disableAutoOpen, e2 = this._state;
          t2 ? (e2.isBeingOpened && e2.cancelOpen(new Y.DatabaseClosed()), this._close(), e2.autoOpen = false, e2.dbOpenError = new Y.DatabaseClosed()) : (this._close(), e2.autoOpen = this._options.autoOpen || e2.isBeingOpened, e2.openComplete = false, e2.dbOpenError = null);
        }, rr.prototype.delete = function(n2) {
          var i2 = this;
          void 0 === n2 && (n2 = { disableAutoOpen: true });
          var o2 = 0 < arguments.length && "object" != typeof arguments[0], a2 = this._state;
          return new _e(function(r3, t2) {
            function e2() {
              i2.close(n2);
              var e3 = i2._deps.indexedDB.deleteDatabase(i2.name);
              e3.onsuccess = Ie(function() {
                var e4, t3, n3;
                e4 = i2._deps, t3 = i2.name, n3 = e4.indexedDB, e4 = e4.IDBKeyRange, bn(n3) || t3 === tt || mn(n3, e4).delete(t3).catch(G), r3();
              }), e3.onerror = Ft(t2), e3.onblocked = i2._fireOnBlocked;
            }
            if (o2) throw new Y.InvalidArgument("Invalid closeOptions argument to db.delete()");
            a2.isBeingOpened ? a2.dbReadyPromise.then(e2) : e2();
          });
        }, rr.prototype.backendDB = function() {
          return this.idbdb;
        }, rr.prototype.isOpen = function() {
          return null !== this.idbdb;
        }, rr.prototype.hasBeenClosed = function() {
          var e2 = this._state.dbOpenError;
          return e2 && "DatabaseClosed" === e2.name;
        }, rr.prototype.hasFailed = function() {
          return null !== this._state.dbOpenError;
        }, rr.prototype.dynamicallyOpened = function() {
          return this._state.autoSchema;
        }, Object.defineProperty(rr.prototype, "tables", { get: function() {
          var t2 = this;
          return O(this._allTables).map(function(e2) {
            return t2._allTables[e2];
          });
        }, enumerable: false, configurable: true }), rr.prototype.transaction = function() {
          var e2 = function(e3, t2, n2) {
            var r3 = arguments.length;
            if (r3 < 2) throw new Y.InvalidArgument("Too few arguments");
            for (var i2 = new Array(r3 - 1); --r3; ) i2[r3 - 1] = arguments[r3];
            return n2 = i2.pop(), [e3, P(i2), n2];
          }.apply(this, arguments);
          return this._transaction.apply(this, e2);
        }, rr.prototype._transaction = function(e2, t2, n2) {
          var r3 = this, i2 = me.trans;
          i2 && i2.db === this && -1 === e2.indexOf("!") || (i2 = null);
          var o2, a2, u2 = -1 !== e2.indexOf("?");
          e2 = e2.replace("!", "").replace("?", "");
          try {
            if (a2 = t2.map(function(e3) {
              e3 = e3 instanceof r3.Table ? e3.name : e3;
              if ("string" != typeof e3) throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
              return e3;
            }), "r" == e2 || e2 === nt) o2 = nt;
            else {
              if ("rw" != e2 && e2 != rt) throw new Y.InvalidArgument("Invalid transaction mode: " + e2);
              o2 = rt;
            }
            if (i2) {
              if (i2.mode === nt && o2 === rt) {
                if (!u2) throw new Y.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                i2 = null;
              }
              i2 && a2.forEach(function(e3) {
                if (i2 && -1 === i2.storeNames.indexOf(e3)) {
                  if (!u2) throw new Y.SubTransaction("Table " + e3 + " not included in parent transaction.");
                  i2 = null;
                }
              }), u2 && i2 && !i2.active && (i2 = null);
            }
          } catch (n3) {
            return i2 ? i2._promise(null, function(e3, t3) {
              t3(n3);
            }) : Xe(n3);
          }
          var s2 = function i3(o3, a3, u3, s3, c2) {
            return _e.resolve().then(function() {
              var e3 = me.transless || me, t3 = o3._createTransaction(a3, u3, o3._dbSchema, s3);
              if (t3.explicit = true, e3 = { trans: t3, transless: e3 }, s3) t3.idbtrans = s3.idbtrans;
              else try {
                t3.create(), t3.idbtrans._explicit = true, o3._state.PR1398_maxLoop = 3;
              } catch (e4) {
                return e4.name === z.InvalidState && o3.isOpen() && 0 < --o3._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), o3.close({ disableAutoOpen: false }), o3.open().then(function() {
                  return i3(o3, a3, u3, null, c2);
                })) : Xe(e4);
              }
              var n3, r4 = B(c2);
              return r4 && Le(), e3 = _e.follow(function() {
                var e4;
                (n3 = c2.call(t3, t3)) && (r4 ? (e4 = Ue.bind(null, null), n3.then(e4, e4)) : "function" == typeof n3.next && "function" == typeof n3.throw && (n3 = Rn(n3)));
              }, e3), (n3 && "function" == typeof n3.then ? _e.resolve(n3).then(function(e4) {
                return t3.active ? e4 : Xe(new Y.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
              }) : e3.then(function() {
                return n3;
              })).then(function(e4) {
                return s3 && t3._resolve(), t3._completion.then(function() {
                  return e4;
                });
              }).catch(function(e4) {
                return t3._reject(e4), Xe(e4);
              });
            });
          }.bind(null, this, o2, a2, i2, n2);
          return i2 ? i2._promise(o2, s2, "lock") : me.trans ? $e(me.transless, function() {
            return r3._whenReady(s2);
          }) : this._whenReady(s2);
        }, rr.prototype.table = function(e2) {
          if (!m(this._allTables, e2)) throw new Y.InvalidTable("Table ".concat(e2, " does not exist"));
          return this._allTables[e2];
        }, rr);
        function rr(e2, t2) {
          var o2 = this;
          this._middlewares = {}, this.verno = 0;
          var n2 = rr.dependencies;
          this._options = t2 = _({ addons: rr.addons, autoOpen: true, indexedDB: n2.indexedDB, IDBKeyRange: n2.IDBKeyRange, cache: "cloned" }, t2), this._deps = { indexedDB: t2.indexedDB, IDBKeyRange: t2.IDBKeyRange };
          n2 = t2.addons;
          this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
          var a2, r3, u2, i2, s2, c2 = { dbOpenError: null, isBeingOpened: false, onReadyBeingFired: null, openComplete: false, dbReadyResolve: G, dbReadyPromise: null, cancelOpen: G, openCanceller: null, autoSchema: true, PR1398_maxLoop: 3, autoOpen: t2.autoOpen };
          c2.dbReadyPromise = new _e(function(e3) {
            c2.dbReadyResolve = e3;
          }), c2.openCanceller = new _e(function(e3, t3) {
            c2.cancelOpen = t3;
          }), this._state = c2, this.name = e2, this.on = mt(this, "populate", "blocked", "versionchange", "close", { ready: [re, G] }), this.once = function(n3, r4) {
            var i3 = function() {
              for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
              o2.on(n3).unsubscribe(i3), r4.apply(o2, e3);
            };
            return o2.on(n3, i3);
          }, this.on.ready.subscribe = p(this.on.ready.subscribe, function(i3) {
            return function(n3, r4) {
              rr.vip(function() {
                var t3, e3 = o2._state;
                e3.openComplete ? (e3.dbOpenError || _e.resolve().then(n3), r4 && i3(n3)) : e3.onReadyBeingFired ? (e3.onReadyBeingFired.push(n3), r4 && i3(n3)) : (i3(n3), t3 = o2, r4 || i3(function e4() {
                  t3.on.ready.unsubscribe(n3), t3.on.ready.unsubscribe(e4);
                }));
              });
            };
          }), this.Collection = (a2 = this, bt(Kt.prototype, function(e3, t3) {
            this.db = a2;
            var n3 = ot, r4 = null;
            if (t3) try {
              n3 = t3();
            } catch (e4) {
              r4 = e4;
            }
            var i3 = e3._ctx, t3 = i3.table, e3 = t3.hook.reading.fire;
            this._ctx = { table: t3, index: i3.index, isPrimKey: !i3.index || t3.schema.primKey.keyPath && i3.index === t3.schema.primKey.name, range: n3, keysOnly: false, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: true, isMatch: null, offset: 0, limit: 1 / 0, error: r4, or: i3.or, valueMapper: e3 !== X2 ? e3 : null };
          })), this.Table = (r3 = this, bt(yt.prototype, function(e3, t3, n3) {
            this.db = r3, this._tx = n3, this.name = e3, this.schema = t3, this.hook = r3._allTables[e3] ? r3._allTables[e3].hook : mt(null, { creating: [Z, G], reading: [H, X2], updating: [te, G], deleting: [ee, G] });
          })), this.Transaction = (u2 = this, bt(Vt.prototype, function(e3, t3, n3, r4, i3) {
            var o3 = this;
            "readonly" !== e3 && t3.forEach(function(e4) {
              e4 = null === (e4 = n3[e4]) || void 0 === e4 ? void 0 : e4.yProps;
              e4 && (t3 = t3.concat(e4.map(function(e5) {
                return e5.updatesTable;
              })));
            }), this.db = u2, this.mode = e3, this.storeNames = t3, this.schema = n3, this.chromeTransactionDurability = r4, this.idbtrans = null, this.on = mt(this, "complete", "error", "abort"), this.parent = i3 || null, this.active = true, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new _e(function(e4, t4) {
              o3._resolve = e4, o3._reject = t4;
            }), this._completion.then(function() {
              o3.active = false, o3.on.complete.fire();
            }, function(e4) {
              var t4 = o3.active;
              return o3.active = false, o3.on.error.fire(e4), o3.parent ? o3.parent._reject(e4) : t4 && o3.idbtrans && o3.idbtrans.abort(), Xe(e4);
            });
          })), this.Version = (i2 = this, bt(yn.prototype, function(e3) {
            this.db = i2, this._cfg = { version: e3, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
          })), this.WhereClause = (s2 = this, bt(Bt.prototype, function(e3, t3, n3) {
            if (this.db = s2, this._ctx = { table: e3, index: ":id" === t3 ? null : t3, or: n3 }, this._cmp = this._ascending = st, this._descending = function(e4, t4) {
              return st(t4, e4);
            }, this._max = function(e4, t4) {
              return 0 < st(e4, t4) ? e4 : t4;
            }, this._min = function(e4, t4) {
              return st(e4, t4) < 0 ? e4 : t4;
            }, this._IDBKeyRange = s2._deps.IDBKeyRange, !this._IDBKeyRange) throw new Y.MissingAPI();
          })), this.on("versionchange", function(e3) {
            0 < e3.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o2.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o2.name, "'. Closing db now to resume the delete request.")), o2.close({ disableAutoOpen: false });
          }), this.on("blocked", function(e3) {
            !e3.newVersion || e3.newVersion < e3.oldVersion ? console.warn("Dexie.delete('".concat(o2.name, "') was blocked")) : console.warn("Upgrade '".concat(o2.name, "' blocked by other connection holding version ").concat(e3.oldVersion / 10));
          }), this._maxKey = Qt(t2.IDBKeyRange), this._createTransaction = function(e3, t3, n3, r4) {
            return new o2.Transaction(e3, t3, n3, o2._options.chromeTransactionDurability, r4);
          }, this._fireOnBlocked = function(t3) {
            o2.on("blocked").fire(t3), et.filter(function(e3) {
              return e3.name === o2.name && e3 !== o2 && !e3._state.vcFired;
            }).map(function(e3) {
              return e3.on("versionchange").fire(t3);
            });
          }, this.use(zn), this.use(er), this.use($n), this.use(Mn), this.use(Un);
          var l2 = new Proxy(this, { get: function(e3, t3, n3) {
            if ("_vip" === t3) return true;
            if ("table" === t3) return function(e4) {
              return tr(o2.table(e4), l2);
            };
            var r4 = Reflect.get(e3, t3, n3);
            return r4 instanceof yt ? tr(r4, l2) : "tables" === t3 ? r4.map(function(e4) {
              return tr(e4, l2);
            }) : "_createTransaction" === t3 ? function() {
              return tr(r4.apply(this, arguments), l2);
            } : r4;
          } });
          this.vip = l2, n2.forEach(function(e3) {
            return e3(o2);
          });
        }
        var ir, F = "undefined" != typeof Symbol && "observable" in Symbol ? Symbol.observable : "@@observable", or = (ar.prototype.subscribe = function(e2, t2, n2) {
          return this._subscribe(e2 && "function" != typeof e2 ? e2 : { next: e2, error: t2, complete: n2 });
        }, ar.prototype[F] = function() {
          return this;
        }, ar);
        function ar(e2) {
          this._subscribe = e2;
        }
        try {
          ir = { indexedDB: f.indexedDB || f.mozIndexedDB || f.webkitIndexedDB || f.msIndexedDB, IDBKeyRange: f.IDBKeyRange || f.webkitIDBKeyRange };
        } catch (e2) {
          ir = { indexedDB: null, IDBKeyRange: null };
        }
        function ur(h2) {
          var d2, p2 = false, e2 = new or(function(r3) {
            var i2 = B(h2);
            var o2, a2 = false, u2 = {}, s2 = {}, e3 = { get closed() {
              return a2;
            }, unsubscribe: function() {
              a2 || (a2 = true, o2 && o2.abort(), c2 && Ut.storagemutated.unsubscribe(f2));
            } };
            r3.start && r3.start(e3);
            var c2 = false, l2 = function() {
              return Ge(t2);
            };
            var f2 = function(e4) {
              Sn(u2, e4), jn(s2, u2) && l2();
            }, t2 = function() {
              var t3, n2, e4;
              !a2 && ir.indexedDB && (u2 = {}, t3 = {}, o2 && o2.abort(), o2 = new AbortController(), e4 = (function(e5) {
                var t4 = je();
                try {
                  i2 && Le();
                  var n3 = Ne(h2, e5);
                  return n3 = i2 ? n3.finally(Ue) : n3;
                } finally {
                  t4 && Ae();
                }
              })(n2 = { subscr: t3, signal: o2.signal, requery: l2, querier: h2, trans: null }), Promise.resolve(e4).then(function(e5) {
                p2 = true, d2 = e5, a2 || n2.signal.aborted || (u2 = {}, (function(e6) {
                  for (var t4 in e6) if (m(e6, t4)) return;
                  return 1;
                })(s2 = t3) || c2 || (Ut(Nt, f2), c2 = true), Ge(function() {
                  return !a2 && r3.next && r3.next(e5);
                }));
              }, function(e5) {
                p2 = false, ["DatabaseClosedError", "AbortError"].includes(null == e5 ? void 0 : e5.name) || a2 || Ge(function() {
                  a2 || r3.error && r3.error(e5);
                });
              }));
            };
            return setTimeout(l2, 0), e3;
          });
          return e2.hasValue = function() {
            return p2;
          }, e2.getValue = function() {
            return d2;
          }, e2;
        }
        var sr = nr;
        function cr(e2) {
          var t2 = fr;
          try {
            fr = true, Ut.storagemutated.fire(e2), qn(e2, true);
          } finally {
            fr = t2;
          }
        }
        r2(sr, _(_({}, Q), { delete: function(e2) {
          return new sr(e2, { addons: [] }).delete();
        }, exists: function(e2) {
          return new sr(e2, { addons: [] }).open().then(function(e3) {
            return e3.close(), true;
          }).catch("NoSuchDatabaseError", function() {
            return false;
          });
        }, getDatabaseNames: function(e2) {
          try {
            return t2 = sr.dependencies, n2 = t2.indexedDB, t2 = t2.IDBKeyRange, (bn(n2) ? Promise.resolve(n2.databases()).then(function(e3) {
              return e3.map(function(e4) {
                return e4.name;
              }).filter(function(e4) {
                return e4 !== tt;
              });
            }) : mn(n2, t2).toCollection().primaryKeys()).then(e2);
          } catch (e3) {
            return Xe(new Y.MissingAPI());
          }
          var t2, n2;
        }, defineClass: function() {
          return function(e2) {
            a(this, e2);
          };
        }, ignoreTransaction: function(e2) {
          return me.trans ? $e(me.transless, e2) : e2();
        }, vip: gn, async: function(t2) {
          return function() {
            try {
              var e2 = Rn(t2.apply(this, arguments));
              return e2 && "function" == typeof e2.then ? e2 : _e.resolve(e2);
            } catch (e3) {
              return Xe(e3);
            }
          };
        }, spawn: function(e2, t2, n2) {
          try {
            var r3 = Rn(e2.apply(n2, t2 || []));
            return r3 && "function" == typeof r3.then ? r3 : _e.resolve(r3);
          } catch (e3) {
            return Xe(e3);
          }
        }, currentTransaction: { get: function() {
          return me.trans || null;
        } }, waitFor: function(e2, t2) {
          t2 = _e.resolve("function" == typeof e2 ? sr.ignoreTransaction(e2) : e2).timeout(t2 || 6e4);
          return me.trans ? me.trans.waitFor(t2) : t2;
        }, Promise: _e, debug: { get: function() {
          return ie;
        }, set: function(e2) {
          oe(e2);
        } }, derive: o, extend: a, props: r2, override: p, Events: mt, on: Ut, liveQuery: ur, extendObservabilitySet: Sn, getByKeyPath: g, setByKeyPath: w, delByKeyPath: function(t2, e2) {
          "string" == typeof e2 ? w(t2, e2, void 0) : "length" in e2 && [].map.call(e2, function(e3) {
            w(t2, e3, void 0);
          });
        }, shallowClone: k, deepClone: S, getObjectDiff: Nn, cmp: st, asap: v, minKey: -1 / 0, addons: [], connections: et, errnames: z, dependencies: ir, cache: An, semVer: "4.2.1", version: "4.2.1".split(".").map(function(e2) {
          return parseInt(e2);
        }).reduce(function(e2, t2, n2) {
          return e2 + t2 / Math.pow(10, 2 * n2);
        }) })), sr.maxKey = Qt(sr.dependencies.IDBKeyRange), "undefined" != typeof dispatchEvent && "undefined" != typeof addEventListener && (Ut(Nt, function(e2) {
          fr || (e2 = new CustomEvent(Lt, { detail: e2 }), fr = true, dispatchEvent(e2), fr = false);
        }), addEventListener(Lt, function(e2) {
          e2 = e2.detail;
          fr || cr(e2);
        }));
        var lr, fr = false, hr = function() {
        };
        return "undefined" != typeof BroadcastChannel && ((hr = function() {
          (lr = new BroadcastChannel(Lt)).onmessage = function(e2) {
            return e2.data && cr(e2.data);
          };
        })(), "function" == typeof lr.unref && lr.unref(), Ut(Nt, function(e2) {
          fr || lr.postMessage(e2);
        })), "undefined" != typeof addEventListener && (addEventListener("pagehide", function(e2) {
          if (!nr.disableBfCache && e2.persisted) {
            ie && console.debug("Dexie: handling persisted pagehide"), null != lr && lr.close();
            for (var t2 = 0, n2 = et; t2 < n2.length; t2++) n2[t2].close({ disableAutoOpen: false });
          }
        }), addEventListener("pageshow", function(e2) {
          !nr.disableBfCache && e2.persisted && (ie && console.debug("Dexie: handling persisted pageshow"), hr(), cr({ all: new _n(-1 / 0, [[]]) }));
        })), _e.rejectionMapper = function(e2, t2) {
          return !e2 || e2 instanceof N || e2 instanceof TypeError || e2 instanceof SyntaxError || !e2.name || !$[e2.name] ? e2 : (t2 = new $[e2.name](t2 || e2.message, e2), "stack" in e2 && l(t2, "stack", { get: function() {
            return this.inner.stack;
          } }), t2);
        }, oe(ie), _(nr, Object.freeze({ __proto__: null, Dexie: nr, liveQuery: ur, Entity: ut, cmp: st, PropModification: ht, replacePrefix: function(e2, t2) {
          return new ht({ replacePrefix: [e2, t2] });
        }, add: function(e2) {
          return new ht({ add: e2 });
        }, remove: function(e2) {
          return new ht({ remove: e2 });
        }, default: nr, RangeSet: _n, mergeRanges: kn, rangesOverlap: On }), { default: nr }), nr;
      });
    })(dexie_min$1);
    return dexie_min$1.exports;
  }
  var dexie_minExports = requireDexie_min();
  const _Dexie = /* @__PURE__ */ getDefaultExportFromCjs(dexie_minExports);
  const DexieSymbol = Symbol.for("Dexie");
  const Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _Dexie);
  if (_Dexie.semVer !== Dexie.semVer) {
    throw new Error(`Two different versions of Dexie loaded in the same app: ${_Dexie.semVer} and ${Dexie.semVer}`);
  }
  const {
    liveQuery,
    mergeRanges,
    rangesOverlap,
    RangeSet,
    cmp,
    Entity,
    PropModification,
    replacePrefix,
    add,
    remove: remove$1,
    DexieYProvider
  } = Dexie;
  class NetworkDatabase extends Dexie {
    constructor() {
      super("UprootNetworkDB");
      // Tables
      __publicField(this, "nodes");
      __publicField(this, "edges");
      __publicField(this, "activities");
      __publicField(this, "companies");
      this.version(1).stores({
        // Nodes: Indexed by id (primary), degree, profile fields, matchScore
        // Allows queries like: "find all 2nd degree connections at Google"
        nodes: "id, degree, profile.name, profile.company, matchScore, status",
        // Edges: Composite primary key [from+to] prevents duplicates
        // Indexed by from/to for pathfinding (get all edges from a node)
        edges: "[from+to], from, to, weight, relationshipType",
        // Activities: For engagement_bridge strategy
        // Critical index: targetId (find who engages with target person)
        activities: "id, actorId, targetId, type, timestamp, scrapedAt",
        // Companies: For company_bridge strategy
        // Indexed by companyId (primary), name, and scrape time
        companies: "companyId, companyName, scrapedAt"
      });
    }
  }
  const networkDB = new NetworkDatabase();
  async function bulkAddNodes(nodes) {
    try {
      await networkDB.nodes.bulkPut(nodes);
      console.log(`[NetworkDB] Added ${nodes.length} nodes`);
    } catch (error) {
      console.error("[NetworkDB] Failed to bulk add nodes:", error);
      throw error;
    }
  }
  async function getActivitiesForTarget(targetId) {
    try {
      return await networkDB.activities.where("targetId").equals(targetId).toArray();
    } catch (error) {
      console.error("[NetworkDB] Failed to get activities for target:", targetId, error);
      return [];
    }
  }
  async function getCompany(companyId) {
    try {
      const company = await networkDB.companies.get(companyId);
      return company || null;
    } catch (error) {
      console.error("[NetworkDB] Failed to get company:", companyId, error);
      return null;
    }
  }
  content;
  async function findSteppingStones(sourceUser, engagedPeople, graph) {
    try {
      const steppingStones = [];
      const sourceNodeId = findNodeIdInGraph$1(graph, sourceUser);
      if (!sourceNodeId) {
        console.log("[SteppingStoneAnalyzer] Source user not found in graph");
        return [];
      }
      const firstDegreeConnections = await graph.getConnections(sourceNodeId);
      const firstDegreeIds = new Set(firstDegreeConnections.map((c) => c.id).filter((id) => id !== void 0));
      const secondDegreeIds = /* @__PURE__ */ new Set();
      for (const connection of firstDegreeConnections) {
        if (!connection.id) continue;
        const secondDegree = await graph.getConnections(connection.id);
        secondDegree.forEach((c) => {
          if (c.id && c.id !== sourceNodeId && !firstDegreeIds.has(c.id)) {
            secondDegreeIds.add(c.id);
          }
        });
      }
      for (const engagedPerson of engagedPeople) {
        const personId = engagedPerson.personId;
        if (firstDegreeIds.has(personId)) {
          const node = graph.getNode?.(personId);
          if (node) {
            steppingStones.push({
              person: engagedPerson,
              connectionDegree: 1,
              pathToSource: [sourceUser, node]
            });
          }
          continue;
        }
        if (secondDegreeIds.has(personId)) {
          const intermediary = firstDegreeConnections.find(async (c) => {
            const connections = await graph.getConnections(c.id || "");
            return connections.some((conn) => conn.id === personId);
          });
          const node = graph.getNode?.(personId);
          if (node && intermediary) {
            steppingStones.push({
              person: engagedPerson,
              connectionDegree: 2,
              pathToSource: [sourceUser, intermediary, node]
            });
          }
          continue;
        }
      }
      console.log(`[SteppingStoneAnalyzer] Found ${steppingStones.length} stepping stones`);
      return steppingStones;
    } catch (error) {
      console.error("[SteppingStoneAnalyzer] Error finding stepping stones:", error);
      return [];
    }
  }
  function findNodeIdInGraph$1(graph, user) {
    if (user.id) {
      const node = graph.getNode?.(user.id);
      if (node) return user.id;
    }
    if (user.email) {
      const node = graph.getNode?.(user.email);
      if (node) return user.email;
    }
    if (user.id) {
      const node = graph.getNode?.(user.id);
      if (node) return user.id;
    }
    return null;
  }
  content;
  function rankSteppingStones(steppingStoneBridges) {
    const scored = steppingStoneBridges.map((bridge) => {
      const qualityScore = bridge.bridgeQuality.overallBridgeQuality;
      const proximityScore = bridge.steppingStone.connectionDegree === 1 ? 1 : bridge.steppingStone.connectionDegree === 2 ? 0.7 : 0.4;
      const engagementScore = bridge.steppingStone.person.engagementStrength;
      const overlapScore = 0.5;
      const compositeScore = qualityScore * 0.4 + proximityScore * 0.3 + engagementScore * 0.2 + overlapScore * 0.1;
      return {
        bridge,
        compositeScore
      };
    });
    scored.sort((a, b) => b.compositeScore - a.compositeScore);
    return scored.map((item, index2) => ({
      ...item.bridge,
      rank: index2 + 1
    }));
  }
  function selectTopSteppingStones(rankedStones, maxCount = 3, minQuality = 0.5) {
    return rankedStones.filter((stone) => stone.bridgeQuality.overallBridgeQuality >= minQuality).slice(0, maxCount);
  }
  function generateConnectionMessage(sourceUser, steppingStone, targetUser, bridgeQuality) {
    const stoneName = steppingStone.person.personName || "there";
    const targetName = targetUser.name || "them";
    const sourceName = sourceUser.name || "me";
    const interests = bridgeQuality.sharedInterests.length > 0 ? bridgeQuality.sharedInterests.slice(0, 3).join(", ") : "professional development";
    const engagementDesc = bridgeQuality.engagementFrequency > 0.7 ? "frequently" : bridgeQuality.engagementFrequency > 0.4 ? "regularly" : "occasionally";
    if (steppingStone.connectionDegree === 1) {
      return `Hey ${stoneName},

I noticed your work on ${interests} - I've been working on similar topics as well.

I also saw you ${engagementDesc} engage with ${targetName}'s content on these same areas.

Since we all share these interests in ${interests}, would you be open to introducing us? I think we'd have great conversations together.

Best,
${sourceName}`;
    } else if (steppingStone.connectionDegree === 2) {
      const intermediary = steppingStone.pathToSource[1]?.name || "our mutual connection";
      return `Hey ${intermediary},

I'd like to connect with ${stoneName} - I saw they're very active in ${interests} work, which aligns with my interests.

I also noticed they ${engagementDesc} engage with ${targetName}'s content on similar topics. Would you be willing to introduce us so we can explore these shared interests?

Best,
${sourceName}`;
    } else {
      return `I'd like to connect regarding our shared interests in ${interests}. I noticed your engagement with ${targetName}'s work and think we could have valuable professional conversations.`;
    }
  }
  function generateReasoning$2(steppingStone, bridgeQuality, targetUser) {
    const stoneName = steppingStone.person.personName || "This person";
    const targetName = targetUser.name || "the target";
    const engagementCount = steppingStone.person.inboundCount + steppingStone.person.outboundCount;
    const engagementTypes = Array.from(steppingStone.person.engagementTypes).join(", ");
    const degreeText = steppingStone.connectionDegree === 1 ? "your direct connection" : steppingStone.connectionDegree === 2 ? "your 2nd-degree connection" : "in your extended network";
    return `${stoneName} is ${degreeText} who ${engagementCount > 0 ? `regularly engages with ${targetName} (${engagementCount} interactions, including ${engagementTypes})` : `knows ${targetName}`}. ${bridgeQuality.sharedInterests.length > 0 ? `You all share interests in ${bridgeQuality.sharedInterests.slice(0, 2).join(" and ")}.` : ""} This creates a natural introduction path.`;
  }
  function generateActionSteps(steppingStone, targetUser) {
    const stoneName = steppingStone.person.personName || "the stepping stone";
    const targetName = targetUser.name || "the target";
    if (steppingStone.connectionDegree === 1) {
      return [
        `Reach out to ${stoneName} (your direct connection)`,
        `Mention your interest in connecting with ${targetName}`,
        `Reference their engagement relationship`,
        `Request an introduction based on shared interests`,
        `Follow up within 3-5 days if no response`
      ];
    } else if (steppingStone.connectionDegree === 2) {
      const intermediary = steppingStone.pathToSource[1]?.name || "your mutual connection";
      return [
        `Contact ${intermediary} (your direct connection)`,
        `Ask for an introduction to ${stoneName}`,
        `Explain your interest in ${targetName} and the shared connection`,
        `Once connected to ${stoneName}, request introduction to ${targetName}`,
        `Maintain the relationship with both ${stoneName} and ${intermediary}`
      ];
    } else {
      return [
        `Research ${stoneName}'s recent activity and posts`,
        `Engage with their content authentically`,
        `Build rapport over 2-3 interactions`,
        `Then request introduction to ${targetName}`
      ];
    }
  }
  content;
  async function getEngagedPosts(_targetUser) {
    try {
      console.log("[EngagementBridge] No engagedPosts data in target profile");
      return [];
    } catch (error) {
      console.error("[EngagementBridge] Error getting engaged posts:", error);
      return [];
    }
  }
  function mergeEngagementDirections(inboundActivities, outboundEngagement) {
    const engagementMap = /* @__PURE__ */ new Map();
    for (const activity of inboundActivities) {
      const existing = engagementMap.get(activity.actorId);
      if (existing) {
        existing.inboundCount++;
        existing.types.add(activity.type);
        const activityDate = new Date(activity.timestamp);
        if (activityDate > existing.lastEngaged) {
          existing.lastEngaged = activityDate;
        }
      } else {
        engagementMap.set(activity.actorId, {
          personId: activity.actorId,
          personName: "",
          inboundCount: 1,
          outboundCount: 0,
          lastEngaged: new Date(activity.timestamp),
          types: /* @__PURE__ */ new Set([activity.type])
        });
      }
    }
    for (const engagement of outboundEngagement) {
      const existing = engagementMap.get(engagement.authorId);
      if (existing) {
        existing.outboundCount++;
        if (engagement.engagementType) {
          existing.types.add(engagement.engagementType);
        }
        const engagementDate = new Date(engagement.timestamp);
        if (engagementDate > existing.lastEngaged) {
          existing.lastEngaged = engagementDate;
        }
      } else {
        engagementMap.set(engagement.authorId, {
          personId: engagement.authorId,
          personName: engagement.authorName || "",
          inboundCount: 0,
          outboundCount: 1,
          lastEngaged: new Date(engagement.timestamp),
          types: new Set(engagement.engagementType ? [engagement.engagementType] : [])
        });
      }
    }
    const engagedPeople = [];
    for (const [_personId, data] of engagementMap.entries()) {
      data.inboundCount + data.outboundCount;
      const isBidirectional = data.inboundCount > 0 && data.outboundCount > 0;
      const recencyDays = (Date.now() - data.lastEngaged.getTime()) / (1e3 * 60 * 60 * 24);
      const recencyScore = Math.max(0, 1 - recencyDays / 90);
      const varietyScore = data.types.size / 3;
      const bidirectionalBonus = isBidirectional ? 0.2 : 0;
      const outboundWeight = 0.6;
      const inboundWeight = 0.4;
      const weightedCount = data.outboundCount * outboundWeight + data.inboundCount * inboundWeight;
      const weightedCountScore = Math.min(weightedCount / 10, 1);
      const engagementStrength = Math.min(
        weightedCountScore * 0.4 + recencyScore * 0.3 + varietyScore * 0.2 + bidirectionalBonus,
        1
      );
      engagedPeople.push({
        personId: data.personId,
        personName: data.personName,
        inboundCount: data.inboundCount,
        outboundCount: data.outboundCount,
        isBidirectional,
        lastEngaged: data.lastEngaged,
        engagementTypes: data.types,
        engagementStrength
      });
    }
    engagedPeople.sort((a, b) => b.engagementStrength - a.engagementStrength);
    return engagedPeople;
  }
  async function calculateBridgeQualityBasic(_sourceUser, steppingStone, _targetUser) {
    try {
      const userToStone = 0.6;
      const stoneToTarget = 0.7;
      const geometricMean = Math.sqrt(userToStone * stoneToTarget);
      const proximityMultiplier = steppingStone.connectionDegree === 1 ? 1.2 : steppingStone.connectionDegree === 2 ? 1.1 : 1;
      const engagementMultiplier = 1 + steppingStone.person.engagementStrength * 0.1;
      const overallBridgeQuality = Math.min(
        geometricMean * proximityMultiplier * engagementMultiplier,
        1
      );
      const baseAcceptance = 0.28;
      const qualityBonus = overallBridgeQuality * 0.12;
      const degreeBonus = steppingStone.connectionDegree === 1 ? 0.08 : 0;
      const estimatedAcceptanceRate = Math.min(
        baseAcceptance + qualityBonus + degreeBonus,
        0.48
      );
      return {
        userToStone,
        stoneToTarget,
        overallBridgeQuality,
        sharedInterests: [],
        connectionDegree: steppingStone.connectionDegree,
        engagementFrequency: steppingStone.person.engagementStrength,
        bestAngle: "Shared professional network",
        estimatedAcceptanceRate
      };
    } catch (error) {
      console.error("[EngagementBridge] Error calculating bridge quality:", error);
      return {
        userToStone: 0.5,
        stoneToTarget: 0.5,
        overallBridgeQuality: 0.5,
        sharedInterests: [],
        connectionDegree: steppingStone.connectionDegree,
        engagementFrequency: 0.5,
        bestAngle: "Professional networking",
        estimatedAcceptanceRate: 0.25
      };
    }
  }
  content;
  async function tryEngagementBridgeStrategy(sourceUser, targetUser, graph) {
    try {
      const targetLinkedInId = targetUser.id;
      if (!targetLinkedInId) {
        console.log("[EngagementBridge] No LinkedIn ID for target");
        return null;
      }
      const inboundActivities = await getActivitiesForTarget(targetLinkedInId);
      console.log(`[EngagementBridge] Found ${inboundActivities.length} inbound activities`);
      const outboundEngagement = await getEngagedPosts(targetUser);
      console.log(`[EngagementBridge] Found ${outboundEngagement.length} outbound engagements`);
      const allEngagedPeople = mergeEngagementDirections(
        inboundActivities,
        outboundEngagement
      );
      console.log(`[EngagementBridge] Total ${allEngagedPeople.length} engaged people`);
      if (allEngagedPeople.length === 0) {
        console.log("[EngagementBridge] No engagement data available");
        return null;
      }
      const steppingStones = await findSteppingStones(
        sourceUser,
        allEngagedPeople,
        graph
      );
      console.log(`[EngagementBridge] Found ${steppingStones.length} stepping stones`);
      if (steppingStones.length === 0) {
        console.log("[EngagementBridge] No stepping stones in user network");
        return null;
      }
      const steppingStoneBridges = [];
      for (const stone of steppingStones.slice(0, 5)) {
        const bridgeQuality = await calculateBridgeQualityBasic(
          sourceUser,
          stone,
          targetUser
        );
        const reasoning = generateReasoning$2(stone, bridgeQuality, targetUser);
        const actionSteps = generateActionSteps(stone, targetUser);
        const connectionMessage = generateConnectionMessage(
          sourceUser,
          stone,
          targetUser,
          bridgeQuality
        );
        steppingStoneBridges.push({
          steppingStone: stone,
          bridgeQuality,
          rank: 0,
          reasoning,
          actionSteps,
          connectionMessage
        });
      }
      const rankedStones = rankSteppingStones(steppingStoneBridges);
      const topStones = selectTopSteppingStones(rankedStones, 3, 0.5);
      console.log(`[EngagementBridge] Selected ${topStones.length} top stepping stones`);
      if (topStones.length === 0) {
        console.log("[EngagementBridge] No high-quality stepping stones found");
        return null;
      }
      const bestStone = topStones[0];
      return {
        type: "engagement_bridge",
        confidence: bestStone.bridgeQuality.overallBridgeQuality,
        estimatedAcceptanceRate: bestStone.bridgeQuality.estimatedAcceptanceRate,
        path: {
          nodes: bestStone.steppingStone.pathToSource,
          edges: [],
          totalWeight: 1 - bestStone.bridgeQuality.overallBridgeQuality,
          successProbability: bestStone.bridgeQuality.estimatedAcceptanceRate * 100,
          mutualConnections: 0
        },
        reasoning: bestStone.reasoning,
        nextSteps: bestStone.actionSteps,
        steppingStones: topStones
      };
    } catch (error) {
      console.error("[EngagementBridge] Strategy failed:", error);
      return null;
    }
  }
  content;
  async function tryCompanyBridgeStrategy(sourceUser, targetUser, graph) {
    try {
      const targetCompany = targetUser.workExperience?.[0]?.company;
      if (!targetCompany) {
        return null;
      }
      const companyId = targetCompany.toLowerCase().replace(/[^a-z0-9]/g, "-");
      const companyData = await getCompany(companyId);
      if (!companyData || companyData.employees.length === 0) {
        return null;
      }
      const sourceNodeId = findNodeIdInGraph(graph, sourceUser);
      if (!sourceNodeId) {
        return null;
      }
      const sourceConnections = await graph.getConnections(sourceNodeId);
      const sourceConnectionIds = new Set(sourceConnections.map((c) => c.id));
      const connectedColleagues = companyData.employees.filter(
        (employee) => sourceConnectionIds.has(employee.profileId)
      );
      if (connectedColleagues.length === 0) {
        return null;
      }
      let bestBridge = null;
      for (const colleague of connectedColleagues) {
        const degreeScore = colleague.connectionDegree === 1 ? 1 : colleague.connectionDegree === 2 ? 0.7 : 0.4;
        const targetRole = targetUser.workExperience?.[0]?.title?.toLowerCase() || "";
        const colleagueRole = colleague.role.toLowerCase();
        const sameDepartment = colleague.department && targetRole.includes(colleague.department.toLowerCase());
        const roleScore = sameDepartment ? 1 : 0.5;
        const seniorityKeywords = ["senior", "lead", "principal", "director", "vp", "head"];
        const isSenior = seniorityKeywords.some((kw) => colleagueRole.includes(kw));
        const seniorityBonus = isSenior ? 0.2 : 0;
        const totalScore = degreeScore * 0.6 + roleScore * 0.3 + seniorityBonus;
        const colleagueNode = graph.getNode?.(colleague.profileId);
        const targetNode = graph.getNode?.(targetUser.id || "");
        if (colleagueNode && targetNode) {
          const path = [
            graph.getNode?.(sourceNodeId),
            colleagueNode,
            targetNode
          ].filter(Boolean);
          if (path.length === 3) {
            if (!bestBridge || totalScore > bestBridge.score) {
              bestBridge = {
                employee: colleague,
                score: totalScore,
                path
              };
            }
          }
        }
      }
      if (bestBridge && bestBridge.score >= 0.4) {
        const colleague = bestBridge.employee;
        const baseAcceptance = 0.32;
        const degreeBonus = colleague.connectionDegree === 1 ? 0.08 : colleague.connectionDegree === 2 ? 0.04 : 0;
        const estimatedAcceptance = Math.min(baseAcceptance + degreeBonus, 0.4);
        return {
          type: "company_bridge",
          confidence: bestBridge.score,
          estimatedAcceptanceRate: estimatedAcceptance,
          path: {
            nodes: bestBridge.path,
            edges: [],
            totalWeight: 0.5,
            successProbability: 0.7,
            mutualConnections: 0
          },
          reasoning: `${colleague.name} works at ${targetCompany} in ${colleague.department || "the same organization"} as ${targetUser.name}. This shared workplace creates a natural introduction path.`,
          nextSteps: [
            `Reach out to ${colleague.name} (your ${colleague.connectionDegree === 1 ? "direct connection" : colleague.connectionDegree + "nd-degree connection"})`,
            `Mention your interest in connecting with ${targetUser.name} at ${targetCompany}`,
            `Ask about ${colleague.name}'s experience working with or alongside ${targetUser.name}`,
            `Request an introduction based on shared company context`,
            colleague.department ? `Reference their shared work in ${colleague.department}` : ""
          ].filter(Boolean)
        };
      }
      return null;
    } catch (error) {
      console.error("[CompanyBridge] Strategy failed:", error);
      return null;
    }
  }
  function findNodeIdInGraph(graph, user) {
    if (user.id) {
      const node = graph.getNode?.(user.id);
      if (node) return user.id;
    }
    if (user.email) {
      const node = graph.getNode?.(user.email);
      if (node) return user.email;
    }
    if (user.id) {
      const node = graph.getNode?.(user.id);
      if (node) return user.id;
    }
    return null;
  }
  content;
  function generateIntermediaryNextSteps(intermediary, _source, target) {
    const steps = [];
    if (intermediary.direction === "outbound") {
      steps.push(
        `Connect with ${intermediary.person.name} first (if not already connected)`
      );
      steps.push(`Build relationship by engaging with their posts`);
      steps.push(
        `Ask ${intermediary.person.name} to introduce you to ${target.name}`
      );
      steps.push(
        `Alternative: Message ${target.name} mentioning ${intermediary.person.name} as a mutual connection`
      );
    } else {
      steps.push(`Reach out to ${intermediary.person.name} first`);
      steps.push(
        `Mention similarities with ${intermediary.person.name} (${(intermediary.sourceToIntermediary * 100).toFixed(0)}% match)`
      );
      steps.push(`Build relationship before asking for introduction`);
      steps.push(
        `After connection is established, ask for introduction to ${target.name}`
      );
    }
    return steps;
  }
  async function tryIntermediaryStrategy(sourceUser, targetUser, graph) {
    try {
      const sourceId = findNodeIdInGraph$2(graph, sourceUser);
      const targetId = findNodeIdInGraph$2(graph, targetUser);
      if (!sourceId) {
        throw new Error("Unable to load your profile from the network. Please ensure you are logged into LinkedIn or have completed your profile in the Resume tab.");
      }
      const sourceConnections = await graph.getConnections(sourceId);
      let targetConnections = [];
      if (targetId && graph.getNode && graph.getNode(targetId)) {
        targetConnections = await graph.getConnections(targetId);
      }
      const intermediaries = findBestIntermediaries(
        sourceUser,
        targetUser,
        sourceConnections,
        targetConnections
      );
      if (intermediaries.length > 0) {
        const bestIntermediary = intermediaries[0];
        const isLowConfidence = bestIntermediary.score <= 0.35;
        return {
          type: "intermediary",
          confidence: bestIntermediary.score,
          intermediary: bestIntermediary,
          lowConfidence: isLowConfidence,
          estimatedAcceptanceRate: bestIntermediary.estimatedAcceptance,
          reasoning: isLowConfidence ? `${bestIntermediary.reasoning} (Note: Limited similarity - consider building relationship first)` : bestIntermediary.reasoning,
          nextSteps: generateIntermediaryNextSteps(
            bestIntermediary,
            sourceUser,
            targetUser
          )
        };
      }
    } catch (error) {
      console.warn("Intermediary search failed, falling back to cold similarity:", error);
    }
    return null;
  }
  content;
  function generateColdSimilarityNextSteps(target, similarity) {
    const topSims = getTopSimilarities(similarity.breakdown);
    return [
      `Research ${target.name}'s recent posts and articles`,
      `Craft highly personalized message (200-250 characters)`,
      `Mention specific shared interests: ${topSims}`,
      `Include clear value proposition`,
      `Follow up with engagement on their content`
    ];
  }
  function generateColdOutreachNextSteps(target, similarity) {
    return [
      `Build your profile first (add relevant skills matching ${target.name}'s domain)`,
      `Engage with ${target.name}'s content regularly (comment thoughtfully, share)`,
      `Look for alternative paths via LinkedIn events, webinars, or mutual groups`,
      `Consider joining professional organizations in ${target.name}'s industry`,
      `Build credibility through content creation in shared interest areas`,
      similarity.breakdown.skills > 0.2 ? `Highlight any technical overlaps in connection message` : `Focus on value proposition rather than commonalities`
    ];
  }
  async function findFallbackCandidate(sourceUser, _targetUser, graph) {
    try {
      const sourceId = sourceUser.id || sourceUser.email || sourceUser.url;
      if (!sourceId) {
        return void 0;
      }
      const connections = await graph.getConnections(sourceId);
      if (connections && connections.length > 0) {
        const mostConnected = connections.reduce((best, current) => {
          const currentScore = (current.skills?.length || 0) + (current.workExperience?.length || 0) * 2 + (current.education?.length || 0);
          const bestScore = (best.skills?.length || 0) + (best.workExperience?.length || 0) * 2 + (best.education?.length || 0);
          return currentScore > bestScore ? current : best;
        });
        return {
          person: mostConnected,
          score: 0.15,
          // Low score to indicate fallback
          pathStrength: 0.15,
          bridgeQuality: 0,
          estimatedAcceptance: 0.12,
          reasoning: `Suggested gateway: ${mostConnected.name} (your most connected contact). Consider building relationship first.`,
          direction: "outbound",
          sourceToIntermediary: 0.5,
          // Assuming you know your own connection
          intermediaryToTarget: 0.1
          // Unknown similarity
        };
      }
    } catch (error) {
      console.warn("[Cold Strategy] Failed to find fallback candidate:", error);
    }
    return void 0;
  }
  async function tryColdSimilarityStrategy(sourceUser, targetUser, directSimilarity, graph) {
    if (directSimilarity.overall >= 0.45) {
      const acceptanceRate2 = 0.18 + (directSimilarity.overall - 0.45) * (0.07 / 0.2);
      return {
        type: "cold-similarity",
        confidence: directSimilarity.overall,
        directSimilarity,
        estimatedAcceptanceRate: acceptanceRate2,
        reasoning: `Moderate profile similarity (${(directSimilarity.overall * 100).toFixed(1)}%). Cold outreach with personalization recommended.`,
        nextSteps: generateColdSimilarityNextSteps(targetUser, directSimilarity)
      };
    }
    const fallbackCandidate = await findFallbackCandidate(sourceUser, targetUser, graph);
    const baseRate = 0.12;
    const similarityBoost = directSimilarity.overall * 0.08;
    const candidateBoost = fallbackCandidate ? 0.02 : 0;
    const acceptanceRate = baseRate + similarityBoost + candidateBoost;
    return {
      type: "cold-outreach",
      confidence: Math.max(0.1, directSimilarity.overall),
      // Minimum 10% confidence
      directSimilarity,
      candidate: fallbackCandidate,
      lowConfidence: true,
      // Flag for UI to show appropriate messaging
      estimatedAcceptanceRate: acceptanceRate,
      reasoning: fallbackCandidate ? `Limited profile overlap (${(directSimilarity.overall * 100).toFixed(1)}%). Consider indirect approach via ${fallbackCandidate.person.name} or value-first engagement.` : `Limited profile overlap (${(directSimilarity.overall * 100).toFixed(1)}%). Recommended approach: value-first cold outreach with strong personalization.`,
      nextSteps: generateColdOutreachNextSteps(targetUser, directSimilarity)
    };
  }
  content;
  async function trySemanticFallbackStrategy(sourceUser, targetUser) {
    try {
      const backendUrl = "http://localhost:3000";
      const response = await fetch(`${backendUrl}/api/find-path`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${await getAuthToken()}`
        },
        body: JSON.stringify({
          userId: sourceUser.id,
          sourceProfile: {
            id: sourceUser.id,
            name: sourceUser.name,
            headline: sourceUser.title,
            company: sourceUser.workExperience?.[0]?.company,
            role: sourceUser.workExperience?.[0]?.title,
            skills: sourceUser.skills?.map((s) => s.name),
            education: sourceUser.education?.map((e) => ({
              school: e.school,
              degree: e.degree,
              field: e.field
            }))
          },
          targetProfile: {
            id: targetUser.id,
            name: targetUser.name,
            headline: targetUser.title,
            company: targetUser.workExperience?.[0]?.company,
            role: targetUser.workExperience?.[0]?.title,
            skills: targetUser.skills?.map((s) => s.name),
            education: targetUser.education?.map((e) => ({
              school: e.school,
              degree: e.degree,
              field: e.field
            }))
          }
        })
      });
      if (!response.ok) {
        throw new Error(`Backend API error: ${response.status}`);
      }
      const data = await response.json();
      const { similarity, sharedContext, reasoning, talkingPoints } = data.data;
      const baseAcceptance = 0.15;
      const similarityBonus = similarity * 0.07;
      const estimatedAcceptance = Math.min(baseAcceptance + similarityBonus, 0.22);
      return {
        type: "semantic",
        confidence: similarity,
        estimatedAcceptanceRate: estimatedAcceptance,
        reasoning: reasoning || `No direct connection path found, but you share ${sharedContext?.length || 0} areas of professional overlap with ${targetUser.name}.`,
        nextSteps: talkingPoints || [
          "Send a personalized connection request",
          "Mention shared professional interests",
          "Reference common background or expertise areas",
          "Explain why you'd like to connect professionally",
          "Keep message concise and authentic (under 300 characters)"
        ],
        // Semantic strategy has no graph path
        lowConfidence: true
      };
    } catch (error) {
      console.error("[SemanticFallback] Backend API call failed:", error);
      return createBasicSemanticStrategy(sourceUser, targetUser);
    }
  }
  function createBasicSemanticStrategy(sourceUser, targetUser) {
    const sharedContext = [];
    const sourceSchools = new Set(sourceUser.education?.map((e) => e.school) || []);
    const targetSchools = targetUser.education?.map((e) => e.school) || [];
    const sharedSchools = targetSchools.filter((school) => sourceSchools.has(school));
    if (sharedSchools.length > 0) {
      sharedContext.push(`Both attended ${sharedSchools[0]}`);
    }
    const sourceSkills = new Set(sourceUser.skills?.map((s) => s.name.toLowerCase()) || []);
    const targetSkills = targetUser.skills?.map((s) => s.name.toLowerCase()) || [];
    const sharedSkills = targetSkills.filter((skill) => sourceSkills.has(skill));
    if (sharedSkills.length > 0) {
      const topShared = sharedSkills.slice(0, 2);
      sharedContext.push(`Shared expertise: ${topShared.join(", ")}`);
    }
    const sourceIndustry = sourceUser.workExperience?.[0]?.company;
    const targetIndustry = targetUser.workExperience?.[0]?.company;
    if (sourceIndustry && targetIndustry) {
      sharedContext.push(`Both work in professional services`);
    }
    const similarityScore = Math.min(sharedContext.length / 3, 0.7);
    const estimatedAcceptance = 0.15 + similarityScore * 0.05;
    return {
      type: "semantic",
      confidence: similarityScore,
      estimatedAcceptanceRate: estimatedAcceptance,
      reasoning: sharedContext.length > 0 ? `While you don't have a direct connection path, you share: ${sharedContext.join("; ")}` : `No direct connection path found. Consider a personalized cold outreach.`,
      nextSteps: [
        `Research ${targetUser.name}'s recent activity and posts`,
        sharedContext.length > 0 ? `Mention your shared background (${sharedContext[0]})` : "Find common ground",
        `Send a thoughtful connection request`,
        `Explain your reason for connecting`,
        `Follow up with value - share relevant content or insights`
      ],
      lowConfidence: true
    };
  }
  async function getAuthToken() {
    try {
      const result2 = await chrome.storage.local.get("authToken");
      return result2.authToken || "";
    } catch {
      return "";
    }
  }
  content;
  content;
  async function findUniversalConnection(sourceUser, targetUser, graph) {
    const mutualStrategy = await tryMutualConnectionStrategy(sourceUser, targetUser, graph);
    if (mutualStrategy) {
      return mutualStrategy;
    }
    const directSimilarity = calculateProfileSimilarity(sourceUser, targetUser);
    const directStrategy = tryDirectSimilarityStrategy(sourceUser, targetUser, directSimilarity);
    if (directStrategy) {
      return directStrategy;
    }
    const engagementStrategy = await tryEngagementBridgeStrategy(sourceUser, targetUser, graph);
    if (engagementStrategy) {
      return engagementStrategy;
    }
    const companyStrategy = await tryCompanyBridgeStrategy(sourceUser, targetUser, graph);
    if (companyStrategy) {
      return companyStrategy;
    }
    const intermediaryStrategy = await tryIntermediaryStrategy(sourceUser, targetUser, graph);
    if (intermediaryStrategy) {
      return intermediaryStrategy;
    }
    const coldStrategy = await tryColdSimilarityStrategy(sourceUser, targetUser, directSimilarity, graph);
    if (coldStrategy.lowConfidence) {
      try {
        const semanticStrategy = await trySemanticFallbackStrategy(sourceUser, targetUser);
        if (semanticStrategy.confidence > coldStrategy.confidence) {
          return semanticStrategy;
        }
      } catch (error) {
        console.log("[Pathfinder] Semantic fallback unavailable, using cold strategy");
      }
    }
    return coldStrategy;
  }
  content;
  content;
  function createGraphAdapter(networkGraph) {
    return {
      async getConnections(userId) {
        const nodes = networkGraph.getConnections(userId);
        return (nodes || []).map((node) => ({
          id: node.id,
          name: node.profile.name || "Unknown",
          email: node.id,
          location: node.profile.location || "",
          title: node.profile.headline || "",
          avatarUrl: node.profile.avatarUrl || void 0,
          url: node.id,
          workExperience: (node.profile.experience || []).map((exp) => ({
            id: `${exp.company}-${exp.title}`,
            company: exp.company || "",
            title: exp.title || "",
            startDate: "",
            endDate: "",
            location: exp.location || "",
            description: "",
            industry: "",
            achievements: [],
            skills: [],
            domains: [],
            responsibilities: []
          })),
          education: (node.profile.education || []).map((edu) => ({
            id: `${edu.school}-${edu.degree || ""}`,
            school: edu.school || "",
            degree: edu.degree || "",
            field: edu.field || "",
            startDate: "",
            endDate: null
          })),
          projects: [],
          skills: (node.profile.skills || []).filter((skill) => skill).map((skill) => ({
            name: typeof skill === "string" ? skill : skill.name,
            level: "intermediate",
            yearsOfExperience: 1,
            category: "Technical"
          })),
          metadata: {
            totalYearsExperience: 0,
            domains: [],
            seniority: "entry",
            careerStage: "professional"
          }
        }));
      },
      async bidirectionalBFS(sourceId, targetId) {
        const result2 = await networkGraph.bidirectionalBFS(sourceId, targetId);
        if (!result2) return null;
        return {
          path: result2.path.map((node) => ({
            id: node.id,
            name: node.profile.name || "Unknown",
            email: node.id,
            location: node.profile.location || "",
            title: node.profile.headline || "",
            avatarUrl: node.profile.avatarUrl || void 0,
            url: node.id,
            workExperience: [],
            education: [],
            projects: [],
            skills: [],
            metadata: {
              totalYearsExperience: 0,
              domains: [],
              seniority: "entry",
              careerStage: "professional"
            }
          })),
          probability: result2.probability,
          mutualConnections: result2.mutualConnections
        };
      },
      getNode(nodeId) {
        const node = networkGraph.getNode(nodeId);
        if (!node) return null;
        return {
          id: node.id,
          name: node.profile.name || "Unknown",
          email: node.id,
          location: node.profile.location || "",
          title: node.profile.headline || "",
          avatarUrl: node.profile.avatarUrl || void 0,
          url: node.id,
          workExperience: [],
          education: [],
          projects: [],
          skills: [],
          metadata: {
            totalYearsExperience: 0,
            domains: [],
            seniority: "entry",
            careerStage: "professional"
          }
        };
      },
      getMutualConnections(userId1, userId2) {
        const nodes = networkGraph.getMutualConnections(userId1, userId2);
        return nodes.map((node) => ({
          id: node.id,
          name: node.profile.name || "Unknown",
          email: node.id,
          location: node.profile.location || "",
          title: node.profile.headline || "",
          avatarUrl: node.profile.avatarUrl || void 0,
          url: node.id,
          workExperience: [],
          education: [],
          projects: [],
          skills: [],
          metadata: {
            totalYearsExperience: 0,
            domains: [],
            seniority: "entry",
            careerStage: "professional"
          }
        }));
      }
    };
  }
  async function ensureCurrentUserInGraph(networkGraph, currentUser) {
    const userId = currentUser.email || currentUser.id || currentUser.url || currentUser.name;
    if (!userId) {
      console.warn("[Uproot] Cannot add current user to graph: no ID available");
      return;
    }
    const currentUserNode = networkGraph.getNode(userId);
    if (!currentUserNode) {
      console.log("[Uproot] Current user not in graph, adding minimal node");
      const currentUserLinkedInProfile = {
        id: userId,
        profileUrl: userId,
        name: currentUser.name,
        headline: currentUser.title || "",
        location: currentUser.location || "",
        avatarUrl: currentUser.avatarUrl,
        photoUrl: currentUser.avatarUrl,
        currentRole: currentUser.workExperience?.[0] ? {
          title: currentUser.workExperience[0].title,
          company: currentUser.workExperience[0].company
        } : void 0,
        experience: currentUser.workExperience?.slice(0, 1).map((exp) => ({
          company: exp.company,
          title: exp.title,
          location: exp.location || ""
        })) || [],
        education: currentUser.education?.map((edu) => ({
          school: edu.school,
          degree: edu.degree,
          field: edu.field
        })) || [],
        certifications: [],
        skills: currentUser.skills?.map((s) => ({
          name: s.name,
          endorsementCount: 0,
          endorsedBy: []
        })) || [],
        connections: void 0,
        mutualConnections: [],
        recentPosts: [],
        userPosts: [],
        engagedPosts: [],
        recentActivity: [],
        scrapedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      const currentUserNetworkNode = {
        id: userId,
        profile: currentUserLinkedInProfile,
        status: "not_contacted",
        degree: 0,
        matchScore: 0
      };
      networkGraph.addNode(currentUserNetworkNode);
      await chrome.storage.local.set({ networkGraph: networkGraph.export() });
      console.log("[Uproot] Added current user to graph");
    }
  }
  async function ensureTargetInGraph(networkGraph, targetProfile) {
    const targetId = targetProfile.email || targetProfile.id || targetProfile.url || targetProfile.name;
    if (!targetId) {
      console.warn("[Uproot] Cannot add target to graph: no ID available");
      return;
    }
    const targetNode = networkGraph.getNode(targetId);
    if (!targetNode || !targetNode.profile.avatarUrl) {
      console.log("[Uproot] Target not in graph or missing avatar, adding/updating node");
      const skills = targetProfile.skills?.map((s) => typeof s === "string" ? s : s.name).filter(Boolean) || [];
      const industry = targetProfile.metadata?.domains?.[0] || targetProfile.workExperience?.[0]?.industry || "";
      const targetLinkedInProfile = {
        id: targetId,
        profileUrl: targetId,
        publicId: targetProfile.publicId || void 0,
        name: targetProfile.name,
        headline: targetProfile.title || "",
        location: targetProfile.location || "",
        industry: industry || void 0,
        avatarUrl: targetProfile.avatarUrl,
        photoUrl: targetProfile.avatarUrl,
        about: void 0,
        // Not available from current scraping
        currentRole: targetProfile.workExperience?.[0] ? {
          title: targetProfile.workExperience[0].title,
          company: targetProfile.workExperience[0].company
        } : void 0,
        experience: targetProfile.workExperience?.slice(0, 3).map((exp) => ({
          company: exp.company,
          title: exp.title,
          location: exp.location || "",
          duration: exp.startDate && exp.endDate ? `${exp.startDate} - ${exp.endDate}` : void 0
        })) || [],
        education: targetProfile.education?.slice(0, 3).map((edu) => ({
          school: edu.school,
          degree: edu.degree || void 0,
          field: edu.field || void 0
        })) || [],
        skills: skills.map((name) => ({
          name,
          endorsementCount: 0,
          endorsedBy: []
        })),
        certifications: [],
        connections: void 0,
        mutualConnections: [],
        recentPosts: [],
        userPosts: [],
        engagedPosts: [],
        recentActivity: [],
        scrapedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      const targetNetworkNode = {
        id: targetId,
        profile: targetLinkedInProfile,
        status: "not_contacted",
        degree: 1,
        matchScore: 0
      };
      networkGraph.addNode(targetNetworkNode);
      await chrome.storage.local.set({ networkGraph: networkGraph.export() });
      console.log("[Uproot] Added/updated target in graph:", {
        name: targetProfile.name,
        hasAvatar: !!targetProfile.avatarUrl,
        skillsCount: skills.length,
        experienceCount: targetLinkedInProfile.experience.length,
        educationCount: targetLinkedInProfile.education.length,
        industry: industry || "(none)"
      });
    }
  }
  async function findConnectionPath(currentUser, targetProfile, networkGraph) {
    console.log("[Uproot] Pathfinding Setup:", {
      source: {
        name: currentUser.name,
        email: currentUser.email,
        description: "YOU (logged-in user)"
      },
      target: {
        name: targetProfile.name,
        email: targetProfile.email,
        avatarUrl: targetProfile.avatarUrl,
        description: "Profile you are viewing"
      }
    });
    if (currentUser.email === targetProfile.email) {
      throw new Error(
        `You are viewing your own profile (${currentUser.name}). Please navigate to another LinkedIn profile to find connection paths.`
      );
    }
    await ensureCurrentUserInGraph(networkGraph, currentUser);
    await ensureTargetInGraph(networkGraph, targetProfile);
    const graphAdapter = createGraphAdapter(networkGraph);
    const result2 = await findUniversalConnection(
      currentUser,
      targetProfile,
      graphAdapter
    );
    return result2;
  }
  content;
  function ProfileTab({ panelWidth: _panelWidth = 400 }) {
    const pageContext = usePageContext();
    const { addPerson, addPath } = useWatchlist();
    const [isLoadingMessage, setIsLoadingMessage] = reactExports.useState(false);
    const [isAddingToWatchlist, setIsAddingToWatchlist] = reactExports.useState(false);
    const [isSavingPath, setIsSavingPath] = reactExports.useState(false);
    const [isSearchingPath, setIsSearchingPath] = reactExports.useState(false);
    const [connectionPath, setConnectionPath] = reactExports.useState(null);
    const [pathError, setPathError] = reactExports.useState(null);
    const [isDetectingUser, setIsDetectingUser] = reactExports.useState(false);
    const [isRefreshingProfile, setIsRefreshingProfile] = reactExports.useState(false);
    const profileData = pageContext.profileData;
    const name = profileData?.name || "Unknown Person";
    const headline = profileData?.headline || "";
    const profileImage = profileData?.profileImage;
    reactExports.useEffect(() => {
      const loadCachedPath = async () => {
        if (!profileData?.profileUrl) return;
        try {
          const result2 = await chrome.storage.local.get("uproot_connection_path_cache");
          const cache = result2.uproot_connection_path_cache || {};
          const cachedData = cache[profileData.profileUrl];
          if (cachedData) {
            if (cachedData.path?.type === "none") {
              console.warn("[Uproot] Invalid cached path (type: none) - removing from cache");
              delete cache[profileData.profileUrl];
              await chrome.storage.local.set({ uproot_connection_path_cache: cache });
              return;
            }
            const now = Date.now();
            const cacheAge = now - cachedData.timestamp;
            const TTL = 24 * 60 * 60 * 1e3;
            if (cacheAge < TTL) {
              console.log("[Uproot] Restored cached connection path for", profileData.name, `(cached ${Math.round(cacheAge / 1e3 / 60)} minutes ago)`);
              setConnectionPath(cachedData.path);
            } else {
              console.log("[Uproot] Cache expired for", profileData.name, "clearing...");
              delete cache[profileData.profileUrl];
              await chrome.storage.local.set({ uproot_connection_path_cache: cache });
            }
          } else {
            console.log("[Uproot] No cached path found for", profileData.name);
          }
        } catch (error) {
          console.warn("[Uproot] Failed to restore cached path:", error);
        }
      };
      loadCachedPath();
    }, [profileData?.profileUrl]);
    const handleGenerateMessage = async () => {
      setIsLoadingMessage(true);
      setTimeout(() => {
        setIsLoadingMessage(false);
        console.log("Generating message for", name);
      }, 2e3);
    };
    const handleAddToWatchlist = async () => {
      if (!profileData) {
        console.error("[Uproot] No profile data available");
        return;
      }
      setIsAddingToWatchlist(true);
      try {
        await addPerson({
          name,
          headline,
          profileUrl: profileData.profileUrl,
          profileImage
        });
        console.log("[Uproot] Added to watchlist:", name);
      } catch (error) {
        console.error("[Uproot] Failed to add to watchlist:", error);
      } finally {
        setIsAddingToWatchlist(false);
      }
    };
    const handleRefreshProfile = async () => {
      setIsRefreshingProfile(true);
      setPathError(null);
      try {
        const freshProfile = await refreshCurrentUser();
        if (!freshProfile) {
          throw new Error("Failed to refresh profile. Please ensure you are logged into LinkedIn.");
        }
        console.log("[Uproot] Profile refreshed successfully:", freshProfile.name);
        const profileUrl = `https://www.linkedin.com/in/${freshProfile.publicId || freshProfile.id || ""}`;
        const userProfile = {
          name: freshProfile.name || "LinkedIn User",
          email: profileUrl,
          location: freshProfile.location || "",
          title: freshProfile.headline || "",
          avatarUrl: freshProfile.avatarUrl,
          url: profileUrl,
          workExperience: (freshProfile.experience || []).map((exp) => ({
            id: `${exp.company}-${exp.title}`,
            company: exp.company || "",
            title: exp.title || "",
            startDate: "",
            endDate: null,
            location: exp.location || "",
            description: "",
            industry: "",
            achievements: [],
            skills: [],
            domains: [],
            responsibilities: []
          })),
          education: (freshProfile.education || []).map((edu) => ({
            id: `${edu.school}-${edu.degree || "degree"}`,
            school: edu.school || "",
            degree: edu.degree || "",
            field: edu.field || "",
            startDate: "",
            endDate: null
          })),
          projects: [],
          skills: (freshProfile.skills || []).filter((skill) => skill).map((skill) => ({
            name: typeof skill === "string" ? skill : skill.name,
            level: "intermediate",
            yearsOfExperience: 1,
            category: "other"
          })),
          metadata: {
            totalYearsExperience: 0,
            domains: [],
            seniority: "entry",
            careerStage: "professional"
          }
        };
        await chrome.storage.local.set({ userProfile });
        handleFindConnectionPath();
      } catch (error) {
        console.error("[Uproot] Error refreshing profile:", error);
        setPathError(error instanceof Error ? error.message : "Failed to refresh profile");
      } finally {
        setIsRefreshingProfile(false);
      }
    };
    const handleFindConnectionPath = async () => {
      if (!profileData) {
        setPathError("No profile loaded");
        return;
      }
      setIsSearchingPath(true);
      setIsDetectingUser(true);
      setPathError(null);
      setConnectionPath(null);
      try {
        const currentUser = await getCurrentUser();
        setIsDetectingUser(false);
        if (!currentUser) {
          throw new Error("Unable to detect your LinkedIn profile. Please ensure you are logged into LinkedIn or complete your profile in the Resume tab.");
        }
        const networkGraph = new NetworkGraph();
        const networkData = await chrome.storage.local.get(["networkGraph"]);
        if (networkData.networkGraph) {
          networkGraph.import(networkData.networkGraph);
        }
        await ensureCurrentUserInGraph(networkGraph, currentUser);
        if (networkGraph.getAllNodes().length === 0) {
          throw new Error(
            "Network graph is empty. The extension will automatically build your network as you visit LinkedIn profiles. Please visit a few LinkedIn profiles first, then try again. Tip: Visit profiles of your connections to build your network graph."
          );
        }
        console.log("[ConnectionPath] Target profile data:", {
          name: profileData.name,
          profileImage: profileData.profileImage,
          hasImage: !!profileData.profileImage,
          publicId: profileData.publicId
        });
        const targetProfile = {
          id: profileData.profileUrl,
          name: profileData.name || "Unknown",
          email: profileData.profileUrl,
          location: "",
          title: profileData.headline || "",
          avatarUrl: profileData.profileImage || void 0,
          publicId: profileData.publicId,
          url: profileData.profileUrl,
          workExperience: [],
          education: [],
          projects: [],
          skills: [],
          metadata: {
            totalYearsExperience: 0,
            domains: [],
            seniority: "entry",
            careerStage: "professional"
          }
        };
        const result2 = await findConnectionPath(currentUser, targetProfile, networkGraph);
        if (result2) {
          setConnectionPath(result2);
          console.log("[ConnectionPath] Strategy found:", {
            type: result2.type,
            confidence: result2.confidence,
            hasPath: !!result2.path,
            hasCandidate: !!result2.candidate,
            hasIntermediary: !!result2.intermediary,
            lowConfidence: result2.lowConfidence || false,
            acceptanceRate: `${(result2.estimatedAcceptanceRate * 100).toFixed(1)}%`
          });
          if (result2.type === "none") {
            console.error('[ConnectionPath] INVALID RESULT: Got type "none" - this should never happen!');
            setPathError("Internal error: Invalid connection strategy. Please report this issue.");
            return;
          }
          try {
            const cacheResult = await chrome.storage.local.get("uproot_connection_path_cache");
            const cache = cacheResult.uproot_connection_path_cache || {};
            cache[profileData.profileUrl] = {
              path: result2,
              timestamp: Date.now()
            };
            await chrome.storage.local.set({ uproot_connection_path_cache: cache });
            console.log("[Uproot] Cached connection path for", profileData.name);
          } catch (error) {
            console.warn("[Uproot] Failed to cache path:", error);
          }
        } else {
          console.error("[ConnectionPath] CRITICAL: findConnectionPath returned null - this violates the guarantee!");
          setConnectionPath(null);
          setPathError("Internal error: No connection strategy returned. Please report this issue.");
        }
      } catch (error) {
        console.error("[Uproot] Pathfinding error:", error);
        setPathError(error instanceof Error ? error.message : "Failed to find connection path");
      } finally {
        setIsSearchingPath(false);
        setIsDetectingUser(false);
      }
    };
    const handleSaveUniversalPathToWatchlist = async () => {
      if (!connectionPath || !profileData) return;
      setIsSavingPath(true);
      try {
        const pathNodes = connectionPath.path?.nodes || [];
        await addPath({
          targetName: profileData.name || "",
          targetProfileUrl: profileData.profileUrl || "",
          targetProfileImage: profileData.profileImage || null,
          targetHeadline: profileData.headline || "",
          path: pathNodes.map((node, index2) => ({
            name: node.name || "",
            profileUrl: node.url || node.id || "",
            profileImage: node.avatarUrl || null,
            degree: index2 + 1,
            connected: false
          })),
          totalSteps: pathNodes.length,
          completedSteps: 0,
          isComplete: false,
          notes: `Strategy: ${connectionPath.type}, Estimated acceptance: ${Math.round(connectionPath.estimatedAcceptanceRate * 100)}%`
        });
        console.log("[Uproot] Path saved to watchlist!");
        setPathError(null);
        setTimeout(() => {
          setIsSavingPath(false);
        }, 2e3);
      } catch (error) {
        console.error("[Uproot] Error saving to watchlist:", error);
        setPathError("Failed to save to watchlist");
        setIsSavingPath(false);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "auto"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ProfileHeader,
            {
              name,
              headline,
              profileImage: profileImage ?? void 0
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: "20px",
                display: "flex",
                flexDirection: "column",
                gap: "12px"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ActionCard$1,
                  {
                    icon: Search,
                    title: "Find Connection Path",
                    description: "Universal pathfinder - works even without mutual connections",
                    buttonText: isDetectingUser ? "Detecting your profile..." : isSearchingPath ? "Searching..." : "Find Connection Path",
                    buttonColor: "#0077B5",
                    isLoading: isSearchingPath || isDetectingUser,
                    onClick: handleFindConnectionPath
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ActionCard$1,
                  {
                    icon: MessageSquare,
                    title: "Generate Connection Message",
                    description: "AI-powered personalized introduction message",
                    buttonText: isLoadingMessage ? "Generating..." : "Generate Message",
                    buttonColor: "#30D158",
                    isLoading: isLoadingMessage,
                    onClick: handleGenerateMessage
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ActionCard$1,
                  {
                    icon: BookmarkPlus,
                    title: "Add to Watchlist",
                    description: "Track this person's activity and connection status",
                    buttonText: isAddingToWatchlist ? "Adding..." : "Add to Watchlist",
                    buttonColor: "#FF9500",
                    isLoading: isAddingToWatchlist,
                    onClick: handleAddToWatchlist
                  }
                ),
                pathError && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ErrorDisplay,
                  {
                    error: pathError,
                    isRefreshingProfile,
                    onRetry: () => {
                      setPathError(null);
                      handleFindConnectionPath();
                    },
                    onRefresh: handleRefreshProfile
                  }
                ),
                connectionPath && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ConnectionResult,
                  {
                    connectionPath,
                    onSaveToWatchlist: handleSaveUniversalPathToWatchlist,
                    isSaving: isSavingPath
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                padding: "20px",
                marginTop: "auto",
                borderTop: "1px solid rgba(0, 0, 0, 0.08)",
                backgroundColor: "rgba(0, 0, 0, 0.02)"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  style: {
                    fontSize: "12px",
                    color: "#8e8e93",
                    margin: 0,
                    textAlign: "center"
                  },
                  children: "ðŸ’¡ Tip: Use Alt+6 to quickly access Profile Actions"
                }
              )
            }
          )
        ]
      }
    );
  }
  content;
  function CompanyTab({ panelWidth: _panelWidth = 400 }) {
    const pageContext = usePageContext();
    const { addCompany } = useWatchlist();
    const [isAddingToWatchlist, setIsAddingToWatchlist] = reactExports.useState(false);
    const companyData = pageContext.companyData;
    const name = companyData?.name || "Unknown Company";
    const industry = companyData?.industry || "";
    const companyLogo = companyData?.companyLogo;
    const followerCount = companyData?.followerCount;
    const employeeCount = companyData?.employeeCount;
    const handleAddToWatchlist = async (enableJobAlerts = false) => {
      if (!companyData) {
        console.error("[Uproot] No company data available");
        return;
      }
      setIsAddingToWatchlist(true);
      try {
        await addCompany({
          name,
          industry,
          companyUrl: companyData.companyUrl,
          companyLogo,
          jobAlertEnabled: enableJobAlerts
        });
        console.log("[Uproot] Added company to watchlist:", name, { jobAlerts: enableJobAlerts });
      } catch (error) {
        console.error("[Uproot] Failed to add company to watchlist:", error);
      } finally {
        setIsAddingToWatchlist(false);
      }
    };
    const handleViewJobs = () => {
      if (companyData) {
        const jobsUrl = companyData.companyUrl.replace(/\/?$/, "/jobs/");
        window.open(jobsUrl, "_blank");
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "auto"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                padding: "20px",
                borderBottom: "1px solid rgba(0, 0, 0, 0.08)",
                backgroundColor: "rgba(0, 119, 181, 0.03)"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: "12px", marginBottom: "8px" }, children: [
                companyLogo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: companyLogo,
                    alt: name,
                    style: {
                      width: "56px",
                      height: "56px",
                      borderRadius: "12px",
                      objectFit: "contain",
                      border: "2px solid rgba(0, 119, 181, 0.2)",
                      backgroundColor: "#FFFFFF",
                      padding: "4px",
                      flexShrink: 0
                    },
                    onError: (e) => {
                      e.target.style.display = "none";
                    }
                  }
                ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      width: "56px",
                      height: "56px",
                      borderRadius: "12px",
                      background: "linear-gradient(135deg, #0077B5 0%, #00A0DC 100%)",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      color: "white",
                      fontSize: "20px",
                      fontWeight: "bold",
                      flexShrink: 0
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { size: 28, strokeWidth: 2 })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h2",
                    {
                      style: {
                        fontSize: "18px",
                        fontWeight: "600",
                        margin: "0 0 6px 0",
                        color: "#1d1d1f",
                        wordBreak: "break-word"
                      },
                      children: name
                    }
                  ),
                  industry && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "p",
                    {
                      style: {
                        fontSize: "13px",
                        color: "#6e6e73",
                        margin: "0 0 4px 0",
                        display: "flex",
                        alignItems: "flex-start",
                        gap: "6px",
                        lineHeight: "1.4",
                        wordBreak: "break-word",
                        whiteSpace: "normal"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: 14, style: { marginTop: "2px", flexShrink: 0 } }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { flex: 1 }, children: industry })
                      ]
                    }
                  ),
                  (followerCount || employeeCount) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "p",
                    {
                      style: {
                        fontSize: "12px",
                        color: "#8e8e93",
                        margin: 0
                      },
                      children: [
                        followerCount && `${followerCount} followers`,
                        followerCount && employeeCount && " ï¿½ ",
                        employeeCount && `${employeeCount} employees`
                      ]
                    }
                  )
                ] })
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: "20px",
                display: "flex",
                flexDirection: "column",
                gap: "12px"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ActionCard,
                  {
                    icon: BookmarkPlus,
                    title: "Add to Watchlist",
                    description: "Track this company and monitor their updates",
                    buttonText: isAddingToWatchlist ? "Adding..." : "Add to Watchlist",
                    buttonColor: "#FF9500",
                    isLoading: isAddingToWatchlist,
                    onClick: () => handleAddToWatchlist(false)
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ActionCard,
                  {
                    icon: Bell,
                    title: "Watch for Job Openings",
                    description: "Get notified when this company posts new jobs matching your preferences",
                    buttonText: isAddingToWatchlist ? "Adding..." : "Enable Job Alerts",
                    buttonColor: "#30D158",
                    isLoading: isAddingToWatchlist,
                    onClick: () => handleAddToWatchlist(true)
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ActionCard,
                  {
                    icon: ExternalLink,
                    title: "View Open Positions",
                    description: "Browse current job listings at this company",
                    buttonText: "View Jobs",
                    buttonColor: "#0077B5",
                    isLoading: false,
                    onClick: handleViewJobs
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                padding: "20px",
                marginTop: "auto",
                borderTop: "1px solid rgba(0, 0, 0, 0.08)",
                backgroundColor: "rgba(0, 0, 0, 0.02)"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  style: {
                    fontSize: "12px",
                    color: "#8e8e93",
                    margin: 0,
                    textAlign: "center"
                  },
                  children: "=ï¿½ Tip: Enable job alerts to get notified of new openings"
                }
              )
            }
          )
        ]
      }
    );
  }
  function ActionCard({
    icon: Icon2,
    title,
    description,
    buttonText,
    buttonColor,
    isLoading,
    onClick
  }) {
    const [isHovered, setIsHovered] = reactExports.useState(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "16px",
          borderRadius: "12px",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: "#FFFFFF",
          boxShadow: isHovered ? "0 4px 12px rgba(0, 0, 0, 0.08)" : "0 2px 4px rgba(0, 0, 0, 0.04)",
          transition: "all 200ms cubic-bezier(0.4, 0.0, 0.2, 1)",
          transform: isHovered ? "translateY(-2px)" : "translateY(0)"
        },
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: "12px", marginBottom: "12px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  width: "40px",
                  height: "40px",
                  borderRadius: "10px",
                  backgroundColor: `${buttonColor}15`,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  flexShrink: 0
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: 20, color: buttonColor, strokeWidth: 2 })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "h3",
                {
                  style: {
                    fontSize: "15px",
                    fontWeight: "600",
                    margin: "0 0 4px 0",
                    color: "#1d1d1f"
                  },
                  children: title
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  style: {
                    fontSize: "13px",
                    color: "#6e6e73",
                    margin: 0,
                    lineHeight: "1.4"
                  },
                  children: description
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick,
              disabled: isLoading,
              style: {
                width: "100%",
                padding: "10px 16px",
                backgroundColor: isLoading ? "#8e8e93" : buttonColor,
                color: "#FFFFFF",
                border: "none",
                borderRadius: "8px",
                fontSize: "14px",
                fontWeight: "600",
                cursor: isLoading ? "not-allowed" : "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "8px",
                transition: "all 150ms cubic-bezier(0.4, 0.0, 0.2, 1)",
                opacity: isLoading ? 0.7 : 1
              },
              onMouseEnter: (e) => {
                if (!isLoading) {
                  e.currentTarget.style.transform = "scale(1.02)";
                }
              },
              onMouseLeave: (e) => {
                e.currentTarget.style.transform = "scale(1)";
              },
              children: [
                isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  LoaderCircle,
                  {
                    size: 16,
                    style: {
                      animation: "spin 1s linear infinite"
                    }
                  }
                ),
                buttonText,
                /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
            @keyframes spin {
              from { transform: rotate(0deg); }
              to { transform: rotate(360deg); }
            }
          ` })
              ]
            }
          )
        ]
      }
    );
  }
  content;
  function PersonCard({ person, onRemove, onViewProfile, isRemoving }) {
    const [isHovered, setIsHovered] = reactExports.useState(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          padding: "16px",
          borderRadius: "12px",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: "#FFFFFF",
          boxShadow: isHovered ? "0 4px 12px rgba(0, 0, 0, 0.08)" : "0 2px 4px rgba(0, 0, 0, 0.04)",
          transition: "all 200ms cubic-bezier(0.4, 0.0, 0.2, 1)",
          transform: isHovered ? "translateY(-2px)" : "translateY(0)"
        },
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: "12px" }, children: [
          person.profileImage ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: person.profileImage,
              alt: person.name,
              style: {
                width: "48px",
                height: "48px",
                borderRadius: "50%",
                objectFit: "cover",
                border: "2px solid rgba(0, 119, 181, 0.2)",
                flexShrink: 0
              },
              onError: (e) => {
                e.target.style.display = "none";
              }
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                width: "48px",
                height: "48px",
                borderRadius: "50%",
                background: "linear-gradient(135deg, #0077B5 0%, #00A0DC 100%)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                color: "white",
                fontSize: "18px",
                fontWeight: "bold",
                flexShrink: 0
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 24, strokeWidth: 2 })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "h3",
              {
                style: {
                  fontSize: "15px",
                  fontWeight: "600",
                  margin: "0 0 4px 0",
                  color: "#1d1d1f",
                  wordBreak: "break-word"
                },
                children: person.name
              }
            ),
            person.headline && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "p",
              {
                style: {
                  fontSize: "13px",
                  color: "#6e6e73",
                  margin: "0 0 8px 0",
                  display: "flex",
                  alignItems: "flex-start",
                  gap: "6px",
                  lineHeight: "1.4",
                  wordBreak: "break-word",
                  whiteSpace: "normal"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: 12, style: { marginTop: "2px", flexShrink: 0 } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { flex: 1 }, children: person.headline })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginTop: "8px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: onViewProfile,
                  style: {
                    padding: "6px 12px",
                    backgroundColor: "#0077B5",
                    color: "#FFFFFF",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    transition: "all 150ms"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.backgroundColor = "#006399";
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "#0077B5";
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { size: 12 }),
                    "View Profile"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: onRemove,
                  disabled: isRemoving,
                  style: {
                    padding: "6px 12px",
                    backgroundColor: "rgba(255, 59, 48, 0.1)",
                    color: "#FF3B30",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: isRemoving ? "not-allowed" : "pointer",
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    transition: "all 150ms",
                    opacity: isRemoving ? 0.6 : 1
                  },
                  onMouseEnter: (e) => {
                    if (!isRemoving) {
                      e.currentTarget.style.backgroundColor = "rgba(255, 59, 48, 0.15)";
                    }
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "rgba(255, 59, 48, 0.1)";
                  },
                  children: [
                    isRemoving ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { size: 12, style: { animation: "spin 1s linear infinite" } }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 12 }),
                    "Remove"
                  ]
                }
              )
            ] })
          ] })
        ] })
      }
    );
  }
  content;
  function CompanyCard({ company, onRemove, onViewCompany, onToggleJobAlerts, onEditPreferences, isRemoving }) {
    const [isHovered, setIsHovered] = reactExports.useState(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          padding: "16px",
          borderRadius: "12px",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: "#FFFFFF",
          boxShadow: isHovered ? "0 4px 12px rgba(0, 0, 0, 0.08)" : "0 2px 4px rgba(0, 0, 0, 0.04)",
          transition: "all 200ms cubic-bezier(0.4, 0.0, 0.2, 1)",
          transform: isHovered ? "translateY(-2px)" : "translateY(0)"
        },
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: "12px" }, children: [
          company.companyLogo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: company.companyLogo,
              alt: company.name,
              style: {
                width: "48px",
                height: "48px",
                borderRadius: "8px",
                objectFit: "contain",
                border: "1px solid rgba(0, 0, 0, 0.08)",
                backgroundColor: "#FFFFFF",
                padding: "4px",
                flexShrink: 0
              },
              onError: (e) => {
                e.target.style.display = "none";
              }
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                width: "48px",
                height: "48px",
                borderRadius: "8px",
                background: "linear-gradient(135deg, #0077B5 0%, #00A0DC 100%)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                color: "white",
                fontSize: "18px",
                fontWeight: "bold",
                flexShrink: 0
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { size: 24, strokeWidth: 2 })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "h3",
              {
                style: {
                  fontSize: "15px",
                  fontWeight: "600",
                  margin: "0 0 4px 0",
                  color: "#1d1d1f",
                  wordBreak: "break-word"
                },
                children: company.name
              }
            ),
            company.industry && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "p",
              {
                style: {
                  fontSize: "13px",
                  color: "#6e6e73",
                  margin: "0 0 8px 0",
                  display: "flex",
                  alignItems: "flex-start",
                  gap: "6px",
                  lineHeight: "1.4",
                  wordBreak: "break-word",
                  whiteSpace: "normal"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: 12, style: { marginTop: "2px", flexShrink: 0 } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { flex: 1 }, children: company.industry })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginTop: "8px", flexWrap: "wrap" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: onViewCompany,
                  style: {
                    padding: "6px 12px",
                    backgroundColor: "#0077B5",
                    color: "#FFFFFF",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    transition: "all 150ms"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.backgroundColor = "#006399";
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "#0077B5";
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { size: 12 }),
                    "View Page"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: onToggleJobAlerts,
                  style: {
                    padding: "6px 12px",
                    backgroundColor: company.jobAlertEnabled ? "rgba(48, 209, 88, 0.1)" : "rgba(0, 119, 181, 0.1)",
                    color: company.jobAlertEnabled ? "#30D158" : "#0077B5",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    transition: "all 150ms"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.backgroundColor = company.jobAlertEnabled ? "rgba(48, 209, 88, 0.15)" : "rgba(0, 119, 181, 0.15)";
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = company.jobAlertEnabled ? "rgba(48, 209, 88, 0.1)" : "rgba(0, 119, 181, 0.1)";
                  },
                  children: [
                    company.jobAlertEnabled ? /* @__PURE__ */ jsxRuntimeExports.jsx(Bell, { size: 12 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Bell, { size: 12 }),
                    company.jobAlertEnabled ? "Alerts Active" : "Enable Alerts"
                  ]
                }
              ),
              company.jobAlertEnabled && onEditPreferences && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: onEditPreferences,
                  style: {
                    padding: "6px 12px",
                    backgroundColor: company.jobPreferences ? "rgba(255, 149, 0, 0.1)" : "rgba(142, 142, 147, 0.1)",
                    color: company.jobPreferences ? "#FF9500" : "#8e8e93",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    transition: "all 150ms"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.backgroundColor = company.jobPreferences ? "rgba(255, 149, 0, 0.15)" : "rgba(142, 142, 147, 0.15)";
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = company.jobPreferences ? "rgba(255, 149, 0, 0.1)" : "rgba(142, 142, 147, 0.1)";
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Settings, { size: 12 }),
                    company.jobPreferences ? "Custom" : "Preferences"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: onRemove,
                  disabled: isRemoving,
                  style: {
                    padding: "6px 12px",
                    backgroundColor: "rgba(255, 59, 48, 0.1)",
                    color: "#FF3B30",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: isRemoving ? "not-allowed" : "pointer",
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    transition: "all 150ms",
                    opacity: isRemoving ? 0.6 : 1
                  },
                  onMouseEnter: (e) => {
                    if (!isRemoving) {
                      e.currentTarget.style.backgroundColor = "rgba(255, 59, 48, 0.15)";
                    }
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "rgba(255, 59, 48, 0.1)";
                  },
                  children: [
                    isRemoving ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { size: 12, style: { animation: "spin 1s linear infinite" } }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 12 }),
                    "Remove"
                  ]
                }
              )
            ] })
          ] })
        ] })
      }
    );
  }
  content;
  function PathCard({ path, onRemove, onViewProfile, onMarkStepConnected, isRemoving }) {
    const [isHovered, setIsHovered] = reactExports.useState(false);
    const progressPercentage = path.totalSteps > 0 ? path.completedSteps / path.totalSteps * 100 : 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "16px",
          borderRadius: "12px",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: "#FFFFFF",
          boxShadow: isHovered ? "0 4px 12px rgba(0, 0, 0, 0.08)" : "0 2px 4px rgba(0, 0, 0, 0.04)",
          transition: "all 200ms cubic-bezier(0.4, 0.0, 0.2, 1)",
          transform: isHovered ? "translateY(-2px)" : "translateY(0)"
        },
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: "12px", marginBottom: "12px" }, children: [
            path.targetProfileImage ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: path.targetProfileImage,
                alt: path.targetName,
                style: {
                  width: "48px",
                  height: "48px",
                  borderRadius: "50%",
                  objectFit: "cover",
                  border: "2px solid rgba(0, 119, 181, 0.2)",
                  flexShrink: 0
                },
                onError: (e) => {
                  e.target.style.display = "none";
                }
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  width: "48px",
                  height: "48px",
                  borderRadius: "50%",
                  background: "linear-gradient(135deg, #0077B5 0%, #00A0DC 100%)",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  color: "white",
                  fontSize: "18px",
                  fontWeight: "bold",
                  flexShrink: 0
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 24, strokeWidth: 2 })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "h3",
                {
                  style: {
                    fontSize: "15px",
                    fontWeight: "600",
                    margin: "0 0 4px 0",
                    color: "#1d1d1f",
                    wordBreak: "break-word"
                  },
                  children: path.targetName
                }
              ),
              path.targetHeadline && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "p",
                {
                  style: {
                    fontSize: "13px",
                    color: "#6e6e73",
                    margin: "0 0 8px 0",
                    display: "flex",
                    alignItems: "flex-start",
                    gap: "6px",
                    lineHeight: "1.4",
                    wordBreak: "break-word",
                    whiteSpace: "normal"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: 12, style: { marginTop: "2px", flexShrink: 0 } }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { flex: 1 }, children: path.targetHeadline })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      flex: 1,
                      height: "6px",
                      backgroundColor: "rgba(0, 0, 0, 0.08)",
                      borderRadius: "3px",
                      overflow: "hidden"
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        style: {
                          width: `${progressPercentage}%`,
                          height: "100%",
                          backgroundColor: path.isComplete ? "#30D158" : "#0077B5",
                          transition: "width 300ms"
                        }
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: "12px", fontWeight: "600", color: "#6e6e73", minWidth: "60px", textAlign: "right" }, children: [
                  path.completedSteps,
                  "/",
                  path.totalSteps,
                  " steps"
                ] })
              ] }),
              path.isComplete && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    display: "inline-flex",
                    alignItems: "center",
                    gap: "4px",
                    padding: "4px 8px",
                    backgroundColor: "rgba(48, 209, 88, 0.1)",
                    borderRadius: "6px",
                    fontSize: "12px",
                    color: "#30D158",
                    fontWeight: "600",
                    marginBottom: "12px"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 12 }),
                    "Path Complete!"
                  ]
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: "12px", paddingLeft: "12px", borderLeft: "2px solid rgba(0, 119, 181, 0.2)" }, children: path.path.map((step, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "center",
                gap: "8px",
                padding: "6px 0",
                opacity: step.connected ? 0.6 : 1
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: () => onMarkStepConnected(path.id, index2),
                    disabled: step.connected,
                    style: {
                      width: "20px",
                      height: "20px",
                      borderRadius: "50%",
                      border: step.connected ? "none" : "2px solid rgba(0, 119, 181, 0.4)",
                      backgroundColor: step.connected ? "#30D158" : "transparent",
                      color: "white",
                      cursor: step.connected ? "default" : "pointer",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      padding: 0,
                      transition: "all 150ms",
                      flexShrink: 0
                    },
                    onMouseEnter: (e) => {
                      if (!step.connected) {
                        e.currentTarget.style.backgroundColor = "rgba(0, 119, 181, 0.1)";
                      }
                    },
                    onMouseLeave: (e) => {
                      if (!step.connected) {
                        e.currentTarget.style.backgroundColor = "transparent";
                      }
                    },
                    children: step.connected ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 12 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Circle, { size: 12 })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "13px", color: step.connected ? "#6e6e73" : "#1d1d1f" }, children: step.name }),
                step.connected && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "11px", color: "#30D158", marginLeft: "auto" }, children: "âœ“ Connected" })
              ]
            },
            index2
          )) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", flexWrap: "wrap" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: onViewProfile,
                style: {
                  padding: "6px 12px",
                  backgroundColor: "#0077B5",
                  color: "#FFFFFF",
                  border: "none",
                  borderRadius: "6px",
                  fontSize: "12px",
                  fontWeight: "600",
                  cursor: "pointer",
                  display: "flex",
                  alignItems: "center",
                  gap: "6px",
                  transition: "all 150ms"
                },
                onMouseEnter: (e) => {
                  e.currentTarget.style.backgroundColor = "#006399";
                },
                onMouseLeave: (e) => {
                  e.currentTarget.style.backgroundColor = "#0077B5";
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { size: 12 }),
                  "View Profile"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: onRemove,
                disabled: isRemoving,
                style: {
                  padding: "6px 12px",
                  backgroundColor: "rgba(255, 59, 48, 0.1)",
                  color: "#FF3B30",
                  border: "none",
                  borderRadius: "6px",
                  fontSize: "12px",
                  fontWeight: "600",
                  cursor: isRemoving ? "not-allowed" : "pointer",
                  display: "flex",
                  alignItems: "center",
                  gap: "6px",
                  transition: "all 150ms",
                  opacity: isRemoving ? 0.6 : 1
                },
                onMouseEnter: (e) => {
                  if (!isRemoving) {
                    e.currentTarget.style.backgroundColor = "rgba(255, 59, 48, 0.15)";
                  }
                },
                onMouseLeave: (e) => {
                  e.currentTarget.style.backgroundColor = "rgba(255, 59, 48, 0.1)";
                },
                children: [
                  isRemoving ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { size: 12, style: { animation: "spin 1s linear infinite" } }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 12 }),
                  "Remove"
                ]
              }
            )
          ] })
        ]
      }
    );
  }
  content;
  function TabSwitcher({ activeView, onViewChange, pathCount, peopleCount, companyCount, searchCount = 0, panelWidth = 400 }) {
    const isVeryNarrow = panelWidth < 380;
    const isNarrow = panelWidth < 450;
    const isCompact = panelWidth < 550;
    const showIcons = !isNarrow;
    const fontSize = isVeryNarrow ? "11px" : isNarrow ? "12px" : "13px";
    const padding = isVeryNarrow ? "6px 8px" : isNarrow ? "8px 10px" : isCompact ? "9px 12px" : "10px 14px";
    const gap = isVeryNarrow ? "4px" : isNarrow ? "6px" : "8px";
    const iconSize = 14;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          padding: "16px",
          borderBottom: "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: "rgba(255, 149, 0, 0.03)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => onViewChange("network"),
              style: {
                flex: 1,
                padding,
                backgroundColor: activeView === "network" ? "#0077B5" : "transparent",
                color: activeView === "network" ? "#FFFFFF" : "#6e6e73",
                border: activeView === "network" ? "none" : "1px solid rgba(0, 0, 0, 0.12)",
                borderRadius: "8px",
                fontSize,
                fontWeight: "600",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "6px",
                transition: "all 150ms"
              },
              onMouseEnter: (e) => {
                if (activeView !== "network") {
                  e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.04)";
                }
              },
              onMouseLeave: (e) => {
                if (activeView !== "network") {
                  e.currentTarget.style.backgroundColor = "transparent";
                }
              },
              children: [
                showIcons && /* @__PURE__ */ jsxRuntimeExports.jsx(GitBranch, { size: iconSize, strokeWidth: 2 }),
                "Network",
                pathCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      padding: "2px 6px",
                      backgroundColor: activeView === "network" ? "rgba(255, 255, 255, 0.25)" : "rgba(0, 0, 0, 0.08)",
                      borderRadius: "10px",
                      fontSize: "12px",
                      fontWeight: "700"
                    },
                    children: pathCount
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => onViewChange("people"),
              style: {
                flex: 1,
                padding,
                backgroundColor: activeView === "people" ? "#0077B5" : "transparent",
                color: activeView === "people" ? "#FFFFFF" : "#6e6e73",
                border: activeView === "people" ? "none" : "1px solid rgba(0, 0, 0, 0.12)",
                borderRadius: "8px",
                fontSize,
                fontWeight: "600",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "6px",
                transition: "all 150ms"
              },
              onMouseEnter: (e) => {
                if (activeView !== "people") {
                  e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.04)";
                }
              },
              onMouseLeave: (e) => {
                if (activeView !== "people") {
                  e.currentTarget.style.backgroundColor = "transparent";
                }
              },
              children: [
                showIcons && /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: iconSize, strokeWidth: 2 }),
                "People",
                peopleCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      padding: "2px 6px",
                      backgroundColor: activeView === "people" ? "rgba(255, 255, 255, 0.25)" : "rgba(0, 0, 0, 0.08)",
                      borderRadius: "10px",
                      fontSize: "12px",
                      fontWeight: "700"
                    },
                    children: peopleCount
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => onViewChange("companies"),
              style: {
                flex: 1,
                padding,
                backgroundColor: activeView === "companies" ? "#0077B5" : "transparent",
                color: activeView === "companies" ? "#FFFFFF" : "#6e6e73",
                border: activeView === "companies" ? "none" : "1px solid rgba(0, 0, 0, 0.12)",
                borderRadius: "8px",
                fontSize,
                fontWeight: "600",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "6px",
                transition: "all 150ms"
              },
              onMouseEnter: (e) => {
                if (activeView !== "companies") {
                  e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.04)";
                }
              },
              onMouseLeave: (e) => {
                if (activeView !== "companies") {
                  e.currentTarget.style.backgroundColor = "transparent";
                }
              },
              children: [
                showIcons && /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { size: iconSize, strokeWidth: 2 }),
                "Companies",
                companyCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      padding: "2px 6px",
                      backgroundColor: activeView === "companies" ? "rgba(255, 255, 255, 0.25)" : "rgba(0, 0, 0, 0.08)",
                      borderRadius: "10px",
                      fontSize: "12px",
                      fontWeight: "700"
                    },
                    children: companyCount
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => onViewChange("search"),
              style: {
                flex: 1,
                padding,
                backgroundColor: activeView === "search" ? "#0077B5" : "transparent",
                color: activeView === "search" ? "#FFFFFF" : "#6e6e73",
                border: activeView === "search" ? "none" : "1px solid rgba(0, 0, 0, 0.12)",
                borderRadius: "8px",
                fontSize,
                fontWeight: "600",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "6px",
                transition: "all 150ms"
              },
              onMouseEnter: (e) => {
                if (activeView !== "search") {
                  e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.04)";
                }
              },
              onMouseLeave: (e) => {
                if (activeView !== "search") {
                  e.currentTarget.style.backgroundColor = "transparent";
                }
              },
              children: [
                showIcons && /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { size: iconSize, strokeWidth: 2 }),
                "Search",
                searchCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      padding: "2px 6px",
                      backgroundColor: activeView === "search" ? "rgba(255, 255, 255, 0.25)" : "rgba(0, 0, 0, 0.08)",
                      borderRadius: "10px",
                      fontSize: "12px",
                      fontWeight: "700"
                    },
                    children: searchCount
                  }
                )
              ]
            }
          )
        ] })
      }
    );
  }
  content;
  function hasSearchKeywords(lower) {
    const searchKeywords = [
      // Question words (flexible for typos: "who r" also matches)
      /\bwho\s+(are|is|were|r)\b/i,
      /\bwhich\s+people/i,
      /\bwhat\s+people/i,
      // Action verbs
      /\b(show|list|find|search|display|get)\b/i,
      /\blooking\s+for/i,
      /\bshow\s+me/i,
      // Plural forms (strong signal for search)
      /\b(people|candidates|connections|folks|contacts|professionals)\b/i,
      // Job titles (plural forms - flexible for typos)
      /\b(engineers?|engneers?|designers?|managers?|recruiters?|developers?|analysts?)\b/i,
      /\bhr\s+(reps|people|managers)/i
    ];
    return searchKeywords.some((pattern) => pattern.test(lower));
  }
  function hasPathKeywords(lower) {
    const pathKeywords = [
      // Introduction keywords
      /\b(introduce|intro|introduction)\b/i,
      /\bconnect\s+me/i,
      // Path finding
      /\bpath\s+to/i,
      /\bhow\s+(can\s+i|do\s+i|to)\s+(reach|contact|get\s+to|meet)/i,
      /\bway\s+to\s+(reach|contact|meet)/i,
      // Connection actions
      /\bget\s+in\s+touch\s+with/i,
      /\bmeet\s+with/i
    ];
    return pathKeywords.some((pattern) => pattern.test(lower));
  }
  function hasMessageKeywords(lower) {
    const messageKeywords = [
      // Message verbs
      /\b(write|draft|compose|generate|create)\b/i,
      // Message nouns
      /\b(message|email|note|outreach|letter)\b/i,
      // Action context
      /\breach\s+out/i,
      /\bsend\s+(a\s+)?(message|email)/i
    ];
    return messageKeywords.some((pattern) => pattern.test(lower));
  }
  function detectProperNouns(message) {
    const words = message.split(/\s+/);
    for (let i = 1; i < words.length; i++) {
      const word = words[i];
      if (word && /^[A-Z][a-z]+/.test(word)) {
        return true;
      }
    }
    return false;
  }
  function countKeywordMatches(intentType, lower) {
    const keywords = {
      SEARCH: [
        /\bwho\b/i,
        /\bshow\b/i,
        /\blist\b/i,
        /\bfind\b/i,
        /\bsearch\b/i,
        /\bpeople\b/i,
        /\bconnections\b/i
      ],
      FIND_PATH: [
        /\bintroduce\b/i,
        /\bconnect\b/i,
        /\bpath\b/i,
        /\breach\b/i,
        /\bhow\s+to\b/i
      ],
      GENERATE_MESSAGE: [
        /\bwrite\b/i,
        /\bdraft\b/i,
        /\bmessage\b/i,
        /\bemail\b/i,
        /\boutreach\b/i
      ],
      GENERAL: [
        /\bthanks\b/i,
        /\bhello\b/i,
        /\bhelp\b/i
      ]
    };
    const intentKeywords = keywords[intentType] || [];
    return intentKeywords.filter((pattern) => pattern.test(lower)).length;
  }
  content;
  function capitalizeCompanyName(company) {
    const knownCompanies = {
      "google": "Google",
      "facebook": "Facebook",
      "meta": "Meta",
      "microsoft": "Microsoft",
      "apple": "Apple",
      "amazon": "Amazon",
      "netflix": "Netflix",
      "tesla": "Tesla",
      "ibm": "IBM",
      "salesforce": "Salesforce",
      "linkedin": "LinkedIn",
      "uber": "Uber",
      "airbnb": "Airbnb",
      "spotify": "Spotify"
    };
    const lower = company.toLowerCase();
    if (knownCompanies[lower]) {
      return knownCompanies[lower];
    }
    return company.split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ");
  }
  function capitalizeLocation(location2) {
    const knownLocations = {
      "sf": "SF",
      "san francisco": "San Francisco",
      "nyc": "NYC",
      "new york": "New York",
      "la": "LA",
      "los angeles": "Los Angeles",
      "seattle": "Seattle",
      "boston": "Boston",
      "austin": "Austin",
      "chicago": "Chicago",
      "dc": "DC",
      "washington dc": "Washington DC"
    };
    const lower = location2.toLowerCase();
    if (knownLocations[lower]) {
      return knownLocations[lower];
    }
    return location2.split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ");
  }
  content;
  function extractCompany(query) {
    const atPattern = /\bat\s+([A-Za-z0-9\s&.'-]+?)(?:\s+(?:in|with|who|that|and|or|,)|$)/i;
    let match = query.match(atPattern);
    if (match?.[1]) {
      return capitalizeCompanyName(match[1].trim());
    }
    const fromPattern = /\bfrom\s+([A-Za-z0-9\s&.'-]+?)(?:\s+(?:in|with|who|that|and|or|,)|$)/i;
    match = query.match(fromPattern);
    if (match?.[1]) {
      return capitalizeCompanyName(match[1].trim());
    }
    const worksAtPattern = /\bworks?\s+at\s+([A-Za-z0-9\s&.'-]+?)(?:\s+(?:in|with|who|that|and|or|,)|$)/i;
    match = query.match(worksAtPattern);
    if (match?.[1]) {
      return capitalizeCompanyName(match[1].trim());
    }
    return null;
  }
  function extractLocation$1(query) {
    const inPattern = /\bin\s+([A-Za-z\s.-]+?)(?:\s+(?:at|with|who|that|and|or|,)|$)/i;
    let match = query.match(inPattern);
    if (match?.[1]) {
      return capitalizeLocation(match[1].trim());
    }
    const basedPattern = /\bbased\s+in\s+([A-Za-z\s.-]+?)(?:\s+(?:at|with|who|that|and|or|,)|$)/i;
    match = query.match(basedPattern);
    if (match?.[1]) {
      return capitalizeLocation(match[1].trim());
    }
    const locatedPattern = /\blocated\s+in\s+([A-Za-z\s.-]+?)(?:\s+(?:at|with|who|that|and|or|,)|$)/i;
    match = query.match(locatedPattern);
    if (match?.[1]) {
      return capitalizeLocation(match[1].trim());
    }
    return null;
  }
  function extractYearsExperience(query) {
    const plusPattern = /(\d+)\s*\+\s*years?/i;
    let match = query.match(plusPattern);
    if (match?.[1]) {
      return { min: parseInt(match[1], 10) };
    }
    const rangePattern = /(\d+)\s*(?:-|to)\s*(\d+)\s*years?/i;
    match = query.match(rangePattern);
    if (match?.[1] && match?.[2]) {
      return {
        min: parseInt(match[1], 10),
        max: parseInt(match[2], 10)
      };
    }
    const exactPattern = /(\d+)\s*years?(?:\s+(?:of\s+)?experience)?/i;
    match = query.match(exactPattern);
    if (match?.[1]) {
      const years = parseInt(match[1], 10);
      return { min: years, max: years };
    }
    return null;
  }
  function extractConnectionDegree(query) {
    const degrees = [];
    if (/\b1st\s+degree/i.test(query) || /\bfirst\s+degree/i.test(query)) {
      degrees.push(1);
    }
    if (/\b2nd\s+degree/i.test(query) || /\bsecond\s+degree/i.test(query)) {
      degrees.push(2);
    }
    if (/\b3rd\s+degree/i.test(query) || /\bthird\s+degree/i.test(query)) {
      degrees.push(3);
    }
    if (/\b1st\s+connections?/i.test(query)) {
      degrees.push(1);
    }
    if (/\b2nd\s+connections?/i.test(query)) {
      degrees.push(2);
    }
    if (/\b3rd\s+connections?/i.test(query)) {
      degrees.push(3);
    }
    if (/\bdirect\s+connections?/i.test(query)) {
      degrees.push(1);
    }
    return degrees.length > 0 ? degrees : null;
  }
  function extractRole(query) {
    const seniorityLevels = [
      "senior",
      "sr",
      "junior",
      "jr",
      "lead",
      "principal",
      "staff",
      "entry level",
      "mid level",
      "executive",
      "chief",
      "head of",
      "vp",
      "director",
      "manager",
      "associate"
    ];
    for (const level of seniorityLevels) {
      const pattern = new RegExp(`\\b${level}\\b`, "i");
      if (pattern.test(query)) {
        return level.toLowerCase();
      }
    }
    return null;
  }
  function buildCleanQuery(query, extracted) {
    let clean = query;
    if (extracted.company) {
      clean = clean.replace(/\bat\s+[A-Za-z0-9\s&.'-]+?(?=\s+(?:in|with|who|that|and|or|,)|$)/gi, "");
      clean = clean.replace(/\bfrom\s+[A-Za-z0-9\s&.'-]+?(?=\s+(?:in|with|who|that|and|or|,)|$)/gi, "");
      clean = clean.replace(/\bworks?\s+at\s+[A-Za-z0-9\s&.'-]+?(?=\s+(?:in|with|who|that|and|or|,)|$)/gi, "");
    }
    if (extracted.location) {
      clean = clean.replace(/\bin\s+[A-Za-z\s.-]+?(?=\s+(?:at|with|who|that|and|or|,)|$)/gi, "");
      clean = clean.replace(/\bbased\s+in\s+[A-Za-z\s.-]+?(?=\s+(?:at|with|who|that|and|or|,)|$)/gi, "");
      clean = clean.replace(/\blocated\s+in\s+[A-Za-z\s.-]+?(?=\s+(?:at|with|who|that|and|or|,)|$)/gi, "");
    }
    clean = clean.replace(/\bwith\s+\d+\s*\+\s*years?/gi, "");
    clean = clean.replace(/\bwith\s+\d+\s*(?:-|to)\s*\d+\s*years?/gi, "");
    clean = clean.replace(/\bwith\s+\d+\s*years?/gi, "");
    clean = clean.replace(/\d+\s*\+\s*years?/gi, "");
    clean = clean.replace(/\d+\s*(?:-|to)\s*\d+\s*years?/gi, "");
    clean = clean.replace(/\d+\s*years?\s*(?:of\s+)?(?:experience)?/gi, "");
    clean = clean.replace(/\b(?:1st|2nd|3rd|first|second|third)\s+degree\s+connections?/gi, "");
    clean = clean.replace(/\b(?:1st|2nd|3rd|first|second|third)\s+(?:degree|connections?)/gi, "");
    clean = clean.replace(/\bdirect\s+connections?/gi, "");
    if (extracted.role) {
      const rolePattern = new RegExp(`\\b${extracted.role}\\b`, "gi");
      clean = clean.replace(rolePattern, "");
    }
    clean = clean.replace(/\s+/g, " ").trim();
    clean = clean.replace(/^(?:find|show|get|list|search|looking for)\s+/i, "");
    clean = clean.replace(/\s+(?:who|that|with)$/i, "");
    return clean;
  }
  content;
  function parseQuery(input) {
    const query = input.trim().toLowerCase();
    const filters = {};
    const company = extractCompany(query);
    if (company) {
      filters.company = company;
    }
    const location2 = extractLocation$1(query);
    if (location2) {
      filters.location = location2;
    }
    const yearsExperience = extractYearsExperience(query);
    if (yearsExperience) {
      filters.yearsExperience = yearsExperience;
    }
    const connectionDegree = extractConnectionDegree(query);
    if (connectionDegree) {
      filters.connectionDegree = connectionDegree;
    }
    const role = extractRole(query);
    if (role) {
      filters.role = role;
    }
    const cleanQuery = buildCleanQuery(query, {
      company,
      location: location2,
      role
    });
    return {
      query: cleanQuery,
      filters: Object.keys(filters).length > 0 ? filters : void 0
    };
  }
  content;
  async function extractEntities(intentType, message) {
    switch (intentType) {
      case "SEARCH":
        return extractSearchEntities(message);
      case "FIND_PATH":
        return extractPathEntities(message);
      case "GENERATE_MESSAGE":
        return extractMessageEntities(message);
      case "GENERAL":
        return extractGeneralEntities(message);
      default:
        return {};
    }
  }
  function extractSearchEntities(message) {
    const cleanMessage = message.replace(/[?!.]+$/, "");
    const parsed = parseQuery(cleanMessage);
    return {
      query: parsed.query || void 0,
      company: parsed.filters?.company,
      role: parsed.filters?.role,
      location: parsed.filters?.location,
      connectionDegree: parsed.filters?.connectionDegree
    };
  }
  function extractPathEntities(message) {
    const entities = {};
    const properNouns = extractProperNouns(message);
    if (properNouns.length > 0) {
      entities.target = properNouns.join(" and ");
    }
    const cleanMessage = message.replace(/[?!.]+$/, "");
    const parsed = parseQuery(cleanMessage);
    if (parsed.filters?.company) {
      entities.targetCompany = parsed.filters.company;
    }
    return entities;
  }
  function extractMessageEntities(message) {
    const entities = {};
    const toPattern = /(?:to|for)\s+([A-Z][a-z]+(?: [A-Z][a-z]+)*)/i;
    const toMatch = message.match(toPattern);
    if (toMatch?.[1]) {
      entities.target = toMatch[1];
    }
    const contextPattern = /(first|second|third|last)\s+(result|person|candidate)/i;
    const contextMatch = message.match(contextPattern);
    if (contextMatch?.[0]) {
      entities.contextReference = contextMatch[0];
    }
    if (!entities.target) {
      const properNouns = extractProperNouns(message);
      if (properNouns.length > 0) {
        entities.target = properNouns.join(" and ");
      }
    }
    return entities;
  }
  function extractGeneralEntities(message) {
    const entities = {};
    const contextPatterns = [
      /(first|second|third|last)\s+(result|person|candidate|one)/i,
      /\b(that|this|them|it)\b/i,
      /\btell\s+me\s+more\s+about\s+(that|this|them|it)/i
    ];
    for (const pattern of contextPatterns) {
      const match = message.match(pattern);
      if (match?.[0]) {
        entities.contextReference = match[0];
        break;
      }
    }
    return entities;
  }
  function extractProperNouns(message) {
    const properNouns = [];
    const words = message.split(/\s+/);
    let currentName = [];
    const skipWords = [
      "i",
      "draft",
      "write",
      "compose",
      "generate",
      "create",
      "help",
      "show",
      "find",
      "list",
      "monday",
      "tuesday",
      "wednesday",
      "thursday",
      "friday",
      "saturday",
      "sunday",
      "january",
      "february",
      "march",
      "april",
      "may",
      "june",
      "july",
      "august",
      "september",
      "october",
      "november",
      "december"
    ];
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      if (word && /^[A-Z][a-z]+/.test(word)) {
        const lower = word.toLowerCase();
        if (!skipWords.includes(lower)) {
          currentName.push(word);
        }
      } else {
        if (currentName.length > 0) {
          properNouns.push(currentName.join(" "));
          currentName = [];
        }
      }
    }
    if (currentName.length > 0) {
      properNouns.push(currentName.join(" "));
    }
    return properNouns;
  }
  content;
  function calculateConfidence(intentType, keywordMatches, hasEntities) {
    let confidence = 0.5 + keywordMatches * 0.1;
    if (hasEntities) {
      confidence += 0.2;
    }
    if (intentType === "GENERAL" && keywordMatches === 0) {
      confidence = 0.4;
    }
    if (Math.abs(confidence - 0.7) < 0.01) {
      confidence += 0.05;
    }
    return Math.min(confidence, 0.95);
  }
  function generateReasoning$1(intentType, entities, confidence) {
    const reasons = [];
    switch (intentType) {
      case "SEARCH":
        reasons.push("Detected search intent");
        if (entities.query) reasons.push(`query: "${entities.query}"`);
        if (entities.company) reasons.push(`company: ${entities.company}`);
        if (entities.role) reasons.push(`role: ${entities.role}`);
        if (entities.location) reasons.push(`location: ${entities.location}`);
        if (entities.connectionDegree) reasons.push(`degrees: ${entities.connectionDegree.join(", ")}`);
        break;
      case "FIND_PATH":
        reasons.push("Detected path-finding intent");
        if (entities.target) reasons.push(`target: ${entities.target}`);
        if (entities.targetCompany) reasons.push(`company: ${entities.targetCompany}`);
        if (!entities.target) reasons.push("(no specific person identified)");
        break;
      case "GENERATE_MESSAGE": {
        reasons.push("Detected message generation intent");
        const skipTargets = ["draft", "write", "compose", "generate", "create"];
        if (entities.target && !skipTargets.includes(entities.target.toLowerCase())) {
          reasons.push(`recipient: ${entities.target}`);
        } else if (entities.contextReference) {
          reasons.push(`context: ${entities.contextReference}`);
        } else {
          reasons.push("no recipient specified");
        }
        break;
      }
      case "GENERAL":
        reasons.push("General query or acknowledgment");
        if (entities.contextReference) reasons.push(`reference: ${entities.contextReference}`);
        break;
    }
    const confidenceLabel = confidence >= 0.8 ? "high" : confidence >= 0.6 ? "medium" : "low";
    reasons.push(`confidence: ${confidenceLabel} (${confidence.toFixed(2)})`);
    return reasons.join(", ");
  }
  content;
  async function classifyIntent(message) {
    const trimmed = message.trim();
    if (!trimmed) {
      return {
        type: "GENERAL",
        confidence: 0.95,
        entities: {},
        reasoning: "Empty message",
        rawMessage: message
      };
    }
    const lower = trimmed.toLowerCase();
    const intentType = classifyIntentType(lower, trimmed);
    const entities = await extractEntities(intentType, trimmed);
    const keywordMatches = countKeywordMatches(intentType, lower);
    const hasEntities = Object.keys(entities).length > 0;
    const confidence = calculateConfidence(intentType, keywordMatches, hasEntities);
    const reasoning = generateReasoning$1(intentType, entities, confidence);
    return {
      type: intentType,
      confidence,
      entities,
      reasoning,
      rawMessage: message
    };
  }
  function classifyIntentType(lower, original) {
    if (hasMessageKeywords(lower)) {
      return "GENERATE_MESSAGE";
    }
    const hasProperNouns = detectProperNouns(original);
    if (hasProperNouns && hasPathKeywords(lower)) {
      return "FIND_PATH";
    }
    if (hasSearchKeywords(lower)) {
      return "SEARCH";
    }
    if (hasPathKeywords(lower)) {
      return "FIND_PATH";
    }
    return "GENERAL";
  }
  content;
  function calculateMatchScore$1(node, query, _filters) {
    let score = 0;
    const connectionWeight = node.degree === 1 ? 40 : node.degree === 2 ? 30 : 20;
    score += connectionWeight;
    const keywordWeight = calculateKeywordScore(node, query);
    score += keywordWeight * 0.3;
    const completenessWeight = calculateCompletenessScore(node);
    score += completenessWeight * 0.2;
    const activityWeight = node.activityScore || 0;
    score += activityWeight * 0.1;
    if (node.matchScore) {
      score += node.matchScore * 0.1;
    }
    return Math.min(Math.round(score), 100);
  }
  function calculateKeywordScore(node, query) {
    if (!query) return 0;
    const queryLower = query.toLowerCase();
    let score = 0;
    let matches = 0;
    if (node.profile.name.toLowerCase() === queryLower) {
      return 100;
    }
    if (node.profile.name.toLowerCase().includes(queryLower)) {
      score += 75;
      matches++;
    }
    if (node.profile.headline?.toLowerCase().includes(queryLower)) {
      score += 50;
      matches++;
    }
    const company = extractCurrentCompany(node);
    if (company?.toLowerCase().includes(queryLower)) {
      score += 40;
      matches++;
    }
    const role = extractCurrentRole(node);
    if (role?.toLowerCase().includes(queryLower)) {
      score += 40;
      matches++;
    }
    const skillMatches = node.profile.skills.filter(
      (skill) => skill.name.toLowerCase().includes(queryLower)
    );
    score += skillMatches.length * 20;
    matches += skillMatches.length;
    return matches > 1 ? Math.min(Math.round(score / matches), 100) : Math.min(score, 100);
  }
  function calculateCompletenessScore(node) {
    let score = 0;
    if (node.profile.name) score += 10;
    if (node.profile.headline) score += 15;
    if (node.profile.location) score += 10;
    if (node.profile.about) score += 15;
    if (node.profile.avatarUrl) score += 5;
    if (node.profile.experience.length > 0) score += 20;
    if (node.profile.education.length > 0) score += 10;
    if (node.profile.skills.length > 0) score += 15;
    return Math.min(score, 100);
  }
  function extractCurrentCompany(node) {
    if (node.profile.experience.length > 0) {
      return node.profile.experience[0]?.company;
    }
    return void 0;
  }
  function extractCurrentRole(node) {
    if (node.profile.experience.length > 0) {
      return node.profile.experience[0]?.title;
    }
    return node.profile.headline;
  }
  function calculateExperienceYears(node) {
    return node.profile.experience.length;
  }
  content;
  function matchesFilters(node, query, filters) {
    const queryLower = query.toLowerCase();
    const keywordMatch = !query || // Empty query matches all
    node.profile.name.toLowerCase().includes(queryLower) || node.profile.headline?.toLowerCase().includes(queryLower) || extractCurrentCompany(node)?.toLowerCase().includes(queryLower) || extractCurrentRole(node)?.toLowerCase().includes(queryLower) || node.profile.skills.some((skill) => skill.name.toLowerCase().includes(queryLower));
    if (!keywordMatch) {
      return false;
    }
    if (filters?.company) {
      const currentCompany = extractCurrentCompany(node);
      if (!currentCompany || !currentCompany.toLowerCase().includes(filters.company.toLowerCase())) {
        return false;
      }
    }
    if (filters?.location) {
      if (!node.profile.location || !node.profile.location.toLowerCase().includes(filters.location.toLowerCase())) {
        return false;
      }
    }
    if (filters?.role) {
      const currentRole = extractCurrentRole(node);
      if (!currentRole || !currentRole.toLowerCase().includes(filters.role.toLowerCase())) {
        return false;
      }
    }
    if (filters?.yearsExperience) {
      const totalYears = calculateExperienceYears(node);
      if (filters.yearsExperience.min && totalYears < filters.yearsExperience.min) {
        return false;
      }
      if (filters.yearsExperience.max && totalYears > filters.yearsExperience.max) {
        return false;
      }
    }
    return true;
  }
  function generateReasoning(node, query, filters) {
    const reasons = [];
    const degreeText = node.degree === 1 ? "1st-degree connection" : node.degree === 2 ? "2nd-degree connection" : "3rd-degree connection";
    reasons.push(degreeText);
    if (query) {
      const queryLower = query.toLowerCase();
      if (node.profile.name.toLowerCase().includes(queryLower)) {
        reasons.push("name match");
      }
      if (node.profile.headline?.toLowerCase().includes(queryLower)) {
        reasons.push("headline match");
      }
      const company = extractCurrentCompany(node);
      if (company?.toLowerCase().includes(queryLower)) {
        reasons.push(`works at ${company}`);
      }
    }
    if (filters?.company) {
      reasons.push(`at ${filters.company}`);
    }
    if (filters?.location) {
      reasons.push(`in ${filters.location}`);
    }
    if (filters?.role) {
      reasons.push(`${filters.role} role`);
    }
    if (node.profile.experience.length > 0) {
      reasons.push(`${node.profile.experience.length} experiences`);
    }
    if (node.profile.mutualConnections.length > 0) {
      reasons.push(`${node.profile.mutualConnections.length} mutual connections`);
    }
    return reasons.join(", ");
  }
  content;
  async function searchGraph(searchQuery) {
    const { query, filters } = searchQuery;
    try {
      let collection = networkDB.nodes.toCollection();
      if (filters?.connectionDegree && filters.connectionDegree.length > 0) {
        collection = collection.filter(
          (node) => filters.connectionDegree.includes(node.degree)
        );
      }
      const allNodes = await collection.toArray();
      const matchedNodes = allNodes.filter((node) => matchesFilters(node, query, filters));
      const results = matchedNodes.map((node) => ({
        profileId: node.id,
        name: node.profile.name,
        headline: node.profile.headline,
        company: extractCurrentCompany(node),
        role: extractCurrentRole(node),
        connectionDegree: node.degree,
        matchScore: calculateMatchScore$1(node, query, filters),
        pathAvailable: node.degree <= 3,
        // Assume path exists for 1st/2nd/3rd degree
        reasoning: generateReasoning(node, query, filters)
      }));
      results.sort((a, b) => {
        if (b.matchScore !== a.matchScore) {
          return b.matchScore - a.matchScore;
        }
        return a.connectionDegree - b.connectionDegree;
      });
      return results.slice(0, 50);
    } catch (error) {
      console.error("[GraphQuery] Failed to search graph:", error);
      return [];
    }
  }
  content;
  function buildCriteriaString(entities) {
    const parts = [];
    if (entities.role) parts.push(entities.role);
    if (entities.query) parts.push(entities.query);
    if (entities.company) parts.push(`at ${entities.company}`);
    if (entities.location) parts.push(`in ${entities.location}`);
    if (entities.connectionDegree) {
      const degrees = entities.connectionDegree.map((d) => `${d}${getDegreeOrdinal(d)}`).join("/");
      parts.push(`(${degrees} degree)`);
    }
    return parts.join(" ") || "your criteria";
  }
  function getDegreeOrdinal(degree) {
    return degree === 1 ? "st" : degree === 2 ? "nd" : "rd";
  }
  function getDegreeLabel(degree) {
    return degree === 1 ? "st degree" : degree === 2 ? "nd degree" : "rd degree";
  }
  async function findUserByName(name, graph) {
    if (!name) return null;
    const nameLower = name.toLowerCase();
    for (const [, node] of Object.entries(graph)) {
      if (node?.profile?.name?.toLowerCase().includes(nameLower)) {
        return node.profile;
      }
    }
    return null;
  }
  function createMessage(content2) {
    return {
      id: crypto.randomUUID(),
      role: "assistant",
      content: content2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  content;
  function formatSearchResponse(results, intent) {
    const count = results.length;
    let content2;
    if (count === 0) {
      const criteria = buildCriteriaString(intent.entities);
      content2 = `I couldn't find anyone matching ${criteria} in your network.

Tips:
â€¢ Try removing some filters
â€¢ Search for a broader role or company
â€¢ Check if you have 2nd or 3rd degree connections`;
    } else if (count === 1) {
      const person = results[0];
      const headline = person.headline ? `, ${person.headline}` : "";
      const company = person.company ? ` at ${person.company}` : "";
      content2 = `I found **${person.name}**${headline}${company}.

â€¢ Connection degree: ${person.connectionDegree}${getDegreeLabel(person.connectionDegree)}
â€¢ Match score: ${person.matchScore}%

Would you like me to find the best path to connect with them?`;
    } else if (count <= 5) {
      const names = results.map((r2) => `â€¢ ${r2.name} (${r2.connectionDegree}${getDegreeLabel(r2.connectionDegree)}${r2.company ? ` at ${r2.company}` : ""})`).join("\n");
      content2 = `I found ${count} people matching your search:

${names}

Would you like details on any of them or help connecting?`;
    } else {
      const topNames = results.slice(0, 5).map((r2) => `â€¢ ${r2.name} (${r2.connectionDegree}${getDegreeLabel(r2.connectionDegree)}${r2.company ? ` at ${r2.company}` : ""})`).join("\n");
      content2 = `I found **${count} professionals** matching your search! Here are the top 5:

${topNames}

(Showing top 5 of ${count} results. Ask me for more details!)`;
    }
    return {
      id: crypto.randomUUID(),
      role: "assistant",
      content: content2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      metadata: {
        searchResults: results.slice(0, 20)
        // Limit metadata size
      }
    };
  }
  function formatPathResponse(strategy, targetUser) {
    let content2;
    switch (strategy.type) {
      case "mutual":
        content2 = formatMutualPathResponse(strategy, targetUser);
        break;
      case "direct-similarity":
        content2 = formatDirectSimilarityResponse(strategy, targetUser);
        break;
      case "engagement_bridge":
        content2 = formatEngagementBridgeResponse(strategy, targetUser);
        break;
      case "company_bridge":
        content2 = formatCompanyBridgeResponse(strategy, targetUser);
        break;
      case "intermediary":
        content2 = formatIntermediaryResponse(strategy, targetUser);
        break;
      case "cold-similarity":
      case "cold-outreach":
        content2 = formatColdOutreachResponse(strategy, targetUser);
        break;
      case "semantic":
        content2 = formatSemanticFallbackResponse(strategy, targetUser);
        break;
      default:
        content2 = `Found a path to ${targetUser.name}. ${strategy.reasoning}`;
    }
    const acceptanceRate = (strategy.estimatedAcceptanceRate * 100).toFixed(0);
    content2 += `

**Estimated acceptance rate:** ${acceptanceRate}%

**Next steps:**
${strategy.nextSteps.map((step) => `â€¢ ${step}`).join("\n")}`;
    return {
      id: crypto.randomUUID(),
      role: "assistant",
      content: content2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      metadata: {
        paths: [strategy]
      }
    };
  }
  function formatMutualPathResponse(strategy, targetUser) {
    if (!strategy.path) {
      return `Great news! You can reach **${targetUser.name}** through mutual connections.`;
    }
    const hopCount = strategy.path.nodes.length - 2;
    const mutualCount = strategy.path.mutualConnections;
    if (hopCount === 1) {
      const intermediary = strategy.path.nodes[1];
      return `Great news! You can reach **${targetUser.name}** through **${intermediary.name}**, who is connected to both of you.

You share ${mutualCount} mutual connection${mutualCount > 1 ? "s" : ""} with ${targetUser.name}.`;
    } else {
      const intermediaries = strategy.path.nodes.slice(1, -1).map((n) => n.name).join(" â†’ ");
      return `I found a path to **${targetUser.name}** through ${hopCount} people:

${intermediaries}

This path has ${mutualCount} mutual connection${mutualCount > 1 ? "s" : ""} and a ${(strategy.path.successProbability * 100).toFixed(0)}% success probability.`;
    }
  }
  function formatDirectSimilarityResponse(strategy, targetUser) {
    if (!strategy.directSimilarity) {
      return `You have high profile similarity with **${targetUser.name}**. Consider sending a direct connection request.`;
    }
    const similarity = (strategy.directSimilarity.overall * 100).toFixed(0);
    const commonalities = [];
    if (strategy.directSimilarity.breakdown.industry > 0.5) {
      commonalities.push("same industry");
    }
    if (strategy.directSimilarity.breakdown.skills > 0.3) {
      commonalities.push("similar skills");
    }
    if (strategy.directSimilarity.breakdown.companies > 0.5) {
      commonalities.push("overlapping company experience");
    }
    if (strategy.directSimilarity.breakdown.education > 0.5) {
      commonalities.push("shared educational background");
    }
    const commonString = commonalities.length > 0 ? ` You share: ${commonalities.join(", ")}.` : "";
    return `You have **${similarity}% profile similarity** with **${targetUser.name}**.${commonString}

Consider sending a direct connection request highlighting your common background!`;
  }
  function formatEngagementBridgeResponse(strategy, targetUser) {
    if (!strategy.intermediary) {
      return `I found a path to **${targetUser.name}** through people who engage with them on LinkedIn.`;
    }
    return `I found **${strategy.intermediary.person.name}** who actively engages with **${targetUser.name}**'s content.

${strategy.intermediary.person.name} can introduce you based on their existing relationship (engagement score: ${(strategy.intermediary.score * 100).toFixed(0)}%).`;
  }
  function formatCompanyBridgeResponse(strategy, targetUser) {
    if (!strategy.intermediary) {
      return `I found a path to **${targetUser.name}** through colleagues at their company.`;
    }
    const currentCompany = targetUser.workExperience?.[0]?.company || "their company";
    return `I found **${strategy.intermediary.person.name}** who works at ${currentCompany} with **${targetUser.name}**.

They can provide a warm introduction as colleagues (connection strength: ${(strategy.intermediary.score * 100).toFixed(0)}%).`;
  }
  function formatIntermediaryResponse(strategy, targetUser) {
    if (!strategy.intermediary) {
      return `I found an intermediary who can bridge you to **${targetUser.name}**.`;
    }
    const { person, sourceToIntermediary, intermediaryToTarget } = strategy.intermediary;
    return `I found **${person.name}** who can bridge you to **${targetUser.name}**.

â€¢ Your similarity with ${person.name}: ${(sourceToIntermediary * 100).toFixed(0)}%
â€¢ ${person.name}'s similarity with ${targetUser.name}: ${(intermediaryToTarget * 100).toFixed(0)}%

They're a strong intermediary with connections to both of you.`;
  }
  function formatColdOutreachResponse(strategy, targetUser) {
    const hasCandidate = strategy.candidate;
    if (!hasCandidate) {
      return `No direct path found to **${targetUser.name}**. I recommend a cold outreach strategy with a personalized message highlighting shared interests or background.`;
    }
    return `No direct path found to **${targetUser.name}**, but I found **${strategy.candidate.person.name}** who might help.

Alternatively, consider a direct cold outreach to ${targetUser.name} with a highly personalized message emphasizing any shared background or interests.`;
  }
  function formatSemanticFallbackResponse(strategy, targetUser) {
    return `Based on AI-powered analysis, I suggest reaching out to **${targetUser.name}** with a personalized message.

${strategy.reasoning}`;
  }
  content;
  async function handleSearchIntent(intent, graph) {
    if (!graph) {
      return createMessage(
        "I need access to your network graph to search. Please make sure your LinkedIn data is loaded."
      );
    }
    const searchQuery = {
      query: intent.entities.query || "",
      filters: {
        company: intent.entities.company,
        role: intent.entities.role,
        location: intent.entities.location,
        connectionDegree: intent.entities.connectionDegree
      }
    };
    const results = await searchGraph(searchQuery);
    return formatSearchResponse(results, intent);
  }
  async function handleFindPathIntent(intent, graph, sourceUser) {
    if (!graph) {
      return createMessage(
        "I need access to your network graph to find connection paths. Please make sure your LinkedIn data is loaded."
      );
    }
    if (!sourceUser) {
      return createMessage(
        "I need your profile information to find connection paths. Please make sure you're logged in."
      );
    }
    const targetUser = await findUserByName(intent.entities.target, graph);
    if (!targetUser) {
      const targetName = intent.entities.target || "this person";
      return createMessage(
        `I couldn't find "${targetName}" in your network. Would you like me to search for people with a similar name or company?`
      );
    }
    const strategy = await findUniversalConnection(sourceUser, targetUser, graph);
    return formatPathResponse(strategy, targetUser);
  }
  function handleGenerateMessageIntent(intent) {
    const target = intent.entities.target || "this person";
    return createMessage(
      `Message generation is coming in Week 4! For now, here's a template you can use to reach out to ${target}:

"Hi [Name],

I noticed we share [common background/interest]. I'd love to connect and learn more about your work at [Company].

Best regards,
[Your Name]"

Tip: Personalize the message by mentioning specific shared experiences or interests!`
    );
  }
  function handleGeneralIntent(intent) {
    const lower = intent.rawMessage.toLowerCase();
    if (/\b(hello|hi|hey|greetings)\b/i.test(lower)) {
      return createMessage(
        "Hello! I can help you find people in your LinkedIn network and discover connection paths. Try asking me:\nâ€¢ 'Who are the engineers at Google?'\nâ€¢ 'How can I reach John Doe?'\nâ€¢ 'Find HR reps at Netflix'"
      );
    }
    if (/\b(thanks|thank you|thx|appreciated)\b/i.test(lower)) {
      return createMessage(
        "You're welcome! Let me know if you need help finding anyone else in your network."
      );
    }
    if (/\b(help|what can you do|how do you work|capabilities)\b/i.test(lower)) {
      return createMessage(
        `I can help you with:

**Search your network**
â€¢ "Find product managers at Meta"
â€¢ "Show me 2nd degree connections at Netflix"
â€¢ "Who are the senior engineers in SF?"

**Discover connection paths**
â€¢ "How can I reach Jane Smith?"
â€¢ "Find the best path to John Doe"
â€¢ "Introduce me to someone at Google"

**Draft outreach messages** (coming soon!)
â€¢ "Write a message to Jane Smith"
â€¢ "Draft an intro email to John Doe"

Ask me anything about your LinkedIn network!`
      );
    }
    if (/\btell\s+me\s+more/i.test(lower) || intent.entities.contextReference) {
      return createMessage(
        "I'd love to help! Could you ask a more specific question? For example:\nâ€¢ 'Who are the engineers at this company?'\nâ€¢ 'Find the best path to connect with them'\nâ€¢ 'Show me their profile details'"
      );
    }
    return createMessage(
      "I'm not sure I understood that. I can help you:\nâ€¢ Search your network (e.g., 'Find engineers at Google')\nâ€¢ Discover connection paths (e.g., 'How can I reach John Doe?')\n\nWhat would you like to do?"
    );
  }
  content;
  async function generateResponse(intent, graph, sourceUser) {
    try {
      switch (intent.type) {
        case "SEARCH":
          return await handleSearchIntent(intent, graph);
        case "FIND_PATH":
          return await handleFindPathIntent(intent, graph, sourceUser);
        case "GENERATE_MESSAGE":
          return handleGenerateMessageIntent(intent);
        case "GENERAL":
          return handleGeneralIntent(intent);
        default:
          return createMessage("I'm not sure how to help with that. Try asking me to find people or discover connection paths!");
      }
    } catch (error) {
      console.error("[ResponseGenerator] Error generating response:", error);
      return createMessage(
        "I encountered an error processing your request. Please try again or rephrase your question."
      );
    }
  }
  content;
  function resolveContextReferences(intent, message, context) {
    const lower = message.toLowerCase();
    if (hasResultReference(lower) && context.lastSearchResults) {
      const index2 = extractResultIndex(lower, context);
      if (index2 !== null && context.lastSearchResults[index2]) {
        const result2 = context.lastSearchResults[index2];
        if (intent.type === "GENERAL" || intent.type === "FIND_PATH") {
          return {
            ...intent,
            type: "FIND_PATH",
            entities: {
              ...intent.entities,
              target: result2.name,
              targetCompany: result2.company
            },
            reasoning: `Resolved context reference to ${result2.name}`
          };
        }
      }
    }
    if (hasPronounReference(lower)) {
      if (context.lastSearchResults && context.lastSearchResults.length > 0) {
        const firstResult = context.lastSearchResults[0];
        if (intent.type === "GENERAL" || intent.type === "FIND_PATH") {
          return {
            ...intent,
            type: "FIND_PATH",
            entities: {
              ...intent.entities,
              target: firstResult.name,
              targetCompany: firstResult.company
            },
            reasoning: `Resolved pronoun reference to ${firstResult.name}`
          };
        }
        if (intent.type === "GENERATE_MESSAGE") {
          return {
            ...intent,
            entities: {
              ...intent.entities,
              target: firstResult.name
            },
            reasoning: `Resolved pronoun reference to ${firstResult.name}`
          };
        }
      }
    }
    if (isRefinement(lower) && context.lastIntent?.type === "SEARCH") {
      return {
        ...intent,
        type: "SEARCH",
        entities: {
          ...context.lastIntent.entities,
          ...intent.entities
        },
        reasoning: "Refined previous search query"
      };
    }
    return intent;
  }
  function hasResultReference(message) {
    return /\b(first|second|third|last|top)\s+(one|person|result|candidate)/.test(message);
  }
  function extractResultIndex(message, context) {
    const match = message.match(/\b(first|second|third|last|top)\s+(one|person|result|candidate)/);
    if (!match) return null;
    const ordinal = match[1];
    switch (ordinal) {
      case "first":
      case "top":
        return 0;
      case "second":
        return 1;
      case "third":
        return 2;
      case "last":
        return context.lastSearchResults ? context.lastSearchResults.length - 1 : null;
      default:
        return null;
    }
  }
  function hasPronounReference(message) {
    return /\b(them|that person|this person|they|their)\b/.test(message);
  }
  function isRefinement(message) {
    return /\b(only|just|filter|refine|narrow|exclude)\b/.test(message) || /\b(show me|give me)\s+(only|just)/.test(message);
  }
  content;
  function isCommandMessage(message) {
    const lower = message.toLowerCase().trim();
    return lower === "start over" || lower === "clear" || lower === "reset" || lower === "new conversation";
  }
  function handleCommand(message) {
    const lower = message.toLowerCase().trim();
    if (lower === "start over" || lower === "clear" || lower === "reset" || lower === "new conversation") {
      return {
        id: crypto.randomUUID(),
        role: "assistant",
        content: "Conversation cleared! How can I help you with your LinkedIn network?",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    return {
      id: crypto.randomUUID(),
      role: "assistant",
      content: "I'm not sure how to help with that command.",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  content;
  class ChatAgent {
    constructor() {
      __publicField(this, "history", []);
      __publicField(this, "context", {});
      __publicField(this, "graph");
      __publicField(this, "sourceUser");
      __publicField(this, "maxHistorySize", 10);
    }
    /**
     * Set network graph for search and pathfinding
     */
    setGraph(graph) {
      this.graph = graph;
    }
    /**
     * Set source user profile for pathfinding
     */
    setSourceUser(user) {
      this.sourceUser = user;
    }
    /**
     * Process a chat message and return response
     */
    async chat(message) {
      const userMessage = {
        id: crypto.randomUUID(),
        role: "user",
        content: message,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      this.addToHistory(userMessage);
      if (isCommandMessage(message)) {
        const response2 = handleCommand(message);
        this.addToHistory(response2);
        if (response2.content.includes("Conversation cleared")) {
          this.clearHistory();
        }
        return response2;
      }
      let intent = await classifyIntent(message);
      intent = resolveContextReferences(intent, message, this.context);
      const response = await generateResponse(intent, this.graph, this.sourceUser);
      this.updateContext(response, intent);
      this.addToHistory(response);
      return response;
    }
    /**
     * Get conversation history
     */
    getHistory() {
      return [...this.history];
    }
    /**
     * Clear conversation history and context
     */
    clearHistory() {
      this.history = [];
      this.context = {};
    }
    /**
     * Get last search results from context
     */
    getLastSearchResults() {
      return this.context.lastSearchResults;
    }
    /**
     * Get last connection paths from context
     */
    getLastPaths() {
      return this.context.lastPaths;
    }
    /**
     * Update context from response
     */
    updateContext(response, intent) {
      if (response.metadata?.searchResults) {
        this.context.lastSearchResults = response.metadata.searchResults;
      }
      if (response.metadata?.paths) {
        this.context.lastPaths = response.metadata.paths;
      }
      this.context.lastIntent = intent;
      this.context.lastQuery = intent.rawMessage;
    }
    /**
     * Add message to history (maintain max size)
     */
    addToHistory(message) {
      this.history.push(message);
      if (this.history.length > this.maxHistorySize) {
        this.history = this.history.slice(-this.maxHistorySize);
      }
    }
  }
  const chatAgent = new ChatAgent();
  content;
  content;
  function UniversalSearch({ onSearchResults, onError }) {
    const [query, setQuery] = reactExports.useState("");
    const [isSearching, setIsSearching] = reactExports.useState(false);
    const inputRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      inputRef.current?.focus();
    }, []);
    const handleSearch = async (searchQuery) => {
      if (!searchQuery.trim() || isSearching) return;
      setIsSearching(true);
      try {
        const response = await chatAgent.chat(searchQuery);
        const rawResults = response.metadata?.searchResults || [];
        const results = rawResults.map((r2) => ({
          profile: {
            id: r2.profileId,
            name: r2.name,
            headline: r2.headline,
            profileUrl: r2.profileId,
            company: r2.company,
            role: r2.role,
            connectionDegree: r2.connectionDegree
          },
          matchScore: r2.matchScore,
          reasoning: r2.reasoning,
          pathAvailable: r2.pathAvailable
        }));
        onSearchResults(results);
      } catch (error) {
        console.error("[UniversalSearch] Search failed:", error);
        if (onError) {
          onError(error);
        }
      } finally {
        setIsSearching(false);
      }
    };
    const handleSubmit = (e) => {
      e.preventDefault();
      handleSearch(query);
    };
    const handleClear = () => {
      setQuery("");
      inputRef.current?.focus();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "16px",
          borderBottom: "1px solid rgba(0, 0, 0, 0.08)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: handleSubmit, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                position: "relative",
                display: "flex",
                alignItems: "center"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      position: "absolute",
                      left: "12px",
                      display: "flex",
                      alignItems: "center",
                      pointerEvents: "none"
                    },
                    children: isSearching ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      LoaderCircle,
                      {
                        size: 18,
                        color: "#0077B5",
                        style: {
                          animation: "spin 1s linear infinite"
                        }
                      }
                    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { size: 18, color: "#6e6e73" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    ref: inputRef,
                    type: "text",
                    value: query,
                    onChange: (e) => setQuery(e.target.value),
                    placeholder: "Search your network...",
                    disabled: isSearching,
                    style: {
                      width: "100%",
                      height: "44px",
                      padding: "0 44px 0 44px",
                      border: "1px solid rgba(0, 0, 0, 0.12)",
                      borderRadius: "12px",
                      fontSize: "14px",
                      backgroundColor: "#FFFFFF",
                      transition: "all 150ms",
                      outline: "none"
                    },
                    onFocus: (e) => {
                      e.currentTarget.style.borderColor = "#0077B5";
                      e.currentTarget.style.boxShadow = "0 0 0 3px rgba(0, 119, 181, 0.1)";
                    },
                    onBlur: (e) => {
                      e.currentTarget.style.borderColor = "rgba(0, 0, 0, 0.12)";
                      e.currentTarget.style.boxShadow = "none";
                    }
                  }
                ),
                query && !isSearching && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: handleClear,
                    style: {
                      position: "absolute",
                      right: "12px",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      width: "24px",
                      height: "24px",
                      border: "none",
                      borderRadius: "50%",
                      backgroundColor: "transparent",
                      cursor: "pointer",
                      transition: "background-color 150ms"
                    },
                    onMouseEnter: (e) => {
                      e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.05)";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.backgroundColor = "transparent";
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 16, color: "#6e6e73" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
              @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
              }
            ` })
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                fontSize: "12px",
                color: "#6e6e73",
                margin: "8px 0 0 0",
                paddingLeft: "4px"
              },
              children: 'Try: "Find ML engineers at Google" or "Who works in AI Ethics?"'
            }
          )
        ]
      }
    );
  }
  content;
  function SearchResults({ results, onFindPath, onGenerateMessage, onViewProfile, isLoading = false }) {
    const [actioningId, setActioningId] = reactExports.useState(null);
    const handleFindPath = async (result2) => {
      setActioningId(result2.profile.id);
      try {
        await onFindPath(result2);
      } finally {
        setActioningId(null);
      }
    };
    const handleGenerateMessage = async (result2) => {
      setActioningId(`msg-${result2.profile.id}`);
      try {
        await onGenerateMessage(result2);
      } finally {
        setActioningId(null);
      }
    };
    const handleViewProfile = (result2) => {
      if (onViewProfile) {
        onViewProfile(result2);
      } else if (result2.profile.profileUrl) {
        window.open(result2.profile.profileUrl, "_blank");
      }
    };
    const getDegreeBadge = (degree) => {
      const colors = {
        1: { bg: "rgba(16, 185, 129, 0.1)", text: "#10B981", label: "1st" },
        2: { bg: "rgba(59, 130, 246, 0.1)", text: "#3B82F6", label: "2nd" },
        3: { bg: "rgba(245, 158, 11, 0.1)", text: "#F59E0B", label: "3rd" }
      };
      const badge = colors[degree] || colors[3];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          style: {
            padding: "4px 8px",
            backgroundColor: badge.bg,
            color: badge.text,
            borderRadius: "6px",
            fontSize: "11px",
            fontWeight: "700"
          },
          children: badge.label
        }
      );
    };
    const getMatchScore = (score) => {
      const percentage = Math.round(score * 100);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            gap: "6px",
            fontSize: "12px",
            color: "#6e6e73"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontWeight: "600" }, children: [
              percentage,
              "%"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "match" })
          ]
        }
      );
    };
    if (isLoading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            padding: "60px 20px"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              LoaderCircle,
              {
                size: 32,
                color: "#0077B5",
                style: {
                  animation: "spin 1s linear infinite"
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "p",
              {
                style: {
                  fontSize: "14px",
                  color: "#6e6e73",
                  margin: "16px 0 0 0"
                },
                children: "Searching your network..."
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
            @keyframes spin {
              from { transform: rotate(0deg); }
              to { transform: rotate(360deg); }
            }
          ` })
          ]
        }
      );
    }
    if (results.length === 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            padding: "60px 20px",
            textAlign: "center"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 48, color: "#0077B5", strokeWidth: 1.5 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "h3",
              {
                style: {
                  fontSize: "18px",
                  fontWeight: "600",
                  margin: "16px 0 8px 0",
                  color: "#1d1d1f"
                },
                children: "No results found"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "p",
              {
                style: {
                  fontSize: "14px",
                  color: "#6e6e73",
                  margin: 0,
                  maxWidth: "280px"
                },
                children: "Try a different search or explore your network"
              }
            )
          ]
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "16px", display: "flex", flexDirection: "column", gap: "12px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            paddingBottom: "8px"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "p",
            {
              style: {
                fontSize: "13px",
                color: "#6e6e73",
                margin: 0
              },
              children: [
                "Found ",
                results.length,
                " ",
                results.length === 1 ? "result" : "results"
              ]
            }
          )
        }
      ),
      results.map((result2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        ResultCard,
        {
          result: result2,
          onFindPath: () => handleFindPath(result2),
          onGenerateMessage: () => handleGenerateMessage(result2),
          onViewProfile: () => handleViewProfile(result2),
          getDegreeBadge,
          getMatchScore,
          isActioning: actioningId === result2.profile.id || actioningId === `msg-${result2.profile.id}`
        },
        result2.profile.id
      ))
    ] });
  }
  function ResultCard({ result: result2, onFindPath, onGenerateMessage, onViewProfile, getDegreeBadge, getMatchScore, isActioning }) {
    const [isHovered, setIsHovered] = reactExports.useState(false);
    const { profile, matchScore } = result2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          padding: "16px",
          borderRadius: "12px",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: "#FFFFFF",
          boxShadow: isHovered ? "0 4px 12px rgba(0, 0, 0, 0.08)" : "0 2px 4px rgba(0, 0, 0, 0.04)",
          transition: "all 200ms cubic-bezier(0.4, 0.0, 0.2, 1)",
          transform: isHovered ? "translateY(-2px)" : "translateY(0)"
        },
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: "12px" }, children: [
          profile.profileImage ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: profile.profileImage,
              alt: profile.name,
              style: {
                width: "56px",
                height: "56px",
                borderRadius: "50%",
                objectFit: "cover",
                border: "2px solid rgba(0, 119, 181, 0.2)",
                flexShrink: 0
              },
              onError: (e) => {
                e.target.style.display = "none";
              }
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                width: "56px",
                height: "56px",
                borderRadius: "50%",
                background: "linear-gradient(135deg, #0077B5 0%, #00A0DC 100%)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                color: "white",
                fontSize: "20px",
                fontWeight: "bold",
                flexShrink: 0
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 28, strokeWidth: 2 })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "4px", flexWrap: "wrap" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "h3",
                {
                  style: {
                    fontSize: "15px",
                    fontWeight: "600",
                    margin: 0,
                    color: "#1d1d1f",
                    wordBreak: "break-word"
                  },
                  children: profile.name
                }
              ),
              profile.connectionDegree && getDegreeBadge(profile.connectionDegree),
              getMatchScore(matchScore)
            ] }),
            profile.headline && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "p",
              {
                style: {
                  fontSize: "13px",
                  color: "#6e6e73",
                  margin: "0 0 8px 0",
                  display: "flex",
                  alignItems: "flex-start",
                  gap: "6px",
                  lineHeight: "1.4",
                  wordBreak: "break-word"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: 12, style: { marginTop: "2px", flexShrink: 0 } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { flex: 1 }, children: profile.headline })
                ]
              }
            ),
            result2.reasoning && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "p",
              {
                style: {
                  fontSize: "12px",
                  color: "#6e6e73",
                  margin: "0 0 12px 0",
                  fontStyle: "italic"
                },
                children: result2.reasoning
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginTop: "12px", flexWrap: "wrap" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: onViewProfile,
                  style: {
                    padding: "6px 12px",
                    backgroundColor: "rgba(0, 119, 181, 0.1)",
                    color: "#0077B5",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    transition: "all 150ms"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.backgroundColor = "rgba(0, 119, 181, 0.15)";
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "rgba(0, 119, 181, 0.1)";
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { size: 12 }),
                    "View"
                  ]
                }
              ),
              result2.pathAvailable && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: onFindPath,
                  disabled: isActioning,
                  style: {
                    padding: "6px 12px",
                    backgroundColor: "#0077B5",
                    color: "#FFFFFF",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: isActioning ? "not-allowed" : "pointer",
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    transition: "all 150ms",
                    opacity: isActioning ? 0.6 : 1
                  },
                  onMouseEnter: (e) => {
                    if (!isActioning) {
                      e.currentTarget.style.backgroundColor = "#006399";
                    }
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "#0077B5";
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(GitBranch, { size: 12 }),
                    "Find Path"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: onGenerateMessage,
                  disabled: isActioning,
                  style: {
                    padding: "6px 12px",
                    backgroundColor: "rgba(16, 185, 129, 0.1)",
                    color: "#10B981",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: isActioning ? "not-allowed" : "pointer",
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    transition: "all 150ms",
                    opacity: isActioning ? 0.6 : 1
                  },
                  onMouseEnter: (e) => {
                    if (!isActioning) {
                      e.currentTarget.style.backgroundColor = "rgba(16, 185, 129, 0.15)";
                    }
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "rgba(16, 185, 129, 0.1)";
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSquare, { size: 12 }),
                    "Message"
                  ]
                }
              )
            ] })
          ] })
        ] })
      }
    );
  }
  content;
  function ConnectionPathView({ path, onGenerateMessage, onClose }) {
    if (!path) return null;
    const getProbabilityColor = (probability) => {
      if (probability >= 0.7) return { bg: "rgba(16, 185, 129, 0.1)", text: "#10B981", label: "High" };
      if (probability >= 0.4) return { bg: "rgba(245, 158, 11, 0.1)", text: "#F59E0B", label: "Medium" };
      return { bg: "rgba(239, 68, 68, 0.1)", text: "#EF4444", label: "Low" };
    };
    const probabilityStyle = getProbabilityColor(path.successProbability);
    const percentage = Math.round(path.successProbability * 100);
    const formatStrategy = (strategy) => {
      return strategy.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          position: "fixed",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: "rgba(0, 0, 0, 0.5)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          zIndex: 1e3,
          padding: "20px"
        },
        onClick: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              backgroundColor: "#FFFFFF",
              borderRadius: "16px",
              maxWidth: "600px",
              width: "100%",
              maxHeight: "90vh",
              overflow: "auto",
              boxShadow: "0 20px 50px rgba(0, 0, 0, 0.3)"
            },
            onClick: (e) => e.stopPropagation(),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    padding: "20px 24px",
                    borderBottom: "1px solid rgba(0, 0, 0, 0.08)",
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "h2",
                      {
                        style: {
                          fontSize: "20px",
                          fontWeight: "600",
                          margin: 0,
                          color: "#1d1d1f"
                        },
                        children: "Connection Path"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        onClick: onClose,
                        style: {
                          width: "32px",
                          height: "32px",
                          border: "none",
                          borderRadius: "50%",
                          backgroundColor: "transparent",
                          cursor: "pointer",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          transition: "background-color 150ms"
                        },
                        onMouseEnter: (e) => {
                          e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.05)";
                        },
                        onMouseLeave: (e) => {
                          e.currentTarget.style.backgroundColor = "transparent";
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 20, color: "#6e6e73" })
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "24px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      backgroundColor: "rgba(0, 119, 181, 0.03)",
                      borderRadius: "12px",
                      padding: "24px",
                      marginBottom: "24px"
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          gap: "12px",
                          flexWrap: "wrap",
                          justifyContent: "center"
                        },
                        children: path.path.map((node, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "12px" }, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            "div",
                            {
                              style: {
                                display: "flex",
                                flexDirection: "column",
                                alignItems: "center",
                                gap: "8px"
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  "div",
                                  {
                                    className: "network-node",
                                    style: {
                                      width: index2 === 0 || index2 === path.path.length - 1 ? "64px" : "56px",
                                      height: index2 === 0 || index2 === path.path.length - 1 ? "64px" : "56px"
                                    },
                                    children: node.profileImage ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      "img",
                                      {
                                        src: node.profileImage,
                                        alt: node.name,
                                        style: {
                                          width: "100%",
                                          height: "100%",
                                          borderRadius: "50%",
                                          objectFit: "cover"
                                        }
                                      }
                                    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      "div",
                                      {
                                        style: {
                                          width: "100%",
                                          height: "100%",
                                          borderRadius: "50%",
                                          background: "linear-gradient(135deg, #0077B5 0%, #00A0DC 100%)",
                                          display: "flex",
                                          alignItems: "center",
                                          justifyContent: "center",
                                          color: "white",
                                          fontSize: "18px",
                                          fontWeight: "bold"
                                        },
                                        children: node.name.charAt(0)
                                      }
                                    )
                                  }
                                ),
                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  "span",
                                  {
                                    style: {
                                      fontSize: "12px",
                                      fontWeight: "600",
                                      color: "#1d1d1f",
                                      maxWidth: "100px",
                                      textAlign: "center",
                                      wordBreak: "break-word"
                                    },
                                    children: index2 === 0 ? "You" : index2 === path.path.length - 1 ? "Target" : node.name
                                  }
                                )
                              ]
                            }
                          ),
                          index2 < path.path.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, { size: 24, color: "#0077B5", strokeWidth: 2 })
                        ] }, node.id))
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "16px", marginBottom: "24px", flexWrap: "wrap" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: "200px" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "p",
                      {
                        style: {
                          fontSize: "12px",
                          color: "#6e6e73",
                          margin: "0 0 6px 0",
                          fontWeight: "600",
                          textTransform: "uppercase",
                          letterSpacing: "0.5px"
                        },
                        children: "Strategy"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        style: {
                          padding: "12px 16px",
                          backgroundColor: "rgba(0, 119, 181, 0.1)",
                          borderRadius: "8px",
                          fontSize: "14px",
                          fontWeight: "600",
                          color: "#0077B5"
                        },
                        children: formatStrategy(path.strategy)
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: "200px" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "p",
                      {
                        style: {
                          fontSize: "12px",
                          color: "#6e6e73",
                          margin: "0 0 6px 0",
                          fontWeight: "600",
                          textTransform: "uppercase",
                          letterSpacing: "0.5px"
                        },
                        children: "Success Probability"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "div",
                      {
                        style: {
                          padding: "12px 16px",
                          backgroundColor: probabilityStyle.bg,
                          borderRadius: "8px",
                          fontSize: "14px",
                          fontWeight: "600",
                          color: probabilityStyle.text,
                          display: "flex",
                          justifyContent: "space-between",
                          alignItems: "center"
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                            percentage,
                            "%"
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "span",
                            {
                              style: {
                                fontSize: "12px",
                                fontWeight: "700",
                                textTransform: "uppercase",
                                letterSpacing: "0.5px"
                              },
                              children: probabilityStyle.label
                            }
                          )
                        ]
                      }
                    )
                  ] })
                ] }),
                path.reasoning && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "24px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "p",
                    {
                      style: {
                        fontSize: "12px",
                        color: "#6e6e73",
                        margin: "0 0 8px 0",
                        fontWeight: "600",
                        textTransform: "uppercase",
                        letterSpacing: "0.5px"
                      },
                      children: "Why This Path?"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "p",
                    {
                      style: {
                        fontSize: "14px",
                        color: "#1d1d1f",
                        margin: 0,
                        lineHeight: "1.6"
                      },
                      children: path.reasoning
                    }
                  )
                ] }),
                path.actionSteps && path.actionSteps.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "24px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "p",
                    {
                      style: {
                        fontSize: "12px",
                        color: "#6e6e73",
                        margin: "0 0 12px 0",
                        fontWeight: "600",
                        textTransform: "uppercase",
                        letterSpacing: "0.5px"
                      },
                      children: "Action Steps"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: path.actionSteps.map((step, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        display: "flex",
                        gap: "12px",
                        alignItems: "flex-start"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            style: {
                              width: "24px",
                              height: "24px",
                              borderRadius: "50%",
                              backgroundColor: "rgba(0, 119, 181, 0.1)",
                              color: "#0077B5",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                              fontSize: "12px",
                              fontWeight: "700",
                              flexShrink: 0
                            },
                            children: index2 + 1
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "p",
                          {
                            style: {
                              fontSize: "14px",
                              color: "#1d1d1f",
                              margin: "2px 0 0 0",
                              lineHeight: "1.5"
                            },
                            children: step
                          }
                        )
                      ]
                    },
                    index2
                  )) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    onClick: onGenerateMessage,
                    style: {
                      width: "100%",
                      padding: "14px 20px",
                      backgroundColor: "#0077B5",
                      color: "#FFFFFF",
                      border: "none",
                      borderRadius: "10px",
                      fontSize: "15px",
                      fontWeight: "600",
                      cursor: "pointer",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      gap: "10px",
                      transition: "all 150ms"
                    },
                    onMouseEnter: (e) => {
                      e.currentTarget.style.backgroundColor = "#006399";
                      e.currentTarget.style.transform = "translateY(-1px)";
                      e.currentTarget.style.boxShadow = "0 4px 12px rgba(0, 119, 181, 0.3)";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.backgroundColor = "#0077B5";
                      e.currentTarget.style.transform = "translateY(0)";
                      e.currentTarget.style.boxShadow = "none";
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSquare, { size: 18 }),
                      "Generate Connection Message"
                    ]
                  }
                )
              ] })
            ]
          }
        )
      }
    );
  }
  content;
  function MessageComposer({
    message: initialMessage,
    alternatives = [],
    reasoning = [],
    characterCount: _characterCount,
    onRegenerate,
    onCopy,
    onClose
  }) {
    const [selectedMessage, setSelectedMessage] = reactExports.useState(initialMessage);
    const [editedMessage, setEditedMessage] = reactExports.useState(initialMessage);
    const [selectedTone, setSelectedTone] = reactExports.useState("professional");
    const [copied, setCopied] = reactExports.useState(false);
    const [isRegenerating, setIsRegenerating] = reactExports.useState(false);
    const currentCharacterCount = editedMessage.length;
    const maxLength = 300;
    const isOverLimit = currentCharacterCount > maxLength;
    const handleCopy = () => {
      if (onCopy) {
        onCopy(editedMessage);
      } else {
        navigator.clipboard.writeText(editedMessage);
      }
      setCopied(true);
      setTimeout(() => setCopied(false), 2e3);
    };
    const handleRegenerate = async () => {
      if (!onRegenerate) return;
      setIsRegenerating(true);
      try {
        await onRegenerate(selectedTone);
      } finally {
        setIsRegenerating(false);
      }
    };
    const handleSelectAlternative = (alt) => {
      setSelectedMessage(alt);
      setEditedMessage(alt);
    };
    const tones = [
      { value: "professional", label: "Professional", emoji: "ðŸ‘”" },
      { value: "casual", label: "Casual", emoji: "ðŸ˜Š" },
      { value: "enthusiastic", label: "Enthusiastic", emoji: "ðŸš€" }
    ];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          position: "fixed",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: "rgba(0, 0, 0, 0.5)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          zIndex: 1e3,
          padding: "20px"
        },
        onClick: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              backgroundColor: "#FFFFFF",
              borderRadius: "16px",
              maxWidth: "600px",
              width: "100%",
              maxHeight: "90vh",
              overflow: "auto",
              boxShadow: "0 20px 50px rgba(0, 0, 0, 0.3)"
            },
            onClick: (e) => e.stopPropagation(),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    padding: "20px 24px",
                    borderBottom: "1px solid rgba(0, 0, 0, 0.08)",
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 20, color: "#0077B5" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "h2",
                        {
                          style: {
                            fontSize: "20px",
                            fontWeight: "600",
                            margin: 0,
                            color: "#1d1d1f"
                          },
                          children: "Connection Message"
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        onClick: onClose,
                        style: {
                          width: "32px",
                          height: "32px",
                          border: "none",
                          borderRadius: "50%",
                          backgroundColor: "transparent",
                          cursor: "pointer",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          transition: "background-color 150ms"
                        },
                        onMouseEnter: (e) => {
                          e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.05)";
                        },
                        onMouseLeave: (e) => {
                          e.currentTarget.style.backgroundColor = "transparent";
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 20, color: "#6e6e73" })
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "24px" }, children: [
                onRegenerate && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "20px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "p",
                    {
                      style: {
                        fontSize: "12px",
                        color: "#6e6e73",
                        margin: "0 0 8px 0",
                        fontWeight: "600",
                        textTransform: "uppercase",
                        letterSpacing: "0.5px"
                      },
                      children: "Tone"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: "8px" }, children: tones.map((tone) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      onClick: () => setSelectedTone(tone.value),
                      style: {
                        flex: 1,
                        padding: "10px 16px",
                        backgroundColor: selectedTone === tone.value ? "rgba(0, 119, 181, 0.1)" : "transparent",
                        color: selectedTone === tone.value ? "#0077B5" : "#6e6e73",
                        border: selectedTone === tone.value ? "2px solid #0077B5" : "1px solid rgba(0, 0, 0, 0.12)",
                        borderRadius: "8px",
                        fontSize: "13px",
                        fontWeight: "600",
                        cursor: "pointer",
                        transition: "all 150ms",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        gap: "6px"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: tone.emoji }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: tone.label })
                      ]
                    },
                    tone.value
                  )) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        display: "flex",
                        justifyContent: "space-between",
                        alignItems: "center",
                        marginBottom: "8px"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "p",
                          {
                            style: {
                              fontSize: "12px",
                              color: "#6e6e73",
                              margin: 0,
                              fontWeight: "600",
                              textTransform: "uppercase",
                              letterSpacing: "0.5px"
                            },
                            children: "Your Message"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "span",
                          {
                            style: {
                              fontSize: "12px",
                              color: isOverLimit ? "#EF4444" : "#6e6e73",
                              fontWeight: "600"
                            },
                            children: [
                              currentCharacterCount,
                              " / ",
                              maxLength
                            ]
                          }
                        )
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      value: editedMessage,
                      onChange: (e) => setEditedMessage(e.target.value),
                      style: {
                        width: "100%",
                        minHeight: "150px",
                        padding: "14px",
                        border: isOverLimit ? "2px solid #EF4444" : "1px solid rgba(0, 0, 0, 0.12)",
                        borderRadius: "10px",
                        fontSize: "14px",
                        lineHeight: "1.6",
                        resize: "vertical",
                        fontFamily: "inherit",
                        backgroundColor: "#FFFFFF",
                        transition: "all 150ms"
                      },
                      onFocus: (e) => {
                        if (!isOverLimit) {
                          e.currentTarget.style.borderColor = "#0077B5";
                          e.currentTarget.style.boxShadow = "0 0 0 3px rgba(0, 119, 181, 0.1)";
                        }
                      },
                      onBlur: (e) => {
                        if (!isOverLimit) {
                          e.currentTarget.style.borderColor = "rgba(0, 0, 0, 0.12)";
                          e.currentTarget.style.boxShadow = "none";
                        }
                      }
                    }
                  ),
                  isOverLimit && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "p",
                    {
                      style: {
                        fontSize: "12px",
                        color: "#EF4444",
                        margin: "6px 0 0 0"
                      },
                      children: [
                        "Message exceeds LinkedIn's ",
                        maxLength,
                        " character limit"
                      ]
                    }
                  )
                ] }),
                reasoning.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      padding: "14px",
                      backgroundColor: "rgba(0, 119, 181, 0.05)",
                      borderRadius: "10px",
                      marginBottom: "16px"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "p",
                        {
                          style: {
                            fontSize: "12px",
                            color: "#6e6e73",
                            margin: "0 0 8px 0",
                            fontWeight: "600",
                            textTransform: "uppercase",
                            letterSpacing: "0.5px"
                          },
                          children: "Why This Message?"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { style: { margin: 0, paddingLeft: "20px", fontSize: "13px", color: "#1d1d1f", lineHeight: "1.6" }, children: reasoning.map((point, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { style: { marginBottom: "4px" }, children: point }, index2)) })
                    ]
                  }
                ),
                alternatives.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "20px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "p",
                    {
                      style: {
                        fontSize: "12px",
                        color: "#6e6e73",
                        margin: "0 0 8px 0",
                        fontWeight: "600",
                        textTransform: "uppercase",
                        letterSpacing: "0.5px"
                      },
                      children: "Alternative Messages"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: alternatives.map((alt, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: () => handleSelectAlternative(alt),
                      style: {
                        padding: "12px",
                        border: selectedMessage === alt ? "2px solid #0077B5" : "1px solid rgba(0, 0, 0, 0.12)",
                        borderRadius: "8px",
                        backgroundColor: selectedMessage === alt ? "rgba(0, 119, 181, 0.05)" : "transparent",
                        fontSize: "13px",
                        color: "#1d1d1f",
                        textAlign: "left",
                        cursor: "pointer",
                        transition: "all 150ms",
                        lineHeight: "1.5"
                      },
                      onMouseEnter: (e) => {
                        if (selectedMessage !== alt) {
                          e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.02)";
                        }
                      },
                      onMouseLeave: (e) => {
                        if (selectedMessage !== alt) {
                          e.currentTarget.style.backgroundColor = "transparent";
                        }
                      },
                      children: alt
                    },
                    index2
                  )) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "12px" }, children: [
                  onRegenerate && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      onClick: handleRegenerate,
                      disabled: isRegenerating,
                      style: {
                        flex: 1,
                        padding: "12px 20px",
                        backgroundColor: "rgba(0, 119, 181, 0.1)",
                        color: "#0077B5",
                        border: "none",
                        borderRadius: "10px",
                        fontSize: "14px",
                        fontWeight: "600",
                        cursor: isRegenerating ? "not-allowed" : "pointer",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        gap: "8px",
                        transition: "all 150ms",
                        opacity: isRegenerating ? 0.6 : 1
                      },
                      onMouseEnter: (e) => {
                        if (!isRegenerating) {
                          e.currentTarget.style.backgroundColor = "rgba(0, 119, 181, 0.15)";
                        }
                      },
                      onMouseLeave: (e) => {
                        e.currentTarget.style.backgroundColor = "rgba(0, 119, 181, 0.1)";
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 16, style: { animation: isRegenerating ? "spin 1s linear infinite" : "none" } }),
                        isRegenerating ? "Regenerating..." : "Regenerate"
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      onClick: handleCopy,
                      disabled: isOverLimit,
                      style: {
                        flex: 1,
                        padding: "12px 20px",
                        backgroundColor: copied ? "#10B981" : "#0077B5",
                        color: "#FFFFFF",
                        border: "none",
                        borderRadius: "10px",
                        fontSize: "14px",
                        fontWeight: "600",
                        cursor: isOverLimit ? "not-allowed" : "pointer",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        gap: "8px",
                        transition: "all 150ms",
                        opacity: isOverLimit ? 0.5 : 1
                      },
                      onMouseEnter: (e) => {
                        if (!copied && !isOverLimit) {
                          e.currentTarget.style.backgroundColor = "#006399";
                        }
                      },
                      onMouseLeave: (e) => {
                        if (!copied) {
                          e.currentTarget.style.backgroundColor = "#0077B5";
                        }
                      },
                      children: [
                        copied ? /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 16 }),
                        copied ? "Copied!" : "Copy Message"
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
              @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
              }
            ` })
              ] })
            ]
          }
        )
      }
    );
  }
  content;
  function CompanyJobPreferences({
    company,
    onSave,
    onCancel
  }) {
    const [useCustom, setUseCustom] = reactExports.useState(!!company.jobPreferences);
    const [preferences, setPreferences] = reactExports.useState(
      company.jobPreferences || {
        keywords: [],
        experienceLevel: [],
        remote: false,
        location: []
      }
    );
    const handleSave = () => {
      if (useCustom) {
        const hasPreferences = preferences.keywords && preferences.keywords.length > 0 || preferences.experienceLevel && preferences.experienceLevel.length > 0 || preferences.remote !== void 0 || preferences.location && preferences.location.length > 0;
        onSave(hasPreferences ? preferences : null);
      } else {
        onSave(null);
      }
    };
    const handleKeywordsChange = (value) => {
      const keywords = value.split(",").map((k) => k.trim()).filter(Boolean);
      setPreferences({ ...preferences, keywords });
    };
    const handleLocationsChange = (value) => {
      const locations = value.split(",").map((l) => l.trim()).filter(Boolean);
      setPreferences({ ...preferences, location: locations });
    };
    const toggleExperienceLevel = (level) => {
      const current = preferences.experienceLevel || [];
      const updated = current.includes(level) ? current.filter((l) => l !== level) : [...current, level];
      setPreferences({ ...preferences, experienceLevel: updated });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "20px",
          backgroundColor: "#FFFFFF",
          borderRadius: "12px",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          boxShadow: "0 4px 12px rgba(0, 0, 0, 0.12)",
          marginTop: "12px"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                marginBottom: "16px"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "h3",
                  {
                    style: {
                      fontSize: "16px",
                      fontWeight: "600",
                      color: "#1d1d1f",
                      display: "flex",
                      alignItems: "center",
                      gap: "8px",
                      margin: 0
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Settings, { size: 18, color: "#0077B5" }),
                      "Job Preferences for ",
                      company.name
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: onCancel,
                    style: {
                      width: "28px",
                      height: "28px",
                      border: "none",
                      borderRadius: "50%",
                      backgroundColor: "transparent",
                      cursor: "pointer",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      transition: "background-color 150ms"
                    },
                    onMouseEnter: (e) => {
                      e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.05)";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.backgroundColor = "transparent";
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 18, color: "#6e6e73" })
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "label",
            {
              style: {
                display: "flex",
                alignItems: "center",
                gap: "8px",
                marginBottom: "20px",
                cursor: "pointer",
                padding: "12px",
                backgroundColor: "rgba(0, 119, 181, 0.05)",
                borderRadius: "8px"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "checkbox",
                    checked: useCustom,
                    onChange: (e) => setUseCustom(e.target.checked),
                    style: { width: "16px", height: "16px", cursor: "pointer" }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: "14px", color: "#1d1d1f", fontWeight: "500" }, children: [
                  "Use custom job preferences for ",
                  company.name
                ] })
              ]
            }
          ),
          !useCustom && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                padding: "16px",
                backgroundColor: "rgba(0, 0, 0, 0.02)",
                borderRadius: "8px",
                fontSize: "13px",
                color: "#6e6e73",
                textAlign: "center"
              },
              children: "This company will use your global job preferences from Settings."
            }
          ),
          useCustom && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "20px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "label",
                {
                  style: {
                    display: "block",
                    fontSize: "13px",
                    fontWeight: "600",
                    color: "#1d1d1f",
                    marginBottom: "8px"
                  },
                  children: "Job Title Keywords"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: preferences.keywords?.join(", ") || "",
                  onChange: (e) => handleKeywordsChange(e.target.value),
                  placeholder: "e.g., engineer, designer, manager",
                  style: {
                    width: "100%",
                    padding: "10px 12px",
                    border: "1px solid rgba(0, 0, 0, 0.12)",
                    borderRadius: "8px",
                    fontSize: "13px",
                    backgroundColor: "#FFFFFF",
                    color: "#1d1d1f",
                    outline: "none",
                    transition: "all 150ms"
                  },
                  onFocus: (e) => {
                    e.currentTarget.style.borderColor = "#0077B5";
                    e.currentTarget.style.boxShadow = "0 0 0 3px rgba(0, 119, 181, 0.1)";
                  },
                  onBlur: (e) => {
                    e.currentTarget.style.borderColor = "rgba(0, 0, 0, 0.12)";
                    e.currentTarget.style.boxShadow = "none";
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "11px", color: "#8e8e93", margin: "4px 0 0 0" }, children: "Comma-separated keywords to match in job titles" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "label",
                {
                  style: {
                    display: "block",
                    fontSize: "13px",
                    fontWeight: "600",
                    color: "#1d1d1f",
                    marginBottom: "8px"
                  },
                  children: "Experience Level"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "8px" }, children: ["Entry", "Mid", "Senior", "Lead", "Director", "Executive"].map((level) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "label",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    padding: "8px 14px",
                    backgroundColor: preferences.experienceLevel?.includes(level) ? "#0077B5" : "rgba(0, 0, 0, 0.04)",
                    color: preferences.experienceLevel?.includes(level) ? "#FFFFFF" : "#1d1d1f",
                    borderRadius: "8px",
                    fontSize: "12px",
                    fontWeight: "500",
                    cursor: "pointer",
                    transition: "all 150ms",
                    border: "none"
                  },
                  onMouseEnter: (e) => {
                    if (!preferences.experienceLevel?.includes(level)) {
                      e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.08)";
                    }
                  },
                  onMouseLeave: (e) => {
                    if (!preferences.experienceLevel?.includes(level)) {
                      e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.04)";
                    }
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "checkbox",
                        checked: preferences.experienceLevel?.includes(level) || false,
                        onChange: () => toggleExperienceLevel(level),
                        style: { display: "none" }
                      }
                    ),
                    level
                  ]
                },
                level
              )) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "label",
                {
                  style: {
                    display: "block",
                    fontSize: "13px",
                    fontWeight: "600",
                    color: "#1d1d1f",
                    marginBottom: "8px"
                  },
                  children: "Work Location"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "label",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: "8px",
                    padding: "12px",
                    backgroundColor: "rgba(0, 0, 0, 0.02)",
                    borderRadius: "8px",
                    cursor: "pointer"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "checkbox",
                        checked: preferences.remote || false,
                        onChange: (e) => setPreferences({ ...preferences, remote: e.target.checked }),
                        style: { width: "16px", height: "16px", cursor: "pointer" }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "13px", color: "#1d1d1f" }, children: "Remote only" })
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "label",
                {
                  style: {
                    display: "block",
                    fontSize: "13px",
                    fontWeight: "600",
                    color: "#1d1d1f",
                    marginBottom: "8px"
                  },
                  children: "Preferred Locations"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: preferences.location?.join(", ") || "",
                  onChange: (e) => handleLocationsChange(e.target.value),
                  placeholder: "e.g., San Francisco, New York, Austin",
                  style: {
                    width: "100%",
                    padding: "10px 12px",
                    border: "1px solid rgba(0, 0, 0, 0.12)",
                    borderRadius: "8px",
                    fontSize: "13px",
                    backgroundColor: "#FFFFFF",
                    color: "#1d1d1f",
                    outline: "none",
                    transition: "all 150ms"
                  },
                  onFocus: (e) => {
                    e.currentTarget.style.borderColor = "#0077B5";
                    e.currentTarget.style.boxShadow = "0 0 0 3px rgba(0, 119, 181, 0.1)";
                  },
                  onBlur: (e) => {
                    e.currentTarget.style.borderColor = "rgba(0, 0, 0, 0.12)";
                    e.currentTarget.style.boxShadow = "none";
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "11px", color: "#8e8e93", margin: "4px 0 0 0" }, children: "Comma-separated city or region names" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                gap: "12px",
                marginTop: "24px",
                paddingTop: "20px",
                borderTop: "1px solid rgba(0, 0, 0, 0.08)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: onCancel,
                    style: {
                      flex: 1,
                      padding: "12px 16px",
                      backgroundColor: "rgba(0, 0, 0, 0.04)",
                      color: "#1d1d1f",
                      border: "none",
                      borderRadius: "8px",
                      fontSize: "14px",
                      fontWeight: "600",
                      cursor: "pointer",
                      transition: "all 150ms"
                    },
                    onMouseEnter: (e) => {
                      e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.08)";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.04)";
                    },
                    children: "Cancel"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: handleSave,
                    style: {
                      flex: 1,
                      padding: "12px 16px",
                      backgroundColor: "#0077B5",
                      color: "#FFFFFF",
                      border: "none",
                      borderRadius: "8px",
                      fontSize: "14px",
                      fontWeight: "600",
                      cursor: "pointer",
                      transition: "all 150ms"
                    },
                    onMouseEnter: (e) => {
                      e.currentTarget.style.backgroundColor = "#006399";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.backgroundColor = "#0077B5";
                    },
                    children: "Save Preferences"
                  }
                )
              ]
            }
          )
        ]
      }
    );
  }
  content;
  const __vite_import_meta_env__ = {};
  function getBackendUrl() {
    const envUrl = __vite_import_meta_env__?.VITE_BACKEND_URL;
    if (envUrl) {
      return envUrl.replace(/\/$/, "");
    }
    return "https://uproot-backend.vercel.app";
  }
  const BASE_URL = getBackendUrl();
  const API_ENDPOINTS = {
    // Search & Pathfinding (Task 4.1)
    SEARCH: `${BASE_URL}/api/search`,
    FIND_PATH: `${BASE_URL}/api/find-path`,
    // Messages & Chat (Task 4.2)
    GENERATE_MESSAGE: `${BASE_URL}/api/generate-message`,
    CHAT: `${BASE_URL}/api/chat`,
    EMBEDDINGS: `${BASE_URL}/api/embeddings`
    // Future endpoints
    // HEALTH: `${BASE_URL}/api/health`,
    // AUTH: `${BASE_URL}/api/auth`,
  };
  const DEFAULT_CONFIG = {
    timeout: 3e4,
    // 30 seconds
    retries: 3,
    cache: true,
    cacheTTL: 5 * 60 * 1e3
    // 5 minutes
  };
  class ApiError extends Error {
    constructor(message, statusCode, errorCode, details) {
      super(message);
      this.statusCode = statusCode;
      this.errorCode = errorCode;
      this.details = details;
      this.name = "ApiError";
    }
  }
  class NetworkError extends Error {
    constructor(message) {
      super(message);
      this.name = "NetworkError";
    }
  }
  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  }
  function logApiRequest(endpoint, method, data) {
  }
  function logApiResponse(endpoint, response, duration) {
  }
  content;
  class ApiCache {
    constructor(maxSize = 100) {
      __publicField(this, "cache");
      __publicField(this, "maxSize");
      __publicField(this, "hitCount", 0);
      __publicField(this, "missCount", 0);
      this.cache = /* @__PURE__ */ new Map();
      this.maxSize = maxSize;
    }
    /**
     * Generate cache key from endpoint and params
     */
    generateKey(endpoint, params) {
      if (!params) {
        return endpoint;
      }
      const sortedParams = Object.keys(params).sort().map((key) => `${key}=${JSON.stringify(params[key])}`).join("&");
      return `${endpoint}?${sortedParams}`;
    }
    /**
     * Get cached response
     */
    get(endpoint, params) {
      const key = this.generateKey(endpoint, params);
      const entry = this.cache.get(key);
      if (!entry) {
        this.missCount++;
        return null;
      }
      const now = Date.now();
      if (now - entry.timestamp > entry.ttl) {
        this.cache.delete(key);
        this.missCount++;
        return null;
      }
      this.hitCount++;
      return entry.data;
    }
    /**
     * Set cached response
     */
    set(endpoint, data, ttl, params) {
      const key = this.generateKey(endpoint, params);
      if (this.cache.size >= this.maxSize) {
        const firstKey = this.cache.keys().next().value;
        if (firstKey !== void 0) {
          this.cache.delete(firstKey);
        }
      }
      this.cache.set(key, {
        data,
        timestamp: Date.now(),
        ttl
      });
    }
    /**
     * Invalidate cache for specific endpoint
     */
    invalidate(endpoint, params) {
      const key = this.generateKey(endpoint, params);
      this.cache.delete(key);
    }
    /**
     * Invalidate all cache entries matching pattern
     */
    invalidatePattern(pattern) {
      const keysToDelete = [];
      for (const key of this.cache.keys()) {
        if (key.includes(pattern)) {
          keysToDelete.push(key);
        }
      }
      keysToDelete.forEach((key) => this.cache.delete(key));
    }
    /**
     * Clear entire cache
     */
    clear() {
      this.cache.clear();
      this.hitCount = 0;
      this.missCount = 0;
    }
    /**
     * Get cache statistics
     */
    getStats() {
      const total = this.hitCount + this.missCount;
      const hitRate = total > 0 ? this.hitCount / total : 0;
      return {
        size: this.cache.size,
        maxSize: this.maxSize,
        hitCount: this.hitCount,
        missCount: this.missCount,
        hitRate: Math.round(hitRate * 100) / 100
      };
    }
  }
  const apiCache = new ApiCache(100);
  function withCache(cacheKey, fetcher, ttl = 5 * 60 * 1e3, params) {
    const cached = apiCache.get(cacheKey, params);
    if (cached !== null) {
      console.log(`[Cache] HIT: ${cacheKey}`);
      return Promise.resolve(cached);
    }
    console.log(`[Cache] MISS: ${cacheKey}`);
    return fetcher().then((data) => {
      apiCache.set(cacheKey, data, ttl, params);
      return data;
    });
  }
  content;
  class ApiClient {
    constructor() {
      __publicField(this, "authToken", null);
      this.loadAuthToken();
    }
    // ==========================================================================
    // Authentication
    // ==========================================================================
    /**
     * Load JWT token from chrome.storage
     */
    async loadAuthToken() {
      try {
        const result2 = await chrome.storage.local.get("authToken");
        this.authToken = result2.authToken || null;
      } catch (error) {
        console.warn("[ApiClient] Failed to load auth token:", error);
        this.authToken = null;
      }
    }
    /**
     * Set JWT token (for login)
     */
    async setAuthToken(token) {
      this.authToken = token;
      await chrome.storage.local.set({ authToken: token });
    }
    /**
     * Clear JWT token (for logout)
     */
    async clearAuthToken() {
      this.authToken = null;
      await chrome.storage.local.remove("authToken");
    }
    /**
     * Get authorization headers
     */
    getAuthHeaders() {
      const headers = {
        "Content-Type": "application/json"
      };
      if (this.authToken) {
        headers["Authorization"] = `Bearer ${this.authToken}`;
      }
      return headers;
    }
    // ==========================================================================
    // Core HTTP Methods
    // ==========================================================================
    /**
     * Make HTTP request with retry logic
     */
    async request(endpoint, options, config = DEFAULT_CONFIG) {
      const startTime = Date.now();
      logApiRequest(endpoint, options.method || "GET", options.body);
      let lastError = null;
      const maxRetries = config.retries ?? DEFAULT_CONFIG.retries;
      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          const controller = new AbortController();
          const timeout = config.timeout ?? DEFAULT_CONFIG.timeout;
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          const response = await fetch(endpoint, {
            ...options,
            headers: {
              ...this.getAuthHeaders(),
              ...options.headers
            },
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({
              error: { code: "UNKNOWN", message: response.statusText }
            }));
            throw new ApiError(
              errorData.error?.message || "Request failed",
              response.status,
              errorData.error?.code || "UNKNOWN",
              errorData.error?.details
            );
          }
          const data = await response.json();
          const duration = Date.now() - startTime;
          logApiResponse(endpoint, data, duration);
          return data.success ? data.data : data;
        } catch (error) {
          lastError = error;
          if (error instanceof ApiError && error.statusCode >= 400 && error.statusCode < 500) {
            throw error;
          }
          if (error.name === "AbortError") {
            if (attempt === maxRetries) {
              throw new TimeoutError(`Request timeout after ${config.timeout}ms`);
            }
          }
          if (attempt < maxRetries) {
            const delay = Math.min(1e3 * Math.pow(2, attempt), 1e4);
            console.warn(`[ApiClient] Retry ${attempt + 1}/${maxRetries} after ${delay}ms...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
            continue;
          }
          throw new NetworkError(lastError?.message || "Network request failed");
        }
      }
      throw lastError || new NetworkError("Request failed");
    }
    // ==========================================================================
    // API Methods - Search & Pathfinding (Task 4.1)
    // ==========================================================================
    /**
     * Search user's network using semantic search
     */
    async search(request, config) {
      const cacheKey = API_ENDPOINTS.SEARCH;
      const cacheTTL = config?.cacheTTL ?? DEFAULT_CONFIG.cacheTTL;
      if (config?.cache !== false && DEFAULT_CONFIG.cache) {
        return withCache(
          cacheKey,
          () => this.request(
            API_ENDPOINTS.SEARCH,
            { method: "POST", body: JSON.stringify(request) },
            config
          ).then((data2) => data2.results),
          cacheTTL,
          request
        );
      }
      const data = await this.request(
        API_ENDPOINTS.SEARCH,
        { method: "POST", body: JSON.stringify(request) },
        config
      );
      return data.results;
    }
    /**
     * Find connection path to target person
     */
    async findPath(request, config) {
      const cacheKey = API_ENDPOINTS.FIND_PATH;
      const cacheTTL = config?.cacheTTL ?? DEFAULT_CONFIG.cacheTTL;
      if (config?.cache !== false && DEFAULT_CONFIG.cache) {
        return withCache(
          cacheKey,
          () => this.request(
            API_ENDPOINTS.FIND_PATH,
            { method: "POST", body: JSON.stringify(request) },
            config
          ).then((data2) => data2.route),
          cacheTTL,
          request
        );
      }
      const data = await this.request(
        API_ENDPOINTS.FIND_PATH,
        { method: "POST", body: JSON.stringify(request) },
        config
      );
      return data.route;
    }
    // ==========================================================================
    // API Methods - Messages & Chat (Task 4.2)
    // ==========================================================================
    /**
     * Generate personalized connection message using research-backed templates
     */
    async generateMessage(request, config) {
      const data = await this.request(
        API_ENDPOINTS.GENERATE_MESSAGE,
        { method: "POST", body: JSON.stringify(request) },
        { ...config, cache: false }
      );
      return data;
    }
    /**
     * Chat with conversational AI for network exploration
     */
    async chat(request, config) {
      const data = await this.request(
        API_ENDPOINTS.CHAT,
        { method: "POST", body: JSON.stringify(request) },
        { ...config, cache: false }
      );
      return data.message;
    }
    /**
     * Get embeddings for texts (batch processing)
     */
    async getEmbeddings(request, config) {
      const cacheKey = API_ENDPOINTS.EMBEDDINGS;
      const cacheTTL = 24 * 60 * 60 * 1e3;
      if (config?.cache !== false && DEFAULT_CONFIG.cache) {
        return withCache(
          cacheKey,
          () => this.request(
            API_ENDPOINTS.EMBEDDINGS,
            { method: "POST", body: JSON.stringify(request) },
            config
          ).then((data2) => data2.embeddings),
          cacheTTL,
          request
        );
      }
      const data = await this.request(
        API_ENDPOINTS.EMBEDDINGS,
        { method: "POST", body: JSON.stringify(request) },
        config
      );
      return data.embeddings;
    }
    // ==========================================================================
    // Cache Management
    // ==========================================================================
    /**
     * Clear all cached responses
     */
    clearCache() {
      apiCache.clear();
    }
    /**
     * Invalidate cache for specific endpoint
     */
    invalidateCache(endpoint, params) {
      apiCache.invalidate(endpoint, params);
    }
    /**
     * Get cache statistics
     */
    getCacheStats() {
      return apiCache.getStats();
    }
  }
  const apiClient = new ApiClient();
  content;
  content;
  function WatchlistTab({ panelWidth = 400 }) {
    const {
      connectionPaths,
      watchlist,
      companyWatchlist,
      isLoading,
      removePath,
      removePerson,
      removeCompany,
      updateCompany,
      markStepConnected: markStepConnected2
    } = useWatchlist();
    const [removingId, setRemovingId] = reactExports.useState(null);
    const [activeView, setActiveView] = reactExports.useState("network");
    const [editingPreferencesId, setEditingPreferencesId] = reactExports.useState(null);
    const [searchResults, setSearchResults] = reactExports.useState([]);
    const [isSearching, setIsSearching] = reactExports.useState(false);
    const [selectedPath, setSelectedPath] = reactExports.useState(null);
    const [generatedMessage, setGeneratedMessage] = reactExports.useState(null);
    const [searchError, setSearchError] = reactExports.useState(null);
    const handleRemovePerson = async (id, name) => {
      setRemovingId(id);
      try {
        await removePerson(id);
        console.log("[Uproot] Removed from watchlist:", name);
      } catch (error) {
        console.error("[Uproot] Failed to remove from watchlist:", error);
      } finally {
        setRemovingId(null);
      }
    };
    const handleRemoveCompany = async (id, name) => {
      setRemovingId(id);
      try {
        await removeCompany(id);
        console.log("[Uproot] Removed company from watchlist:", name);
      } catch (error) {
        console.error("[Uproot] Failed to remove company from watchlist:", error);
      } finally {
        setRemovingId(null);
      }
    };
    const handleToggleJobAlerts = async (company) => {
      try {
        await updateCompany(company.id, {
          jobAlertEnabled: !company.jobAlertEnabled
        });
        console.log("[Uproot] Toggled job alerts for:", company.name, !company.jobAlertEnabled);
      } catch (error) {
        console.error("[Uproot] Failed to toggle job alerts:", error);
      }
    };
    const handleSavePreferences = async (companyId, preferences) => {
      try {
        await updateCompany(companyId, {
          jobPreferences: preferences || void 0
        });
        console.log("[Uproot] Updated job preferences for company:", companyId);
        setEditingPreferencesId(null);
      } catch (error) {
        console.error("[Uproot] Failed to update job preferences:", error);
      }
    };
    const handleRemovePath = async (id, name) => {
      setRemovingId(id);
      try {
        await removePath(id);
        console.log("[Uproot] Removed connection path:", name);
      } catch (error) {
        console.error("[Uproot] Failed to remove connection path:", error);
      } finally {
        setRemovingId(null);
      }
    };
    const handleMarkStepConnected = async (pathId, stepIndex) => {
      try {
        await markStepConnected2(pathId, stepIndex);
        console.log("[Uproot] Marked step as connected:", pathId, stepIndex);
      } catch (error) {
        console.error("[Uproot] Failed to mark step as connected:", error);
      }
    };
    const handleViewProfile = (url) => {
      window.open(url, "_blank");
    };
    const handleSearchResults = (results) => {
      setSearchResults(results);
      setSearchError(null);
      setActiveView("search");
    };
    const handleSearchError = (error) => {
      console.error("[WatchlistTab] Search error:", error);
      setSearchError(error.message || "Failed to search network");
    };
    const handleFindPath = async (result2) => {
      try {
        setIsSearching(true);
        const userId = "current-user-id";
        const route = await apiClient.findPath({
          userId,
          sourceProfileId: userId,
          targetProfileId: result2.profile.id
        });
        setSelectedPath(route);
      } catch (error) {
        console.error("[WatchlistTab] Failed to find path:", error);
        setSearchError("Failed to find connection path");
      } finally {
        setIsSearching(false);
      }
    };
    const handleGenerateMessage = async (result2) => {
      try {
        setIsSearching(true);
        const userId = "current-user-id";
        const currentUserProfile = {
          id: userId,
          name: "Current User"
          // Add other profile fields
        };
        const response = await apiClient.generateMessage({
          userId,
          targetProfile: result2.profile,
          sourceProfile: currentUserProfile,
          context: {
            purpose: "networking"
          },
          tone: "professional"
        });
        setGeneratedMessage({
          message: response.message,
          alternatives: response.alternatives || [],
          reasoning: response.reasoning || []
        });
      } catch (error) {
        console.error("[WatchlistTab] Failed to generate message:", error);
        setSearchError("Failed to generate message");
      } finally {
        setIsSearching(false);
      }
    };
    const handleGenerateMessageFromPath = async () => {
      if (!selectedPath) return;
      try {
        setIsSearching(true);
        const userId = "current-user-id";
        const currentUserProfile = {
          id: userId,
          name: "Current User"
        };
        const targetProfile = selectedPath.path[selectedPath.path.length - 1];
        const response = await apiClient.generateMessage({
          userId,
          targetProfile,
          sourceProfile: currentUserProfile,
          context: {
            purpose: "networking",
            pathInfo: selectedPath
          },
          tone: "professional"
        });
        setGeneratedMessage({
          message: response.message,
          alternatives: response.alternatives || [],
          reasoning: response.reasoning || []
        });
        setSelectedPath(null);
      } catch (error) {
        console.error("[WatchlistTab] Failed to generate message:", error);
        setSearchError("Failed to generate message");
      } finally {
        setIsSearching(false);
      }
    };
    if (isLoading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            padding: "40px 20px"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              LoaderCircle,
              {
                size: 32,
                color: "#0077B5",
                style: {
                  animation: "spin 1s linear infinite"
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "p",
              {
                style: {
                  fontSize: "14px",
                  color: "#6e6e73",
                  margin: "16px 0 0 0"
                },
                children: "Loading watchlist..."
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
            @keyframes spin {
              from { transform: rotate(0deg); }
              to { transform: rotate(360deg); }
            }
          ` })
          ]
        }
      );
    }
    const currentList = activeView === "network" ? connectionPaths : activeView === "people" ? watchlist : companyWatchlist;
    const isEmpty2 = currentList.length === 0;
    if (isEmpty2 && activeView !== "search") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            height: "100%",
            overflow: "auto"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TabSwitcher,
              {
                activeView,
                onViewChange: setActiveView,
                pathCount: connectionPaths.length,
                peopleCount: watchlist.length,
                companyCount: companyWatchlist.length,
                searchCount: searchResults.length,
                panelWidth
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "center",
                  justifyContent: "center",
                  flex: 1,
                  padding: "40px 20px",
                  textAlign: "center"
                },
                children: activeView === "network" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(GitBranch, { size: 48, color: "#0077B5", strokeWidth: 1.5 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h3",
                    {
                      style: {
                        fontSize: "18px",
                        fontWeight: "600",
                        margin: "16px 0 8px 0",
                        color: "#1d1d1f"
                      },
                      children: "No connection paths saved yet"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "p",
                    {
                      style: {
                        fontSize: "14px",
                        color: "#6e6e73",
                        margin: 0,
                        maxWidth: "280px"
                      },
                      children: "Find a connection path to someone and save it to track your progress"
                    }
                  )
                ] }) : activeView === "people" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 48, color: "#0077B5", strokeWidth: 1.5 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h3",
                    {
                      style: {
                        fontSize: "18px",
                        fontWeight: "600",
                        margin: "16px 0 8px 0",
                        color: "#1d1d1f"
                      },
                      children: "No people saved yet"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "p",
                    {
                      style: {
                        fontSize: "14px",
                        color: "#6e6e73",
                        margin: 0,
                        maxWidth: "280px"
                      },
                      children: 'Visit a LinkedIn profile and click "Add to Watchlist" to start tracking people'
                    }
                  )
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { size: 48, color: "#0077B5", strokeWidth: 1.5 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h3",
                    {
                      style: {
                        fontSize: "18px",
                        fontWeight: "600",
                        margin: "16px 0 8px 0",
                        color: "#1d1d1f"
                      },
                      children: "No companies saved yet"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "p",
                    {
                      style: {
                        fontSize: "14px",
                        color: "#6e6e73",
                        margin: 0,
                        maxWidth: "280px"
                      },
                      children: 'Visit a LinkedIn company page and click "Add to Watchlist" to start tracking companies and job openings'
                    }
                  )
                ] })
              }
            )
          ]
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "auto"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TabSwitcher,
            {
              activeView,
              onViewChange: setActiveView,
              pathCount: connectionPaths.length,
              peopleCount: watchlist.length,
              companyCount: companyWatchlist.length,
              searchCount: searchResults.length,
              panelWidth
            }
          ),
          activeView === "search" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(UniversalSearch, { onSearchResults: handleSearchResults, onError: handleSearchError }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SearchResults,
              {
                results: searchResults,
                onFindPath: handleFindPath,
                onGenerateMessage: handleGenerateMessage,
                isLoading: isSearching
              }
            ),
            searchError && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  margin: "16px",
                  padding: "12px 16px",
                  backgroundColor: "rgba(239, 68, 68, 0.1)",
                  color: "#EF4444",
                  borderRadius: "8px",
                  fontSize: "13px"
                },
                children: searchError
              }
            )
          ] }) : (
            /* List */
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "16px", display: "flex", flexDirection: "column", gap: "12px" }, children: activeView === "network" ? connectionPaths.map((path) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              PathCard,
              {
                path,
                onRemove: () => handleRemovePath(path.id, path.targetName),
                onViewProfile: () => handleViewProfile(path.targetProfileUrl),
                onMarkStepConnected: handleMarkStepConnected,
                isRemoving: removingId === path.id
              },
              path.id
            )) : activeView === "people" ? watchlist.map((person) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              PersonCard,
              {
                person,
                onRemove: () => handleRemovePerson(person.id, person.name),
                onViewProfile: () => handleViewProfile(person.profileUrl),
                isRemoving: removingId === person.id
              },
              person.id
            )) : companyWatchlist.map((company) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CompanyCard,
                {
                  company,
                  onRemove: () => handleRemoveCompany(company.id, company.name),
                  onViewCompany: () => handleViewProfile(company.companyUrl),
                  onToggleJobAlerts: () => handleToggleJobAlerts(company),
                  onEditPreferences: () => setEditingPreferencesId(company.id),
                  isRemoving: removingId === company.id
                }
              ),
              editingPreferencesId === company.id && /* @__PURE__ */ jsxRuntimeExports.jsx(
                CompanyJobPreferences,
                {
                  company,
                  onSave: (prefs) => handleSavePreferences(company.id, prefs),
                  onCancel: () => setEditingPreferencesId(null)
                }
              )
            ] }, company.id)) })
          ),
          selectedPath && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ConnectionPathView,
            {
              path: selectedPath,
              onGenerateMessage: handleGenerateMessageFromPath,
              onClose: () => setSelectedPath(null)
            }
          ),
          generatedMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(
            MessageComposer,
            {
              message: generatedMessage.message,
              alternatives: generatedMessage.alternatives,
              reasoning: generatedMessage.reasoning,
              onClose: () => setGeneratedMessage(null)
            }
          )
        ]
      }
    );
  }
  content;
  content;
  function OnboardingTab({ panelWidth: _panelWidth = 400 }) {
    const [currentStep, setCurrentStep] = reactExports.useState(0);
    const [preferences, setPreferences] = reactExports.useState({
      jobTitles: [],
      experienceLevel: [],
      workLocation: [],
      locations: [],
      industries: []
    });
    const [jobTitleInput, setJobTitleInput] = reactExports.useState("");
    const [locationInput, setLocationInput] = reactExports.useState("");
    const [industryInput, setIndustryInput] = reactExports.useState("");
    const handleNext = () => {
      setCurrentStep((prev) => Math.min(prev + 1, 2));
    };
    const handleBack = () => {
      setCurrentStep((prev) => Math.max(prev - 1, 0));
    };
    const handleComplete = async () => {
      try {
        await completeOnboarding(preferences);
        console.log("[Uproot] Onboarding completed!");
        window.location.reload();
      } catch (error) {
        console.error("[Uproot] Failed to complete onboarding:", error);
      }
    };
    const addJobTitle = () => {
      if (jobTitleInput.trim() && !preferences.jobTitles.includes(jobTitleInput.trim())) {
        setPreferences({
          ...preferences,
          jobTitles: [...preferences.jobTitles, jobTitleInput.trim()]
        });
        setJobTitleInput("");
      }
    };
    const removeJobTitle = (title) => {
      setPreferences({
        ...preferences,
        jobTitles: preferences.jobTitles.filter((t) => t !== title)
      });
    };
    const toggleExperienceLevel = (level) => {
      const updated = preferences.experienceLevel.includes(level) ? preferences.experienceLevel.filter((l) => l !== level) : [...preferences.experienceLevel, level];
      setPreferences({ ...preferences, experienceLevel: updated });
    };
    const toggleWorkLocation = (location2) => {
      const updated = preferences.workLocation.includes(location2) ? preferences.workLocation.filter((l) => l !== location2) : [...preferences.workLocation, location2];
      setPreferences({ ...preferences, workLocation: updated });
    };
    const addLocation = () => {
      if (locationInput.trim() && !preferences.locations.includes(locationInput.trim())) {
        setPreferences({
          ...preferences,
          locations: [...preferences.locations, locationInput.trim()]
        });
        setLocationInput("");
      }
    };
    const removeLocation = (loc) => {
      setPreferences({
        ...preferences,
        locations: preferences.locations.filter((l) => l !== loc)
      });
    };
    const addIndustry = () => {
      if (industryInput.trim() && !preferences.industries.includes(industryInput.trim())) {
        setPreferences({
          ...preferences,
          industries: [...preferences.industries, industryInput.trim()]
        });
        setIndustryInput("");
      }
    };
    const removeIndustry = (ind) => {
      setPreferences({
        ...preferences,
        industries: preferences.industries.filter((i) => i !== ind)
      });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "auto"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: "20px 20px 16px 20px",
                borderBottom: "1px solid rgba(0, 0, 0, 0.08)",
                backgroundColor: "rgba(255, 149, 0, 0.03)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: "8px", marginBottom: "12px" }, children: [0, 1, 2].map((step) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      flex: 1,
                      height: "4px",
                      backgroundColor: currentStep >= step ? "#0077B5" : "rgba(0, 0, 0, 0.1)",
                      borderRadius: "2px",
                      transition: "all 300ms"
                    }
                  },
                  step
                )) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "p",
                  {
                    style: {
                      fontSize: "13px",
                      color: "#6e6e73",
                      margin: 0,
                      textAlign: "center"
                    },
                    children: [
                      "Step ",
                      currentStep + 1,
                      " of 3"
                    ]
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                flex: 1,
                padding: "24px 20px",
                overflowY: "auto"
              },
              children: [
                currentStep === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(WelcomeStep, {}),
                currentStep === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  JobPreferencesStep,
                  {
                    preferences,
                    jobTitleInput,
                    setJobTitleInput,
                    addJobTitle,
                    removeJobTitle,
                    toggleExperienceLevel,
                    toggleWorkLocation
                  }
                ),
                currentStep === 2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  LocationPreferencesStep,
                  {
                    preferences,
                    locationInput,
                    setLocationInput,
                    addLocation,
                    removeLocation,
                    industryInput,
                    setIndustryInput,
                    addIndustry,
                    removeIndustry
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: "16px 20px",
                borderTop: "1px solid rgba(0, 0, 0, 0.08)",
                display: "flex",
                gap: "12px"
              },
              children: [
                currentStep > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: handleBack,
                    style: {
                      flex: 1,
                      padding: "12px 16px",
                      backgroundColor: "transparent",
                      color: "#0077B5",
                      border: "1px solid #0077B5",
                      borderRadius: "8px",
                      fontSize: "14px",
                      fontWeight: "600",
                      cursor: "pointer",
                      transition: "all 150ms"
                    },
                    onMouseEnter: (e) => {
                      e.currentTarget.style.backgroundColor = "rgba(0, 119, 181, 0.05)";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.backgroundColor = "transparent";
                    },
                    children: "Back"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: currentStep === 2 ? handleComplete : handleNext,
                    style: {
                      flex: 1,
                      padding: "12px 16px",
                      backgroundColor: "#0077B5",
                      color: "#FFFFFF",
                      border: "none",
                      borderRadius: "8px",
                      fontSize: "14px",
                      fontWeight: "600",
                      cursor: "pointer",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      gap: "8px",
                      transition: "all 150ms"
                    },
                    onMouseEnter: (e) => {
                      e.currentTarget.style.backgroundColor = "#006399";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.backgroundColor = "#0077B5";
                    },
                    children: currentStep === 2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 16 }),
                      "Complete Setup"
                    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      "Next",
                      /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, { size: 16 })
                    ] })
                  }
                )
              ]
            }
          )
        ]
      }
    );
  }
  function WelcomeStep() {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", maxWidth: "400px", margin: "0 auto", padding: "20px 0" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "80px",
            height: "80px",
            margin: "0 auto 24px",
            borderRadius: "20px",
            background: "linear-gradient(135deg, #0077B5 0%, #00A0DC 100%)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Rocket, { size: 40, color: "#FFFFFF", strokeWidth: 2 })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "h1",
        {
          style: {
            fontSize: "24px",
            fontWeight: "700",
            margin: "0 0 12px 0",
            color: "#1d1d1f"
          },
          children: "Welcome to Uproot!"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "p",
        {
          style: {
            fontSize: "15px",
            color: "#6e6e73",
            margin: "0 0 32px 0",
            lineHeight: "1.6"
          },
          children: "Your AI-powered LinkedIn assistant for networking and job searching"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "left", display: "flex", flexDirection: "column", gap: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Feature,
          {
            icon: "ðŸŽ¯",
            title: "Smart Networking",
            description: "Find the shortest path to connect with anyone on LinkedIn"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Feature,
          {
            icon: "ðŸ‘ï¸",
            title: "Job Monitoring",
            description: "Track companies and get notified of relevant job openings"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Feature,
          {
            icon: "ðŸ“",
            title: "ATS-Beating Resume & Cover Letters",
            description: "Auto-generate tailored resumes and cover letters for every job that bypass ATS systems"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Feature,
          {
            icon: "ðŸ¤–",
            title: "Smart Application Assistant",
            description: "Highlight & save common questions, paste answers instantly, or let AI fill it out - sounds human, beats ATS"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Feature,
          {
            icon: "âœ‰ï¸",
            title: "AI Connection Messages",
            description: "Generate personalized connection messages with behavioral psychology that get responses"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Feature,
          {
            icon: "ðŸ§ ",
            title: "UX Psychology & Behavioral Tech",
            description: "Animations and micro-interactions designed to keep you motivated and engaged throughout your job search"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "p",
        {
          style: {
            fontSize: "13px",
            color: "#8e8e93",
            margin: "32px 0 0 0",
            lineHeight: "1.5"
          },
          children: "Let's set up your job preferences so we can help you find the perfect opportunities"
        }
      )
    ] });
  }
  function Feature({ icon, title, description }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "12px", alignItems: "flex-start" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "24px", flexShrink: 0 }, children: icon }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "h3",
          {
            style: {
              fontSize: "15px",
              fontWeight: "600",
              margin: "0 0 4px 0",
              color: "#1d1d1f"
            },
            children: title
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            style: {
              fontSize: "13px",
              color: "#6e6e73",
              margin: 0,
              lineHeight: "1.4"
            },
            children: description
          }
        )
      ] })
    ] });
  }
  function JobPreferencesStep({
    preferences,
    jobTitleInput,
    setJobTitleInput,
    addJobTitle,
    removeJobTitle,
    toggleExperienceLevel,
    toggleWorkLocation
  }) {
    const experienceLevels = [
      { value: "internship", label: "Internship" },
      { value: "entry", label: "Entry Level" },
      { value: "mid", label: "Mid Level" },
      { value: "senior", label: "Senior" },
      { value: "director", label: "Director" },
      { value: "executive", label: "Executive" }
    ];
    const workLocations = [
      { value: "remote", label: "Remote", icon: "ðŸ " },
      { value: "hybrid", label: "Hybrid", icon: "ðŸ”„" },
      { value: "onsite", label: "On-site", icon: "ðŸ¢" }
    ];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { maxWidth: "500px", margin: "0 auto" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", marginBottom: "32px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: 32, color: "#0077B5", strokeWidth: 2, style: { marginBottom: "12px" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "h2",
          {
            style: {
              fontSize: "20px",
              fontWeight: "700",
              margin: "0 0 8px 0",
              color: "#1d1d1f"
            },
            children: "What type of roles are you looking for?"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "14px", color: "#6e6e73", margin: 0 }, children: "This helps us find the most relevant opportunities" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "24px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "label",
          {
            style: {
              fontSize: "13px",
              fontWeight: "600",
              color: "#1d1d1f",
              display: "block",
              marginBottom: "8px"
            },
            children: "Job Titles *"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "12px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: jobTitleInput,
              onChange: (e) => setJobTitleInput(e.target.value),
              onKeyPress: (e) => e.key === "Enter" && addJobTitle(),
              placeholder: "e.g., Marketing Manager",
              style: {
                flex: 1,
                padding: "10px 12px",
                border: "1px solid rgba(0, 0, 0, 0.12)",
                borderRadius: "6px",
                fontSize: "14px",
                outline: "none"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: addJobTitle,
              style: {
                padding: "10px 16px",
                backgroundColor: "#0077B5",
                color: "#FFFFFF",
                border: "none",
                borderRadius: "6px",
                fontSize: "14px",
                fontWeight: "600",
                cursor: "pointer"
              },
              children: "Add"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "8px" }, children: preferences.jobTitles.map((title) => /* @__PURE__ */ jsxRuntimeExports.jsx(Pill, { text: title, onRemove: () => removeJobTitle(title) }, title)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "24px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "label",
          {
            style: {
              fontSize: "13px",
              fontWeight: "600",
              color: "#1d1d1f",
              display: "block",
              marginBottom: "8px"
            },
            children: "Experience Level"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "8px" }, children: experienceLevels.map((level) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleChip,
          {
            label: level.label,
            isSelected: preferences.experienceLevel.includes(level.value),
            onClick: () => toggleExperienceLevel(level.value)
          },
          level.value
        )) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "24px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "label",
          {
            style: {
              fontSize: "13px",
              fontWeight: "600",
              color: "#1d1d1f",
              display: "block",
              marginBottom: "8px"
            },
            children: "Work Location Preference"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: "8px" }, children: workLocations.map((loc) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleChip,
          {
            label: `${loc.icon} ${loc.label}`,
            isSelected: preferences.workLocation.includes(loc.value),
            onClick: () => toggleWorkLocation(loc.value)
          },
          loc.value
        )) })
      ] })
    ] });
  }
  function LocationPreferencesStep({
    preferences,
    locationInput,
    setLocationInput,
    addLocation,
    removeLocation,
    industryInput,
    setIndustryInput,
    addIndustry,
    removeIndustry
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { maxWidth: "500px", margin: "0 auto" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", marginBottom: "32px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { size: 32, color: "#0077B5", strokeWidth: 2, style: { marginBottom: "12px" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "h2",
          {
            style: {
              fontSize: "20px",
              fontWeight: "700",
              margin: "0 0 8px 0",
              color: "#1d1d1f"
            },
            children: "Where do you want to work?"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "14px", color: "#6e6e73", margin: 0 }, children: 'Add cities, regions, or "Remote" for remote positions' })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "24px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "label",
          {
            style: {
              fontSize: "13px",
              fontWeight: "600",
              color: "#1d1d1f",
              display: "block",
              marginBottom: "8px"
            },
            children: "Preferred Locations (Optional)"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "12px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: locationInput,
              onChange: (e) => setLocationInput(e.target.value),
              onKeyPress: (e) => e.key === "Enter" && addLocation(),
              placeholder: "e.g., New York, NY",
              style: {
                flex: 1,
                padding: "10px 12px",
                border: "1px solid rgba(0, 0, 0, 0.12)",
                borderRadius: "6px",
                fontSize: "14px",
                outline: "none"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: addLocation,
              style: {
                padding: "10px 16px",
                backgroundColor: "#0077B5",
                color: "#FFFFFF",
                border: "none",
                borderRadius: "6px",
                fontSize: "14px",
                fontWeight: "600",
                cursor: "pointer"
              },
              children: "Add"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "8px" }, children: preferences.locations.map((loc) => /* @__PURE__ */ jsxRuntimeExports.jsx(Pill, { text: loc, onRemove: () => removeLocation(loc) }, loc)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "24px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "label",
          {
            style: {
              fontSize: "13px",
              fontWeight: "600",
              color: "#1d1d1f",
              display: "block",
              marginBottom: "8px"
            },
            children: "Industries of Interest (Optional)"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "12px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: industryInput,
              onChange: (e) => setIndustryInput(e.target.value),
              onKeyPress: (e) => e.key === "Enter" && addIndustry(),
              placeholder: "e.g., Technology, Healthcare",
              style: {
                flex: 1,
                padding: "10px 12px",
                border: "1px solid rgba(0, 0, 0, 0.12)",
                borderRadius: "6px",
                fontSize: "14px",
                outline: "none"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: addIndustry,
              style: {
                padding: "10px 16px",
                backgroundColor: "#0077B5",
                color: "#FFFFFF",
                border: "none",
                borderRadius: "6px",
                fontSize: "14px",
                fontWeight: "600",
                cursor: "pointer"
              },
              children: "Add"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "8px" }, children: preferences.industries.map((ind) => /* @__PURE__ */ jsxRuntimeExports.jsx(Pill, { text: ind, onRemove: () => removeIndustry(ind) }, ind)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            padding: "16px",
            backgroundColor: "rgba(48, 209, 88, 0.1)",
            borderRadius: "8px",
            border: "1px solid rgba(48, 209, 88, 0.2)"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "p",
            {
              style: {
                fontSize: "13px",
                color: "#30D158",
                margin: 0,
                display: "flex",
                alignItems: "flex-start",
                gap: "8px"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 16, style: { marginTop: "1px", flexShrink: 0 } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "You can always update these preferences later in Settings" })
              ]
            }
          )
        }
      )
    ] });
  }
  function Pill({ text, onRemove }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "inline-flex",
          alignItems: "center",
          gap: "6px",
          padding: "6px 12px",
          backgroundColor: "rgba(0, 119, 181, 0.1)",
          borderRadius: "16px",
          fontSize: "13px",
          color: "#0077B5",
          fontWeight: "500"
        },
        children: [
          text,
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: onRemove,
              style: {
                background: "none",
                border: "none",
                cursor: "pointer",
                padding: 0,
                display: "flex",
                alignItems: "center",
                color: "#0077B5",
                fontSize: "16px",
                lineHeight: 1
              },
              children: "Ã—"
            }
          )
        ]
      }
    );
  }
  function ToggleChip({ label, isSelected, onClick }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick,
        style: {
          padding: "8px 14px",
          backgroundColor: isSelected ? "#0077B5" : "transparent",
          color: isSelected ? "#FFFFFF" : "#6e6e73",
          border: `1px solid ${isSelected ? "#0077B5" : "rgba(0, 0, 0, 0.12)"}`,
          borderRadius: "20px",
          fontSize: "13px",
          fontWeight: "600",
          cursor: "pointer",
          transition: "all 150ms"
        },
        onMouseEnter: (e) => {
          if (!isSelected) {
            e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.04)";
          }
        },
        onMouseLeave: (e) => {
          if (!isSelected) {
            e.currentTarget.style.backgroundColor = "transparent";
          }
        },
        children: label
      }
    );
  }
  content;
  function JobPreferencesSettings({ panelWidth: _panelWidth = 400 }) {
    const [preferences, setPreferences] = reactExports.useState({
      jobTitles: [],
      experienceLevel: [],
      workLocation: [],
      locations: [],
      industries: []
    });
    const [isLoading, setIsLoading] = reactExports.useState(true);
    const [isSaving, setIsSaving] = reactExports.useState(false);
    const [saveMessage, setSaveMessage] = reactExports.useState(null);
    const [jobTitleInput, setJobTitleInput] = reactExports.useState("");
    const [locationInput, setLocationInput] = reactExports.useState("");
    const [industryInput, setIndustryInput] = reactExports.useState("");
    reactExports.useEffect(() => {
      async function loadPreferences() {
        try {
          const state = await getOnboardingState();
          if (state.preferences) {
            setPreferences(state.preferences);
          }
        } catch (error) {
          console.error("[Uproot] Error loading preferences:", error);
        } finally {
          setIsLoading(false);
        }
      }
      loadPreferences();
    }, []);
    const handleSave = reactExports.useCallback(async () => {
      setIsSaving(true);
      setSaveMessage(null);
      try {
        const state = await getOnboardingState();
        await saveOnboardingState({
          ...state,
          preferences
        });
        const { updateFeedPreferences } = useSettingsStore.getState();
        await updateFeedPreferences({
          globalFilters: {
            keywords: preferences.jobTitles,
            experienceLevel: preferences.experienceLevel,
            remote: preferences.workLocation.includes("remote"),
            locations: preferences.locations
          }
        });
        console.log("[Uproot] Synced job preferences to feedPreferences");
        setSaveMessage("âœ“ Preferences saved successfully!");
        setTimeout(() => setSaveMessage(null), 3e3);
      } catch (error) {
        console.error("[Uproot] Error saving preferences:", error);
        setSaveMessage("âœ— Failed to save preferences");
      } finally {
        setIsSaving(false);
      }
    }, [preferences]);
    const addJobTitle = reactExports.useCallback(() => {
      if (jobTitleInput.trim() && !preferences.jobTitles.includes(jobTitleInput.trim())) {
        setPreferences((prev) => ({
          ...prev,
          jobTitles: [...prev.jobTitles, jobTitleInput.trim()]
        }));
        setJobTitleInput("");
      }
    }, [jobTitleInput, preferences.jobTitles]);
    const removeJobTitle = reactExports.useCallback((title) => {
      setPreferences((prev) => ({
        ...prev,
        jobTitles: prev.jobTitles.filter((t) => t !== title)
      }));
    }, []);
    const toggleExperienceLevel = reactExports.useCallback((level) => {
      setPreferences((prev) => ({
        ...prev,
        experienceLevel: prev.experienceLevel.includes(level) ? prev.experienceLevel.filter((l) => l !== level) : [...prev.experienceLevel, level]
      }));
    }, []);
    const toggleWorkLocation = reactExports.useCallback((location2) => {
      setPreferences((prev) => ({
        ...prev,
        workLocation: prev.workLocation.includes(location2) ? prev.workLocation.filter((l) => l !== location2) : [...prev.workLocation, location2]
      }));
    }, []);
    const addLocation = reactExports.useCallback(() => {
      if (locationInput.trim() && !preferences.locations.includes(locationInput.trim())) {
        setPreferences((prev) => ({
          ...prev,
          locations: [...prev.locations, locationInput.trim()]
        }));
        setLocationInput("");
      }
    }, [locationInput, preferences.locations]);
    const removeLocation = reactExports.useCallback((location2) => {
      setPreferences((prev) => ({
        ...prev,
        locations: prev.locations.filter((l) => l !== location2)
      }));
    }, []);
    const addIndustry = reactExports.useCallback(() => {
      if (industryInput.trim() && !preferences.industries.includes(industryInput.trim())) {
        setPreferences((prev) => ({
          ...prev,
          industries: [...prev.industries, industryInput.trim()]
        }));
        setIndustryInput("");
      }
    }, [industryInput, preferences.industries]);
    const removeIndustry = reactExports.useCallback((industry) => {
      setPreferences((prev) => ({
        ...prev,
        industries: prev.industries.filter((i) => i !== industry)
      }));
    }, []);
    const experienceLevels = [
      { value: "internship", label: "Internship" },
      { value: "entry", label: "Entry Level" },
      { value: "mid", label: "Mid Level" },
      { value: "senior", label: "Senior" },
      { value: "director", label: "Director" },
      { value: "executive", label: "Executive" }
    ];
    const workLocations = [
      { value: "remote", label: "Remote", icon: "ðŸ " },
      { value: "hybrid", label: "Hybrid", icon: "ðŸ”„" },
      { value: "onsite", label: "On-site", icon: "ðŸ¢" }
    ];
    if (isLoading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            color: "#6e6e73"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 24, className: "animate-spin" })
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "hidden"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                flex: 1,
                overflowY: "auto",
                padding: "20px"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Section$2, { title: "Job Titles", description: "What roles are you looking for?", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithAdd,
                    {
                      value: jobTitleInput,
                      onChange: setJobTitleInput,
                      onAdd: addJobTitle,
                      placeholder: "e.g., Product Manager, Marketing Manager"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(PillList, { items: preferences.jobTitles, onRemove: removeJobTitle })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Section$2, { title: "Experience Level", description: "Select all that apply", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "8px" }, children: experienceLevels.map(({ value, label }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TogglePill,
                  {
                    label,
                    isActive: preferences.experienceLevel.includes(value),
                    onClick: () => toggleExperienceLevel(value)
                  },
                  value
                )) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Section$2, { title: "Work Location", description: "Where do you want to work?", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "8px" }, children: workLocations.map(({ value, label, icon }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TogglePill,
                  {
                    label: `${icon} ${label}`,
                    isActive: preferences.workLocation.includes(value),
                    onClick: () => toggleWorkLocation(value)
                  },
                  value
                )) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Section$2, { title: "Locations", description: "Cities or regions you're interested in", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithAdd,
                    {
                      value: locationInput,
                      onChange: setLocationInput,
                      onAdd: addLocation,
                      placeholder: "e.g., New York, NY or Remote"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(PillList, { items: preferences.locations, onRemove: removeLocation })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Section$2,
                  {
                    title: "Industries",
                    description: "Which industries interest you? (Optional)",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        InputWithAdd,
                        {
                          value: industryInput,
                          onChange: setIndustryInput,
                          onAdd: addIndustry,
                          placeholder: "e.g., Technology, Healthcare"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(PillList, { items: preferences.industries, onRemove: removeIndustry })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "80px" } })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: "16px 20px",
                borderTop: "1px solid rgba(0, 0, 0, 0.08)",
                backgroundColor: "rgba(255, 255, 255, 0.95)",
                backdropFilter: "blur(10px)"
              },
              children: [
                saveMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      fontSize: "13px",
                      color: saveMessage.startsWith("âœ“") ? "#34C759" : "#FF3B30",
                      marginBottom: "12px",
                      textAlign: "center",
                      fontWeight: "500"
                    },
                    children: saveMessage
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: handleSave,
                    disabled: isSaving,
                    style: {
                      width: "100%",
                      padding: "14px",
                      backgroundColor: isSaving ? "#86868b" : "#0077B5",
                      color: "white",
                      border: "none",
                      borderRadius: "12px",
                      fontSize: "15px",
                      fontWeight: "600",
                      cursor: isSaving ? "not-allowed" : "pointer",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      gap: "8px",
                      transition: "all 150ms",
                      opacity: isSaving ? 0.6 : 1
                    },
                    onMouseEnter: (e) => {
                      if (!isSaving) {
                        e.currentTarget.style.backgroundColor = "#005885";
                        e.currentTarget.style.transform = "scale(1.01)";
                      }
                    },
                    onMouseLeave: (e) => {
                      if (!isSaving) {
                        e.currentTarget.style.backgroundColor = "#0077B5";
                        e.currentTarget.style.transform = "scale(1)";
                      }
                    },
                    children: isSaving ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 16, className: "animate-spin" }),
                      "Saving..."
                    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Save, { size: 16 }),
                      "Save Preferences"
                    ] })
                  }
                )
              ]
            }
          )
        ]
      }
    );
  }
  function Section$2({
    title,
    description,
    children
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "28px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "h3",
        {
          style: {
            fontSize: "15px",
            fontWeight: "600",
            margin: "0 0 4px 0",
            color: "#1d1d1f"
          },
          children: title
        }
      ),
      description && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "p",
        {
          style: {
            fontSize: "13px",
            color: "#6e6e73",
            margin: "0 0 12px 0"
          },
          children: description
        }
      ),
      children
    ] });
  }
  function InputWithAdd({
    value,
    onChange,
    onAdd,
    placeholder
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "12px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          value,
          onChange: (e) => onChange(e.target.value),
          onKeyPress: (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              onAdd();
            }
          },
          placeholder,
          style: {
            flex: 1,
            padding: "10px 14px",
            border: "1px solid rgba(0, 0, 0, 0.1)",
            borderRadius: "8px",
            fontSize: "14px",
            outline: "none",
            transition: "border-color 150ms"
          },
          onFocus: (e) => {
            e.currentTarget.style.borderColor = "#0077B5";
          },
          onBlur: (e) => {
            e.currentTarget.style.borderColor = "rgba(0, 0, 0, 0.1)";
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: onAdd,
          disabled: !value.trim(),
          style: {
            padding: "10px 18px",
            backgroundColor: value.trim() ? "#0077B5" : "rgba(0, 0, 0, 0.05)",
            color: value.trim() ? "white" : "rgba(0, 0, 0, 0.3)",
            border: "none",
            borderRadius: "8px",
            fontSize: "14px",
            fontWeight: "600",
            cursor: value.trim() ? "pointer" : "not-allowed",
            transition: "all 150ms",
            whiteSpace: "nowrap"
          },
          onMouseEnter: (e) => {
            if (value.trim()) {
              e.currentTarget.style.backgroundColor = "#005885";
            }
          },
          onMouseLeave: (e) => {
            if (value.trim()) {
              e.currentTarget.style.backgroundColor = "#0077B5";
            }
          },
          children: "Add"
        }
      )
    ] });
  }
  function PillList({
    items,
    onRemove
  }) {
    if (items.length === 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "p",
        {
          style: {
            fontSize: "13px",
            color: "#86868b",
            fontStyle: "italic",
            margin: 0
          },
          children: "No items added yet"
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "8px" }, children: items.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          alignItems: "center",
          gap: "6px",
          padding: "6px 10px 6px 12px",
          backgroundColor: "rgba(0, 119, 181, 0.1)",
          borderRadius: "20px",
          fontSize: "13px",
          color: "#0077B5",
          fontWeight: "500"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: item }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => onRemove(item),
              style: {
                background: "none",
                border: "none",
                cursor: "pointer",
                padding: "2px",
                display: "flex",
                alignItems: "center",
                borderRadius: "50%",
                transition: "background-color 150ms"
              },
              onMouseEnter: (e) => {
                e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
              },
              onMouseLeave: (e) => {
                e.currentTarget.style.backgroundColor = "transparent";
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 12 })
            }
          )
        ]
      },
      item
    )) });
  }
  function TogglePill({
    label,
    isActive,
    onClick
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick,
        style: {
          padding: "10px 16px",
          backgroundColor: isActive ? "#0077B5" : "rgba(0, 0, 0, 0.05)",
          color: isActive ? "white" : "#1d1d1f",
          border: isActive ? "2px solid #0077B5" : "2px solid transparent",
          borderRadius: "20px",
          fontSize: "14px",
          fontWeight: "500",
          cursor: "pointer",
          transition: "all 150ms",
          whiteSpace: "nowrap"
        },
        onMouseEnter: (e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.08)";
          } else {
            e.currentTarget.style.backgroundColor = "#005885";
          }
        },
        onMouseLeave: (e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.05)";
          } else {
            e.currentTarget.style.backgroundColor = "#0077B5";
          }
        },
        children: label
      }
    );
  }
  content;
  function LoadingSpinner({
    size = 20,
    color = COLORS.accent.default,
    className = ""
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RefreshCw,
      {
        size,
        color,
        className: `animate-spin ${className}`
      }
    );
  }
  content;
  function Toggle({ label, checked, onChange, disabled = false }) {
    const trackRef = reactExports.useRef(null);
    const thumbRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      if (trackRef.current) {
        const bgColor = checked ? COLORS.accent.default : COLORS.background.tertiary;
        trackRef.current.style.backgroundColor = bgColor;
        trackRef.current.setAttribute("data-checked", String(checked));
      }
      if (thumbRef.current) {
        const leftPos = checked ? "22px" : "2px";
        thumbRef.current.style.left = leftPos;
      }
    }, [checked]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "label",
      {
        style: {
          display: "flex",
          alignItems: "center",
          gap: `${SPACING.sm}px`,
          cursor: disabled ? "not-allowed" : "pointer",
          userSelect: "none",
          opacity: disabled ? 0.5 : 1
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              ref: trackRef,
              onClick: disabled ? void 0 : onChange,
              role: "switch",
              "aria-checked": checked,
              "aria-label": label,
              tabIndex: disabled ? -1 : 0,
              "data-toggle-track": true,
              "data-checked": checked,
              onKeyDown: (e) => {
                if (!disabled && (e.key === "Enter" || e.key === " ")) {
                  e.preventDefault();
                  onChange();
                }
              },
              style: {
                width: "44px",
                height: "24px",
                backgroundColor: checked ? COLORS.accent.default : COLORS.background.tertiary,
                borderRadius: `${SPACING.sm}px`,
                position: "relative",
                transition: `background-color ${TRANSITIONS.duration.normal}ms ${TRANSITIONS.easing.standardStr}`,
                cursor: disabled ? "not-allowed" : "pointer"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  ref: thumbRef,
                  "data-toggle-thumb": true,
                  style: {
                    width: "20px",
                    height: "20px",
                    backgroundColor: COLORS.background.primary,
                    borderRadius: "50%",
                    position: "absolute",
                    top: "2px",
                    left: checked ? "22px" : "2px",
                    transition: `left ${TRANSITIONS.duration.normal}ms ${TRANSITIONS.easing.standardStr}`,
                    boxShadow: SHADOWS.sm
                  }
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                fontSize: `${TYPOGRAPHY.fontSize.base}px`,
                fontWeight: TYPOGRAPHY.fontWeight.medium,
                color: COLORS.text.primary
              },
              children: label
            }
          )
        ]
      }
    );
  }
  content;
  function Checkbox({
    label,
    description,
    checked,
    onChange,
    disabled = false
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "label",
      {
        style: {
          display: "flex",
          alignItems: "flex-start",
          gap: `${SPACING.xs + 2}px`,
          cursor: disabled ? "not-allowed" : "pointer",
          padding: `${SPACING.xs}px`,
          borderRadius: `${RADIUS.sm}px`,
          transition: `background-color ${TRANSITIONS.duration.normal}ms ${TRANSITIONS.easing.standardStr}`,
          opacity: disabled ? 0.5 : 1
        },
        onMouseEnter: (e) => {
          if (!disabled) {
            e.currentTarget.style.backgroundColor = COLORS.background.hover;
          }
        },
        onMouseLeave: (e) => {
          e.currentTarget.style.backgroundColor = "transparent";
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked,
              onChange: disabled ? void 0 : onChange,
              disabled,
              style: {
                width: "18px",
                height: "18px",
                marginTop: "2px",
                cursor: disabled ? "not-allowed" : "pointer",
                accentColor: COLORS.accent.default
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  fontSize: `${TYPOGRAPHY.fontSize.base}px`,
                  fontWeight: TYPOGRAPHY.fontWeight.medium,
                  color: COLORS.text.primary,
                  marginBottom: description ? "2px" : 0
                },
                children: label
              }
            ),
            description && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  fontSize: `${TYPOGRAPHY.fontSize.sm}px`,
                  color: COLORS.text.tertiary
                },
                children: description
              }
            )
          ] })
        ]
      }
    );
  }
  content;
  function RadioButton({
    label,
    checked,
    onChange,
    disabled = false
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "label",
      {
        style: {
          display: "flex",
          alignItems: "center",
          gap: `${SPACING.xs + 2}px`,
          cursor: disabled ? "not-allowed" : "pointer",
          padding: `${SPACING.xs}px`,
          borderRadius: `${RADIUS.sm}px`,
          transition: `background-color ${TRANSITIONS.duration.normal}ms ${TRANSITIONS.easing.standardStr}`,
          opacity: disabled ? 0.5 : 1
        },
        onMouseEnter: (e) => {
          if (!disabled) {
            e.currentTarget.style.backgroundColor = COLORS.background.hover;
          }
        },
        onMouseLeave: (e) => {
          e.currentTarget.style.backgroundColor = "transparent";
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "radio",
              checked,
              onChange: disabled ? void 0 : onChange,
              disabled,
              style: {
                width: "18px",
                height: "18px",
                cursor: disabled ? "not-allowed" : "pointer",
                accentColor: COLORS.accent.default
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                fontSize: `${TYPOGRAPHY.fontSize.base}px`,
                fontWeight: TYPOGRAPHY.fontWeight.medium,
                color: COLORS.text.primary
              },
              children: label
            }
          )
        ]
      }
    );
  }
  content;
  content;
  content;
  content;
  content;
  content;
  function NotificationSettings({ panelWidth = 400 }) {
    const textColor = "#1d1d1f";
    const accentColor = "#0077B5";
    const notifications = useSettingsStore((state) => state.notifications);
    const updateNotifications = useSettingsStore((state) => state.updateNotifications);
    const loadSettings = useSettingsStore((state) => state.loadSettings);
    const [localNotifications, setLocalNotifications] = reactExports.useState(notifications);
    const [isLoading, setIsLoading] = reactExports.useState(true);
    const [isSaving, setIsSaving] = reactExports.useState(false);
    const [saveMessage, setSaveMessage] = reactExports.useState(null);
    const [emailAddress, setEmailAddress] = reactExports.useState("");
    const [phoneNumber, setPhoneNumber] = reactExports.useState("");
    const isCompact = panelWidth < 380;
    reactExports.useEffect(() => {
      async function loadNotificationSettings() {
        try {
          await loadSettings();
          setIsLoading(false);
        } catch (error) {
          console.error("[Uproot] Error loading notification settings:", error);
          setIsLoading(false);
        }
      }
      loadNotificationSettings();
    }, [loadSettings]);
    reactExports.useEffect(() => {
      setLocalNotifications(notifications);
    }, [notifications]);
    const handleSave = reactExports.useCallback(async () => {
      setIsSaving(true);
      setSaveMessage(null);
      try {
        await updateNotifications(localNotifications);
        setSaveMessage("âœ“ Notification preferences saved successfully!");
        setTimeout(() => setSaveMessage(null), 3e3);
      } catch (error) {
        console.error("[Uproot] Error saving notification preferences:", error);
        setSaveMessage("âœ— Failed to save preferences");
      } finally {
        setIsSaving(false);
      }
    }, [localNotifications, updateNotifications]);
    const toggleEmailEnabled = reactExports.useCallback(() => {
      setLocalNotifications((prev) => ({
        ...prev,
        email: {
          ...prev.email,
          enabled: !prev.email.enabled
        }
      }));
    }, []);
    const toggleEmailType = reactExports.useCallback((type) => {
      setLocalNotifications((prev) => ({
        ...prev,
        email: {
          ...prev.email,
          types: prev.email.types.includes(type) ? prev.email.types.filter((t) => t !== type) : [...prev.email.types, type]
        }
      }));
    }, []);
    const updateEmailFrequency = reactExports.useCallback((frequency) => {
      setLocalNotifications((prev) => ({
        ...prev,
        email: {
          ...prev.email,
          frequency
        }
      }));
    }, []);
    const toggleSMSEnabled = reactExports.useCallback(() => {
      setLocalNotifications((prev) => ({
        ...prev,
        sms: {
          ...prev.sms,
          enabled: !prev.sms.enabled
        }
      }));
    }, []);
    const toggleSMSType = reactExports.useCallback((type) => {
      setLocalNotifications((prev) => ({
        ...prev,
        sms: {
          ...prev.sms,
          types: prev.sms.types.includes(type) ? prev.sms.types.filter((t) => t !== type) : [...prev.sms.types, type]
        }
      }));
    }, []);
    const togglePushEnabled = reactExports.useCallback(() => {
      setLocalNotifications((prev) => ({
        ...prev,
        push: {
          ...prev.push,
          enabled: !prev.push.enabled
        }
      }));
    }, []);
    const togglePushType = reactExports.useCallback((type) => {
      setLocalNotifications((prev) => ({
        ...prev,
        push: {
          ...prev.push,
          types: prev.push.types.includes(type) ? prev.push.types.filter((t) => t !== type) : [...prev.push.types, type]
        }
      }));
    }, []);
    const notificationTypes = [
      { value: "job_alert", label: "Job Alerts", description: "New jobs matching your preferences" },
      { value: "connection_accepted", label: "Connections", description: "When someone accepts your connection" },
      { value: "message_follow_up", label: "Follow-ups", description: "Message reminders and follow-ups" },
      { value: "activity_update", label: "Activity", description: "Watchlist activity updates" },
      { value: "system", label: "System", description: "Important system notifications" }
    ];
    const emailFrequencies = [
      { value: "instant", label: "Instant" },
      { value: "daily", label: "Daily Digest" },
      { value: "weekly", label: "Weekly Digest" }
    ];
    if (isLoading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: "400px"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: 32 })
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          height: "100%",
          overflow: "auto",
          padding: isCompact ? "16px" : "20px",
          maxWidth: "600px"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "24px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "h2",
              {
                style: {
                  fontSize: "20px",
                  fontWeight: "700",
                  margin: "0 0 8px 0",
                  color: textColor
                },
                children: "Notification Preferences"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "13px", color: textColor, opacity: 0.6, margin: 0 }, children: "Choose how you want to be notified about important updates" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Section$1, { title: "Email Notifications", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Mail, { size: 18, color: accentColor }), textColor, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Toggle,
              {
                label: "Enable email notifications",
                checked: localNotifications.email.enabled,
                onChange: toggleEmailEnabled
              }
            ) }),
            localNotifications.email.enabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "label",
                  {
                    style: {
                      display: "block",
                      fontSize: "13px",
                      fontWeight: "600",
                      marginBottom: "6px",
                      color: textColor
                    },
                    children: "Email Address"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "email",
                    value: emailAddress,
                    onChange: (e) => setEmailAddress(e.target.value),
                    placeholder: "your.email@example.com",
                    style: {
                      width: "100%",
                      padding: "10px 12px",
                      border: `1px solid ${textColor}20`,
                      borderRadius: "8px",
                      fontSize: "13px",
                      fontFamily: "inherit",
                      color: textColor,
                      backgroundColor: "transparent"
                    }
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "label",
                  {
                    style: {
                      display: "block",
                      fontSize: "13px",
                      fontWeight: "600",
                      marginBottom: "8px",
                      color: textColor
                    },
                    children: "Notify me about"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: notificationTypes.map((type) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Checkbox,
                  {
                    label: type.label,
                    description: type.description,
                    checked: localNotifications.email.types.includes(type.value),
                    onChange: () => toggleEmailType(type.value)
                  },
                  type.value
                )) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "label",
                  {
                    style: {
                      display: "block",
                      fontSize: "13px",
                      fontWeight: "600",
                      marginBottom: "8px",
                      color: textColor
                    },
                    children: "Email Frequency"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: emailFrequencies.map((freq) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  RadioButton,
                  {
                    label: freq.label,
                    checked: localNotifications.email.frequency === freq.value,
                    onChange: () => updateEmailFrequency(freq.value)
                  },
                  freq.value
                )) })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Section$1, { title: "SMS Notifications", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSquare, { size: 18, color: accentColor }), textColor, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Toggle,
              {
                label: "Enable SMS notifications",
                checked: localNotifications.sms.enabled,
                onChange: toggleSMSEnabled
              }
            ) }),
            localNotifications.sms.enabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "label",
                  {
                    style: {
                      display: "block",
                      fontSize: "13px",
                      fontWeight: "600",
                      marginBottom: "6px",
                      color: textColor
                    },
                    children: "Phone Number"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "tel",
                    value: phoneNumber,
                    onChange: (e) => setPhoneNumber(e.target.value),
                    placeholder: "+1 (555) 123-4567",
                    style: {
                      width: "100%",
                      padding: "10px 12px",
                      border: `1px solid ${textColor}20`,
                      borderRadius: "8px",
                      fontSize: "13px",
                      fontFamily: "inherit",
                      color: textColor,
                      backgroundColor: "transparent"
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "11px", color: `${textColor}80`, margin: "4px 0 0 0" }, children: "Standard messaging rates may apply" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "label",
                  {
                    style: {
                      display: "block",
                      fontSize: "13px",
                      fontWeight: "600",
                      marginBottom: "8px",
                      color: textColor
                    },
                    children: "Notify me about"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: notificationTypes.filter((t) => ["job_alert", "connection_accepted"].includes(t.value)).map((type) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Checkbox,
                  {
                    label: type.label,
                    description: type.description,
                    checked: localNotifications.sms.types.includes(type.value),
                    onChange: () => toggleSMSType(type.value)
                  },
                  type.value
                )) })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Section$1, { title: "Push Notifications", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Bell, { size: 18, color: accentColor }), textColor, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Toggle,
              {
                label: "Enable browser notifications",
                checked: localNotifications.push.enabled,
                onChange: togglePushEnabled
              }
            ) }),
            localNotifications.push.enabled && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "label",
                {
                  style: {
                    display: "block",
                    fontSize: "13px",
                    fontWeight: "600",
                    marginBottom: "8px",
                    color: "#1d1d1f"
                  },
                  children: "Notify me about"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: notificationTypes.map((type) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Checkbox,
                {
                  label: type.label,
                  description: type.description,
                  checked: localNotifications.push.types.includes(type.value),
                  onChange: () => togglePushType(type.value)
                },
                type.value
              )) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: `${SPACING.xl}px` }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                onClick: handleSave,
                disabled: isSaving,
                fullWidth: true,
                icon: isSaving ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: 16, color: COLORS.text.inverse }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Save, { size: 16 }),
                children: isSaving ? "Saving..." : "Save Preferences"
              }
            ),
            saveMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  marginTop: "12px",
                  padding: "12px",
                  backgroundColor: saveMessage.startsWith("âœ“") ? "#E8F5E9" : "#FFEBEE",
                  color: saveMessage.startsWith("âœ“") ? "#2E7D32" : "#C62828",
                  borderRadius: "8px",
                  fontSize: "13px",
                  textAlign: "center"
                },
                children: saveMessage
              }
            )
          ] })
        ]
      }
    );
  }
  function Section$1({ title, icon, children, textColor }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          marginBottom: `${SPACING.xl}px`,
          padding: `${SPACING.lg}px`,
          backgroundColor: `${textColor}08`,
          backdropFilter: "blur(10px)",
          WebkitBackdropFilter: "blur(10px)",
          borderRadius: `${RADIUS.lg}px`,
          border: `1px solid ${COLORS.border.default}`,
          boxShadow: SHADOWS.md
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: `${SPACING.xs}px`, marginBottom: `${SPACING.md}px` }, children: [
            icon,
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "h3",
              {
                style: {
                  fontSize: `${TYPOGRAPHY.fontSize.lg}px`,
                  fontWeight: TYPOGRAPHY.fontWeight.semibold,
                  margin: 0,
                  color: textColor
                },
                children: title
              }
            )
          ] }),
          children
        ]
      }
    );
  }
  content;
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function() {
    __assign = Object.assign || function __assign2(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
    return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  }
  function __param(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result2 = (0, decorators[i])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result2 === void 0) continue;
        if (result2 === null || typeof result2 !== "object") throw new TypeError("Object expected");
        if (_ = accept(result2.get)) descriptor.get = _;
        if (_ = accept(result2.set)) descriptor.set = _;
        if (_ = accept(result2.init)) initializers.unshift(_);
      } else if (_ = accept(result2)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  }
  function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  }
  function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
  }
  function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r2, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r2[k] = a[j];
    return r2;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function awaitReturn(f) {
      return function(v) {
        return Promise.resolve(v).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
        if (f) i[n] = f(i[n]);
      }
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r2) {
      r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  };
  var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function(o2) {
      var ar = [];
      for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
      return ar;
    };
    return ownKeys(o);
  };
  function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result2 = {};
    if (mod != null) {
      for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
    }
    __setModuleDefault(result2, mod);
    return result2;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  }
  function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
  }
  function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async });
    } else if (async) {
      env.stack.push({ async: true });
    }
    return value;
  }
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  function __disposeResources(env) {
    function fail(e) {
      env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r2, s = 0;
    function next() {
      while (r2 = env.stack.pop()) {
        try {
          if (!r2.async && s === 1) return s = 0, env.stack.push(r2), Promise.resolve().then(next);
          if (r2.dispose) {
            var result2 = r2.dispose.call(r2.value);
            if (r2.async) return s |= 2, Promise.resolve(result2).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  }
  function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
        return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
      });
    }
    return path;
  }
  const tslib_es6 = {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __esDecorate,
    __runInitializers,
    __propKey,
    __setFunctionName,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
    __rewriteRelativeImportExtension
  };
  const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    __addDisposableResource,
    get __assign() {
      return __assign;
    },
    __asyncDelegator,
    __asyncGenerator,
    __asyncValues,
    __await,
    __awaiter,
    __classPrivateFieldGet,
    __classPrivateFieldIn,
    __classPrivateFieldSet,
    __createBinding,
    __decorate,
    __disposeResources,
    __esDecorate,
    __exportStar,
    __extends,
    __generator,
    __importDefault,
    __importStar,
    __makeTemplateObject,
    __metadata,
    __param,
    __propKey,
    __read,
    __rest,
    __rewriteRelativeImportExtension,
    __runInitializers,
    __setFunctionName,
    __spread,
    __spreadArray,
    __spreadArrays,
    __values,
    default: tslib_es6
  }, Symbol.toStringTag, { value: "Module" }));
  const resolveFetch$4 = (customFetch) => {
    if (customFetch) {
      return (...args) => customFetch(...args);
    }
    return (...args) => fetch(...args);
  };
  class FunctionsError extends Error {
    constructor(message, name = "FunctionsError", context) {
      super(message);
      this.name = name;
      this.context = context;
    }
  }
  class FunctionsFetchError extends FunctionsError {
    constructor(context) {
      super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
    }
  }
  class FunctionsRelayError extends FunctionsError {
    constructor(context) {
      super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
    }
  }
  class FunctionsHttpError extends FunctionsError {
    constructor(context) {
      super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
    }
  }
  var FunctionRegion;
  (function(FunctionRegion2) {
    FunctionRegion2["Any"] = "any";
    FunctionRegion2["ApNortheast1"] = "ap-northeast-1";
    FunctionRegion2["ApNortheast2"] = "ap-northeast-2";
    FunctionRegion2["ApSouth1"] = "ap-south-1";
    FunctionRegion2["ApSoutheast1"] = "ap-southeast-1";
    FunctionRegion2["ApSoutheast2"] = "ap-southeast-2";
    FunctionRegion2["CaCentral1"] = "ca-central-1";
    FunctionRegion2["EuCentral1"] = "eu-central-1";
    FunctionRegion2["EuWest1"] = "eu-west-1";
    FunctionRegion2["EuWest2"] = "eu-west-2";
    FunctionRegion2["EuWest3"] = "eu-west-3";
    FunctionRegion2["SaEast1"] = "sa-east-1";
    FunctionRegion2["UsEast1"] = "us-east-1";
    FunctionRegion2["UsWest1"] = "us-west-1";
    FunctionRegion2["UsWest2"] = "us-west-2";
  })(FunctionRegion || (FunctionRegion = {}));
  class FunctionsClient {
    /**
     * Creates a new Functions client bound to an Edge Functions URL.
     *
     * @example
     * ```ts
     * import { FunctionsClient, FunctionRegion } from '@supabase/functions-js'
     *
     * const functions = new FunctionsClient('https://xyzcompany.supabase.co/functions/v1', {
     *   headers: { apikey: 'public-anon-key' },
     *   region: FunctionRegion.UsEast1,
     * })
     * ```
     */
    constructor(url, { headers = {}, customFetch, region = FunctionRegion.Any } = {}) {
      this.url = url;
      this.headers = headers;
      this.region = region;
      this.fetch = resolveFetch$4(customFetch);
    }
    /**
     * Updates the authorization header
     * @param token - the new jwt token sent in the authorisation header
     * @example
     * ```ts
     * functions.setAuth(session.access_token)
     * ```
     */
    setAuth(token) {
      this.headers.Authorization = `Bearer ${token}`;
    }
    /**
     * Invokes a function
     * @param functionName - The name of the Function to invoke.
     * @param options - Options for invoking the Function.
     * @example
     * ```ts
     * const { data, error } = await functions.invoke('hello-world', {
     *   body: { name: 'Ada' },
     * })
     * ```
     */
    invoke(functionName_1) {
      return __awaiter(this, arguments, void 0, function* (functionName, options = {}) {
        var _a2;
        let timeoutId;
        let timeoutController;
        try {
          const { headers, method, body: functionArgs, signal, timeout } = options;
          let _headers = {};
          let { region } = options;
          if (!region) {
            region = this.region;
          }
          const url = new URL(`${this.url}/${functionName}`);
          if (region && region !== "any") {
            _headers["x-region"] = region;
            url.searchParams.set("forceFunctionRegion", region);
          }
          let body;
          if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers)) {
            if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
              _headers["Content-Type"] = "application/octet-stream";
              body = functionArgs;
            } else if (typeof functionArgs === "string") {
              _headers["Content-Type"] = "text/plain";
              body = functionArgs;
            } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) {
              body = functionArgs;
            } else {
              _headers["Content-Type"] = "application/json";
              body = JSON.stringify(functionArgs);
            }
          } else {
            body = functionArgs;
          }
          let effectiveSignal = signal;
          if (timeout) {
            timeoutController = new AbortController();
            timeoutId = setTimeout(() => timeoutController.abort(), timeout);
            if (signal) {
              effectiveSignal = timeoutController.signal;
              signal.addEventListener("abort", () => timeoutController.abort());
            } else {
              effectiveSignal = timeoutController.signal;
            }
          }
          const response = yield this.fetch(url.toString(), {
            method: method || "POST",
            // headers priority is (high to low):
            // 1. invoke-level headers
            // 2. client-level headers
            // 3. default Content-Type header
            headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
            body,
            signal: effectiveSignal
          }).catch((fetchError) => {
            throw new FunctionsFetchError(fetchError);
          });
          const isRelayError = response.headers.get("x-relay-error");
          if (isRelayError && isRelayError === "true") {
            throw new FunctionsRelayError(response);
          }
          if (!response.ok) {
            throw new FunctionsHttpError(response);
          }
          let responseType = ((_a2 = response.headers.get("Content-Type")) !== null && _a2 !== void 0 ? _a2 : "text/plain").split(";")[0].trim();
          let data;
          if (responseType === "application/json") {
            data = yield response.json();
          } else if (responseType === "application/octet-stream" || responseType === "application/pdf") {
            data = yield response.blob();
          } else if (responseType === "text/event-stream") {
            data = response;
          } else if (responseType === "multipart/form-data") {
            data = yield response.formData();
          } else {
            data = yield response.text();
          }
          return { data, error: null, response };
        } catch (error) {
          return {
            data: null,
            error,
            response: error instanceof FunctionsHttpError || error instanceof FunctionsRelayError ? error.context : void 0
          };
        } finally {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
        }
      });
    }
  }
  var cjs = {};
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
  var PostgrestClient$1 = {};
  var PostgrestQueryBuilder$1 = {};
  var PostgrestFilterBuilder$1 = {};
  var PostgrestTransformBuilder$1 = {};
  var PostgrestBuilder$1 = {};
  var PostgrestError$1 = {};
  var hasRequiredPostgrestError;
  function requirePostgrestError() {
    if (hasRequiredPostgrestError) return PostgrestError$1;
    hasRequiredPostgrestError = 1;
    Object.defineProperty(PostgrestError$1, "__esModule", { value: true });
    class PostgrestError2 extends Error {
      /**
       * @example
       * ```ts
       * import PostgrestError from '@supabase/postgrest-js'
       *
       * throw new PostgrestError({
       *   message: 'Row level security prevented the request',
       *   details: 'RLS denied the insert',
       *   hint: 'Check your policies',
       *   code: 'PGRST301',
       * })
       * ```
       */
      constructor(context) {
        super(context.message);
        this.name = "PostgrestError";
        this.details = context.details;
        this.hint = context.hint;
        this.code = context.code;
      }
    }
    PostgrestError$1.default = PostgrestError2;
    return PostgrestError$1;
  }
  var hasRequiredPostgrestBuilder;
  function requirePostgrestBuilder() {
    if (hasRequiredPostgrestBuilder) return PostgrestBuilder$1;
    hasRequiredPostgrestBuilder = 1;
    Object.defineProperty(PostgrestBuilder$1, "__esModule", { value: true });
    const tslib_1 = require$$0;
    const PostgrestError_1 = tslib_1.__importDefault(requirePostgrestError());
    class PostgrestBuilder2 {
      /**
       * Creates a builder configured for a specific PostgREST request.
       *
       * @example
       * ```ts
       * import PostgrestQueryBuilder from '@supabase/postgrest-js'
       *
       * const builder = new PostgrestQueryBuilder(
       *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),
       *   { headers: new Headers({ apikey: 'public-anon-key' }) }
       * )
       * ```
       */
      constructor(builder) {
        var _a2, _b;
        this.shouldThrowOnError = false;
        this.method = builder.method;
        this.url = builder.url;
        this.headers = new Headers(builder.headers);
        this.schema = builder.schema;
        this.body = builder.body;
        this.shouldThrowOnError = (_a2 = builder.shouldThrowOnError) !== null && _a2 !== void 0 ? _a2 : false;
        this.signal = builder.signal;
        this.isMaybeSingle = (_b = builder.isMaybeSingle) !== null && _b !== void 0 ? _b : false;
        if (builder.fetch) {
          this.fetch = builder.fetch;
        } else {
          this.fetch = fetch;
        }
      }
      /**
       * If there's an error with the query, throwOnError will reject the promise by
       * throwing the error instead of returning it as part of a successful response.
       *
       * {@link https://github.com/supabase/supabase-js/issues/92}
       */
      throwOnError() {
        this.shouldThrowOnError = true;
        return this;
      }
      /**
       * Set an HTTP header for the request.
       */
      setHeader(name, value) {
        this.headers = new Headers(this.headers);
        this.headers.set(name, value);
        return this;
      }
      then(onfulfilled, onrejected) {
        if (this.schema === void 0) ;
        else if (["GET", "HEAD"].includes(this.method)) {
          this.headers.set("Accept-Profile", this.schema);
        } else {
          this.headers.set("Content-Profile", this.schema);
        }
        if (this.method !== "GET" && this.method !== "HEAD") {
          this.headers.set("Content-Type", "application/json");
        }
        const _fetch = this.fetch;
        let res = _fetch(this.url.toString(), {
          method: this.method,
          headers: this.headers,
          body: JSON.stringify(this.body),
          signal: this.signal
        }).then(async (res2) => {
          var _a2, _b, _c, _d;
          let error = null;
          let data = null;
          let count = null;
          let status = res2.status;
          let statusText = res2.statusText;
          if (res2.ok) {
            if (this.method !== "HEAD") {
              const body = await res2.text();
              if (body === "") ;
              else if (this.headers.get("Accept") === "text/csv") {
                data = body;
              } else if (this.headers.get("Accept") && ((_a2 = this.headers.get("Accept")) === null || _a2 === void 0 ? void 0 : _a2.includes("application/vnd.pgrst.plan+text"))) {
                data = body;
              } else {
                data = JSON.parse(body);
              }
            }
            const countHeader = (_b = this.headers.get("Prefer")) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);
            const contentRange = (_c = res2.headers.get("content-range")) === null || _c === void 0 ? void 0 : _c.split("/");
            if (countHeader && contentRange && contentRange.length > 1) {
              count = parseInt(contentRange[1]);
            }
            if (this.isMaybeSingle && this.method === "GET" && Array.isArray(data)) {
              if (data.length > 1) {
                error = {
                  // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
                  code: "PGRST116",
                  details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                  hint: null,
                  message: "JSON object requested, multiple (or no) rows returned"
                };
                data = null;
                count = null;
                status = 406;
                statusText = "Not Acceptable";
              } else if (data.length === 1) {
                data = data[0];
              } else {
                data = null;
              }
            }
          } else {
            const body = await res2.text();
            try {
              error = JSON.parse(body);
              if (Array.isArray(error) && res2.status === 404) {
                data = [];
                error = null;
                status = 200;
                statusText = "OK";
              }
            } catch (_e) {
              if (res2.status === 404 && body === "") {
                status = 204;
                statusText = "No Content";
              } else {
                error = {
                  message: body
                };
              }
            }
            if (error && this.isMaybeSingle && ((_d = error === null || error === void 0 ? void 0 : error.details) === null || _d === void 0 ? void 0 : _d.includes("0 rows"))) {
              error = null;
              status = 200;
              statusText = "OK";
            }
            if (error && this.shouldThrowOnError) {
              throw new PostgrestError_1.default(error);
            }
          }
          const postgrestResponse = {
            error,
            data,
            count,
            status,
            statusText
          };
          return postgrestResponse;
        });
        if (!this.shouldThrowOnError) {
          res = res.catch((fetchError) => {
            var _a2, _b, _c, _d, _e, _f;
            let errorDetails = "";
            const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;
            if (cause) {
              const causeMessage = (_a2 = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _a2 !== void 0 ? _a2 : "";
              const causeCode = (_b = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _b !== void 0 ? _b : "";
              errorDetails = `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _c !== void 0 ? _c : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;
              errorDetails += `

Caused by: ${(_d = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _d !== void 0 ? _d : "Error"}: ${causeMessage}`;
              if (causeCode) {
                errorDetails += ` (${causeCode})`;
              }
              if (cause === null || cause === void 0 ? void 0 : cause.stack) {
                errorDetails += `
${cause.stack}`;
              }
            } else {
              errorDetails = (_e = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _e !== void 0 ? _e : "";
            }
            return {
              error: {
                message: `${(_f = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _f !== void 0 ? _f : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
                details: errorDetails,
                hint: "",
                code: ""
              },
              data: null,
              count: null,
              status: 0,
              statusText: ""
            };
          });
        }
        return res.then(onfulfilled, onrejected);
      }
      /**
       * Override the type of the returned `data`.
       *
       * @typeParam NewResult - The new result type to override with
       * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
       */
      returns() {
        return this;
      }
      /**
       * Override the type of the returned `data` field in the response.
       *
       * @typeParam NewResult - The new type to cast the response data to
       * @typeParam Options - Optional type configuration (defaults to { merge: true })
       * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)
       * @example
       * ```typescript
       * // Merge with existing types (default behavior)
       * const query = supabase
       *   .from('users')
       *   .select()
       *   .overrideTypes<{ custom_field: string }>()
       *
       * // Replace existing types completely
       * const replaceQuery = supabase
       *   .from('users')
       *   .select()
       *   .overrideTypes<{ id: number; name: string }, { merge: false }>()
       * ```
       * @returns A PostgrestBuilder instance with the new type
       */
      overrideTypes() {
        return this;
      }
    }
    PostgrestBuilder$1.default = PostgrestBuilder2;
    return PostgrestBuilder$1;
  }
  var hasRequiredPostgrestTransformBuilder;
  function requirePostgrestTransformBuilder() {
    if (hasRequiredPostgrestTransformBuilder) return PostgrestTransformBuilder$1;
    hasRequiredPostgrestTransformBuilder = 1;
    Object.defineProperty(PostgrestTransformBuilder$1, "__esModule", { value: true });
    const tslib_1 = require$$0;
    const PostgrestBuilder_1 = tslib_1.__importDefault(requirePostgrestBuilder());
    class PostgrestTransformBuilder2 extends PostgrestBuilder_1.default {
      /**
       * Perform a SELECT on the query result.
       *
       * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
       * return modified rows. By calling this method, modified rows are returned in
       * `data`.
       *
       * @param columns - The columns to retrieve, separated by commas
       */
      select(columns) {
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
          if (/\s/.test(c) && !quoted) {
            return "";
          }
          if (c === '"') {
            quoted = !quoted;
          }
          return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        this.headers.append("Prefer", "return=representation");
        return this;
      }
      /**
       * Order the query result by `column`.
       *
       * You can call this method multiple times to order by multiple columns.
       *
       * You can order referenced tables, but it only affects the ordering of the
       * parent table if you use `!inner` in the query.
       *
       * @param column - The column to order by
       * @param options - Named parameters
       * @param options.ascending - If `true`, the result will be in ascending order
       * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
       * `null`s appear last.
       * @param options.referencedTable - Set this to order a referenced table by
       * its columns
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.order` : "order";
        const existingOrder = this.url.searchParams.get(key);
        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column}.${ascending ? "asc" : "desc"}${nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
        return this;
      }
      /**
       * Limit the query result by `count`.
       *
       * @param count - The maximum number of rows to return
       * @param options - Named parameters
       * @param options.referencedTable - Set this to limit rows of referenced
       * tables instead of the parent table
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(key, `${count}`);
        return this;
      }
      /**
       * Limit the query result by starting at an offset `from` and ending at the offset `to`.
       * Only records within this range are returned.
       * This respects the query order and if there is no order clause the range could behave unexpectedly.
       * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
       * and fourth rows of the query.
       *
       * @param from - The starting index from which to limit the result
       * @param to - The last index to which to limit the result
       * @param options - Named parameters
       * @param options.referencedTable - Set this to limit rows of referenced
       * tables instead of the parent table
       * @param options.foreignTable - Deprecated, use `options.referencedTable`
       * instead
       */
      range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {
        const keyOffset = typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`;
        const keyLimit = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
        this.url.searchParams.set(keyOffset, `${from}`);
        this.url.searchParams.set(keyLimit, `${to - from + 1}`);
        return this;
      }
      /**
       * Set the AbortSignal for the fetch request.
       *
       * @param signal - The AbortSignal to use for the fetch request
       */
      abortSignal(signal) {
        this.signal = signal;
        return this;
      }
      /**
       * Return `data` as a single object instead of an array of objects.
       *
       * Query result must be one row (e.g. using `.limit(1)`), otherwise this
       * returns an error.
       */
      single() {
        this.headers.set("Accept", "application/vnd.pgrst.object+json");
        return this;
      }
      /**
       * Return `data` as a single object instead of an array of objects.
       *
       * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
       * this returns an error.
       */
      maybeSingle() {
        if (this.method === "GET") {
          this.headers.set("Accept", "application/json");
        } else {
          this.headers.set("Accept", "application/vnd.pgrst.object+json");
        }
        this.isMaybeSingle = true;
        return this;
      }
      /**
       * Return `data` as a string in CSV format.
       */
      csv() {
        this.headers.set("Accept", "text/csv");
        return this;
      }
      /**
       * Return `data` as an object in [GeoJSON](https://geojson.org) format.
       */
      geojson() {
        this.headers.set("Accept", "application/geo+json");
        return this;
      }
      /**
       * Return `data` as the EXPLAIN plan for the query.
       *
       * You need to enable the
       * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
       * setting before using this method.
       *
       * @param options - Named parameters
       *
       * @param options.analyze - If `true`, the query will be executed and the
       * actual run time will be returned
       *
       * @param options.verbose - If `true`, the query identifier will be returned
       * and `data` will include the output columns of the query
       *
       * @param options.settings - If `true`, include information on configuration
       * parameters that affect query planning
       *
       * @param options.buffers - If `true`, include information on buffer usage
       *
       * @param options.wal - If `true`, include information on WAL record generation
       *
       * @param options.format - The format of the output, can be `"text"` (default)
       * or `"json"`
       */
      explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
        var _a2;
        const options = [
          analyze ? "analyze" : null,
          verbose ? "verbose" : null,
          settings ? "settings" : null,
          buffers ? "buffers" : null,
          wal ? "wal" : null
        ].filter(Boolean).join("|");
        const forMediatype = (_a2 = this.headers.get("Accept")) !== null && _a2 !== void 0 ? _a2 : "application/json";
        this.headers.set("Accept", `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`);
        if (format === "json") {
          return this;
        } else {
          return this;
        }
      }
      /**
       * Rollback the query.
       *
       * `data` will still be returned, but the query is not committed.
       */
      rollback() {
        this.headers.append("Prefer", "tx=rollback");
        return this;
      }
      /**
       * Override the type of the returned `data`.
       *
       * @typeParam NewResult - The new result type to override with
       * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
       */
      returns() {
        return this;
      }
      /**
       * Set the maximum number of rows that can be affected by the query.
       * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.
       *
       * @param value - The maximum number of rows that can be affected
       */
      maxAffected(value) {
        this.headers.append("Prefer", "handling=strict");
        this.headers.append("Prefer", `max-affected=${value}`);
        return this;
      }
    }
    PostgrestTransformBuilder$1.default = PostgrestTransformBuilder2;
    return PostgrestTransformBuilder$1;
  }
  var hasRequiredPostgrestFilterBuilder;
  function requirePostgrestFilterBuilder() {
    if (hasRequiredPostgrestFilterBuilder) return PostgrestFilterBuilder$1;
    hasRequiredPostgrestFilterBuilder = 1;
    Object.defineProperty(PostgrestFilterBuilder$1, "__esModule", { value: true });
    const tslib_1 = require$$0;
    const PostgrestTransformBuilder_1 = tslib_1.__importDefault(requirePostgrestTransformBuilder());
    const PostgrestReservedCharsRegexp = new RegExp("[,()]");
    class PostgrestFilterBuilder2 extends PostgrestTransformBuilder_1.default {
      /**
       * Match only rows where `column` is equal to `value`.
       *
       * To check if the value of `column` is NULL, you should use `.is()` instead.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      eq(column, value) {
        this.url.searchParams.append(column, `eq.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is not equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      neq(column, value) {
        this.url.searchParams.append(column, `neq.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is greater than `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      gt(column, value) {
        this.url.searchParams.append(column, `gt.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is greater than or equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      gte(column, value) {
        this.url.searchParams.append(column, `gte.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is less than `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      lt(column, value) {
        this.url.searchParams.append(column, `lt.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is less than or equal to `value`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      lte(column, value) {
        this.url.searchParams.append(column, `lte.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` matches `pattern` case-sensitively.
       *
       * @param column - The column to filter on
       * @param pattern - The pattern to match with
       */
      like(column, pattern) {
        this.url.searchParams.append(column, `like.${pattern}`);
        return this;
      }
      /**
       * Match only rows where `column` matches all of `patterns` case-sensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      likeAllOf(column, patterns) {
        this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches any of `patterns` case-sensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      likeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches `pattern` case-insensitively.
       *
       * @param column - The column to filter on
       * @param pattern - The pattern to match with
       */
      ilike(column, pattern) {
        this.url.searchParams.append(column, `ilike.${pattern}`);
        return this;
      }
      /**
       * Match only rows where `column` matches all of `patterns` case-insensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      ilikeAllOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches any of `patterns` case-insensitively.
       *
       * @param column - The column to filter on
       * @param patterns - The patterns to match with
       */
      ilikeAnyOf(column, patterns) {
        this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
        return this;
      }
      /**
       * Match only rows where `column` matches the PostgreSQL regex `pattern`
       * case-sensitively (using the `~` operator).
       *
       * @param column - The column to filter on
       * @param pattern - The PostgreSQL regular expression pattern to match with
       */
      regexMatch(column, pattern) {
        this.url.searchParams.append(column, `match.${pattern}`);
        return this;
      }
      /**
       * Match only rows where `column` matches the PostgreSQL regex `pattern`
       * case-insensitively (using the `~*` operator).
       *
       * @param column - The column to filter on
       * @param pattern - The PostgreSQL regular expression pattern to match with
       */
      regexIMatch(column, pattern) {
        this.url.searchParams.append(column, `imatch.${pattern}`);
        return this;
      }
      /**
       * Match only rows where `column` IS `value`.
       *
       * For non-boolean columns, this is only relevant for checking if the value of
       * `column` is NULL by setting `value` to `null`.
       *
       * For boolean columns, you can also set `value` to `true` or `false` and it
       * will behave the same way as `.eq()`.
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      is(column, value) {
        this.url.searchParams.append(column, `is.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` IS DISTINCT FROM `value`.
       *
       * Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values
       * are considered equal (not distinct), and comparing `NULL` with any non-NULL
       * value returns true (distinct).
       *
       * @param column - The column to filter on
       * @param value - The value to filter with
       */
      isDistinct(column, value) {
        this.url.searchParams.append(column, `isdistinct.${value}`);
        return this;
      }
      /**
       * Match only rows where `column` is included in the `values` array.
       *
       * @param column - The column to filter on
       * @param values - The values array to filter with
       */
      in(column, values) {
        const cleanedValues = Array.from(new Set(values)).map((s) => {
          if (typeof s === "string" && PostgrestReservedCharsRegexp.test(s))
            return `"${s}"`;
          else
            return `${s}`;
        }).join(",");
        this.url.searchParams.append(column, `in.(${cleanedValues})`);
        return this;
      }
      /**
       * Only relevant for jsonb, array, and range columns. Match only rows where
       * `column` contains every element appearing in `value`.
       *
       * @param column - The jsonb, array, or range column to filter on
       * @param value - The jsonb, array, or range value to filter with
       */
      contains(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `cs.${value}`);
        } else if (Array.isArray(value)) {
          this.url.searchParams.append(column, `cs.{${value.join(",")}}`);
        } else {
          this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
        }
        return this;
      }
      /**
       * Only relevant for jsonb, array, and range columns. Match only rows where
       * every element appearing in `column` is contained by `value`.
       *
       * @param column - The jsonb, array, or range column to filter on
       * @param value - The jsonb, array, or range value to filter with
       */
      containedBy(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `cd.${value}`);
        } else if (Array.isArray(value)) {
          this.url.searchParams.append(column, `cd.{${value.join(",")}}`);
        } else {
          this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
        }
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is greater than any element in `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeGt(column, range) {
        this.url.searchParams.append(column, `sr.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is either contained in `range` or greater than any element in
       * `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeGte(column, range) {
        this.url.searchParams.append(column, `nxl.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is less than any element in `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeLt(column, range) {
        this.url.searchParams.append(column, `sl.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where every element in
       * `column` is either contained in `range` or less than any element in
       * `range`.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeLte(column, range) {
        this.url.searchParams.append(column, `nxr.${range}`);
        return this;
      }
      /**
       * Only relevant for range columns. Match only rows where `column` is
       * mutually exclusive to `range` and there can be no element between the two
       * ranges.
       *
       * @param column - The range column to filter on
       * @param range - The range to filter with
       */
      rangeAdjacent(column, range) {
        this.url.searchParams.append(column, `adj.${range}`);
        return this;
      }
      /**
       * Only relevant for array and range columns. Match only rows where
       * `column` and `value` have an element in common.
       *
       * @param column - The array or range column to filter on
       * @param value - The array or range value to filter with
       */
      overlaps(column, value) {
        if (typeof value === "string") {
          this.url.searchParams.append(column, `ov.${value}`);
        } else {
          this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
        }
        return this;
      }
      /**
       * Only relevant for text and tsvector columns. Match only rows where
       * `column` matches the query string in `query`.
       *
       * @param column - The text or tsvector column to filter on
       * @param query - The query text to match with
       * @param options - Named parameters
       * @param options.config - The text search configuration to use
       * @param options.type - Change how the `query` text is interpreted
       */
      textSearch(column, query, { config, type } = {}) {
        let typePart = "";
        if (type === "plain") {
          typePart = "pl";
        } else if (type === "phrase") {
          typePart = "ph";
        } else if (type === "websearch") {
          typePart = "w";
        }
        const configPart = config === void 0 ? "" : `(${config})`;
        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
        return this;
      }
      /**
       * Match only rows where each column in `query` keys is equal to its
       * associated value. Shorthand for multiple `.eq()`s.
       *
       * @param query - The object to filter with, with column names as keys mapped
       * to their filter values
       */
      match(query) {
        Object.entries(query).forEach(([column, value]) => {
          this.url.searchParams.append(column, `eq.${value}`);
        });
        return this;
      }
      /**
       * Match only rows which doesn't satisfy the filter.
       *
       * Unlike most filters, `opearator` and `value` are used as-is and need to
       * follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure they are properly sanitized.
       *
       * @param column - The column to filter on
       * @param operator - The operator to be negated to filter with, following
       * PostgREST syntax
       * @param value - The value to filter with, following PostgREST syntax
       */
      not(column, operator, value) {
        this.url.searchParams.append(column, `not.${operator}.${value}`);
        return this;
      }
      /**
       * Match only rows which satisfy at least one of the filters.
       *
       * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure it's properly sanitized.
       *
       * It's currently not possible to do an `.or()` filter across multiple tables.
       *
       * @param filters - The filters to use, following PostgREST syntax
       * @param options - Named parameters
       * @param options.referencedTable - Set this to filter on referenced tables
       * instead of the parent table
       * @param options.foreignTable - Deprecated, use `referencedTable` instead
       */
      or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
        const key = referencedTable ? `${referencedTable}.or` : "or";
        this.url.searchParams.append(key, `(${filters})`);
        return this;
      }
      /**
       * Match only rows which satisfy the filter. This is an escape hatch - you
       * should use the specific filter methods wherever possible.
       *
       * Unlike most filters, `opearator` and `value` are used as-is and need to
       * follow [PostgREST
       * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
       * to make sure they are properly sanitized.
       *
       * @param column - The column to filter on
       * @param operator - The operator to filter with, following PostgREST syntax
       * @param value - The value to filter with, following PostgREST syntax
       */
      filter(column, operator, value) {
        this.url.searchParams.append(column, `${operator}.${value}`);
        return this;
      }
    }
    PostgrestFilterBuilder$1.default = PostgrestFilterBuilder2;
    return PostgrestFilterBuilder$1;
  }
  var hasRequiredPostgrestQueryBuilder;
  function requirePostgrestQueryBuilder() {
    if (hasRequiredPostgrestQueryBuilder) return PostgrestQueryBuilder$1;
    hasRequiredPostgrestQueryBuilder = 1;
    Object.defineProperty(PostgrestQueryBuilder$1, "__esModule", { value: true });
    const tslib_1 = require$$0;
    const PostgrestFilterBuilder_1 = tslib_1.__importDefault(requirePostgrestFilterBuilder());
    class PostgrestQueryBuilder2 {
      /**
       * Creates a query builder scoped to a Postgres table or view.
       *
       * @example
       * ```ts
       * import PostgrestQueryBuilder from '@supabase/postgrest-js'
       *
       * const query = new PostgrestQueryBuilder(
       *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),
       *   { headers: { apikey: 'public-anon-key' } }
       * )
       * ```
       */
      constructor(url, { headers = {}, schema, fetch: fetch2 }) {
        this.url = url;
        this.headers = new Headers(headers);
        this.schema = schema;
        this.fetch = fetch2;
      }
      /**
       * Perform a SELECT query on the table or view.
       *
       * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
       *
       * @param options - Named parameters
       *
       * @param options.head - When set to `true`, `data` will not be returned.
       * Useful if you only need the count.
       *
       * @param options.count - Count algorithm to use to count rows in the table or view.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      select(columns, options) {
        const { head: head2 = false, count } = options !== null && options !== void 0 ? options : {};
        const method = head2 ? "HEAD" : "GET";
        let quoted = false;
        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
          if (/\s/.test(c) && !quoted) {
            return "";
          }
          if (c === '"') {
            quoted = !quoted;
          }
          return c;
        }).join("");
        this.url.searchParams.set("select", cleanedColumns);
        if (count) {
          this.headers.append("Prefer", `count=${count}`);
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch
        });
      }
      /**
       * Perform an INSERT into the table or view.
       *
       * By default, inserted rows are not returned. To return it, chain the call
       * with `.select()`.
       *
       * @param values - The values to insert. Pass an object to insert a single row
       * or an array to insert multiple rows.
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count inserted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       *
       * @param options.defaultToNull - Make missing fields default to `null`.
       * Otherwise, use the default value for the column. Only applies for bulk
       * inserts.
       */
      insert(values, { count, defaultToNull = true } = {}) {
        var _a2;
        const method = "POST";
        if (count) {
          this.headers.append("Prefer", `count=${count}`);
        }
        if (!defaultToNull) {
          this.headers.append("Prefer", `missing=default`);
        }
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            this.url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
        });
      }
      /**
       * Perform an UPSERT on the table or view. Depending on the column(s) passed
       * to `onConflict`, `.upsert()` allows you to perform the equivalent of
       * `.insert()` if a row with the corresponding `onConflict` columns doesn't
       * exist, or if it does exist, perform an alternative action depending on
       * `ignoreDuplicates`.
       *
       * By default, upserted rows are not returned. To return it, chain the call
       * with `.select()`.
       *
       * @param values - The values to upsert with. Pass an object to upsert a
       * single row or an array to upsert multiple rows.
       *
       * @param options - Named parameters
       *
       * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
       * duplicate rows are determined. Two rows are duplicates if all the
       * `onConflict` columns are equal.
       *
       * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
       * `false`, duplicate rows are merged with existing rows.
       *
       * @param options.count - Count algorithm to use to count upserted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       *
       * @param options.defaultToNull - Make missing fields default to `null`.
       * Otherwise, use the default value for the column. This only applies when
       * inserting new rows, not when merging with existing rows under
       * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
       */
      upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
        var _a2;
        const method = "POST";
        this.headers.append("Prefer", `resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`);
        if (onConflict !== void 0)
          this.url.searchParams.set("on_conflict", onConflict);
        if (count) {
          this.headers.append("Prefer", `count=${count}`);
        }
        if (!defaultToNull) {
          this.headers.append("Prefer", "missing=default");
        }
        if (Array.isArray(values)) {
          const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
          if (columns.length > 0) {
            const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
            this.url.searchParams.set("columns", uniqueColumns.join(","));
          }
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
        });
      }
      /**
       * Perform an UPDATE on the table or view.
       *
       * By default, updated rows are not returned. To return it, chain the call
       * with `.select()` after filters.
       *
       * @param values - The values to update with
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count updated rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      update(values, { count } = {}) {
        var _a2;
        const method = "PATCH";
        if (count) {
          this.headers.append("Prefer", `count=${count}`);
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: values,
          fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
        });
      }
      /**
       * Perform a DELETE on the table or view.
       *
       * By default, deleted rows are not returned. To return it, chain the call
       * with `.select()` after filters.
       *
       * @param options - Named parameters
       *
       * @param options.count - Count algorithm to use to count deleted rows.
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      delete({ count } = {}) {
        var _a2;
        const method = "DELETE";
        if (count) {
          this.headers.append("Prefer", `count=${count}`);
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
        });
      }
    }
    PostgrestQueryBuilder$1.default = PostgrestQueryBuilder2;
    return PostgrestQueryBuilder$1;
  }
  var hasRequiredPostgrestClient;
  function requirePostgrestClient() {
    if (hasRequiredPostgrestClient) return PostgrestClient$1;
    hasRequiredPostgrestClient = 1;
    Object.defineProperty(PostgrestClient$1, "__esModule", { value: true });
    const tslib_1 = require$$0;
    const PostgrestQueryBuilder_1 = tslib_1.__importDefault(requirePostgrestQueryBuilder());
    const PostgrestFilterBuilder_1 = tslib_1.__importDefault(requirePostgrestFilterBuilder());
    class PostgrestClient2 {
      // TODO: Add back shouldThrowOnError once we figure out the typings
      /**
       * Creates a PostgREST client.
       *
       * @param url - URL of the PostgREST endpoint
       * @param options - Named parameters
       * @param options.headers - Custom headers
       * @param options.schema - Postgres schema to switch to
       * @param options.fetch - Custom fetch
       * @example
       * ```ts
       * import PostgrestClient from '@supabase/postgrest-js'
       *
       * const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {
       *   headers: { apikey: 'public-anon-key' },
       *   schema: 'public',
       * })
       * ```
       */
      constructor(url, { headers = {}, schema, fetch: fetch2 } = {}) {
        this.url = url;
        this.headers = new Headers(headers);
        this.schemaName = schema;
        this.fetch = fetch2;
      }
      /**
       * Perform a query on a table or a view.
       *
       * @param relation - The table or view name to query
       */
      from(relation) {
        if (!relation || typeof relation !== "string" || relation.trim() === "") {
          throw new Error("Invalid relation name: relation must be a non-empty string.");
        }
        const url = new URL(`${this.url}/${relation}`);
        return new PostgrestQueryBuilder_1.default(url, {
          headers: new Headers(this.headers),
          schema: this.schemaName,
          fetch: this.fetch
        });
      }
      /**
       * Select a schema to query or perform an function (rpc) call.
       *
       * The schema needs to be on the list of exposed schemas inside Supabase.
       *
       * @param schema - The schema to query
       */
      schema(schema) {
        return new PostgrestClient2(this.url, {
          headers: this.headers,
          schema,
          fetch: this.fetch
        });
      }
      /**
       * Perform a function call.
       *
       * @param fn - The function name to call
       * @param args - The arguments to pass to the function call
       * @param options - Named parameters
       * @param options.head - When set to `true`, `data` will not be returned.
       * Useful if you only need the count.
       * @param options.get - When set to `true`, the function will be called with
       * read-only access mode.
       * @param options.count - Count algorithm to use to count rows returned by the
       * function. Only applicable for [set-returning
       * functions](https://www.postgresql.org/docs/current/functions-srf.html).
       *
       * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
       * hood.
       *
       * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
       * statistics under the hood.
       *
       * `"estimated"`: Uses exact count for low numbers and planned count for high
       * numbers.
       */
      rpc(fn, args = {}, { head: head2 = false, get: get2 = false, count } = {}) {
        var _a2;
        let method;
        const url = new URL(`${this.url}/rpc/${fn}`);
        let body;
        if (head2 || get2) {
          method = head2 ? "HEAD" : "GET";
          Object.entries(args).filter(([_, value]) => value !== void 0).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(",")}}` : `${value}`]).forEach(([name, value]) => {
            url.searchParams.append(name, value);
          });
        } else {
          method = "POST";
          body = args;
        }
        const headers = new Headers(this.headers);
        if (count) {
          headers.set("Prefer", `count=${count}`);
        }
        return new PostgrestFilterBuilder_1.default({
          method,
          url,
          headers,
          schema: this.schemaName,
          body,
          fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
        });
      }
    }
    PostgrestClient$1.default = PostgrestClient2;
    return PostgrestClient$1;
  }
  var hasRequiredCjs;
  function requireCjs() {
    if (hasRequiredCjs) return cjs;
    hasRequiredCjs = 1;
    Object.defineProperty(cjs, "__esModule", { value: true });
    cjs.PostgrestError = cjs.PostgrestBuilder = cjs.PostgrestTransformBuilder = cjs.PostgrestFilterBuilder = cjs.PostgrestQueryBuilder = cjs.PostgrestClient = void 0;
    const tslib_1 = require$$0;
    const PostgrestClient_1 = tslib_1.__importDefault(requirePostgrestClient());
    cjs.PostgrestClient = PostgrestClient_1.default;
    const PostgrestQueryBuilder_1 = tslib_1.__importDefault(requirePostgrestQueryBuilder());
    cjs.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
    const PostgrestFilterBuilder_1 = tslib_1.__importDefault(requirePostgrestFilterBuilder());
    cjs.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
    const PostgrestTransformBuilder_1 = tslib_1.__importDefault(requirePostgrestTransformBuilder());
    cjs.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;
    const PostgrestBuilder_1 = tslib_1.__importDefault(requirePostgrestBuilder());
    cjs.PostgrestBuilder = PostgrestBuilder_1.default;
    const PostgrestError_1 = tslib_1.__importDefault(requirePostgrestError());
    cjs.PostgrestError = PostgrestError_1.default;
    cjs.default = {
      PostgrestClient: PostgrestClient_1.default,
      PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,
      PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,
      PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,
      PostgrestBuilder: PostgrestBuilder_1.default,
      PostgrestError: PostgrestError_1.default
    };
    return cjs;
  }
  var cjsExports = requireCjs();
  const index = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports);
  const index$1 = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    default: index
  }, [cjsExports]);
  const {
    PostgrestClient,
    PostgrestQueryBuilder,
    PostgrestFilterBuilder,
    PostgrestTransformBuilder,
    PostgrestBuilder,
    PostgrestError
  } = index || index$1;
  class WebSocketFactory {
    /**
     * Static-only utility â€“ prevent instantiation.
     */
    constructor() {
    }
    static detectEnvironment() {
      var _a2;
      if (typeof WebSocket !== "undefined") {
        return { type: "native", constructor: WebSocket };
      }
      if (typeof globalThis !== "undefined" && typeof globalThis.WebSocket !== "undefined") {
        return { type: "native", constructor: globalThis.WebSocket };
      }
      if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
        return { type: "native", constructor: global.WebSocket };
      }
      if (typeof globalThis !== "undefined" && typeof globalThis.WebSocketPair !== "undefined" && typeof globalThis.WebSocket === "undefined") {
        return {
          type: "cloudflare",
          error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
          workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
        };
      }
      if (typeof globalThis !== "undefined" && globalThis.EdgeRuntime || typeof navigator !== "undefined" && ((_a2 = navigator.userAgent) === null || _a2 === void 0 ? void 0 : _a2.includes("Vercel-Edge"))) {
        return {
          type: "unsupported",
          error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
          workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
        };
      }
      if (typeof process !== "undefined") {
        const processVersions = process["versions"];
        if (processVersions && processVersions["node"]) {
          const versionString = processVersions["node"];
          const nodeVersion = parseInt(versionString.replace(/^v/, "").split(".")[0]);
          if (nodeVersion >= 22) {
            if (typeof globalThis.WebSocket !== "undefined") {
              return { type: "native", constructor: globalThis.WebSocket };
            }
            return {
              type: "unsupported",
              error: `Node.js ${nodeVersion} detected but native WebSocket not found.`,
              workaround: "Provide a WebSocket implementation via the transport option."
            };
          }
          return {
            type: "unsupported",
            error: `Node.js ${nodeVersion} detected without native WebSocket support.`,
            workaround: 'For Node.js < 22, install "ws" package and provide it via the transport option:\nimport ws from "ws"\nnew RealtimeClient(url, { transport: ws })'
          };
        }
      }
      return {
        type: "unsupported",
        error: "Unknown JavaScript runtime without WebSocket support.",
        workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
      };
    }
    /**
     * Returns the best available WebSocket constructor for the current runtime.
     *
     * @example
     * ```ts
     * const WS = WebSocketFactory.getWebSocketConstructor()
     * const socket = new WS('wss://realtime.supabase.co/socket')
     * ```
     */
    static getWebSocketConstructor() {
      const env = this.detectEnvironment();
      if (env.constructor) {
        return env.constructor;
      }
      let errorMessage = env.error || "WebSocket not supported in this environment.";
      if (env.workaround) {
        errorMessage += `

Suggested solution: ${env.workaround}`;
      }
      throw new Error(errorMessage);
    }
    /**
     * Creates a WebSocket using the detected constructor.
     *
     * @example
     * ```ts
     * const socket = WebSocketFactory.createWebSocket('wss://realtime.supabase.co/socket')
     * ```
     */
    static createWebSocket(url, protocols) {
      const WS = this.getWebSocketConstructor();
      return new WS(url, protocols);
    }
    /**
     * Detects whether the runtime can establish WebSocket connections.
     *
     * @example
     * ```ts
     * if (!WebSocketFactory.isWebSocketSupported()) {
     *   console.warn('Falling back to long polling')
     * }
     * ```
     */
    static isWebSocketSupported() {
      try {
        const env = this.detectEnvironment();
        return env.type === "native" || env.type === "ws";
      } catch (_a2) {
        return false;
      }
    }
  }
  const version$3 = "2.84.0";
  const DEFAULT_VERSION = `realtime-js/${version$3}`;
  const VSN_1_0_0 = "1.0.0";
  const VSN_2_0_0 = "2.0.0";
  const DEFAULT_VSN = VSN_1_0_0;
  const DEFAULT_TIMEOUT = 1e4;
  const WS_CLOSE_NORMAL = 1e3;
  const MAX_PUSH_BUFFER_SIZE = 100;
  var SOCKET_STATES;
  (function(SOCKET_STATES2) {
    SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
    SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
    SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
    SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
  })(SOCKET_STATES || (SOCKET_STATES = {}));
  var CHANNEL_STATES;
  (function(CHANNEL_STATES2) {
    CHANNEL_STATES2["closed"] = "closed";
    CHANNEL_STATES2["errored"] = "errored";
    CHANNEL_STATES2["joined"] = "joined";
    CHANNEL_STATES2["joining"] = "joining";
    CHANNEL_STATES2["leaving"] = "leaving";
  })(CHANNEL_STATES || (CHANNEL_STATES = {}));
  var CHANNEL_EVENTS;
  (function(CHANNEL_EVENTS2) {
    CHANNEL_EVENTS2["close"] = "phx_close";
    CHANNEL_EVENTS2["error"] = "phx_error";
    CHANNEL_EVENTS2["join"] = "phx_join";
    CHANNEL_EVENTS2["reply"] = "phx_reply";
    CHANNEL_EVENTS2["leave"] = "phx_leave";
    CHANNEL_EVENTS2["access_token"] = "access_token";
  })(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
  var TRANSPORTS;
  (function(TRANSPORTS2) {
    TRANSPORTS2["websocket"] = "websocket";
  })(TRANSPORTS || (TRANSPORTS = {}));
  var CONNECTION_STATE;
  (function(CONNECTION_STATE2) {
    CONNECTION_STATE2["Connecting"] = "connecting";
    CONNECTION_STATE2["Open"] = "open";
    CONNECTION_STATE2["Closing"] = "closing";
    CONNECTION_STATE2["Closed"] = "closed";
  })(CONNECTION_STATE || (CONNECTION_STATE = {}));
  class Serializer {
    constructor() {
      this.HEADER_LENGTH = 1;
      this.META_LENGTH = 4;
      this.USER_BROADCAST_PUSH_META_LENGTH = 5;
      this.KINDS = { userBroadcastPush: 3, userBroadcast: 4 };
      this.BINARY_ENCODING = 0;
      this.JSON_ENCODING = 1;
      this.BROADCAST_EVENT = "broadcast";
    }
    encode(msg, callback) {
      if (msg.event === this.BROADCAST_EVENT && !(msg.payload instanceof ArrayBuffer) && typeof msg.payload.event === "string") {
        return callback(this._binaryEncodeUserBroadcastPush(msg));
      }
      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
      return callback(JSON.stringify(payload));
    }
    _binaryEncodeUserBroadcastPush(message) {
      var _a2;
      if (this._isArrayBuffer((_a2 = message.payload) === null || _a2 === void 0 ? void 0 : _a2.payload)) {
        return this._encodeBinaryUserBroadcastPush(message);
      } else {
        return this._encodeJsonUserBroadcastPush(message);
      }
    }
    _encodeBinaryUserBroadcastPush(message) {
      var _a2, _b, _c, _d;
      const topic = message.topic;
      const ref = (_a2 = message.ref) !== null && _a2 !== void 0 ? _a2 : "";
      const joinRef = (_b = message.join_ref) !== null && _b !== void 0 ? _b : "";
      const userEvent = message.payload.event;
      const userPayload = (_d = (_c = message.payload) === null || _c === void 0 ? void 0 : _c.payload) !== null && _d !== void 0 ? _d : new ArrayBuffer(0);
      const metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length;
      const header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.userBroadcastPush);
      view.setUint8(offset++, joinRef.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, userEvent.length);
      view.setUint8(offset++, this.BINARY_ENCODING);
      Array.from(joinRef, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(userEvent, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + userPayload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(userPayload), header.byteLength);
      return combined.buffer;
    }
    _encodeJsonUserBroadcastPush(message) {
      var _a2, _b, _c, _d;
      const topic = message.topic;
      const ref = (_a2 = message.ref) !== null && _a2 !== void 0 ? _a2 : "";
      const joinRef = (_b = message.join_ref) !== null && _b !== void 0 ? _b : "";
      const userEvent = message.payload.event;
      const userPayload = (_d = (_c = message.payload) === null || _c === void 0 ? void 0 : _c.payload) !== null && _d !== void 0 ? _d : {};
      const encoder = new TextEncoder();
      const encodedUserPayload = encoder.encode(JSON.stringify(userPayload)).buffer;
      const metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length;
      const header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.userBroadcastPush);
      view.setUint8(offset++, joinRef.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, userEvent.length);
      view.setUint8(offset++, this.JSON_ENCODING);
      Array.from(joinRef, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(userEvent, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + encodedUserPayload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(encodedUserPayload), header.byteLength);
      return combined.buffer;
    }
    decode(rawPayload, callback) {
      if (this._isArrayBuffer(rawPayload)) {
        let result2 = this._binaryDecode(rawPayload);
        return callback(result2);
      }
      if (typeof rawPayload === "string") {
        const jsonPayload = JSON.parse(rawPayload);
        const [join_ref, ref, topic, event, payload] = jsonPayload;
        return callback({ join_ref, ref, topic, event, payload });
      }
      return callback({});
    }
    _binaryDecode(buffer) {
      const view = new DataView(buffer);
      const kind2 = view.getUint8(0);
      const decoder = new TextDecoder();
      switch (kind2) {
        case this.KINDS.userBroadcast:
          return this._decodeUserBroadcast(buffer, view, decoder);
      }
    }
    _decodeUserBroadcast(buffer, view, decoder) {
      const topicSize = view.getUint8(1);
      const userEventSize = view.getUint8(2);
      const metadataSize = view.getUint8(3);
      const payloadEncoding = view.getUint8(4);
      let offset = this.HEADER_LENGTH + 4;
      const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      const userEvent = decoder.decode(buffer.slice(offset, offset + userEventSize));
      offset = offset + userEventSize;
      const metadata = decoder.decode(buffer.slice(offset, offset + metadataSize));
      offset = offset + metadataSize;
      const payload = buffer.slice(offset, buffer.byteLength);
      const parsedPayload = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(payload)) : payload;
      const data = {
        type: this.BROADCAST_EVENT,
        event: userEvent,
        payload: parsedPayload
      };
      if (metadataSize > 0) {
        data["meta"] = JSON.parse(metadata);
      }
      return { join_ref: null, ref: null, topic, event: this.BROADCAST_EVENT, payload: data };
    }
    _isArrayBuffer(buffer) {
      var _a2;
      return buffer instanceof ArrayBuffer || ((_a2 = buffer === null || buffer === void 0 ? void 0 : buffer.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) === "ArrayBuffer";
    }
  }
  class Timer {
    constructor(callback, timerCalc) {
      this.callback = callback;
      this.timerCalc = timerCalc;
      this.timer = void 0;
      this.tries = 0;
      this.callback = callback;
      this.timerCalc = timerCalc;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
      this.timer = void 0;
    }
    // Cancels any previous scheduleTimeout and schedules callback
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  }
  var PostgresTypes;
  (function(PostgresTypes2) {
    PostgresTypes2["abstime"] = "abstime";
    PostgresTypes2["bool"] = "bool";
    PostgresTypes2["date"] = "date";
    PostgresTypes2["daterange"] = "daterange";
    PostgresTypes2["float4"] = "float4";
    PostgresTypes2["float8"] = "float8";
    PostgresTypes2["int2"] = "int2";
    PostgresTypes2["int4"] = "int4";
    PostgresTypes2["int4range"] = "int4range";
    PostgresTypes2["int8"] = "int8";
    PostgresTypes2["int8range"] = "int8range";
    PostgresTypes2["json"] = "json";
    PostgresTypes2["jsonb"] = "jsonb";
    PostgresTypes2["money"] = "money";
    PostgresTypes2["numeric"] = "numeric";
    PostgresTypes2["oid"] = "oid";
    PostgresTypes2["reltime"] = "reltime";
    PostgresTypes2["text"] = "text";
    PostgresTypes2["time"] = "time";
    PostgresTypes2["timestamp"] = "timestamp";
    PostgresTypes2["timestamptz"] = "timestamptz";
    PostgresTypes2["timetz"] = "timetz";
    PostgresTypes2["tsrange"] = "tsrange";
    PostgresTypes2["tstzrange"] = "tstzrange";
  })(PostgresTypes || (PostgresTypes = {}));
  const convertChangeData = (columns, record, options = {}) => {
    var _a2;
    const skipTypes = (_a2 = options.skipTypes) !== null && _a2 !== void 0 ? _a2 : [];
    if (!record) {
      return {};
    }
    return Object.keys(record).reduce((acc, rec_key) => {
      acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
      return acc;
    }, {});
  };
  const convertColumn = (columnName, columns, record, skipTypes) => {
    const column = columns.find((x) => x.name === columnName);
    const colType = column === null || column === void 0 ? void 0 : column.type;
    const value = record[columnName];
    if (colType && !skipTypes.includes(colType)) {
      return convertCell(colType, value);
    }
    return noop$1(value);
  };
  const convertCell = (type, value) => {
    if (type.charAt(0) === "_") {
      const dataType = type.slice(1, type.length);
      return toArray(value, dataType);
    }
    switch (type) {
      case PostgresTypes.bool:
        return toBoolean(value);
      case PostgresTypes.float4:
      case PostgresTypes.float8:
      case PostgresTypes.int2:
      case PostgresTypes.int4:
      case PostgresTypes.int8:
      case PostgresTypes.numeric:
      case PostgresTypes.oid:
        return toNumber(value);
      case PostgresTypes.json:
      case PostgresTypes.jsonb:
        return toJson(value);
      case PostgresTypes.timestamp:
        return toTimestampString(value);
      // Format to be consistent with PostgREST
      case PostgresTypes.abstime:
      // To allow users to cast it based on Timezone
      case PostgresTypes.date:
      // To allow users to cast it based on Timezone
      case PostgresTypes.daterange:
      case PostgresTypes.int4range:
      case PostgresTypes.int8range:
      case PostgresTypes.money:
      case PostgresTypes.reltime:
      // To allow users to cast it based on Timezone
      case PostgresTypes.text:
      case PostgresTypes.time:
      // To allow users to cast it based on Timezone
      case PostgresTypes.timestamptz:
      // To allow users to cast it based on Timezone
      case PostgresTypes.timetz:
      // To allow users to cast it based on Timezone
      case PostgresTypes.tsrange:
      case PostgresTypes.tstzrange:
        return noop$1(value);
      default:
        return noop$1(value);
    }
  };
  const noop$1 = (value) => {
    return value;
  };
  const toBoolean = (value) => {
    switch (value) {
      case "t":
        return true;
      case "f":
        return false;
      default:
        return value;
    }
  };
  const toNumber = (value) => {
    if (typeof value === "string") {
      const parsedValue = parseFloat(value);
      if (!Number.isNaN(parsedValue)) {
        return parsedValue;
      }
    }
    return value;
  };
  const toJson = (value) => {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch (error) {
        console.log(`JSON parse error: ${error}`);
        return value;
      }
    }
    return value;
  };
  const toArray = (value, type) => {
    if (typeof value !== "string") {
      return value;
    }
    const lastIdx = value.length - 1;
    const closeBrace = value[lastIdx];
    const openBrace = value[0];
    if (openBrace === "{" && closeBrace === "}") {
      let arr;
      const valTrim = value.slice(1, lastIdx);
      try {
        arr = JSON.parse("[" + valTrim + "]");
      } catch (_) {
        arr = valTrim ? valTrim.split(",") : [];
      }
      return arr.map((val) => convertCell(type, val));
    }
    return value;
  };
  const toTimestampString = (value) => {
    if (typeof value === "string") {
      return value.replace(" ", "T");
    }
    return value;
  };
  const httpEndpointURL = (socketUrl) => {
    const wsUrl = new URL(socketUrl);
    wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, "http");
    wsUrl.pathname = wsUrl.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, "");
    if (wsUrl.pathname === "" || wsUrl.pathname === "/") {
      wsUrl.pathname = "/api/broadcast";
    } else {
      wsUrl.pathname = wsUrl.pathname + "/api/broadcast";
    }
    return wsUrl.href;
  };
  class Push {
    /**
     * Initializes the Push
     *
     * @param channel The Channel
     * @param event The event, for example `"phx_join"`
     * @param payload The payload, for example `{user_id: 123}`
     * @param timeout The push timeout in milliseconds
     */
    constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {
      this.channel = channel;
      this.event = event;
      this.payload = payload;
      this.timeout = timeout;
      this.sent = false;
      this.timeoutTimer = void 0;
      this.ref = "";
      this.receivedResp = null;
      this.recHooks = [];
      this.refEvent = null;
    }
    resend(timeout) {
      this.timeout = timeout;
      this._cancelRefEvent();
      this.ref = "";
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
      this.send();
    }
    send() {
      if (this._hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload,
        ref: this.ref,
        join_ref: this.channel._joinRef()
      });
    }
    updatePayload(payload) {
      this.payload = Object.assign(Object.assign({}, this.payload), payload);
    }
    receive(status, callback) {
      var _a2;
      if (this._hasReceived(status)) {
        callback((_a2 = this.receivedResp) === null || _a2 === void 0 ? void 0 : _a2.response);
      }
      this.recHooks.push({ status, callback });
      return this;
    }
    startTimeout() {
      if (this.timeoutTimer) {
        return;
      }
      this.ref = this.channel.socket._makeRef();
      this.refEvent = this.channel._replyEventName(this.ref);
      const callback = (payload) => {
        this._cancelRefEvent();
        this._cancelTimeout();
        this.receivedResp = payload;
        this._matchReceive(payload);
      };
      this.channel._on(this.refEvent, {}, callback);
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    trigger(status, response) {
      if (this.refEvent)
        this.channel._trigger(this.refEvent, { status, response });
    }
    destroy() {
      this._cancelRefEvent();
      this._cancelTimeout();
    }
    _cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel._off(this.refEvent, {});
    }
    _cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = void 0;
    }
    _matchReceive({ status, response }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    _hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
  }
  var REALTIME_PRESENCE_LISTEN_EVENTS;
  (function(REALTIME_PRESENCE_LISTEN_EVENTS2) {
    REALTIME_PRESENCE_LISTEN_EVENTS2["SYNC"] = "sync";
    REALTIME_PRESENCE_LISTEN_EVENTS2["JOIN"] = "join";
    REALTIME_PRESENCE_LISTEN_EVENTS2["LEAVE"] = "leave";
  })(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
  class RealtimePresence {
    /**
     * Creates a Presence helper that keeps the local presence state in sync with the server.
     *
     * @param channel - The realtime channel to bind to.
     * @param opts - Optional custom event names, e.g. `{ events: { state: 'state', diff: 'diff' } }`.
     *
     * @example
     * ```ts
     * const presence = new RealtimePresence(channel)
     *
     * channel.on('presence', ({ event, key }) => {
     *   console.log(`Presence ${event} on ${key}`)
     * })
     * ```
     */
    constructor(channel, opts) {
      this.channel = channel;
      this.state = {};
      this.pendingDiffs = [];
      this.joinRef = null;
      this.enabled = false;
      this.caller = {
        onJoin: () => {
        },
        onLeave: () => {
        },
        onSync: () => {
        }
      };
      const events2 = (opts === null || opts === void 0 ? void 0 : opts.events) || {
        state: "presence_state",
        diff: "presence_diff"
      };
      this.channel._on(events2.state, {}, (newState) => {
        const { onJoin, onLeave, onSync } = this.caller;
        this.joinRef = this.channel._joinRef();
        this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
        this.pendingDiffs.forEach((diff) => {
          this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        });
        this.pendingDiffs = [];
        onSync();
      });
      this.channel._on(events2.diff, {}, (diff) => {
        const { onJoin, onLeave, onSync } = this.caller;
        if (this.inPendingSyncState()) {
          this.pendingDiffs.push(diff);
        } else {
          this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
          onSync();
        }
      });
      this.onJoin((key, currentPresences, newPresences) => {
        this.channel._trigger("presence", {
          event: "join",
          key,
          currentPresences,
          newPresences
        });
      });
      this.onLeave((key, currentPresences, leftPresences) => {
        this.channel._trigger("presence", {
          event: "leave",
          key,
          currentPresences,
          leftPresences
        });
      });
      this.onSync(() => {
        this.channel._trigger("presence", { event: "sync" });
      });
    }
    /**
     * Used to sync the list of presences on the server with the
     * client's state.
     *
     * An optional `onJoin` and `onLeave` callback can be provided to
     * react to changes in the client's local presences across
     * disconnects and reconnects with the server.
     *
     * @internal
     */
    static syncState(currentState, newState, onJoin, onLeave) {
      const state = this.cloneDeep(currentState);
      const transformedState = this.transformState(newState);
      const joins = {};
      const leaves = {};
      this.map(state, (key, presences) => {
        if (!transformedState[key]) {
          leaves[key] = presences;
        }
      });
      this.map(transformedState, (key, newPresences) => {
        const currentPresences = state[key];
        if (currentPresences) {
          const newPresenceRefs = newPresences.map((m) => m.presence_ref);
          const curPresenceRefs = currentPresences.map((m) => m.presence_ref);
          const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);
          const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);
          if (joinedPresences.length > 0) {
            joins[key] = joinedPresences;
          }
          if (leftPresences.length > 0) {
            leaves[key] = leftPresences;
          }
        } else {
          joins[key] = newPresences;
        }
      });
      return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
    }
    /**
     * Used to sync a diff of presence join and leave events from the
     * server, as they happen.
     *
     * Like `syncState`, `syncDiff` accepts optional `onJoin` and
     * `onLeave` callbacks to react to a user joining or leaving from a
     * device.
     *
     * @internal
     */
    static syncDiff(state, diff, onJoin, onLeave) {
      const { joins, leaves } = {
        joins: this.transformState(diff.joins),
        leaves: this.transformState(diff.leaves)
      };
      if (!onJoin) {
        onJoin = () => {
        };
      }
      if (!onLeave) {
        onLeave = () => {
        };
      }
      this.map(joins, (key, newPresences) => {
        var _a2;
        const currentPresences = (_a2 = state[key]) !== null && _a2 !== void 0 ? _a2 : [];
        state[key] = this.cloneDeep(newPresences);
        if (currentPresences.length > 0) {
          const joinedPresenceRefs = state[key].map((m) => m.presence_ref);
          const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);
          state[key].unshift(...curPresences);
        }
        onJoin(key, currentPresences, newPresences);
      });
      this.map(leaves, (key, leftPresences) => {
        let currentPresences = state[key];
        if (!currentPresences)
          return;
        const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);
        currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);
        state[key] = currentPresences;
        onLeave(key, currentPresences, leftPresences);
        if (currentPresences.length === 0)
          delete state[key];
      });
      return state;
    }
    /** @internal */
    static map(obj, func) {
      return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
    }
    /**
     * Remove 'metas' key
     * Change 'phx_ref' to 'presence_ref'
     * Remove 'phx_ref' and 'phx_ref_prev'
     *
     * @example
     * // returns {
     *  abc123: [
     *    { presence_ref: '2', user_id: 1 },
     *    { presence_ref: '3', user_id: 2 }
     *  ]
     * }
     * RealtimePresence.transformState({
     *  abc123: {
     *    metas: [
     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
     *      { phx_ref: '3', user_id: 2 }
     *    ]
     *  }
     * })
     *
     * @internal
     */
    static transformState(state) {
      state = this.cloneDeep(state);
      return Object.getOwnPropertyNames(state).reduce((newState, key) => {
        const presences = state[key];
        if ("metas" in presences) {
          newState[key] = presences.metas.map((presence) => {
            presence["presence_ref"] = presence["phx_ref"];
            delete presence["phx_ref"];
            delete presence["phx_ref_prev"];
            return presence;
          });
        } else {
          newState[key] = presences;
        }
        return newState;
      }, {});
    }
    /** @internal */
    static cloneDeep(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    /** @internal */
    onJoin(callback) {
      this.caller.onJoin = callback;
    }
    /** @internal */
    onLeave(callback) {
      this.caller.onLeave = callback;
    }
    /** @internal */
    onSync(callback) {
      this.caller.onSync = callback;
    }
    /** @internal */
    inPendingSyncState() {
      return !this.joinRef || this.joinRef !== this.channel._joinRef();
    }
  }
  var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
  (function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["ALL"] = "*";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["INSERT"] = "INSERT";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["UPDATE"] = "UPDATE";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["DELETE"] = "DELETE";
  })(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
  var REALTIME_LISTEN_TYPES;
  (function(REALTIME_LISTEN_TYPES2) {
    REALTIME_LISTEN_TYPES2["BROADCAST"] = "broadcast";
    REALTIME_LISTEN_TYPES2["PRESENCE"] = "presence";
    REALTIME_LISTEN_TYPES2["POSTGRES_CHANGES"] = "postgres_changes";
    REALTIME_LISTEN_TYPES2["SYSTEM"] = "system";
  })(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
  var REALTIME_SUBSCRIBE_STATES;
  (function(REALTIME_SUBSCRIBE_STATES2) {
    REALTIME_SUBSCRIBE_STATES2["SUBSCRIBED"] = "SUBSCRIBED";
    REALTIME_SUBSCRIBE_STATES2["TIMED_OUT"] = "TIMED_OUT";
    REALTIME_SUBSCRIBE_STATES2["CLOSED"] = "CLOSED";
    REALTIME_SUBSCRIBE_STATES2["CHANNEL_ERROR"] = "CHANNEL_ERROR";
  })(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
  class RealtimeChannel {
    /**
     * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.
     *
     * The topic determines which realtime stream you are subscribing to. Config options let you
     * enable acknowledgement for broadcasts, presence tracking, or private channels.
     *
     * @example
     * ```ts
     * import RealtimeClient from '@supabase/realtime-js'
     *
     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {
     *   params: { apikey: 'public-anon-key' },
     * })
     * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)
     * ```
     */
    constructor(topic, params = { config: {} }, socket) {
      var _a2, _b;
      this.topic = topic;
      this.params = params;
      this.socket = socket;
      this.bindings = {};
      this.state = CHANNEL_STATES.closed;
      this.joinedOnce = false;
      this.pushBuffer = [];
      this.subTopic = topic.replace(/^realtime:/i, "");
      this.params.config = Object.assign({
        broadcast: { ack: false, self: false },
        presence: { key: "", enabled: false },
        private: false
      }, params.config);
      this.timeout = this.socket.timeout;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this._onClose(() => {
        this.rejoinTimer.reset();
        this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket._remove(this);
      });
      this._onError((reason) => {
        if (this._isLeaving() || this._isClosed()) {
          return;
        }
        this.socket.log("channel", `error ${this.topic}`, reason);
        this.state = CHANNEL_STATES.errored;
        this.rejoinTimer.scheduleTimeout();
      });
      this.joinPush.receive("timeout", () => {
        if (!this._isJoining()) {
          return;
        }
        this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
        this.state = CHANNEL_STATES.errored;
        this.rejoinTimer.scheduleTimeout();
      });
      this.joinPush.receive("error", (reason) => {
        if (this._isLeaving() || this._isClosed()) {
          return;
        }
        this.socket.log("channel", `error ${this.topic}`, reason);
        this.state = CHANNEL_STATES.errored;
        this.rejoinTimer.scheduleTimeout();
      });
      this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {
        this._trigger(this._replyEventName(ref), payload);
      });
      this.presence = new RealtimePresence(this);
      this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint);
      this.private = this.params.config.private || false;
      if (!this.private && ((_b = (_a2 = this.params.config) === null || _a2 === void 0 ? void 0 : _a2.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {
        throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;
      }
    }
    /** Subscribe registers your client with the server */
    subscribe(callback, timeout = this.timeout) {
      var _a2, _b, _c;
      if (!this.socket.isConnected()) {
        this.socket.connect();
      }
      if (this.state == CHANNEL_STATES.closed) {
        const { config: { broadcast, presence, private: isPrivate } } = this.params;
        const postgres_changes = (_b = (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.map((r2) => r2.filter)) !== null && _b !== void 0 ? _b : [];
        const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;
        const accessTokenPayload = {};
        const config = {
          broadcast,
          presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),
          postgres_changes,
          private: isPrivate
        };
        if (this.socket.accessTokenValue) {
          accessTokenPayload.access_token = this.socket.accessTokenValue;
        }
        this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));
        this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
        this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));
        this.joinedOnce = true;
        this._rejoin(timeout);
        this.joinPush.receive("ok", async ({ postgres_changes: postgres_changes2 }) => {
          var _a3;
          this.socket.setAuth();
          if (postgres_changes2 === void 0) {
            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
            return;
          } else {
            const clientPostgresBindings = this.bindings.postgres_changes;
            const bindingsLen = (_a3 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a3 !== void 0 ? _a3 : 0;
            const newPostgresBindings = [];
            for (let i = 0; i < bindingsLen; i++) {
              const clientPostgresBinding = clientPostgresBindings[i];
              const { filter: { event, schema, table, filter } } = clientPostgresBinding;
              const serverPostgresFilter = postgres_changes2 && postgres_changes2[i];
              if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
                newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));
              } else {
                this.unsubscribe();
                this.state = CHANNEL_STATES.errored;
                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
                return;
              }
            }
            this.bindings.postgres_changes = newPostgresBindings;
            callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
            return;
          }
        }).receive("error", (error) => {
          this.state = CHANNEL_STATES.errored;
          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(", ") || "error")));
          return;
        }).receive("timeout", () => {
          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
          return;
        });
      }
      return this;
    }
    /**
     * Returns the current presence state for this channel.
     *
     * The shape is a map keyed by presence key (for example a user id) where each entry contains the
     * tracked metadata for that user.
     */
    presenceState() {
      return this.presence.state;
    }
    /**
     * Sends the supplied payload to the presence tracker so other subscribers can see that this
     * client is online. Use `untrack` to stop broadcasting presence for the same key.
     */
    async track(payload, opts = {}) {
      return await this.send({
        type: "presence",
        event: "track",
        payload
      }, opts.timeout || this.timeout);
    }
    /**
     * Removes the current presence state for this client.
     */
    async untrack(opts = {}) {
      return await this.send({
        type: "presence",
        event: "untrack"
      }, opts);
    }
    on(type, filter, callback) {
      if (this.state === CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {
        this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);
        this.unsubscribe().then(() => this.subscribe());
      }
      return this._on(type, filter, callback);
    }
    /**
     * Sends a broadcast message explicitly via REST API.
     *
     * This method always uses the REST API endpoint regardless of WebSocket connection state.
     * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.
     *
     * @param event The name of the broadcast event
     * @param payload Payload to be sent (required)
     * @param opts Options including timeout
     * @returns Promise resolving to object with success status, and error details if failed
     */
    async httpSend(event, payload, opts = {}) {
      var _a2;
      const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
      if (payload === void 0 || payload === null) {
        return Promise.reject("Payload is required for httpSend()");
      }
      const options = {
        method: "POST",
        headers: {
          Authorization: authorization,
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event,
              payload,
              private: this.private
            }
          ]
        })
      };
      const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a2 = opts.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout);
      if (response.status === 202) {
        return { success: true };
      }
      let errorMessage = response.statusText;
      try {
        const errorBody = await response.json();
        errorMessage = errorBody.error || errorBody.message || errorMessage;
      } catch (_b) {
      }
      return Promise.reject(new Error(errorMessage));
    }
    /**
     * Sends a message into the channel.
     *
     * @param args Arguments to send to channel
     * @param args.type The type of event to send
     * @param args.event The name of the event being sent
     * @param args.payload Payload to be sent
     * @param opts Options to be used during the send process
     */
    async send(args, opts = {}) {
      var _a2, _b;
      if (!this._canPush() && args.type === "broadcast") {
        console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
        const { event, payload: endpoint_payload } = args;
        const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
        const options = {
          method: "POST",
          headers: {
            Authorization: authorization,
            apikey: this.socket.apiKey ? this.socket.apiKey : "",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            messages: [
              {
                topic: this.subTopic,
                event,
                payload: endpoint_payload,
                private: this.private
              }
            ]
          })
        };
        try {
          const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a2 = opts.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout);
          await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());
          return response.ok ? "ok" : "error";
        } catch (error) {
          if (error.name === "AbortError") {
            return "timed out";
          } else {
            return "error";
          }
        }
      } else {
        return new Promise((resolve) => {
          var _a3, _b2, _c;
          const push = this._push(args.type, args, opts.timeout || this.timeout);
          if (args.type === "broadcast" && !((_c = (_b2 = (_a3 = this.params) === null || _a3 === void 0 ? void 0 : _a3.config) === null || _b2 === void 0 ? void 0 : _b2.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
            resolve("ok");
          }
          push.receive("ok", () => resolve("ok"));
          push.receive("error", () => resolve("error"));
          push.receive("timeout", () => resolve("timed out"));
        });
      }
    }
    /**
     * Updates the payload that will be sent the next time the channel joins (reconnects).
     * Useful for rotating access tokens or updating config without re-creating the channel.
     */
    updateJoinPayload(payload) {
      this.joinPush.updatePayload(payload);
    }
    /**
     * Leaves the channel.
     *
     * Unsubscribes from server events, and instructs channel to terminate on server.
     * Triggers onClose() hooks.
     *
     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
     * channel.unsubscribe().receive("ok", () => alert("left!") )
     */
    unsubscribe(timeout = this.timeout) {
      this.state = CHANNEL_STATES.leaving;
      const onClose = () => {
        this.socket.log("channel", `leave ${this.topic}`);
        this._trigger(CHANNEL_EVENTS.close, "leave", this._joinRef());
      };
      this.joinPush.destroy();
      let leavePush = null;
      return new Promise((resolve) => {
        leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);
        leavePush.receive("ok", () => {
          onClose();
          resolve("ok");
        }).receive("timeout", () => {
          onClose();
          resolve("timed out");
        }).receive("error", () => {
          resolve("error");
        });
        leavePush.send();
        if (!this._canPush()) {
          leavePush.trigger("ok", {});
        }
      }).finally(() => {
        leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();
      });
    }
    /**
     * Teardown the channel.
     *
     * Destroys and stops related timers.
     */
    teardown() {
      this.pushBuffer.forEach((push) => push.destroy());
      this.pushBuffer = [];
      this.rejoinTimer.reset();
      this.joinPush.destroy();
      this.state = CHANNEL_STATES.closed;
      this.bindings = {};
    }
    /** @internal */
    async _fetchWithTimeout(url, options, timeout) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));
      clearTimeout(id);
      return response;
    }
    /** @internal */
    _push(event, payload, timeout = this.timeout) {
      if (!this.joinedOnce) {
        throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
      }
      let pushEvent = new Push(this, event, payload, timeout);
      if (this._canPush()) {
        pushEvent.send();
      } else {
        this._addToPushBuffer(pushEvent);
      }
      return pushEvent;
    }
    /** @internal */
    _addToPushBuffer(pushEvent) {
      pushEvent.startTimeout();
      this.pushBuffer.push(pushEvent);
      if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {
        const removedPush = this.pushBuffer.shift();
        if (removedPush) {
          removedPush.destroy();
          this.socket.log("channel", `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);
        }
      }
    }
    /**
     * Overridable message hook
     *
     * Receives all events for specialized message handling before dispatching to the channel callbacks.
     * Must return the payload, modified or unmodified.
     *
     * @internal
     */
    _onMessage(_event, payload, _ref) {
      return payload;
    }
    /** @internal */
    _isMember(topic) {
      return this.topic === topic;
    }
    /** @internal */
    _joinRef() {
      return this.joinPush.ref;
    }
    /** @internal */
    _trigger(type, payload, ref) {
      var _a2, _b;
      const typeLower = type.toLocaleLowerCase();
      const { close, error, leave, join } = CHANNEL_EVENTS;
      const events2 = [close, error, leave, join];
      if (ref && events2.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
        return;
      }
      let handledPayload = this._onMessage(typeLower, payload, ref);
      if (payload && !handledPayload) {
        throw "channel onMessage callbacks must return the payload, modified or unmodified";
      }
      if (["insert", "update", "delete"].includes(typeLower)) {
        (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.filter((bind) => {
          var _a3, _b2, _c;
          return ((_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event) === "*" || ((_c = (_b2 = bind.filter) === null || _b2 === void 0 ? void 0 : _b2.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
        }).map((bind) => bind.callback(handledPayload, ref));
      } else {
        (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {
          var _a3, _b2, _c, _d, _e, _f;
          if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
            if ("id" in bind) {
              const bindId = bind.id;
              const bindEvent = (_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event;
              return bindId && ((_b2 = payload.ids) === null || _b2 === void 0 ? void 0 : _b2.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
            } else {
              const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
              return bindEvent === "*" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
            }
          } else {
            return bind.type.toLocaleLowerCase() === typeLower;
          }
        }).map((bind) => {
          if (typeof handledPayload === "object" && "ids" in handledPayload) {
            const postgresChanges = handledPayload.data;
            const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;
            const enrichedPayload = {
              schema,
              table,
              commit_timestamp,
              eventType: type2,
              new: {},
              old: {},
              errors
            };
            handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
          }
          bind.callback(handledPayload, ref);
        });
      }
    }
    /** @internal */
    _isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    /** @internal */
    _isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    /** @internal */
    _isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    /** @internal */
    _isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
    /** @internal */
    _replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    /** @internal */
    _on(type, filter, callback) {
      const typeLower = type.toLocaleLowerCase();
      const binding = {
        type: typeLower,
        filter,
        callback
      };
      if (this.bindings[typeLower]) {
        this.bindings[typeLower].push(binding);
      } else {
        this.bindings[typeLower] = [binding];
      }
      return this;
    }
    /** @internal */
    _off(type, filter) {
      const typeLower = type.toLocaleLowerCase();
      if (this.bindings[typeLower]) {
        this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {
          var _a2;
          return !(((_a2 = bind.type) === null || _a2 === void 0 ? void 0 : _a2.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
        });
      }
      return this;
    }
    /** @internal */
    static isEqual(obj1, obj2) {
      if (Object.keys(obj1).length !== Object.keys(obj2).length) {
        return false;
      }
      for (const k in obj1) {
        if (obj1[k] !== obj2[k]) {
          return false;
        }
      }
      return true;
    }
    /** @internal */
    _rejoinUntilConnected() {
      this.rejoinTimer.scheduleTimeout();
      if (this.socket.isConnected()) {
        this._rejoin();
      }
    }
    /**
     * Registers a callback that will be executed when the channel closes.
     *
     * @internal
     */
    _onClose(callback) {
      this._on(CHANNEL_EVENTS.close, {}, callback);
    }
    /**
     * Registers a callback that will be executed when the channel encounteres an error.
     *
     * @internal
     */
    _onError(callback) {
      this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));
    }
    /**
     * Returns `true` if the socket is connected and the channel has been joined.
     *
     * @internal
     */
    _canPush() {
      return this.socket.isConnected() && this._isJoined();
    }
    /** @internal */
    _rejoin(timeout = this.timeout) {
      if (this._isLeaving()) {
        return;
      }
      this.socket._leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    /** @internal */
    _getPayloadRecords(payload) {
      const records = {
        new: {},
        old: {}
      };
      if (payload.type === "INSERT" || payload.type === "UPDATE") {
        records.new = convertChangeData(payload.columns, payload.record);
      }
      if (payload.type === "UPDATE" || payload.type === "DELETE") {
        records.old = convertChangeData(payload.columns, payload.old_record);
      }
      return records;
    }
  }
  const noop = () => {
  };
  const CONNECTION_TIMEOUTS = {
    HEARTBEAT_INTERVAL: 25e3,
    RECONNECT_DELAY: 10,
    HEARTBEAT_TIMEOUT_FALLBACK: 100
  };
  const RECONNECT_INTERVALS = [1e3, 2e3, 5e3, 1e4];
  const DEFAULT_RECONNECT_FALLBACK = 1e4;
  const WORKER_SCRIPT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
  class RealtimeClient {
    /**
     * Initializes the Socket.
     *
     * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
     * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation
     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
     * @param options.params The optional params to pass when connecting.
     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.
     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
     * @param options.heartbeatCallback The optional function to handle heartbeat status.
     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
     * @param options.logLevel Sets the log level for Realtime
     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
     * @param options.worker Use Web Worker to set a side flow. Defaults to false.
     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
     * @example
     * ```ts
     * import RealtimeClient from '@supabase/realtime-js'
     *
     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {
     *   params: { apikey: 'public-anon-key' },
     * })
     * client.connect()
     * ```
     */
    constructor(endPoint, options) {
      var _a2;
      this.accessTokenValue = null;
      this.apiKey = null;
      this.channels = new Array();
      this.endPoint = "";
      this.httpEndpoint = "";
      this.headers = {};
      this.params = {};
      this.timeout = DEFAULT_TIMEOUT;
      this.transport = null;
      this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
      this.heartbeatTimer = void 0;
      this.pendingHeartbeatRef = null;
      this.heartbeatCallback = noop;
      this.ref = 0;
      this.reconnectTimer = null;
      this.vsn = DEFAULT_VSN;
      this.logger = noop;
      this.conn = null;
      this.sendBuffer = [];
      this.serializer = new Serializer();
      this.stateChangeCallbacks = {
        open: [],
        close: [],
        error: [],
        message: []
      };
      this.accessToken = null;
      this._connectionState = "disconnected";
      this._wasManualDisconnect = false;
      this._authPromise = null;
      this._resolveFetch = (customFetch) => {
        if (customFetch) {
          return (...args) => customFetch(...args);
        }
        return (...args) => fetch(...args);
      };
      if (!((_a2 = options === null || options === void 0 ? void 0 : options.params) === null || _a2 === void 0 ? void 0 : _a2.apikey)) {
        throw new Error("API key is required to connect to Realtime");
      }
      this.apiKey = options.params.apikey;
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.httpEndpoint = httpEndpointURL(endPoint);
      this._initializeOptions(options);
      this._setupReconnectionTimer();
      this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
    }
    /**
     * Connects the socket, unless already connected.
     */
    connect() {
      if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {
        return;
      }
      this._setConnectionState("connecting");
      if (this.accessToken && !this._authPromise) {
        this._setAuthSafely("connect");
      }
      if (this.transport) {
        this.conn = new this.transport(this.endpointURL());
      } else {
        try {
          this.conn = WebSocketFactory.createWebSocket(this.endpointURL());
        } catch (error) {
          this._setConnectionState("disconnected");
          const errorMessage = error.message;
          if (errorMessage.includes("Node.js")) {
            throw new Error(`${errorMessage}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`);
          }
          throw new Error(`WebSocket not available: ${errorMessage}`);
        }
      }
      this._setupConnectionHandlers();
    }
    /**
     * Returns the URL of the websocket.
     * @returns string The URL of the websocket.
     */
    endpointURL() {
      return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: this.vsn }));
    }
    /**
     * Disconnects the socket.
     *
     * @param code A numeric status code to send on disconnect.
     * @param reason A custom reason for the disconnect.
     */
    disconnect(code, reason) {
      if (this.isDisconnecting()) {
        return;
      }
      this._setConnectionState("disconnecting", true);
      if (this.conn) {
        const fallbackTimer = setTimeout(() => {
          this._setConnectionState("disconnected");
        }, 100);
        this.conn.onclose = () => {
          clearTimeout(fallbackTimer);
          this._setConnectionState("disconnected");
        };
        if (typeof this.conn.close === "function") {
          if (code) {
            this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
          } else {
            this.conn.close();
          }
        }
        this._teardownConnection();
      } else {
        this._setConnectionState("disconnected");
      }
    }
    /**
     * Returns all created channels
     */
    getChannels() {
      return this.channels;
    }
    /**
     * Unsubscribes and removes a single channel
     * @param channel A RealtimeChannel instance
     */
    async removeChannel(channel) {
      const status = await channel.unsubscribe();
      if (this.channels.length === 0) {
        this.disconnect();
      }
      return status;
    }
    /**
     * Unsubscribes and removes all channels
     */
    async removeAllChannels() {
      const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));
      this.channels = [];
      this.disconnect();
      return values_1;
    }
    /**
     * Logs the message.
     *
     * For customized logging, `this.logger` can be overridden.
     */
    log(kind2, msg, data) {
      this.logger(kind2, msg, data);
    }
    /**
     * Returns the current state of the socket.
     */
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return CONNECTION_STATE.Connecting;
        case SOCKET_STATES.open:
          return CONNECTION_STATE.Open;
        case SOCKET_STATES.closing:
          return CONNECTION_STATE.Closing;
        default:
          return CONNECTION_STATE.Closed;
      }
    }
    /**
     * Returns `true` is the connection is open.
     */
    isConnected() {
      return this.connectionState() === CONNECTION_STATE.Open;
    }
    /**
     * Returns `true` if the connection is currently connecting.
     */
    isConnecting() {
      return this._connectionState === "connecting";
    }
    /**
     * Returns `true` if the connection is currently disconnecting.
     */
    isDisconnecting() {
      return this._connectionState === "disconnecting";
    }
    /**
     * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.
     *
     * Topics are automatically prefixed with `realtime:` to match the Realtime service.
     * If a channel with the same topic already exists it will be returned instead of creating
     * a duplicate connection.
     */
    channel(topic, params = { config: {} }) {
      const realtimeTopic = `realtime:${topic}`;
      const exists = this.getChannels().find((c) => c.topic === realtimeTopic);
      if (!exists) {
        const chan = new RealtimeChannel(`realtime:${topic}`, params, this);
        this.channels.push(chan);
        return chan;
      } else {
        return exists;
      }
    }
    /**
     * Push out a message if the socket is connected.
     *
     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
     */
    push(data) {
      const { topic, event, payload, ref } = data;
      const callback = () => {
        this.encode(data, (result2) => {
          var _a2;
          (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.send(result2);
        });
      };
      this.log("push", `${topic} ${event} (${ref})`, payload);
      if (this.isConnected()) {
        callback();
      } else {
        this.sendBuffer.push(callback);
      }
    }
    /**
     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
     *
     * If param is null it will use the `accessToken` callback function or the token set on the client.
     *
     * On callback used, it will set the value of the token internal to the client.
     *
     * @param token A JWT string to override the token set on the client.
     */
    async setAuth(token = null) {
      this._authPromise = this._performAuth(token);
      try {
        await this._authPromise;
      } finally {
        this._authPromise = null;
      }
    }
    /**
     * Sends a heartbeat message if the socket is connected.
     */
    async sendHeartbeat() {
      var _a2;
      if (!this.isConnected()) {
        try {
          this.heartbeatCallback("disconnected");
        } catch (e) {
          this.log("error", "error in heartbeat callback", e);
        }
        return;
      }
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        try {
          this.heartbeatCallback("timeout");
        } catch (e) {
          this.log("error", "error in heartbeat callback", e);
        }
        this._wasManualDisconnect = false;
        (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.close(WS_CLOSE_NORMAL, "heartbeat timeout");
        setTimeout(() => {
          var _a3;
          if (!this.isConnected()) {
            (_a3 = this.reconnectTimer) === null || _a3 === void 0 ? void 0 : _a3.scheduleTimeout();
          }
        }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);
        return;
      }
      this.pendingHeartbeatRef = this._makeRef();
      this.push({
        topic: "phoenix",
        event: "heartbeat",
        payload: {},
        ref: this.pendingHeartbeatRef
      });
      try {
        this.heartbeatCallback("sent");
      } catch (e) {
        this.log("error", "error in heartbeat callback", e);
      }
      this._setAuthSafely("heartbeat");
    }
    /**
     * Sets a callback that receives lifecycle events for internal heartbeat messages.
     * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).
     */
    onHeartbeat(callback) {
      this.heartbeatCallback = callback;
    }
    /**
     * Flushes send buffer
     */
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback) => callback());
        this.sendBuffer = [];
      }
    }
    /**
     * Return the next message ref, accounting for overflows
     *
     * @internal
     */
    _makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    /**
     * Unsubscribe from channels with the specified topic.
     *
     * @internal
     */
    _leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));
      if (dupChannel) {
        this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.unsubscribe();
      }
    }
    /**
     * Removes a subscription from the socket.
     *
     * @param channel An open subscription.
     *
     * @internal
     */
    _remove(channel) {
      this.channels = this.channels.filter((c) => c.topic !== channel.topic);
    }
    /** @internal */
    _onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        if (msg.topic === "phoenix" && msg.event === "phx_reply") {
          try {
            this.heartbeatCallback(msg.payload.status === "ok" ? "ok" : "error");
          } catch (e) {
            this.log("error", "error in heartbeat callback", e);
          }
        }
        if (msg.ref && msg.ref === this.pendingHeartbeatRef) {
          this.pendingHeartbeatRef = null;
        }
        const { topic, event, payload, ref } = msg;
        const refString = ref ? `(${ref})` : "";
        const status = payload.status || "";
        this.log("receive", `${status} ${topic} ${event} ${refString}`.trim(), payload);
        this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));
        this._triggerStateCallbacks("message", msg);
      });
    }
    /**
     * Clear specific timer
     * @internal
     */
    _clearTimer(timer) {
      var _a2;
      if (timer === "heartbeat" && this.heartbeatTimer) {
        clearInterval(this.heartbeatTimer);
        this.heartbeatTimer = void 0;
      } else if (timer === "reconnect") {
        (_a2 = this.reconnectTimer) === null || _a2 === void 0 ? void 0 : _a2.reset();
      }
    }
    /**
     * Clear all timers
     * @internal
     */
    _clearAllTimers() {
      this._clearTimer("heartbeat");
      this._clearTimer("reconnect");
    }
    /**
     * Setup connection handlers for WebSocket events
     * @internal
     */
    _setupConnectionHandlers() {
      if (!this.conn)
        return;
      if ("binaryType" in this.conn) {
        this.conn.binaryType = "arraybuffer";
      }
      this.conn.onopen = () => this._onConnOpen();
      this.conn.onerror = (error) => this._onConnError(error);
      this.conn.onmessage = (event) => this._onConnMessage(event);
      this.conn.onclose = (event) => this._onConnClose(event);
    }
    /**
     * Teardown connection and cleanup resources
     * @internal
     */
    _teardownConnection() {
      if (this.conn) {
        if (this.conn.readyState === SOCKET_STATES.open || this.conn.readyState === SOCKET_STATES.connecting) {
          try {
            this.conn.close();
          } catch (e) {
            this.log("error", "Error closing connection", e);
          }
        }
        this.conn.onopen = null;
        this.conn.onerror = null;
        this.conn.onmessage = null;
        this.conn.onclose = null;
        this.conn = null;
      }
      this._clearAllTimers();
      this.channels.forEach((channel) => channel.teardown());
    }
    /** @internal */
    _onConnOpen() {
      this._setConnectionState("connected");
      this.log("transport", `connected to ${this.endpointURL()}`);
      const authPromise = this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());
      authPromise.then(() => {
        this.flushSendBuffer();
      }).catch((e) => {
        this.log("error", "error waiting for auth on connect", e);
        this.flushSendBuffer();
      });
      this._clearTimer("reconnect");
      if (!this.worker) {
        this._startHeartbeat();
      } else {
        if (!this.workerRef) {
          this._startWorkerHeartbeat();
        }
      }
      this._triggerStateCallbacks("open");
    }
    /** @internal */
    _startHeartbeat() {
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    /** @internal */
    _startWorkerHeartbeat() {
      if (this.workerUrl) {
        this.log("worker", `starting worker for from ${this.workerUrl}`);
      } else {
        this.log("worker", `starting default worker`);
      }
      const objectUrl = this._workerObjectUrl(this.workerUrl);
      this.workerRef = new Worker(objectUrl);
      this.workerRef.onerror = (error) => {
        this.log("worker", "worker error", error.message);
        this.workerRef.terminate();
      };
      this.workerRef.onmessage = (event) => {
        if (event.data.event === "keepAlive") {
          this.sendHeartbeat();
        }
      };
      this.workerRef.postMessage({
        event: "start",
        interval: this.heartbeatIntervalMs
      });
    }
    /** @internal */
    _onConnClose(event) {
      var _a2;
      this._setConnectionState("disconnected");
      this.log("transport", "close", event);
      this._triggerChanError();
      this._clearTimer("heartbeat");
      if (!this._wasManualDisconnect) {
        (_a2 = this.reconnectTimer) === null || _a2 === void 0 ? void 0 : _a2.scheduleTimeout();
      }
      this._triggerStateCallbacks("close", event);
    }
    /** @internal */
    _onConnError(error) {
      this._setConnectionState("disconnected");
      this.log("transport", `${error}`);
      this._triggerChanError();
      this._triggerStateCallbacks("error", error);
    }
    /** @internal */
    _triggerChanError() {
      this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));
    }
    /** @internal */
    _appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      const prefix = url.match(/\?/) ? "&" : "?";
      const query = new URLSearchParams(params);
      return `${url}${prefix}${query}`;
    }
    _workerObjectUrl(url) {
      let result_url;
      if (url) {
        result_url = url;
      } else {
        const blob = new Blob([WORKER_SCRIPT], { type: "application/javascript" });
        result_url = URL.createObjectURL(blob);
      }
      return result_url;
    }
    /**
     * Set connection state with proper state management
     * @internal
     */
    _setConnectionState(state, manual = false) {
      this._connectionState = state;
      if (state === "connecting") {
        this._wasManualDisconnect = false;
      } else if (state === "disconnecting") {
        this._wasManualDisconnect = manual;
      }
    }
    /**
     * Perform the actual auth operation
     * @internal
     */
    async _performAuth(token = null) {
      let tokenToSend;
      if (token) {
        tokenToSend = token;
      } else if (this.accessToken) {
        tokenToSend = await this.accessToken();
      } else {
        tokenToSend = this.accessTokenValue;
      }
      if (this.accessTokenValue != tokenToSend) {
        this.accessTokenValue = tokenToSend;
        this.channels.forEach((channel) => {
          const payload = {
            access_token: tokenToSend,
            version: DEFAULT_VERSION
          };
          tokenToSend && channel.updateJoinPayload(payload);
          if (channel.joinedOnce && channel._isJoined()) {
            channel._push(CHANNEL_EVENTS.access_token, {
              access_token: tokenToSend
            });
          }
        });
      }
    }
    /**
     * Wait for any in-flight auth operations to complete
     * @internal
     */
    async _waitForAuthIfNeeded() {
      if (this._authPromise) {
        await this._authPromise;
      }
    }
    /**
     * Safely call setAuth with standardized error handling
     * @internal
     */
    _setAuthSafely(context = "general") {
      this.setAuth().catch((e) => {
        this.log("error", `error setting auth in ${context}`, e);
      });
    }
    /**
     * Trigger state change callbacks with proper error handling
     * @internal
     */
    _triggerStateCallbacks(event, data) {
      try {
        this.stateChangeCallbacks[event].forEach((callback) => {
          try {
            callback(data);
          } catch (e) {
            this.log("error", `error in ${event} callback`, e);
          }
        });
      } catch (e) {
        this.log("error", `error triggering ${event} callbacks`, e);
      }
    }
    /**
     * Setup reconnection timer with proper configuration
     * @internal
     */
    _setupReconnectionTimer() {
      this.reconnectTimer = new Timer(async () => {
        setTimeout(async () => {
          await this._waitForAuthIfNeeded();
          if (!this.isConnected()) {
            this.connect();
          }
        }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);
      }, this.reconnectAfterMs);
    }
    /**
     * Initialize client options with defaults
     * @internal
     */
    _initializeOptions(options) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.transport = (_a2 = options === null || options === void 0 ? void 0 : options.transport) !== null && _a2 !== void 0 ? _a2 : null;
      this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : DEFAULT_TIMEOUT;
      this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
      this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;
      this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;
      this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;
      this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : DEFAULT_VSN;
      if (options === null || options === void 0 ? void 0 : options.params)
        this.params = options.params;
      if (options === null || options === void 0 ? void 0 : options.logger)
        this.logger = options.logger;
      if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {
        this.logLevel = options.logLevel || options.log_level;
        this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });
      }
      this.reconnectAfterMs = (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : ((tries) => {
        return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;
      });
      switch (this.vsn) {
        case VSN_1_0_0:
          this.encode = (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : ((payload, callback) => {
            return callback(JSON.stringify(payload));
          });
          this.decode = (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : ((payload, callback) => {
            return callback(JSON.parse(payload));
          });
          break;
        case VSN_2_0_0:
          this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);
          this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);
          break;
        default:
          throw new Error(`Unsupported serializer version: ${this.vsn}`);
      }
      if (this.worker) {
        if (typeof window !== "undefined" && !window.Worker) {
          throw new Error("Web Worker is not supported");
        }
        this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
      }
    }
  }
  class StorageError extends Error {
    constructor(message) {
      super(message);
      this.__isStorageError = true;
      this.name = "StorageError";
    }
  }
  function isStorageError(error) {
    return typeof error === "object" && error !== null && "__isStorageError" in error;
  }
  class StorageApiError extends StorageError {
    constructor(message, status, statusCode) {
      super(message);
      this.name = "StorageApiError";
      this.status = status;
      this.statusCode = statusCode;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status,
        statusCode: this.statusCode
      };
    }
  }
  class StorageUnknownError extends StorageError {
    constructor(message, originalError) {
      super(message);
      this.name = "StorageUnknownError";
      this.originalError = originalError;
    }
  }
  const resolveFetch$3 = (customFetch) => {
    if (customFetch) {
      return (...args) => customFetch(...args);
    }
    return (...args) => fetch(...args);
  };
  const resolveResponse = () => {
    return Response;
  };
  const recursiveToCamel = (item) => {
    if (Array.isArray(item)) {
      return item.map((el) => recursiveToCamel(el));
    } else if (typeof item === "function" || item !== Object(item)) {
      return item;
    }
    const result2 = {};
    Object.entries(item).forEach(([key, value]) => {
      const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ""));
      result2[newKey] = recursiveToCamel(value);
    });
    return result2;
  };
  const isPlainObject$1 = (value) => {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  };
  const _getErrorMessage$2 = (err) => {
    var _a2;
    return err.msg || err.message || err.error_description || (typeof err.error === "string" ? err.error : (_a2 = err.error) === null || _a2 === void 0 ? void 0 : _a2.message) || JSON.stringify(err);
  };
  const handleError$2 = (error, reject, options) => __awaiter(void 0, void 0, void 0, function* () {
    const Res = yield resolveResponse();
    if (error instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
      error.json().then((err) => {
        const status = error.status || 500;
        const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || status + "";
        reject(new StorageApiError(_getErrorMessage$2(err), status, statusCode));
      }).catch((err) => {
        reject(new StorageUnknownError(_getErrorMessage$2(err), err));
      });
    } else {
      reject(new StorageUnknownError(_getErrorMessage$2(error), error));
    }
  });
  const _getRequestParams$2 = (method, options, parameters, body) => {
    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
    if (method === "GET" || !body) {
      return params;
    }
    if (isPlainObject$1(body)) {
      params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
      params.body = JSON.stringify(body);
    } else {
      params.body = body;
    }
    if (options === null || options === void 0 ? void 0 : options.duplex) {
      params.duplex = options.duplex;
    }
    return Object.assign(Object.assign({}, params), parameters);
  };
  function _handleRequest$2(fetcher, method, url, options, parameters, body) {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => {
        fetcher(url, _getRequestParams$2(method, options, parameters, body)).then((result2) => {
          if (!result2.ok)
            throw result2;
          if (options === null || options === void 0 ? void 0 : options.noResolveJson)
            return result2;
          return result2.json();
        }).then((data) => resolve(data)).catch((error) => handleError$2(error, reject, options));
      });
    });
  }
  function get(fetcher, url, options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      return _handleRequest$2(fetcher, "GET", url, options, parameters);
    });
  }
  function post$1(fetcher, url, body, options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      return _handleRequest$2(fetcher, "POST", url, options, parameters, body);
    });
  }
  function put(fetcher, url, body, options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      return _handleRequest$2(fetcher, "PUT", url, options, parameters, body);
    });
  }
  function head(fetcher, url, options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      return _handleRequest$2(fetcher, "HEAD", url, Object.assign(Object.assign({}, options), { noResolveJson: true }), parameters);
    });
  }
  function remove(fetcher, url, body, options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      return _handleRequest$2(fetcher, "DELETE", url, options, parameters, body);
    });
  }
  class StreamDownloadBuilder {
    constructor(downloadFn, shouldThrowOnError) {
      this.downloadFn = downloadFn;
      this.shouldThrowOnError = shouldThrowOnError;
    }
    then(onfulfilled, onrejected) {
      return this.execute().then(onfulfilled, onrejected);
    }
    execute() {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const result2 = yield this.downloadFn();
          return {
            data: result2.body,
            error: null
          };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
  }
  var _a;
  class BlobDownloadBuilder {
    constructor(downloadFn, shouldThrowOnError) {
      this.downloadFn = downloadFn;
      this.shouldThrowOnError = shouldThrowOnError;
      this[_a] = "BlobDownloadBuilder";
      this.promise = null;
    }
    asStream() {
      return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);
    }
    then(onfulfilled, onrejected) {
      return this.getPromise().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
      return this.getPromise().catch(onrejected);
    }
    finally(onfinally) {
      return this.getPromise().finally(onfinally);
    }
    getPromise() {
      if (!this.promise) {
        this.promise = this.execute();
      }
      return this.promise;
    }
    execute() {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const result2 = yield this.downloadFn();
          return {
            data: yield result2.blob(),
            error: null
          };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
  }
  _a = Symbol.toStringTag;
  const DEFAULT_SEARCH_OPTIONS = {
    limit: 100,
    offset: 0,
    sortBy: {
      column: "name",
      order: "asc"
    }
  };
  const DEFAULT_FILE_OPTIONS = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: false
  };
  class StorageFileApi {
    constructor(url, headers = {}, bucketId, fetch2) {
      this.shouldThrowOnError = false;
      this.url = url;
      this.headers = headers;
      this.bucketId = bucketId;
      this.fetch = resolveFetch$3(fetch2);
    }
    /**
     * Enable throwing errors instead of returning them.
     *
     * @category File Buckets
     */
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    /**
     * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
     *
     * @param method HTTP method.
     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
     * @param fileBody The body of the file to be stored in the bucket.
     */
    uploadOrUpdate(method, path, fileBody, fileOptions) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          let body;
          const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
          let headers = Object.assign(Object.assign({}, this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
          const metadata = options.metadata;
          if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
            body = new FormData();
            body.append("cacheControl", options.cacheControl);
            if (metadata) {
              body.append("metadata", this.encodeMetadata(metadata));
            }
            body.append("", fileBody);
          } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
            body = fileBody;
            if (!body.has("cacheControl")) {
              body.append("cacheControl", options.cacheControl);
            }
            if (metadata && !body.has("metadata")) {
              body.append("metadata", this.encodeMetadata(metadata));
            }
          } else {
            body = fileBody;
            headers["cache-control"] = `max-age=${options.cacheControl}`;
            headers["content-type"] = options.contentType;
            if (metadata) {
              headers["x-metadata"] = this.toBase64(this.encodeMetadata(metadata));
            }
            const isStream = typeof ReadableStream !== "undefined" && body instanceof ReadableStream || body && typeof body === "object" && "pipe" in body && typeof body.pipe === "function";
            if (isStream && !options.duplex) {
              options.duplex = "half";
            }
          }
          if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {
            headers = Object.assign(Object.assign({}, headers), fileOptions.headers);
          }
          const cleanPath = this._removeEmptyFolders(path);
          const _path = this._getFinalPath(cleanPath);
          const data = yield (method == "PUT" ? put : post$1)(this.fetch, `${this.url}/object/${_path}`, body, Object.assign({ headers }, (options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {}));
          return {
            data: { path: cleanPath, id: data.Id, fullPath: data.Key },
            error: null
          };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Uploads a file to an existing bucket.
     *
     * @category File Buckets
     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
     * @param fileBody The body of the file to be stored in the bucket.
     * @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.
     * @returns Promise with file path and id or error
     *
     * @example Upload file
     * ```js
     * const avatarFile = event.target.files[0]
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .upload('public/avatar1.png', avatarFile, {
     *     cacheControl: '3600',
     *     upsert: false
     *   })
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "path": "public/avatar1.png",
     *     "fullPath": "avatars/public/avatar1.png"
     *   },
     *   "error": null
     * }
     * ```
     *
     * @example Upload file using `ArrayBuffer` from base64 file data
     * ```js
     * import { decode } from 'base64-arraybuffer'
     *
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .upload('public/avatar1.png', decode('base64FileData'), {
     *     contentType: 'image/png'
     *   })
     * ```
     */
    upload(path, fileBody, fileOptions) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
      });
    }
    /**
     * Upload a file with a token generated from `createSignedUploadUrl`.
     *
     * @category File Buckets
     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
     * @param token The token generated from `createSignedUploadUrl`
     * @param fileBody The body of the file to be stored in the bucket.
     * @param fileOptions Optional file upload options including cacheControl and contentType.
     * @returns Promise with file path and full path or error
     *
     * @example Upload to a signed URL
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "path": "folder/cat.jpg",
     *     "fullPath": "avatars/folder/cat.jpg"
     *   },
     *   "error": null
     * }
     * ```
     */
    uploadToSignedUrl(path, token, fileBody, fileOptions) {
      return __awaiter(this, void 0, void 0, function* () {
        const cleanPath = this._removeEmptyFolders(path);
        const _path = this._getFinalPath(cleanPath);
        const url = new URL(this.url + `/object/upload/sign/${_path}`);
        url.searchParams.set("token", token);
        try {
          let body;
          const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);
          const headers = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(options.upsert) });
          if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
            body = new FormData();
            body.append("cacheControl", options.cacheControl);
            body.append("", fileBody);
          } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
            body = fileBody;
            body.append("cacheControl", options.cacheControl);
          } else {
            body = fileBody;
            headers["cache-control"] = `max-age=${options.cacheControl}`;
            headers["content-type"] = options.contentType;
          }
          const data = yield put(this.fetch, url.toString(), body, { headers });
          return {
            data: { path: cleanPath, fullPath: data.Key },
            error: null
          };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Creates a signed upload URL.
     * Signed upload URLs can be used to upload files to the bucket without further authentication.
     * They are valid for 2 hours.
     *
     * @category File Buckets
     * @param path The file path, including the current file name. For example `folder/image.png`.
     * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
     * @returns Promise with signed upload URL, token, and path or error
     *
     * @example Create Signed Upload URL
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .createSignedUploadUrl('folder/cat.jpg')
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "signedUrl": "https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>",
     *     "path": "folder/cat.jpg",
     *     "token": "<TOKEN>"
     *   },
     *   "error": null
     * }
     * ```
     */
    createSignedUploadUrl(path, options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          let _path = this._getFinalPath(path);
          const headers = Object.assign({}, this.headers);
          if (options === null || options === void 0 ? void 0 : options.upsert) {
            headers["x-upsert"] = "true";
          }
          const data = yield post$1(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers });
          const url = new URL(this.url + data.url);
          const token = url.searchParams.get("token");
          if (!token) {
            throw new StorageError("No token returned by API");
          }
          return { data: { signedUrl: url.toString(), path, token }, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Replaces an existing file at the specified path with a new one.
     *
     * @category File Buckets
     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
     * @param fileBody The body of the file to be stored in the bucket.
     * @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.
     * @returns Promise with file path and id or error
     *
     * @example Update file
     * ```js
     * const avatarFile = event.target.files[0]
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .update('public/avatar1.png', avatarFile, {
     *     cacheControl: '3600',
     *     upsert: true
     *   })
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "path": "public/avatar1.png",
     *     "fullPath": "avatars/public/avatar1.png"
     *   },
     *   "error": null
     * }
     * ```
     *
     * @example Update file using `ArrayBuffer` from base64 file data
     * ```js
     * import {decode} from 'base64-arraybuffer'
     *
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .update('public/avatar1.png', decode('base64FileData'), {
     *     contentType: 'image/png'
     *   })
     * ```
     */
    update(path, fileBody, fileOptions) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
      });
    }
    /**
     * Moves an existing file to a new path in the same bucket.
     *
     * @category File Buckets
     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
     * @param options The destination options.
     * @returns Promise with success message or error
     *
     * @example Move file
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .move('public/avatar1.png', 'private/avatar2.png')
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "message": "Successfully moved"
     *   },
     *   "error": null
     * }
     * ```
     */
    move(fromPath, toPath, options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post$1(this.fetch, `${this.url}/object/move`, {
            bucketId: this.bucketId,
            sourceKey: fromPath,
            destinationKey: toPath,
            destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
          }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Copies an existing file to a new path in the same bucket.
     *
     * @category File Buckets
     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
     * @param options The destination options.
     * @returns Promise with copied file path or error
     *
     * @example Copy file
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .copy('public/avatar1.png', 'private/avatar2.png')
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "path": "avatars/private/avatar2.png"
     *   },
     *   "error": null
     * }
     * ```
     */
    copy(fromPath, toPath, options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post$1(this.fetch, `${this.url}/object/copy`, {
            bucketId: this.bucketId,
            sourceKey: fromPath,
            destinationKey: toPath,
            destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
          }, { headers: this.headers });
          return { data: { path: data.Key }, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
     *
     * @category File Buckets
     * @param path The file path, including the current file name. For example `folder/image.png`.
     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
     * @param options.transform Transform the asset before serving it to the client.
     * @returns Promise with signed URL or error
     *
     * @example Create Signed URL
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .createSignedUrl('folder/avatar1.png', 60)
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>"
     *   },
     *   "error": null
     * }
     * ```
     *
     * @example Create a signed URL for an asset with transformations
     * ```js
     * const { data } = await supabase
     *   .storage
     *   .from('avatars')
     *   .createSignedUrl('folder/avatar1.png', 60, {
     *     transform: {
     *       width: 100,
     *       height: 100,
     *     }
     *   })
     * ```
     *
     * @example Create a signed URL which triggers the download of the asset
     * ```js
     * const { data } = await supabase
     *   .storage
     *   .from('avatars')
     *   .createSignedUrl('folder/avatar1.png', 60, {
     *     download: true,
     *   })
     * ```
     */
    createSignedUrl(path, expiresIn, options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          let _path = this._getFinalPath(path);
          let data = yield post$1(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, (options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {}), { headers: this.headers });
          const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
          const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
          data = { signedUrl };
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
     *
     * @category File Buckets
     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
     * @returns Promise with array of signed URLs or error
     *
     * @example Create Signed URLs
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": [
     *     {
     *       "error": null,
     *       "path": "folder/avatar1.png",
     *       "signedURL": "/object/sign/avatars/folder/avatar1.png?token=<TOKEN>",
     *       "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>"
     *     },
     *     {
     *       "error": null,
     *       "path": "folder/avatar2.png",
     *       "signedURL": "/object/sign/avatars/folder/avatar2.png?token=<TOKEN>",
     *       "signedUrl": "https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>"
     *     }
     *   ],
     *   "error": null
     * }
     * ```
     */
    createSignedUrls(paths, expiresIn, options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post$1(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });
          const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
          return {
            data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null })),
            error: null
          };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
     *
     * @category File Buckets
     * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
     * @param options.transform Transform the asset before serving it to the client.
     * @returns BlobDownloadBuilder instance for downloading the file
     *
     * @example Download file
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .download('folder/avatar1.png')
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": <BLOB>,
     *   "error": null
     * }
     * ```
     *
     * @example Download file with transformations
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .download('folder/avatar1.png', {
     *     transform: {
     *       width: 100,
     *       height: 100,
     *       quality: 80
     *     }
     *   })
     * ```
     */
    download(path, options) {
      const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
      const renderPath = wantsTransformation ? "render/image/authenticated" : "object";
      const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
      const queryString = transformationQuery ? `?${transformationQuery}` : "";
      const _path = this._getFinalPath(path);
      const downloadFn = () => get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
        headers: this.headers,
        noResolveJson: true
      });
      return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);
    }
    /**
     * Retrieves the details of an existing file.
     *
     * @category File Buckets
     * @param path The file path, including the file name. For example `folder/image.png`.
     * @returns Promise with file metadata or error
     *
     * @example Get file info
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .info('folder/avatar1.png')
     * ```
     */
    info(path) {
      return __awaiter(this, void 0, void 0, function* () {
        const _path = this._getFinalPath(path);
        try {
          const data = yield get(this.fetch, `${this.url}/object/info/${_path}`, {
            headers: this.headers
          });
          return { data: recursiveToCamel(data), error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Checks the existence of a file.
     *
     * @category File Buckets
     * @param path The file path, including the file name. For example `folder/image.png`.
     * @returns Promise with boolean indicating file existence or error
     *
     * @example Check file existence
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .exists('folder/avatar1.png')
     * ```
     */
    exists(path) {
      return __awaiter(this, void 0, void 0, function* () {
        const _path = this._getFinalPath(path);
        try {
          yield head(this.fetch, `${this.url}/object/${_path}`, {
            headers: this.headers
          });
          return { data: true, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error) && error instanceof StorageUnknownError) {
            const originalError = error.originalError;
            if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {
              return { data: false, error };
            }
          }
          throw error;
        }
      });
    }
    /**
     * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
     * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
     *
     * @category File Buckets
     * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
     * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
     * @param options.transform Transform the asset before serving it to the client.
     * @returns Object with public URL
     *
     * @example Returns the URL for an asset in a public bucket
     * ```js
     * const { data } = supabase
     *   .storage
     *   .from('public-bucket')
     *   .getPublicUrl('folder/avatar1.png')
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "publicUrl": "https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png"
     *   }
     * }
     * ```
     *
     * @example Returns the URL for an asset in a public bucket with transformations
     * ```js
     * const { data } = supabase
     *   .storage
     *   .from('public-bucket')
     *   .getPublicUrl('folder/avatar1.png', {
     *     transform: {
     *       width: 100,
     *       height: 100,
     *     }
     *   })
     * ```
     *
     * @example Returns the URL which triggers the download of an asset in a public bucket
     * ```js
     * const { data } = supabase
     *   .storage
     *   .from('public-bucket')
     *   .getPublicUrl('folder/avatar1.png', {
     *     download: true,
     *   })
     * ```
     */
    getPublicUrl(path, options) {
      const _path = this._getFinalPath(path);
      const _queryString = [];
      const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
      if (downloadQueryParam !== "") {
        _queryString.push(downloadQueryParam);
      }
      const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
      const renderPath = wantsTransformation ? "render/image" : "object";
      const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
      if (transformationQuery !== "") {
        _queryString.push(transformationQuery);
      }
      let queryString = _queryString.join("&");
      if (queryString !== "") {
        queryString = `?${queryString}`;
      }
      return {
        data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) }
      };
    }
    /**
     * Deletes files within the same bucket
     *
     * @category File Buckets
     * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
     * @returns Promise with list of deleted files or error
     *
     * @example Delete file
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .remove(['folder/avatar1.png'])
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": [],
     *   "error": null
     * }
     * ```
     */
    remove(paths) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Get file metadata
     * @param id the file id to retrieve metadata
     */
    // async getMetadata(
    //   id: string
    // ): Promise<
    //   | {
    //       data: Metadata
    //       error: null
    //     }
    //   | {
    //       data: null
    //       error: StorageError
    //     }
    // > {
    //   try {
    //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
    //     return { data, error: null }
    //   } catch (error) {
    //     if (isStorageError(error)) {
    //       return { data: null, error }
    //     }
    //     throw error
    //   }
    // }
    /**
     * Update file metadata
     * @param id the file id to update metadata
     * @param meta the new file metadata
     */
    // async updateMetadata(
    //   id: string,
    //   meta: Metadata
    // ): Promise<
    //   | {
    //       data: Metadata
    //       error: null
    //     }
    //   | {
    //       data: null
    //       error: StorageError
    //     }
    // > {
    //   try {
    //     const data = await post(
    //       this.fetch,
    //       `${this.url}/metadata/${id}`,
    //       { ...meta },
    //       { headers: this.headers }
    //     )
    //     return { data, error: null }
    //   } catch (error) {
    //     if (isStorageError(error)) {
    //       return { data: null, error }
    //     }
    //     throw error
    //   }
    // }
    /**
     * Lists all the files and folders within a path of the bucket.
     *
     * @category File Buckets
     * @param path The folder path.
     * @param options Search options including limit (defaults to 100), offset, sortBy, and search
     * @param parameters Optional fetch parameters including signal for cancellation
     * @returns Promise with list of files or error
     *
     * @example List files in a bucket
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .list('folder', {
     *     limit: 100,
     *     offset: 0,
     *     sortBy: { column: 'name', order: 'asc' },
     *   })
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": [
     *     {
     *       "name": "avatar1.png",
     *       "id": "e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2",
     *       "updated_at": "2024-05-22T23:06:05.580Z",
     *       "created_at": "2024-05-22T23:04:34.443Z",
     *       "last_accessed_at": "2024-05-22T23:04:34.443Z",
     *       "metadata": {
     *         "eTag": "\"c5e8c553235d9af30ef4f6e280790b92\"",
     *         "size": 32175,
     *         "mimetype": "image/png",
     *         "cacheControl": "max-age=3600",
     *         "lastModified": "2024-05-22T23:06:05.574Z",
     *         "contentLength": 32175,
     *         "httpStatusCode": 200
     *       }
     *     }
     *   ],
     *   "error": null
     * }
     * ```
     *
     * @example Search files in a bucket
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .from('avatars')
     *   .list('folder', {
     *     limit: 100,
     *     offset: 0,
     *     sortBy: { column: 'name', order: 'asc' },
     *     search: 'jon'
     *   })
     * ```
     */
    list(path, options, parameters) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || "" });
          const data = yield post$1(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * @experimental this method signature might change in the future
     *
     * @category File Buckets
     * @param options search options
     * @param parameters
     */
    listV2(options, parameters) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const body = Object.assign({}, options);
          const data = yield post$1(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, body, { headers: this.headers }, parameters);
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    encodeMetadata(metadata) {
      return JSON.stringify(metadata);
    }
    toBase64(data) {
      if (typeof Buffer !== "undefined") {
        return Buffer.from(data).toString("base64");
      }
      return btoa(data);
    }
    _getFinalPath(path) {
      return `${this.bucketId}/${path.replace(/^\/+/, "")}`;
    }
    _removeEmptyFolders(path) {
      return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
    }
    transformOptsToQueryString(transform) {
      const params = [];
      if (transform.width) {
        params.push(`width=${transform.width}`);
      }
      if (transform.height) {
        params.push(`height=${transform.height}`);
      }
      if (transform.resize) {
        params.push(`resize=${transform.resize}`);
      }
      if (transform.format) {
        params.push(`format=${transform.format}`);
      }
      if (transform.quality) {
        params.push(`quality=${transform.quality}`);
      }
      return params.join("&");
    }
  }
  const version$2 = "2.84.0";
  const DEFAULT_HEADERS$3 = {
    "X-Client-Info": `storage-js/${version$2}`
  };
  class StorageBucketApi {
    constructor(url, headers = {}, fetch2, opts) {
      this.shouldThrowOnError = false;
      const baseUrl = new URL(url);
      if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {
        const isSupabaseHost = /supabase\.(co|in|red)$/.test(baseUrl.hostname);
        if (isSupabaseHost && !baseUrl.hostname.includes("storage.supabase.")) {
          baseUrl.hostname = baseUrl.hostname.replace("supabase.", "storage.supabase.");
        }
      }
      this.url = baseUrl.href.replace(/\/$/, "");
      this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$3), headers);
      this.fetch = resolveFetch$3(fetch2);
    }
    /**
     * Enable throwing errors instead of returning them.
     *
     * @category File Buckets
     */
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    /**
     * Retrieves the details of all Storage buckets within an existing project.
     *
     * @category File Buckets
     * @param options Query parameters for listing buckets
     * @param options.limit Maximum number of buckets to return
     * @param options.offset Number of buckets to skip
     * @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')
     * @param options.sortOrder Sort order ('asc' or 'desc')
     * @param options.search Search term to filter bucket names
     * @returns Promise with list of buckets or error
     *
     * @example List buckets
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .listBuckets()
     * ```
     *
     * @example List buckets with options
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .listBuckets({
     *     limit: 10,
     *     offset: 0,
     *     sortColumn: 'created_at',
     *     sortOrder: 'desc',
     *     search: 'prod'
     *   })
     * ```
     */
    listBuckets(options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const queryString = this.listBucketOptionsToQueryString(options);
          const data = yield get(this.fetch, `${this.url}/bucket${queryString}`, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Retrieves the details of an existing Storage bucket.
     *
     * @category File Buckets
     * @param id The unique identifier of the bucket you would like to retrieve.
     * @returns Promise with bucket details or error
     *
     * @example Get bucket
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .getBucket('avatars')
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "id": "avatars",
     *     "name": "avatars",
     *     "owner": "",
     *     "public": false,
     *     "file_size_limit": 1024,
     *     "allowed_mime_types": [
     *       "image/png"
     *     ],
     *     "created_at": "2024-05-22T22:26:05.100Z",
     *     "updated_at": "2024-05-22T22:26:05.100Z"
     *   },
     *   "error": null
     * }
     * ```
     */
    getBucket(id) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Creates a new Storage bucket
     *
     * @category File Buckets
     * @param id A unique identifier for the bucket you are creating.
     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
     * The global file size limit takes precedence over this value.
     * The default value is null, which doesn't set a per bucket file size limit.
     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
     * The default value is null, which allows files with all mime types to be uploaded.
     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
     * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.
     *   - default bucket type is `STANDARD`
     * @returns Promise with newly created bucket id or error
     *
     * @example Create bucket
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .createBucket('avatars', {
     *     public: false,
     *     allowedMimeTypes: ['image/png'],
     *     fileSizeLimit: 1024
     *   })
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "name": "avatars"
     *   },
     *   "error": null
     * }
     * ```
     */
    createBucket(id_1) {
      return __awaiter(this, arguments, void 0, function* (id, options = {
        public: false
      }) {
        try {
          const data = yield post$1(this.fetch, `${this.url}/bucket`, {
            id,
            name: id,
            type: options.type,
            public: options.public,
            file_size_limit: options.fileSizeLimit,
            allowed_mime_types: options.allowedMimeTypes
          }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Updates a Storage bucket
     *
     * @category File Buckets
     * @param id A unique identifier for the bucket you are updating.
     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
     * The global file size limit takes precedence over this value.
     * The default value is null, which doesn't set a per bucket file size limit.
     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
     * The default value is null, which allows files with all mime types to be uploaded.
     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
     * @returns Promise with success message or error
     *
     * @example Update bucket
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .updateBucket('avatars', {
     *     public: false,
     *     allowedMimeTypes: ['image/png'],
     *     fileSizeLimit: 1024
     *   })
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "message": "Successfully updated"
     *   },
     *   "error": null
     * }
     * ```
     */
    updateBucket(id, options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield put(this.fetch, `${this.url}/bucket/${id}`, {
            id,
            name: id,
            public: options.public,
            file_size_limit: options.fileSizeLimit,
            allowed_mime_types: options.allowedMimeTypes
          }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Removes all objects inside a single bucket.
     *
     * @category File Buckets
     * @param id The unique identifier of the bucket you would like to empty.
     * @returns Promise with success message or error
     *
     * @example Empty bucket
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .emptyBucket('avatars')
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "message": "Successfully emptied"
     *   },
     *   "error": null
     * }
     * ```
     */
    emptyBucket(id) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post$1(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
     * You must first `empty()` the bucket.
     *
     * @category File Buckets
     * @param id The unique identifier of the bucket you would like to delete.
     * @returns Promise with success message or error
     *
     * @example Delete bucket
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .deleteBucket('avatars')
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "message": "Successfully deleted"
     *   },
     *   "error": null
     * }
     * ```
     */
    deleteBucket(id) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    listBucketOptionsToQueryString(options) {
      const params = {};
      if (options) {
        if ("limit" in options) {
          params.limit = String(options.limit);
        }
        if ("offset" in options) {
          params.offset = String(options.offset);
        }
        if (options.search) {
          params.search = options.search;
        }
        if (options.sortColumn) {
          params.sortColumn = options.sortColumn;
        }
        if (options.sortOrder) {
          params.sortOrder = options.sortOrder;
        }
      }
      return Object.keys(params).length > 0 ? "?" + new URLSearchParams(params).toString() : "";
    }
  }
  class StorageAnalyticsClient {
    /**
     * @alpha
     *
     * Creates a new StorageAnalyticsClient instance
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Analytics Buckets
     * @param url - The base URL for the storage API
     * @param headers - HTTP headers to include in requests
     * @param fetch - Optional custom fetch implementation
     *
     * @example
     * ```typescript
     * const client = new StorageAnalyticsClient(url, headers)
     * ```
     */
    constructor(url, headers = {}, fetch2) {
      this.shouldThrowOnError = false;
      this.url = url.replace(/\/$/, "");
      this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$3), headers);
      this.fetch = resolveFetch$3(fetch2);
    }
    /**
     * @alpha
     *
     * Enable throwing errors instead of returning them in the response
     * When enabled, failed operations will throw instead of returning { data: null, error }
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Analytics Buckets
     * @returns This instance for method chaining
     */
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    /**
     * @alpha
     *
     * Creates a new analytics bucket using Iceberg tables
     * Analytics buckets are optimized for analytical queries and data processing
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Analytics Buckets
     * @param name A unique name for the bucket you are creating
     * @returns Promise with newly created bucket name or error
     *
     * @example Create analytics bucket
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .analytics
     *   .createBucket('analytics-data')
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "name": "analytics-data"
     *   },
     *   "error": null
     * }
     * ```
     */
    createBucket(name) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post$1(this.fetch, `${this.url}/bucket`, { name }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * @alpha
     *
     * Retrieves the details of all Analytics Storage buckets within an existing project
     * Only returns buckets of type 'ANALYTICS'
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Analytics Buckets
     * @param options Query parameters for listing buckets
     * @param options.limit Maximum number of buckets to return
     * @param options.offset Number of buckets to skip
     * @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')
     * @param options.sortOrder Sort order ('asc' or 'desc')
     * @param options.search Search term to filter bucket names
     * @returns Promise with list of analytics buckets or error
     *
     * @example List analytics buckets
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .analytics
     *   .listBuckets({
     *     limit: 10,
     *     offset: 0,
     *     sortColumn: 'created_at',
     *     sortOrder: 'desc'
     *   })
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": [
     *     {
     *       "id": "analytics-data",
     *       "name": "analytics-data",
     *       "type": "ANALYTICS",
     *       "created_at": "2024-05-22T22:26:05.100Z",
     *       "updated_at": "2024-05-22T22:26:05.100Z"
     *     }
     *   ],
     *   "error": null
     * }
     * ```
     */
    listBuckets(options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const queryParams = new URLSearchParams();
          if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0)
            queryParams.set("limit", options.limit.toString());
          if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0)
            queryParams.set("offset", options.offset.toString());
          if (options === null || options === void 0 ? void 0 : options.sortColumn)
            queryParams.set("sortColumn", options.sortColumn);
          if (options === null || options === void 0 ? void 0 : options.sortOrder)
            queryParams.set("sortOrder", options.sortOrder);
          if (options === null || options === void 0 ? void 0 : options.search)
            queryParams.set("search", options.search);
          const queryString = queryParams.toString();
          const url = queryString ? `${this.url}/bucket?${queryString}` : `${this.url}/bucket`;
          const data = yield get(this.fetch, url, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     * @alpha
     *
     * Deletes an existing analytics bucket
     * A bucket can't be deleted with existing objects inside it
     * You must first empty the bucket before deletion
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Analytics Buckets
     * @param bucketName The unique identifier of the bucket you would like to delete
     * @returns Promise with success message or error
     *
     * @example Delete analytics bucket
     * ```js
     * const { data, error } = await supabase
     *   .storage
     *   .analytics
     *   .deleteBucket('analytics-data')
     * ```
     *
     * Response:
     * ```json
     * {
     *   "data": {
     *     "message": "Successfully deleted"
     *   },
     *   "error": null
     * }
     * ```
     */
    deleteBucket(bucketName) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield remove(this.fetch, `${this.url}/bucket/${bucketName}`, {}, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
  }
  const DEFAULT_HEADERS$2 = {
    "X-Client-Info": `storage-js/${version$2}`,
    "Content-Type": "application/json"
  };
  class StorageVectorsError extends Error {
    constructor(message) {
      super(message);
      this.__isStorageVectorsError = true;
      this.name = "StorageVectorsError";
    }
  }
  function isStorageVectorsError(error) {
    return typeof error === "object" && error !== null && "__isStorageVectorsError" in error;
  }
  class StorageVectorsApiError extends StorageVectorsError {
    constructor(message, status, statusCode) {
      super(message);
      this.name = "StorageVectorsApiError";
      this.status = status;
      this.statusCode = statusCode;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status,
        statusCode: this.statusCode
      };
    }
  }
  class StorageVectorsUnknownError extends StorageVectorsError {
    constructor(message, originalError) {
      super(message);
      this.name = "StorageVectorsUnknownError";
      this.originalError = originalError;
    }
  }
  var StorageVectorsErrorCode;
  (function(StorageVectorsErrorCode2) {
    StorageVectorsErrorCode2["InternalError"] = "InternalError";
    StorageVectorsErrorCode2["S3VectorConflictException"] = "S3VectorConflictException";
    StorageVectorsErrorCode2["S3VectorNotFoundException"] = "S3VectorNotFoundException";
    StorageVectorsErrorCode2["S3VectorBucketNotEmpty"] = "S3VectorBucketNotEmpty";
    StorageVectorsErrorCode2["S3VectorMaxBucketsExceeded"] = "S3VectorMaxBucketsExceeded";
    StorageVectorsErrorCode2["S3VectorMaxIndexesExceeded"] = "S3VectorMaxIndexesExceeded";
  })(StorageVectorsErrorCode || (StorageVectorsErrorCode = {}));
  const resolveFetch$2 = (customFetch) => {
    if (customFetch) {
      return (...args) => customFetch(...args);
    }
    return (...args) => fetch(...args);
  };
  const isPlainObject = (value) => {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  };
  const _getErrorMessage$1 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
  const handleError$1 = (error, reject, options) => __awaiter(void 0, void 0, void 0, function* () {
    const isResponseLike2 = error && typeof error === "object" && "status" in error && "ok" in error && typeof error.status === "number";
    if (isResponseLike2 && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
      const status = error.status || 500;
      const responseError = error;
      if (typeof responseError.json === "function") {
        responseError.json().then((err) => {
          const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + "";
          reject(new StorageVectorsApiError(_getErrorMessage$1(err), status, statusCode));
        }).catch(() => {
          const statusCode = status + "";
          const message = responseError.statusText || `HTTP ${status} error`;
          reject(new StorageVectorsApiError(message, status, statusCode));
        });
      } else {
        const statusCode = status + "";
        const message = responseError.statusText || `HTTP ${status} error`;
        reject(new StorageVectorsApiError(message, status, statusCode));
      }
    } else {
      reject(new StorageVectorsUnknownError(_getErrorMessage$1(error), error));
    }
  });
  const _getRequestParams$1 = (method, options, parameters, body) => {
    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
    if (!body) {
      return params;
    }
    if (isPlainObject(body)) {
      params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
      params.body = JSON.stringify(body);
    } else {
      params.body = body;
    }
    return Object.assign(Object.assign({}, params), parameters);
  };
  function _handleRequest$1(fetcher, method, url, options, parameters, body) {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => {
        fetcher(url, _getRequestParams$1(method, options, parameters, body)).then((result2) => {
          if (!result2.ok)
            throw result2;
          if (options === null || options === void 0 ? void 0 : options.noResolveJson)
            return result2;
          const contentType = result2.headers.get("content-type");
          if (!contentType || !contentType.includes("application/json")) {
            return {};
          }
          return result2.json();
        }).then((data) => resolve(data)).catch((error) => handleError$1(error, reject, options));
      });
    });
  }
  function post(fetcher, url, body, options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      return _handleRequest$1(fetcher, "POST", url, options, parameters, body);
    });
  }
  class VectorIndexApi {
    /**
     *
     * @alpha
     *
     * Creates an API client for managing vector indexes.
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param url - Base URL for the Storage Vectors API.
     * @param headers - Default headers sent with each request.
     * @param fetch - Optional custom `fetch` implementation for non-browser runtimes.
     *
     * @example
     * ```typescript
     * const client = new VectorIndexApi(url, headers)
     * ```
     */
    constructor(url, headers = {}, fetch2) {
      this.shouldThrowOnError = false;
      this.url = url.replace(/\/$/, "");
      this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$2), headers);
      this.fetch = resolveFetch$2(fetch2);
    }
    /**
     *
     * @alpha
     *
     * Enable throwing errors instead of returning them in the response
     * When enabled, failed operations will throw instead of returning { data: null, error }
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @returns This instance for method chaining
     * @example
     * ```typescript
     * const client = new VectorIndexApi(url, headers)
     * client.throwOnError()
     * const { data } = await client.createIndex(options) // throws on error
     * ```
     */
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    /**
     *
     * @alpha
     *
     * Creates a new vector index within a bucket
     * Defines the schema for vectors including dimensionality, distance metric, and metadata config
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Index configuration
     * @param options.vectorBucketName - Name of the parent vector bucket
     * @param options.indexName - Unique name for the index within the bucket
     * @param options.dataType - Data type for vector components (currently only 'float32')
     * @param options.dimension - Dimensionality of vectors (e.g., 384, 768, 1536)
     * @param options.distanceMetric - Similarity metric ('cosine', 'euclidean', 'dotproduct')
     * @param options.metadataConfiguration - Optional config for non-filterable metadata keys
     * @returns Promise with empty response on success or error
     *
     * @throws {StorageVectorsApiError} With code:
     * - `S3VectorConflictException` if index already exists (HTTP 409)
     * - `S3VectorMaxIndexesExceeded` if quota exceeded (HTTP 400)
     * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * const { data, error } = await client.createIndex({
     *   vectorBucketName: 'embeddings-prod',
     *   indexName: 'documents-openai-small',
     *   dataType: 'float32',
     *   dimension: 1536,
     *   distanceMetric: 'cosine',
     *   metadataConfiguration: {
     *     nonFilterableMetadataKeys: ['raw_text', 'internal_id']
     *   }
     * })
     * ```
     */
    createIndex(options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post(this.fetch, `${this.url}/CreateIndex`, options, {
            headers: this.headers
          });
          return { data: data || {}, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     *
     * @alpha
     *
     * Retrieves metadata for a specific vector index
     * Returns index configuration including dimension, distance metric, and metadata settings
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param vectorBucketName - Name of the parent vector bucket
     * @param indexName - Name of the index to retrieve
     * @returns Promise with index metadata or error
     *
     * @throws {StorageVectorsApiError} With code:
     * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * const { data, error } = await client.getIndex('embeddings-prod', 'documents-openai-small')
     * if (data) {
     *   console.log('Index dimension:', data.index.dimension)
     *   console.log('Distance metric:', data.index.distanceMetric)
     * }
     * ```
     */
    getIndex(vectorBucketName, indexName) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post(this.fetch, `${this.url}/GetIndex`, { vectorBucketName, indexName }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     *
     * @alpha
     *
     * Lists vector indexes within a bucket with optional filtering and pagination
     * Supports prefix-based filtering and paginated results
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Listing options
     * @param options.vectorBucketName - Name of the parent vector bucket
     * @param options.prefix - Filter indexes by name prefix
     * @param options.maxResults - Maximum results per page (default: 100)
     * @param options.nextToken - Pagination token from previous response
     * @returns Promise with list of indexes and pagination token
     *
     * @throws {StorageVectorsApiError} With code:
     * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * // List all indexes in a bucket
     * const { data, error } = await client.listIndexes({
     *   vectorBucketName: 'embeddings-prod',
     *   prefix: 'documents-'
     * })
     * if (data) {
     *   console.log('Found indexes:', data.indexes.map(i => i.indexName))
     *   // Fetch next page if available
     *   if (data.nextToken) {
     *     const next = await client.listIndexes({
     *       vectorBucketName: 'embeddings-prod',
     *       nextToken: data.nextToken
     *     })
     *   }
     * }
     * ```
     */
    listIndexes(options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post(this.fetch, `${this.url}/ListIndexes`, options, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     *
     * @alpha
     *
     * Deletes a vector index and all its data
     * This operation removes the index schema and all vectors stored in the index
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param vectorBucketName - Name of the parent vector bucket
     * @param indexName - Name of the index to delete
     * @returns Promise with empty response on success or error
     *
     * @throws {StorageVectorsApiError} With code:
     * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * // Delete an index and all its vectors
     * const { error } = await client.deleteIndex('embeddings-prod', 'old-index')
     * if (!error) {
     *   console.log('Index deleted successfully')
     * }
     * ```
     */
    deleteIndex(vectorBucketName, indexName) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post(this.fetch, `${this.url}/DeleteIndex`, { vectorBucketName, indexName }, { headers: this.headers });
          return { data: data || {}, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
  }
  class VectorDataApi {
    /**
     *
     * @alpha
     *
     * Creates a VectorDataApi bound to a Storage Vectors deployment.
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param url - Base URL for the Storage Vectors API.
     * @param headers - Default headers (for example authentication tokens).
     * @param fetch - Optional custom `fetch` implementation for non-browser runtimes.
     *
     * @example
     * ```typescript
     * const client = new VectorDataApi(url, headers)
     * ```
     */
    constructor(url, headers = {}, fetch2) {
      this.shouldThrowOnError = false;
      this.url = url.replace(/\/$/, "");
      this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$2), headers);
      this.fetch = resolveFetch$2(fetch2);
    }
    /**
     *
     * @alpha
     *
     * Enable throwing errors instead of returning them in the response
     * When enabled, failed operations will throw instead of returning { data: null, error }
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @returns This instance for method chaining
     * @example
     * ```typescript
     * const client = new VectorDataApi(url, headers)
     * client.throwOnError()
     * const { data } = await client.putVectors(options) // throws on error
     * ```
     */
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    /**
     *
     * @alpha
     *
     * Inserts or updates vectors in batch (upsert operation)
     * Accepts 1-500 vectors per request. Larger batches should be split
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Vector insertion options
     * @param options.vectorBucketName - Name of the parent vector bucket
     * @param options.indexName - Name of the target index
     * @param options.vectors - Array of vectors to insert/update (1-500 items)
     * @returns Promise with empty response on success or error
     *
     * @throws {StorageVectorsApiError} With code:
     * - `S3VectorConflictException` if duplicate key conflict occurs (HTTP 409)
     * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * const { data, error } = await client.putVectors({
     *   vectorBucketName: 'embeddings-prod',
     *   indexName: 'documents-openai-small',
     *   vectors: [
     *     {
     *       key: 'doc-1',
     *       data: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions
     *       metadata: { title: 'Introduction', page: 1 }
     *     },
     *     {
     *       key: 'doc-2',
     *       data: { float32: [0.4, 0.5, 0.6, ...] },
     *       metadata: { title: 'Conclusion', page: 42 }
     *     }
     *   ]
     * })
     * ```
     */
    putVectors(options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          if (options.vectors.length < 1 || options.vectors.length > 500) {
            throw new Error("Vector batch size must be between 1 and 500 items");
          }
          const data = yield post(this.fetch, `${this.url}/PutVectors`, options, {
            headers: this.headers
          });
          return { data: data || {}, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     *
     * @alpha
     *
     * Retrieves vectors by their keys in batch
     * Optionally includes vector data and/or metadata in response
     * Additional permissions required when returning data or metadata
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Vector retrieval options
     * @param options.vectorBucketName - Name of the parent vector bucket
     * @param options.indexName - Name of the index
     * @param options.keys - Array of vector keys to retrieve
     * @param options.returnData - Whether to include vector embeddings (requires permission)
     * @param options.returnMetadata - Whether to include metadata (requires permission)
     * @returns Promise with array of vectors or error
     *
     * @throws {StorageVectorsApiError} With code:
     * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * const { data, error } = await client.getVectors({
     *   vectorBucketName: 'embeddings-prod',
     *   indexName: 'documents-openai-small',
     *   keys: ['doc-1', 'doc-2', 'doc-3'],
     *   returnData: false,     // Don't return embeddings
     *   returnMetadata: true   // Return metadata only
     * })
     * if (data) {
     *   data.vectors.forEach(v => console.log(v.key, v.metadata))
     * }
     * ```
     */
    getVectors(options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post(this.fetch, `${this.url}/GetVectors`, options, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     *
     * @alpha
     *
     * Lists/scans vectors in an index with pagination
     * Supports parallel scanning via segment configuration for high-throughput scenarios
     * Additional permissions required when returning data or metadata
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Vector listing options
     * @param options.vectorBucketName - Name of the parent vector bucket
     * @param options.indexName - Name of the index
     * @param options.maxResults - Maximum results per page (default: 500, max: 1000)
     * @param options.nextToken - Pagination token from previous response
     * @param options.returnData - Whether to include vector embeddings (requires permission)
     * @param options.returnMetadata - Whether to include metadata (requires permission)
     * @param options.segmentCount - Total parallel segments (1-16) for distributed scanning
     * @param options.segmentIndex - Zero-based segment index (0 to segmentCount-1)
     * @returns Promise with array of vectors, pagination token, or error
     *
     * @throws {StorageVectorsApiError} With code:
     * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * // Simple pagination
     * let nextToken: string | undefined
     * do {
     *   const { data, error } = await client.listVectors({
     *     vectorBucketName: 'embeddings-prod',
     *     indexName: 'documents-openai-small',
     *     maxResults: 500,
     *     nextToken,
     *     returnMetadata: true
     *   })
     *   if (error) break
     *   console.log('Batch:', data.vectors.length)
     *   nextToken = data.nextToken
     * } while (nextToken)
     *
     * // Parallel scanning (4 concurrent workers)
     * const workers = [0, 1, 2, 3].map(async (segmentIndex) => {
     *   const { data } = await client.listVectors({
     *     vectorBucketName: 'embeddings-prod',
     *     indexName: 'documents-openai-small',
     *     segmentCount: 4,
     *     segmentIndex,
     *     returnMetadata: true
     *   })
     *   return data?.vectors || []
     * })
     * const results = await Promise.all(workers)
     * ```
     */
    listVectors(options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          if (options.segmentCount !== void 0) {
            if (options.segmentCount < 1 || options.segmentCount > 16) {
              throw new Error("segmentCount must be between 1 and 16");
            }
            if (options.segmentIndex !== void 0) {
              if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {
                throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);
              }
            }
          }
          const data = yield post(this.fetch, `${this.url}/ListVectors`, options, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     *
     * @alpha
     *
     * Queries for similar vectors using approximate nearest neighbor (ANN) search
     * Returns top-K most similar vectors based on the configured distance metric
     * Supports optional metadata filtering (requires GetVectors permission)
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Query options
     * @param options.vectorBucketName - Name of the parent vector bucket
     * @param options.indexName - Name of the index
     * @param options.queryVector - Query embedding to find similar vectors
     * @param options.topK - Number of nearest neighbors to return (default: 10)
     * @param options.filter - Optional JSON filter for metadata (requires GetVectors permission)
     * @param options.returnDistance - Whether to include similarity distances
     * @param options.returnMetadata - Whether to include metadata (requires GetVectors permission)
     * @returns Promise with array of similar vectors ordered by distance
     *
     * @throws {StorageVectorsApiError} With code:
     * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * // Semantic search with filtering
     * const { data, error } = await client.queryVectors({
     *   vectorBucketName: 'embeddings-prod',
     *   indexName: 'documents-openai-small',
     *   queryVector: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions
     *   topK: 5,
     *   filter: {
     *     category: 'technical',
     *     published: true
     *   },
     *   returnDistance: true,
     *   returnMetadata: true
     * })
     * if (data) {
     *   data.matches.forEach(match => {
     *     console.log(`${match.key}: distance=${match.distance}`)
     *     console.log('Metadata:', match.metadata)
     *   })
     * }
     * ```
     */
    queryVectors(options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post(this.fetch, `${this.url}/QueryVectors`, options, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     *
     * @alpha
     *
     * Deletes vectors by their keys in batch
     * Accepts 1-500 keys per request
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Vector deletion options
     * @param options.vectorBucketName - Name of the parent vector bucket
     * @param options.indexName - Name of the index
     * @param options.keys - Array of vector keys to delete (1-500 items)
     * @returns Promise with empty response on success or error
     *
     * @throws {StorageVectorsApiError} With code:
     * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * const { error } = await client.deleteVectors({
     *   vectorBucketName: 'embeddings-prod',
     *   indexName: 'documents-openai-small',
     *   keys: ['doc-1', 'doc-2', 'doc-3']
     * })
     * if (!error) {
     *   console.log('Vectors deleted successfully')
     * }
     * ```
     */
    deleteVectors(options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          if (options.keys.length < 1 || options.keys.length > 500) {
            throw new Error("Keys batch size must be between 1 and 500 items");
          }
          const data = yield post(this.fetch, `${this.url}/DeleteVectors`, options, {
            headers: this.headers
          });
          return { data: data || {}, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
  }
  class VectorBucketApi {
    /**
     *
     * @alpha
     *
     * Creates a new VectorBucketApi instance
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param url - The base URL for the storage vectors API
     * @param headers - HTTP headers to include in requests
     * @param fetch - Optional custom fetch implementation
     *
     * @example
     * ```typescript
     * const client = new VectorBucketApi(url, headers)
     * ```
     */
    constructor(url, headers = {}, fetch2) {
      this.shouldThrowOnError = false;
      this.url = url.replace(/\/$/, "");
      this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$2), headers);
      this.fetch = resolveFetch$2(fetch2);
    }
    /**
     *
     * @alpha
     *
     * Enable throwing errors instead of returning them in the response
     * When enabled, failed operations will throw instead of returning { data: null, error }
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @returns This instance for method chaining
     * @example
     * ```typescript
     * const client = new VectorBucketApi(url, headers)
     * client.throwOnError()
     * const { data } = await client.createBucket('my-bucket') // throws on error
     * ```
     */
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    /**
     *
     * @alpha
     *
     * Creates a new vector bucket
     * Vector buckets are containers for vector indexes and their data
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param vectorBucketName - Unique name for the vector bucket
     * @returns Promise with empty response on success or error
     *
     * @throws {StorageVectorsApiError} With code:
     * - `S3VectorConflictException` if bucket already exists (HTTP 409)
     * - `S3VectorMaxBucketsExceeded` if quota exceeded (HTTP 400)
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * const { data, error } = await client.createBucket('embeddings-prod')
     * if (error) {
     *   console.error('Failed to create bucket:', error.message)
     * }
     * ```
     */
    createBucket(vectorBucketName) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post(this.fetch, `${this.url}/CreateVectorBucket`, { vectorBucketName }, { headers: this.headers });
          return { data: data || {}, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     *
     * @alpha
     *
     * Retrieves metadata for a specific vector bucket
     * Returns bucket configuration including encryption settings and creation time
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param vectorBucketName - Name of the vector bucket to retrieve
     * @returns Promise with bucket metadata or error
     *
     * @throws {StorageVectorsApiError} With code:
     * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * const { data, error } = await client.getBucket('embeddings-prod')
     * if (data) {
     *   console.log('Bucket created at:', new Date(data.vectorBucket.creationTime! * 1000))
     * }
     * ```
     */
    getBucket(vectorBucketName) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post(this.fetch, `${this.url}/GetVectorBucket`, { vectorBucketName }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     *
     * @alpha
     *
     * Lists vector buckets with optional filtering and pagination
     * Supports prefix-based filtering and paginated results
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Listing options
     * @param options.prefix - Filter buckets by name prefix
     * @param options.maxResults - Maximum results per page (default: 100)
     * @param options.nextToken - Pagination token from previous response
     * @returns Promise with list of buckets and pagination token
     *
     * @throws {StorageVectorsApiError} With code:
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * // List all buckets with prefix 'prod-'
     * const { data, error } = await client.listBuckets({ prefix: 'prod-' })
     * if (data) {
     *   console.log('Found buckets:', data.buckets.length)
     *   // Fetch next page if available
     *   if (data.nextToken) {
     *     const next = await client.listBuckets({ nextToken: data.nextToken })
     *   }
     * }
     * ```
     */
    listBuckets() {
      return __awaiter(this, arguments, void 0, function* (options = {}) {
        try {
          const data = yield post(this.fetch, `${this.url}/ListVectorBuckets`, options, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    /**
     *
     * @alpha
     *
     * Deletes a vector bucket
     * Bucket must be empty before deletion (all indexes must be removed first)
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param vectorBucketName - Name of the vector bucket to delete
     * @returns Promise with empty response on success or error
     *
     * @throws {StorageVectorsApiError} With code:
     * - `S3VectorBucketNotEmpty` if bucket contains indexes (HTTP 400)
     * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
     * - `InternalError` for server errors (HTTP 500)
     *
     * @example
     * ```typescript
     * // Delete all indexes first, then delete bucket
     * const { error } = await client.deleteBucket('old-bucket')
     * if (error?.statusCode === 'S3VectorBucketNotEmpty') {
     *   console.error('Must delete all indexes first')
     * }
     * ```
     */
    deleteBucket(vectorBucketName) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const data = yield post(this.fetch, `${this.url}/DeleteVectorBucket`, { vectorBucketName }, { headers: this.headers });
          return { data: data || {}, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if (isStorageVectorsError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
  }
  class StorageVectorsClient extends VectorBucketApi {
    /**
     * @alpha
     *
     * Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param url - Base URL of the Storage Vectors REST API.
     * @param options.headers - Optional headers (for example `Authorization`) applied to every request.
     * @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.
     *
     * @example
     * ```typescript
     * const client = new StorageVectorsClient(url, options)
     * ```
     */
    constructor(url, options = {}) {
      super(url, options.headers || {}, options.fetch);
    }
    /**
     *
     * @alpha
     *
     * Access operations for a specific vector bucket
     * Returns a scoped client for index and vector operations within the bucket
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param vectorBucketName - Name of the vector bucket
     * @returns Bucket-scoped client with index and vector operations
     *
     * @example
     * ```typescript
     * const bucket = client.bucket('embeddings-prod')
     *
     * // Create an index in this bucket
     * await bucket.createIndex({
     *   indexName: 'documents-openai',
     *   dataType: 'float32',
     *   dimension: 1536,
     *   distanceMetric: 'cosine'
     * })
     *
     * // List indexes in this bucket
     * const { data } = await bucket.listIndexes()
     * ```
     */
    from(vectorBucketName) {
      return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);
    }
  }
  class VectorBucketScope extends VectorIndexApi {
    /**
     * @alpha
     *
     * Creates a helper that automatically scopes all index operations to the provided bucket.
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @example
     * ```typescript
     * const bucket = client.bucket('embeddings-prod')
     * ```
     */
    constructor(url, headers, vectorBucketName, fetch2) {
      super(url, headers, fetch2);
      this.vectorBucketName = vectorBucketName;
    }
    /**
     *
     * @alpha
     *
     * Creates a new vector index in this bucket
     * Convenience method that automatically includes the bucket name
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Index configuration (vectorBucketName is automatically set)
     * @returns Promise with empty response on success or error
     *
     * @example
     * ```typescript
     * const bucket = client.bucket('embeddings-prod')
     * await bucket.createIndex({
     *   indexName: 'documents-openai',
     *   dataType: 'float32',
     *   dimension: 1536,
     *   distanceMetric: 'cosine',
     *   metadataConfiguration: {
     *     nonFilterableMetadataKeys: ['raw_text']
     *   }
     * })
     * ```
     */
    createIndex(options) {
      const _super = Object.create(null, {
        createIndex: { get: () => super.createIndex }
      });
      return __awaiter(this, void 0, void 0, function* () {
        return _super.createIndex.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName }));
      });
    }
    /**
     *
     * @alpha
     *
     * Lists indexes in this bucket
     * Convenience method that automatically includes the bucket name
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Listing options (vectorBucketName is automatically set)
     * @returns Promise with list of indexes or error
     *
     * @example
     * ```typescript
     * const bucket = client.bucket('embeddings-prod')
     * const { data } = await bucket.listIndexes({ prefix: 'documents-' })
     * ```
     */
    listIndexes() {
      const _super = Object.create(null, {
        listIndexes: { get: () => super.listIndexes }
      });
      return __awaiter(this, arguments, void 0, function* (options = {}) {
        return _super.listIndexes.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName }));
      });
    }
    /**
     *
     * @alpha
     *
     * Retrieves metadata for a specific index in this bucket
     * Convenience method that automatically includes the bucket name
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param indexName - Name of the index to retrieve
     * @returns Promise with index metadata or error
     *
     * @example
     * ```typescript
     * const bucket = client.bucket('embeddings-prod')
     * const { data } = await bucket.getIndex('documents-openai')
     * console.log('Dimension:', data?.index.dimension)
     * ```
     */
    getIndex(indexName) {
      const _super = Object.create(null, {
        getIndex: { get: () => super.getIndex }
      });
      return __awaiter(this, void 0, void 0, function* () {
        return _super.getIndex.call(this, this.vectorBucketName, indexName);
      });
    }
    /**
     *
     * @alpha
     *
     * Deletes an index from this bucket
     * Convenience method that automatically includes the bucket name
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param indexName - Name of the index to delete
     * @returns Promise with empty response on success or error
     *
     * @example
     * ```typescript
     * const bucket = client.bucket('embeddings-prod')
     * await bucket.deleteIndex('old-index')
     * ```
     */
    deleteIndex(indexName) {
      const _super = Object.create(null, {
        deleteIndex: { get: () => super.deleteIndex }
      });
      return __awaiter(this, void 0, void 0, function* () {
        return _super.deleteIndex.call(this, this.vectorBucketName, indexName);
      });
    }
    /**
     *
     * @alpha
     *
     * Access operations for a specific index within this bucket
     * Returns a scoped client for vector data operations
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param indexName - Name of the index
     * @returns Index-scoped client with vector data operations
     *
     * @example
     * ```typescript
     * const index = client.bucket('embeddings-prod').index('documents-openai')
     *
     * // Insert vectors
     * await index.putVectors({
     *   vectors: [
     *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }
     *   ]
     * })
     *
     * // Query similar vectors
     * const { data } = await index.queryVectors({
     *   queryVector: { float32: [...] },
     *   topK: 5
     * })
     * ```
     */
    index(indexName) {
      return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);
    }
  }
  class VectorIndexScope extends VectorDataApi {
    /**
     *
     * @alpha
     *
     * Creates a helper that automatically scopes all vector operations to the provided bucket/index names.
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @example
     * ```typescript
     * const index = client.bucket('embeddings-prod').index('documents-openai')
     * ```
     */
    constructor(url, headers, vectorBucketName, indexName, fetch2) {
      super(url, headers, fetch2);
      this.vectorBucketName = vectorBucketName;
      this.indexName = indexName;
    }
    /**
     *
     * @alpha
     *
     * Inserts or updates vectors in this index
     * Convenience method that automatically includes bucket and index names
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Vector insertion options (bucket and index names automatically set)
     * @returns Promise with empty response on success or error
     *
     * @example
     * ```typescript
     * const index = client.bucket('embeddings-prod').index('documents-openai')
     * await index.putVectors({
     *   vectors: [
     *     {
     *       key: 'doc-1',
     *       data: { float32: [0.1, 0.2, ...] },
     *       metadata: { title: 'Introduction', page: 1 }
     *     }
     *   ]
     * })
     * ```
     */
    putVectors(options) {
      const _super = Object.create(null, {
        putVectors: { get: () => super.putVectors }
      });
      return __awaiter(this, void 0, void 0, function* () {
        return _super.putVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
      });
    }
    /**
     *
     * @alpha
     *
     * Retrieves vectors by keys from this index
     * Convenience method that automatically includes bucket and index names
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Vector retrieval options (bucket and index names automatically set)
     * @returns Promise with array of vectors or error
     *
     * @example
     * ```typescript
     * const index = client.bucket('embeddings-prod').index('documents-openai')
     * const { data } = await index.getVectors({
     *   keys: ['doc-1', 'doc-2'],
     *   returnMetadata: true
     * })
     * ```
     */
    getVectors(options) {
      const _super = Object.create(null, {
        getVectors: { get: () => super.getVectors }
      });
      return __awaiter(this, void 0, void 0, function* () {
        return _super.getVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
      });
    }
    /**
     *
     * @alpha
     *
     * Lists vectors in this index with pagination
     * Convenience method that automatically includes bucket and index names
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Listing options (bucket and index names automatically set)
     * @returns Promise with array of vectors and pagination token
     *
     * @example
     * ```typescript
     * const index = client.bucket('embeddings-prod').index('documents-openai')
     * const { data } = await index.listVectors({
     *   maxResults: 500,
     *   returnMetadata: true
     * })
     * ```
     */
    listVectors() {
      const _super = Object.create(null, {
        listVectors: { get: () => super.listVectors }
      });
      return __awaiter(this, arguments, void 0, function* (options = {}) {
        return _super.listVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
      });
    }
    /**
     *
     * @alpha
     *
     * Queries for similar vectors in this index
     * Convenience method that automatically includes bucket and index names
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Query options (bucket and index names automatically set)
     * @returns Promise with array of similar vectors ordered by distance
     *
     * @example
     * ```typescript
     * const index = client.bucket('embeddings-prod').index('documents-openai')
     * const { data } = await index.queryVectors({
     *   queryVector: { float32: [0.1, 0.2, ...] },
     *   topK: 5,
     *   filter: { category: 'technical' },
     *   returnDistance: true,
     *   returnMetadata: true
     * })
     * ```
     */
    queryVectors(options) {
      const _super = Object.create(null, {
        queryVectors: { get: () => super.queryVectors }
      });
      return __awaiter(this, void 0, void 0, function* () {
        return _super.queryVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
      });
    }
    /**
     *
     * @alpha
     *
     * Deletes vectors by keys from this index
     * Convenience method that automatically includes bucket and index names
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @param options - Deletion options (bucket and index names automatically set)
     * @returns Promise with empty response on success or error
     *
     * @example
     * ```typescript
     * const index = client.bucket('embeddings-prod').index('documents-openai')
     * await index.deleteVectors({
     *   keys: ['doc-1', 'doc-2', 'doc-3']
     * })
     * ```
     */
    deleteVectors(options) {
      const _super = Object.create(null, {
        deleteVectors: { get: () => super.deleteVectors }
      });
      return __awaiter(this, void 0, void 0, function* () {
        return _super.deleteVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
      });
    }
  }
  class StorageClient extends StorageBucketApi {
    /**
     * Creates a client for Storage buckets, files, analytics, and vectors.
     *
     * @category File Buckets
     * @example
     * ```ts
     * import { StorageClient } from '@supabase/storage-js'
     *
     * const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {
     *   apikey: 'public-anon-key',
     * })
     * const avatars = storage.from('avatars')
     * ```
     */
    constructor(url, headers = {}, fetch2, opts) {
      super(url, headers, fetch2, opts);
    }
    /**
     * Perform file operation in a bucket.
     *
     * @category File Buckets
     * @param id The bucket id to operate on.
     *
     * @example
     * ```typescript
     * const avatars = storage.from('avatars')
     * ```
     */
    from(id) {
      return new StorageFileApi(this.url, this.headers, id, this.fetch);
    }
    /**
     *
     * @alpha
     *
     * Access vector storage operations.
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Vector Buckets
     * @returns A StorageVectorsClient instance configured with the current storage settings.
     */
    get vectors() {
      return new StorageVectorsClient(this.url + "/vector", {
        headers: this.headers,
        fetch: this.fetch
      });
    }
    /**
     *
     * @alpha
     *
     * Access analytics storage operations using Iceberg tables.
     *
     * **Public alpha:** This API is part of a public alpha release and may not be available to your account type.
     *
     * @category Analytics Buckets
     * @returns A StorageAnalyticsClient instance configured with the current storage settings.
     * @example
     * ```typescript
     * const client = createClient(url, key)
     * const analytics = client.storage.analytics
     *
     * // Create an analytics bucket
     * await analytics.createBucket('my-analytics-bucket')
     *
     * // List all analytics buckets
     * const { data: buckets } = await analytics.listBuckets()
     *
     * // Delete an analytics bucket
     * await analytics.deleteBucket('old-analytics-bucket')
     * ```
     */
    get analytics() {
      return new StorageAnalyticsClient(this.url + "/iceberg", this.headers, this.fetch);
    }
  }
  const version$1 = "2.84.0";
  let JS_ENV = "";
  if (typeof Deno !== "undefined") {
    JS_ENV = "deno";
  } else if (typeof document !== "undefined") {
    JS_ENV = "web";
  } else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    JS_ENV = "react-native";
  } else {
    JS_ENV = "node";
  }
  const DEFAULT_HEADERS$1 = { "X-Client-Info": `supabase-js-${JS_ENV}/${version$1}` };
  const DEFAULT_GLOBAL_OPTIONS = {
    headers: DEFAULT_HEADERS$1
  };
  const DEFAULT_DB_OPTIONS = {
    schema: "public"
  };
  const DEFAULT_AUTH_OPTIONS = {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    flowType: "implicit"
  };
  const DEFAULT_REALTIME_OPTIONS = {};
  const resolveFetch$1 = (customFetch) => {
    if (customFetch) {
      return (...args) => customFetch(...args);
    }
    return (...args) => fetch(...args);
  };
  const resolveHeadersConstructor = () => {
    return Headers;
  };
  const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
    const fetch2 = resolveFetch$1(customFetch);
    const HeadersConstructor = resolveHeadersConstructor();
    return async (input, init) => {
      var _a2;
      const accessToken = (_a2 = await getAccessToken()) !== null && _a2 !== void 0 ? _a2 : supabaseKey;
      let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
      if (!headers.has("apikey")) {
        headers.set("apikey", supabaseKey);
      }
      if (!headers.has("Authorization")) {
        headers.set("Authorization", `Bearer ${accessToken}`);
      }
      return fetch2(input, Object.assign(Object.assign({}, init), { headers }));
    };
  };
  function ensureTrailingSlash(url) {
    return url.endsWith("/") ? url : url + "/";
  }
  function applySettingDefaults(options, defaults) {
    var _a2, _b;
    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
    const { db: DEFAULT_DB_OPTIONS2, auth: DEFAULT_AUTH_OPTIONS2, realtime: DEFAULT_REALTIME_OPTIONS2, global: DEFAULT_GLOBAL_OPTIONS2 } = defaults;
    const result2 = {
      db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS2), dbOptions),
      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS2), authOptions),
      realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS2), realtimeOptions),
      storage: {},
      global: Object.assign(Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS2), globalOptions), { headers: Object.assign(Object.assign({}, (_a2 = DEFAULT_GLOBAL_OPTIONS2 === null || DEFAULT_GLOBAL_OPTIONS2 === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS2.headers) !== null && _a2 !== void 0 ? _a2 : {}), (_b = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _b !== void 0 ? _b : {}) }),
      accessToken: async () => ""
    };
    if (options.accessToken) {
      result2.accessToken = options.accessToken;
    } else {
      delete result2.accessToken;
    }
    return result2;
  }
  function validateSupabaseUrl(supabaseUrl2) {
    const trimmedUrl = supabaseUrl2 === null || supabaseUrl2 === void 0 ? void 0 : supabaseUrl2.trim();
    if (!trimmedUrl) {
      throw new Error("supabaseUrl is required.");
    }
    if (!trimmedUrl.match(/^https?:\/\//i)) {
      throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
    }
    try {
      return new URL(ensureTrailingSlash(trimmedUrl));
    } catch (_a2) {
      throw Error("Invalid supabaseUrl: Provided URL is malformed.");
    }
  }
  const version = "2.84.0";
  const AUTO_REFRESH_TICK_DURATION_MS = 30 * 1e3;
  const AUTO_REFRESH_TICK_THRESHOLD = 3;
  const EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;
  const GOTRUE_URL = "http://localhost:9999";
  const STORAGE_KEY$1 = "supabase.auth.token";
  const DEFAULT_HEADERS = { "X-Client-Info": `gotrue-js/${version}` };
  const API_VERSION_HEADER_NAME = "X-Supabase-Api-Version";
  const API_VERSIONS = {
    "2024-01-01": {
      timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
      name: "2024-01-01"
    }
  };
  const BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;
  const JWKS_TTL = 10 * 60 * 1e3;
  class AuthError extends Error {
    constructor(message, status, code) {
      super(message);
      this.__isAuthError = true;
      this.name = "AuthError";
      this.status = status;
      this.code = code;
    }
  }
  function isAuthError(error) {
    return typeof error === "object" && error !== null && "__isAuthError" in error;
  }
  class AuthApiError extends AuthError {
    constructor(message, status, code) {
      super(message, status, code);
      this.name = "AuthApiError";
      this.status = status;
      this.code = code;
    }
  }
  function isAuthApiError(error) {
    return isAuthError(error) && error.name === "AuthApiError";
  }
  class AuthUnknownError extends AuthError {
    constructor(message, originalError) {
      super(message);
      this.name = "AuthUnknownError";
      this.originalError = originalError;
    }
  }
  class CustomAuthError extends AuthError {
    constructor(message, name, status, code) {
      super(message, status, code);
      this.name = name;
      this.status = status;
    }
  }
  class AuthSessionMissingError extends CustomAuthError {
    constructor() {
      super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
    }
  }
  function isAuthSessionMissingError(error) {
    return isAuthError(error) && error.name === "AuthSessionMissingError";
  }
  class AuthInvalidTokenResponseError extends CustomAuthError {
    constructor() {
      super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0);
    }
  }
  class AuthInvalidCredentialsError extends CustomAuthError {
    constructor(message) {
      super(message, "AuthInvalidCredentialsError", 400, void 0);
    }
  }
  class AuthImplicitGrantRedirectError extends CustomAuthError {
    constructor(message, details = null) {
      super(message, "AuthImplicitGrantRedirectError", 500, void 0);
      this.details = null;
      this.details = details;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status,
        details: this.details
      };
    }
  }
  function isAuthImplicitGrantRedirectError(error) {
    return isAuthError(error) && error.name === "AuthImplicitGrantRedirectError";
  }
  class AuthPKCEGrantCodeExchangeError extends CustomAuthError {
    constructor(message, details = null) {
      super(message, "AuthPKCEGrantCodeExchangeError", 500, void 0);
      this.details = null;
      this.details = details;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status,
        details: this.details
      };
    }
  }
  class AuthRetryableFetchError extends CustomAuthError {
    constructor(message, status) {
      super(message, "AuthRetryableFetchError", status, void 0);
    }
  }
  function isAuthRetryableFetchError(error) {
    return isAuthError(error) && error.name === "AuthRetryableFetchError";
  }
  class AuthWeakPasswordError extends CustomAuthError {
    constructor(message, status, reasons) {
      super(message, "AuthWeakPasswordError", status, "weak_password");
      this.reasons = reasons;
    }
  }
  class AuthInvalidJwtError extends CustomAuthError {
    constructor(message) {
      super(message, "AuthInvalidJwtError", 400, "invalid_jwt");
    }
  }
  const TO_BASE64URL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("");
  const IGNORE_BASE64URL = " 	\n\r=".split("");
  const FROM_BASE64URL = (() => {
    const charMap = new Array(128);
    for (let i = 0; i < charMap.length; i += 1) {
      charMap[i] = -1;
    }
    for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {
      charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;
    }
    for (let i = 0; i < TO_BASE64URL.length; i += 1) {
      charMap[TO_BASE64URL[i].charCodeAt(0)] = i;
    }
    return charMap;
  })();
  function byteToBase64URL(byte, state, emit) {
    if (byte !== null) {
      state.queue = state.queue << 8 | byte;
      state.queuedBits += 8;
      while (state.queuedBits >= 6) {
        const pos = state.queue >> state.queuedBits - 6 & 63;
        emit(TO_BASE64URL[pos]);
        state.queuedBits -= 6;
      }
    } else if (state.queuedBits > 0) {
      state.queue = state.queue << 6 - state.queuedBits;
      state.queuedBits = 6;
      while (state.queuedBits >= 6) {
        const pos = state.queue >> state.queuedBits - 6 & 63;
        emit(TO_BASE64URL[pos]);
        state.queuedBits -= 6;
      }
    }
  }
  function byteFromBase64URL(charCode, state, emit) {
    const bits = FROM_BASE64URL[charCode];
    if (bits > -1) {
      state.queue = state.queue << 6 | bits;
      state.queuedBits += 6;
      while (state.queuedBits >= 8) {
        emit(state.queue >> state.queuedBits - 8 & 255);
        state.queuedBits -= 8;
      }
    } else if (bits === -2) {
      return;
    } else {
      throw new Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`);
    }
  }
  function stringFromBase64URL(str) {
    const conv = [];
    const utf8Emit = (codepoint) => {
      conv.push(String.fromCodePoint(codepoint));
    };
    const utf8State = {
      utf8seq: 0,
      codepoint: 0
    };
    const b64State = { queue: 0, queuedBits: 0 };
    const byteEmit = (byte) => {
      stringFromUTF8(byte, utf8State, utf8Emit);
    };
    for (let i = 0; i < str.length; i += 1) {
      byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);
    }
    return conv.join("");
  }
  function codepointToUTF8(codepoint, emit) {
    if (codepoint <= 127) {
      emit(codepoint);
      return;
    } else if (codepoint <= 2047) {
      emit(192 | codepoint >> 6);
      emit(128 | codepoint & 63);
      return;
    } else if (codepoint <= 65535) {
      emit(224 | codepoint >> 12);
      emit(128 | codepoint >> 6 & 63);
      emit(128 | codepoint & 63);
      return;
    } else if (codepoint <= 1114111) {
      emit(240 | codepoint >> 18);
      emit(128 | codepoint >> 12 & 63);
      emit(128 | codepoint >> 6 & 63);
      emit(128 | codepoint & 63);
      return;
    }
    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);
  }
  function stringToUTF8(str, emit) {
    for (let i = 0; i < str.length; i += 1) {
      let codepoint = str.charCodeAt(i);
      if (codepoint > 55295 && codepoint <= 56319) {
        const highSurrogate = (codepoint - 55296) * 1024 & 65535;
        const lowSurrogate = str.charCodeAt(i + 1) - 56320 & 65535;
        codepoint = (lowSurrogate | highSurrogate) + 65536;
        i += 1;
      }
      codepointToUTF8(codepoint, emit);
    }
  }
  function stringFromUTF8(byte, state, emit) {
    if (state.utf8seq === 0) {
      if (byte <= 127) {
        emit(byte);
        return;
      }
      for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {
        if ((byte >> 7 - leadingBit & 1) === 0) {
          state.utf8seq = leadingBit;
          break;
        }
      }
      if (state.utf8seq === 2) {
        state.codepoint = byte & 31;
      } else if (state.utf8seq === 3) {
        state.codepoint = byte & 15;
      } else if (state.utf8seq === 4) {
        state.codepoint = byte & 7;
      } else {
        throw new Error("Invalid UTF-8 sequence");
      }
      state.utf8seq -= 1;
    } else if (state.utf8seq > 0) {
      if (byte <= 127) {
        throw new Error("Invalid UTF-8 sequence");
      }
      state.codepoint = state.codepoint << 6 | byte & 63;
      state.utf8seq -= 1;
      if (state.utf8seq === 0) {
        emit(state.codepoint);
      }
    }
  }
  function base64UrlToUint8Array(str) {
    const result2 = [];
    const state = { queue: 0, queuedBits: 0 };
    const onByte = (byte) => {
      result2.push(byte);
    };
    for (let i = 0; i < str.length; i += 1) {
      byteFromBase64URL(str.charCodeAt(i), state, onByte);
    }
    return new Uint8Array(result2);
  }
  function stringToUint8Array(str) {
    const result2 = [];
    stringToUTF8(str, (byte) => result2.push(byte));
    return new Uint8Array(result2);
  }
  function bytesToBase64URL(bytes) {
    const result2 = [];
    const state = { queue: 0, queuedBits: 0 };
    const onChar = (char) => {
      result2.push(char);
    };
    bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));
    byteToBase64URL(null, state, onChar);
    return result2.join("");
  }
  function expiresAt(expiresIn) {
    const timeNow = Math.round(Date.now() / 1e3);
    return timeNow + expiresIn;
  }
  function generateCallbackId() {
    return Symbol("auth-callback");
  }
  const isBrowser = () => typeof window !== "undefined" && typeof document !== "undefined";
  const localStorageWriteTests = {
    tested: false,
    writable: false
  };
  const supportsLocalStorage = () => {
    if (!isBrowser()) {
      return false;
    }
    try {
      if (typeof globalThis.localStorage !== "object") {
        return false;
      }
    } catch (e) {
      return false;
    }
    if (localStorageWriteTests.tested) {
      return localStorageWriteTests.writable;
    }
    const randomKey = `lswt-${Math.random()}${Math.random()}`;
    try {
      globalThis.localStorage.setItem(randomKey, randomKey);
      globalThis.localStorage.removeItem(randomKey);
      localStorageWriteTests.tested = true;
      localStorageWriteTests.writable = true;
    } catch (e) {
      localStorageWriteTests.tested = true;
      localStorageWriteTests.writable = false;
    }
    return localStorageWriteTests.writable;
  };
  function parseParametersFromURL(href) {
    const result2 = {};
    const url = new URL(href);
    if (url.hash && url.hash[0] === "#") {
      try {
        const hashSearchParams = new URLSearchParams(url.hash.substring(1));
        hashSearchParams.forEach((value, key) => {
          result2[key] = value;
        });
      } catch (e) {
      }
    }
    url.searchParams.forEach((value, key) => {
      result2[key] = value;
    });
    return result2;
  }
  const resolveFetch = (customFetch) => {
    if (customFetch) {
      return (...args) => customFetch(...args);
    }
    return (...args) => fetch(...args);
  };
  const looksLikeFetchResponse = (maybeResponse) => {
    return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
  };
  const setItemAsync = async (storage2, key, data) => {
    await storage2.setItem(key, JSON.stringify(data));
  };
  const getItemAsync = async (storage2, key) => {
    const value = await storage2.getItem(key);
    if (!value) {
      return null;
    }
    try {
      return JSON.parse(value);
    } catch (_a2) {
      return value;
    }
  };
  const removeItemAsync = async (storage2, key) => {
    await storage2.removeItem(key);
  };
  class Deferred {
    constructor() {
      this.promise = new Deferred.promiseConstructor((res, rej) => {
        this.resolve = res;
        this.reject = rej;
      });
    }
  }
  Deferred.promiseConstructor = Promise;
  function decodeJWT(token) {
    const parts = token.split(".");
    if (parts.length !== 3) {
      throw new AuthInvalidJwtError("Invalid JWT structure");
    }
    for (let i = 0; i < parts.length; i++) {
      if (!BASE64URL_REGEX.test(parts[i])) {
        throw new AuthInvalidJwtError("JWT not in base64url format");
      }
    }
    const data = {
      // using base64url lib
      header: JSON.parse(stringFromBase64URL(parts[0])),
      payload: JSON.parse(stringFromBase64URL(parts[1])),
      signature: base64UrlToUint8Array(parts[2]),
      raw: {
        header: parts[0],
        payload: parts[1]
      }
    };
    return data;
  }
  async function sleep(time) {
    return await new Promise((accept) => {
      setTimeout(() => accept(null), time);
    });
  }
  function retryable(fn, isRetryable) {
    const promise = new Promise((accept, reject) => {
      (async () => {
        for (let attempt = 0; attempt < Infinity; attempt++) {
          try {
            const result2 = await fn(attempt);
            if (!isRetryable(attempt, null, result2)) {
              accept(result2);
              return;
            }
          } catch (e) {
            if (!isRetryable(attempt, e)) {
              reject(e);
              return;
            }
          }
        }
      })();
    });
    return promise;
  }
  function dec2hex(dec) {
    return ("0" + dec.toString(16)).substr(-2);
  }
  function generatePKCEVerifier() {
    const verifierLength = 56;
    const array = new Uint32Array(verifierLength);
    if (typeof crypto === "undefined") {
      const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
      const charSetLen = charSet.length;
      let verifier = "";
      for (let i = 0; i < verifierLength; i++) {
        verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
      }
      return verifier;
    }
    crypto.getRandomValues(array);
    return Array.from(array, dec2hex).join("");
  }
  async function sha256(randomString) {
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(randomString);
    const hash = await crypto.subtle.digest("SHA-256", encodedData);
    const bytes = new Uint8Array(hash);
    return Array.from(bytes).map((c) => String.fromCharCode(c)).join("");
  }
  async function generatePKCEChallenge(verifier) {
    const hasCryptoSupport = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof TextEncoder !== "undefined";
    if (!hasCryptoSupport) {
      console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
      return verifier;
    }
    const hashed = await sha256(verifier);
    return btoa(hashed).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
  async function getCodeChallengeAndMethod(storage2, storageKey, isPasswordRecovery = false) {
    const codeVerifier = generatePKCEVerifier();
    let storedCodeVerifier = codeVerifier;
    if (isPasswordRecovery) {
      storedCodeVerifier += "/PASSWORD_RECOVERY";
    }
    await setItemAsync(storage2, `${storageKey}-code-verifier`, storedCodeVerifier);
    const codeChallenge = await generatePKCEChallenge(codeVerifier);
    const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
    return [codeChallenge, codeChallengeMethod];
  }
  const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
  function parseResponseAPIVersion(response) {
    const apiVersion = response.headers.get(API_VERSION_HEADER_NAME);
    if (!apiVersion) {
      return null;
    }
    if (!apiVersion.match(API_VERSION_REGEX)) {
      return null;
    }
    try {
      const date = /* @__PURE__ */ new Date(`${apiVersion}T00:00:00.0Z`);
      return date;
    } catch (e) {
      return null;
    }
  }
  function validateExp(exp) {
    if (!exp) {
      throw new Error("Missing exp claim");
    }
    const timeNow = Math.floor(Date.now() / 1e3);
    if (exp <= timeNow) {
      throw new Error("JWT has expired");
    }
  }
  function getAlgorithm(alg) {
    switch (alg) {
      case "RS256":
        return {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        };
      case "ES256":
        return {
          name: "ECDSA",
          namedCurve: "P-256",
          hash: { name: "SHA-256" }
        };
      default:
        throw new Error("Invalid alg claim");
    }
  }
  const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
  function validateUUID(str) {
    if (!UUID_REGEX.test(str)) {
      throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not");
    }
  }
  function userNotAvailableProxy() {
    const proxyTarget = {};
    return new Proxy(proxyTarget, {
      get: (target, prop) => {
        if (prop === "__isUserNotAvailableProxy") {
          return true;
        }
        if (typeof prop === "symbol") {
          const sProp = prop.toString();
          if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)") {
            return void 0;
          }
        }
        throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${prop}" property of the session object is not supported. Please use getUser() instead.`);
      },
      set: (_target, prop) => {
        throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
      },
      deleteProperty: (_target, prop) => {
        throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
      }
    });
  }
  function insecureUserWarningProxy(user, suppressWarningRef) {
    return new Proxy(user, {
      get: (target, prop, receiver) => {
        if (prop === "__isInsecureUserWarningProxy") {
          return true;
        }
        if (typeof prop === "symbol") {
          const sProp = prop.toString();
          if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)" || sProp === "Symbol(nodejs.util.inspect.custom)") {
            return Reflect.get(target, prop, receiver);
          }
        }
        if (!suppressWarningRef.value && typeof prop === "string") {
          console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.");
          suppressWarningRef.value = true;
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  }
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  const _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
  const NETWORK_ERROR_CODES = [502, 503, 504];
  async function handleError(error) {
    var _a2;
    if (!looksLikeFetchResponse(error)) {
      throw new AuthRetryableFetchError(_getErrorMessage(error), 0);
    }
    if (NETWORK_ERROR_CODES.includes(error.status)) {
      throw new AuthRetryableFetchError(_getErrorMessage(error), error.status);
    }
    let data;
    try {
      data = await error.json();
    } catch (e) {
      throw new AuthUnknownError(_getErrorMessage(e), e);
    }
    let errorCode = void 0;
    const responseAPIVersion = parseResponseAPIVersion(error);
    if (responseAPIVersion && responseAPIVersion.getTime() >= API_VERSIONS["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string") {
      errorCode = data.code;
    } else if (typeof data === "object" && data && typeof data.error_code === "string") {
      errorCode = data.error_code;
    }
    if (!errorCode) {
      if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
        throw new AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);
      }
    } else if (errorCode === "weak_password") {
      throw new AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a2 = data.weak_password) === null || _a2 === void 0 ? void 0 : _a2.reasons) || []);
    } else if (errorCode === "session_not_found") {
      throw new AuthSessionMissingError();
    }
    throw new AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);
  }
  const _getRequestParams = (method, options, parameters, body) => {
    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
    if (method === "GET") {
      return params;
    }
    params.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, options === null || options === void 0 ? void 0 : options.headers);
    params.body = JSON.stringify(body);
    return Object.assign(Object.assign({}, params), parameters);
  };
  async function _request(fetcher, method, url, options) {
    var _a2;
    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
    if (!headers[API_VERSION_HEADER_NAME]) {
      headers[API_VERSION_HEADER_NAME] = API_VERSIONS["2024-01-01"].name;
    }
    if (options === null || options === void 0 ? void 0 : options.jwt) {
      headers["Authorization"] = `Bearer ${options.jwt}`;
    }
    const qs = (_a2 = options === null || options === void 0 ? void 0 : options.query) !== null && _a2 !== void 0 ? _a2 : {};
    if (options === null || options === void 0 ? void 0 : options.redirectTo) {
      qs["redirect_to"] = options.redirectTo;
    }
    const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
    const data = await _handleRequest(fetcher, method, url + queryString, {
      headers,
      noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
    }, {}, options === null || options === void 0 ? void 0 : options.body);
    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };
  }
  async function _handleRequest(fetcher, method, url, options, parameters, body) {
    const requestParams = _getRequestParams(method, options, parameters, body);
    let result2;
    try {
      result2 = await fetcher(url, Object.assign({}, requestParams));
    } catch (e) {
      console.error(e);
      throw new AuthRetryableFetchError(_getErrorMessage(e), 0);
    }
    if (!result2.ok) {
      await handleError(result2);
    }
    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
      return result2;
    }
    try {
      return await result2.json();
    } catch (e) {
      await handleError(e);
    }
  }
  function _sessionResponse(data) {
    var _a2;
    let session = null;
    if (hasSession(data)) {
      session = Object.assign({}, data);
      if (!data.expires_at) {
        session.expires_at = expiresAt(data.expires_in);
      }
    }
    const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
    return { data: { session, user }, error: null };
  }
  function _sessionResponsePassword(data) {
    const response = _sessionResponse(data);
    if (!response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
      response.data.weak_password = data.weak_password;
    }
    return response;
  }
  function _userResponse(data) {
    var _a2;
    const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
    return { data: { user }, error: null };
  }
  function _ssoResponse(data) {
    return { data, error: null };
  }
  function _generateLinkResponse(data) {
    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
    const properties = {
      action_link,
      email_otp,
      hashed_token,
      redirect_to,
      verification_type
    };
    const user = Object.assign({}, rest);
    return {
      data: {
        properties,
        user
      },
      error: null
    };
  }
  function _noResolveJsonResponse(data) {
    return data;
  }
  function hasSession(data) {
    return data.access_token && data.refresh_token && data.expires_in;
  }
  const SIGN_OUT_SCOPES = ["global", "local", "others"];
  class GoTrueAdminApi {
    /**
     * Creates an admin API client that can be used to manage users and OAuth clients.
     *
     * @example
     * ```ts
     * import { GoTrueAdminApi } from '@supabase/auth-js'
     *
     * const admin = new GoTrueAdminApi({
     *   url: 'https://xyzcompany.supabase.co/auth/v1',
     *   headers: { Authorization: `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}` },
     * })
     * ```
     */
    constructor({ url = "", headers = {}, fetch: fetch2 }) {
      this.url = url;
      this.headers = headers;
      this.fetch = resolveFetch(fetch2);
      this.mfa = {
        listFactors: this._listFactors.bind(this),
        deleteFactor: this._deleteFactor.bind(this)
      };
      this.oauth = {
        listClients: this._listOAuthClients.bind(this),
        createClient: this._createOAuthClient.bind(this),
        getClient: this._getOAuthClient.bind(this),
        updateClient: this._updateOAuthClient.bind(this),
        deleteClient: this._deleteOAuthClient.bind(this),
        regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
      };
    }
    /**
     * Removes a logged-in session.
     * @param jwt A valid, logged-in JWT.
     * @param scope The logout sope.
     */
    async signOut(jwt, scope = SIGN_OUT_SCOPES[0]) {
      if (SIGN_OUT_SCOPES.indexOf(scope) < 0) {
        throw new Error(`@supabase/auth-js: Parameter scope must be one of ${SIGN_OUT_SCOPES.join(", ")}`);
      }
      try {
        await _request(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
          headers: this.headers,
          jwt,
          noResolveJson: true
        });
        return { data: null, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    /**
     * Sends an invite link to an email address.
     * @param email The email address of the user.
     * @param options Additional options to be included when inviting.
     */
    async inviteUserByEmail(email, options = {}) {
      try {
        return await _request(this.fetch, "POST", `${this.url}/invite`, {
          body: { email, data: options.data },
          headers: this.headers,
          redirectTo: options.redirectTo,
          xform: _userResponse
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    }
    /**
     * Generates email links and OTPs to be sent via a custom email provider.
     * @param email The user's email.
     * @param options.password User password. For signup only.
     * @param options.data Optional user metadata. For signup only.
     * @param options.redirectTo The redirect url which should be appended to the generated link
     */
    async generateLink(params) {
      try {
        const { options } = params, rest = __rest(params, ["options"]);
        const body = Object.assign(Object.assign({}, rest), options);
        if ("newEmail" in rest) {
          body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
          delete body["newEmail"];
        }
        return await _request(this.fetch, "POST", `${this.url}/admin/generate_link`, {
          body,
          headers: this.headers,
          xform: _generateLinkResponse,
          redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
        });
      } catch (error) {
        if (isAuthError(error)) {
          return {
            data: {
              properties: null,
              user: null
            },
            error
          };
        }
        throw error;
      }
    }
    // User Admin API
    /**
     * Creates a new user.
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
    async createUser(attributes) {
      try {
        return await _request(this.fetch, "POST", `${this.url}/admin/users`, {
          body: attributes,
          headers: this.headers,
          xform: _userResponse
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    }
    /**
     * Get a list of users.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
     */
    async listUsers(params) {
      var _a2, _b, _c, _d, _e, _f, _g;
      try {
        const pagination = { nextPage: null, lastPage: 0, total: 0 };
        const response = await _request(this.fetch, "GET", `${this.url}/admin/users`, {
          headers: this.headers,
          noResolveJson: true,
          query: {
            page: (_b = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "",
            per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
          },
          xform: _noResolveJsonResponse
        });
        if (response.error)
          throw response.error;
        const users = await response.json();
        const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
        const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
        if (links.length > 0) {
          links.forEach((link) => {
            const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
            const rel = JSON.parse(link.split(";")[1].split("=")[1]);
            pagination[`${rel}Page`] = page;
          });
          pagination.total = parseInt(total);
        }
        return { data: Object.assign(Object.assign({}, users), pagination), error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { users: [] }, error };
        }
        throw error;
      }
    }
    /**
     * Get user by id.
     *
     * @param uid The user's unique identifier
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
    async getUserById(uid) {
      validateUUID(uid);
      try {
        return await _request(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
          headers: this.headers,
          xform: _userResponse
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    }
    /**
     * Updates the user data.
     *
     * @param attributes The data you want to update.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
    async updateUserById(uid, attributes) {
      validateUUID(uid);
      try {
        return await _request(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
          body: attributes,
          headers: this.headers,
          xform: _userResponse
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    }
    /**
     * Delete a user. Requires a `service_role` key.
     *
     * @param id The user id you want to remove.
     * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
     * Defaults to false for backward compatibility.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
    async deleteUser(id, shouldSoftDelete = false) {
      validateUUID(id);
      try {
        return await _request(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {
          headers: this.headers,
          body: {
            should_soft_delete: shouldSoftDelete
          },
          xform: _userResponse
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    }
    async _listFactors(params) {
      validateUUID(params.userId);
      try {
        const { data, error } = await _request(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {
          headers: this.headers,
          xform: (factors) => {
            return { data: { factors }, error: null };
          }
        });
        return { data, error };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    async _deleteFactor(params) {
      validateUUID(params.userId);
      validateUUID(params.id);
      try {
        const data = await _request(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    /**
     * Lists all OAuth clients with optional pagination.
     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
    async _listOAuthClients(params) {
      var _a2, _b, _c, _d, _e, _f, _g;
      try {
        const pagination = { nextPage: null, lastPage: 0, total: 0 };
        const response = await _request(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
          headers: this.headers,
          noResolveJson: true,
          query: {
            page: (_b = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "",
            per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
          },
          xform: _noResolveJsonResponse
        });
        if (response.error)
          throw response.error;
        const clients = await response.json();
        const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
        const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
        if (links.length > 0) {
          links.forEach((link) => {
            const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
            const rel = JSON.parse(link.split(";")[1].split("=")[1]);
            pagination[`${rel}Page`] = page;
          });
          pagination.total = parseInt(total);
        }
        return { data: Object.assign(Object.assign({}, clients), pagination), error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { clients: [] }, error };
        }
        throw error;
      }
    }
    /**
     * Creates a new OAuth client.
     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
    async _createOAuthClient(params) {
      try {
        return await _request(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
          body: params,
          headers: this.headers,
          xform: (client2) => {
            return { data: client2, error: null };
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    /**
     * Gets details of a specific OAuth client.
     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
    async _getOAuthClient(clientId) {
      try {
        return await _request(this.fetch, "GET", `${this.url}/admin/oauth/clients/${clientId}`, {
          headers: this.headers,
          xform: (client2) => {
            return { data: client2, error: null };
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    /**
     * Updates an existing OAuth client.
     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
    async _updateOAuthClient(clientId, params) {
      try {
        return await _request(this.fetch, "PUT", `${this.url}/admin/oauth/clients/${clientId}`, {
          body: params,
          headers: this.headers,
          xform: (client2) => {
            return { data: client2, error: null };
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    /**
     * Deletes an OAuth client.
     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
    async _deleteOAuthClient(clientId) {
      try {
        await _request(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${clientId}`, {
          headers: this.headers,
          noResolveJson: true
        });
        return { data: null, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    /**
     * Regenerates the secret for an OAuth client.
     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
    async _regenerateOAuthClientSecret(clientId) {
      try {
        return await _request(this.fetch, "POST", `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {
          headers: this.headers,
          xform: (client2) => {
            return { data: client2, error: null };
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
  }
  function memoryLocalStorageAdapter(store = {}) {
    return {
      getItem: (key) => {
        return store[key] || null;
      },
      setItem: (key, value) => {
        store[key] = value;
      },
      removeItem: (key) => {
        delete store[key];
      }
    };
  }
  const internals = {
    /**
     * @experimental
     */
    debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
  };
  class LockAcquireTimeoutError extends Error {
    constructor(message) {
      super(message);
      this.isAcquireTimeout = true;
    }
  }
  class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {
  }
  async function navigatorLock(name, acquireTimeout, fn) {
    if (internals.debug) {
      console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name, acquireTimeout);
    }
    const abortController = new globalThis.AbortController();
    if (acquireTimeout > 0) {
      setTimeout(() => {
        abortController.abort();
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name);
        }
      }, acquireTimeout);
    }
    return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
      mode: "exclusive",
      ifAvailable: true
    } : {
      mode: "exclusive",
      signal: abortController.signal
    }, async (lock) => {
      if (lock) {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: acquired", name, lock.name);
        }
        try {
          return await fn();
        } finally {
          if (internals.debug) {
            console.log("@supabase/gotrue-js: navigatorLock: released", name, lock.name);
          }
        }
      } else {
        if (acquireTimeout === 0) {
          if (internals.debug) {
            console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name);
          }
          throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
        } else {
          if (internals.debug) {
            try {
              const result2 = await globalThis.navigator.locks.query();
              console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result2, null, "  "));
            } catch (e) {
              console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e);
            }
          }
          console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
          return await fn();
        }
      }
    }));
  }
  function polyfillGlobalThis() {
    if (typeof globalThis === "object")
      return;
    try {
      Object.defineProperty(Object.prototype, "__magic__", {
        get: function() {
          return this;
        },
        configurable: true
      });
      __magic__.globalThis = __magic__;
      delete Object.prototype.__magic__;
    } catch (e) {
      if (typeof self !== "undefined") {
        self.globalThis = self;
      }
    }
  }
  function getAddress(address) {
    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
      throw new Error(`@supabase/auth-js: Address "${address}" is invalid.`);
    }
    return address.toLowerCase();
  }
  function fromHex(hex) {
    return parseInt(hex, 16);
  }
  function toHex(value) {
    const bytes = new TextEncoder().encode(value);
    const hex = Array.from(bytes, (byte) => byte.toString(16).padStart(2, "0")).join("");
    return "0x" + hex;
  }
  function createSiweMessage(parameters) {
    var _a2;
    const { chainId, domain, expirationTime, issuedAt = /* @__PURE__ */ new Date(), nonce, notBefore, requestId, resources, scheme, uri, version: version2 } = parameters;
    {
      if (!Number.isInteger(chainId))
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);
      if (!domain)
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.`);
      if (nonce && nonce.length < 8)
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${nonce}`);
      if (!uri)
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.`);
      if (version2 !== "1")
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${version2}`);
      if ((_a2 = parameters.statement) === null || _a2 === void 0 ? void 0 : _a2.includes("\n"))
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${parameters.statement}`);
    }
    const address = getAddress(parameters.address);
    const origin = scheme ? `${scheme}://${domain}` : domain;
    const statement = parameters.statement ? `${parameters.statement}
` : "";
    const prefix = `${origin} wants you to sign in with your Ethereum account:
${address}

${statement}`;
    let suffix = `URI: ${uri}
Version: ${version2}
Chain ID: ${chainId}${nonce ? `
Nonce: ${nonce}` : ""}
Issued At: ${issuedAt.toISOString()}`;
    if (expirationTime)
      suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
    if (notBefore)
      suffix += `
Not Before: ${notBefore.toISOString()}`;
    if (requestId)
      suffix += `
Request ID: ${requestId}`;
    if (resources) {
      let content2 = "\nResources:";
      for (const resource of resources) {
        if (!resource || typeof resource !== "string")
          throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${resource}`);
        content2 += `
- ${resource}`;
      }
      suffix += content2;
    }
    return `${prefix}
${suffix}`;
  }
  class WebAuthnError extends Error {
    constructor({ message, code, cause, name }) {
      var _a2;
      super(message, { cause });
      this.__isWebAuthnError = true;
      this.name = (_a2 = name !== null && name !== void 0 ? name : cause instanceof Error ? cause.name : void 0) !== null && _a2 !== void 0 ? _a2 : "Unknown Error";
      this.code = code;
    }
  }
  class WebAuthnUnknownError extends WebAuthnError {
    constructor(message, originalError) {
      super({
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: originalError,
        message
      });
      this.name = "WebAuthnUnknownError";
      this.originalError = originalError;
    }
  }
  function identifyRegistrationError({ error, options }) {
    var _a2, _b, _c;
    const { publicKey } = options;
    if (!publicKey) {
      throw Error("options was missing required publicKey property");
    }
    if (error.name === "AbortError") {
      if (options.signal instanceof AbortSignal) {
        return new WebAuthnError({
          message: "Registration ceremony was sent an abort signal",
          code: "ERROR_CEREMONY_ABORTED",
          cause: error
        });
      }
    } else if (error.name === "ConstraintError") {
      if (((_a2 = publicKey.authenticatorSelection) === null || _a2 === void 0 ? void 0 : _a2.requireResidentKey) === true) {
        return new WebAuthnError({
          message: "Discoverable credentials were required but no available authenticator supported it",
          code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
          cause: error
        });
      } else if (
        // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
        options.mediation === "conditional" && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === "required"
      ) {
        return new WebAuthnError({
          message: "User verification was required during automatic registration but it could not be performed",
          code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
          cause: error
        });
      } else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === "required") {
        return new WebAuthnError({
          message: "User verification was required but no available authenticator supported it",
          code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
          cause: error
        });
      }
    } else if (error.name === "InvalidStateError") {
      return new WebAuthnError({
        message: "The authenticator was previously registered",
        code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
        cause: error
      });
    } else if (error.name === "NotAllowedError") {
      return new WebAuthnError({
        message: error.message,
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: error
      });
    } else if (error.name === "NotSupportedError") {
      const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === "public-key");
      if (validPubKeyCredParams.length === 0) {
        return new WebAuthnError({
          message: 'No entry in pubKeyCredParams was of type "public-key"',
          code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
          cause: error
        });
      }
      return new WebAuthnError({
        message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
        code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
        cause: error
      });
    } else if (error.name === "SecurityError") {
      const effectiveDomain = window.location.hostname;
      if (!isValidDomain(effectiveDomain)) {
        return new WebAuthnError({
          message: `${window.location.hostname} is an invalid domain`,
          code: "ERROR_INVALID_DOMAIN",
          cause: error
        });
      } else if (publicKey.rp.id !== effectiveDomain) {
        return new WebAuthnError({
          message: `The RP ID "${publicKey.rp.id}" is invalid for this domain`,
          code: "ERROR_INVALID_RP_ID",
          cause: error
        });
      }
    } else if (error.name === "TypeError") {
      if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
        return new WebAuthnError({
          message: "User ID was not between 1 and 64 characters",
          code: "ERROR_INVALID_USER_ID_LENGTH",
          cause: error
        });
      }
    } else if (error.name === "UnknownError") {
      return new WebAuthnError({
        message: "The authenticator was unable to process the specified options, or could not create a new credential",
        code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
        cause: error
      });
    }
    return new WebAuthnError({
      message: "a Non-Webauthn related error has occurred",
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error
    });
  }
  function identifyAuthenticationError({ error, options }) {
    const { publicKey } = options;
    if (!publicKey) {
      throw Error("options was missing required publicKey property");
    }
    if (error.name === "AbortError") {
      if (options.signal instanceof AbortSignal) {
        return new WebAuthnError({
          message: "Authentication ceremony was sent an abort signal",
          code: "ERROR_CEREMONY_ABORTED",
          cause: error
        });
      }
    } else if (error.name === "NotAllowedError") {
      return new WebAuthnError({
        message: error.message,
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: error
      });
    } else if (error.name === "SecurityError") {
      const effectiveDomain = window.location.hostname;
      if (!isValidDomain(effectiveDomain)) {
        return new WebAuthnError({
          message: `${window.location.hostname} is an invalid domain`,
          code: "ERROR_INVALID_DOMAIN",
          cause: error
        });
      } else if (publicKey.rpId !== effectiveDomain) {
        return new WebAuthnError({
          message: `The RP ID "${publicKey.rpId}" is invalid for this domain`,
          code: "ERROR_INVALID_RP_ID",
          cause: error
        });
      }
    } else if (error.name === "UnknownError") {
      return new WebAuthnError({
        message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
        code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
        cause: error
      });
    }
    return new WebAuthnError({
      message: "a Non-Webauthn related error has occurred",
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error
    });
  }
  class WebAuthnAbortService {
    /**
     * Create an abort signal for a new WebAuthn operation.
     * Automatically cancels any existing operation.
     *
     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}
     */
    createNewAbortSignal() {
      if (this.controller) {
        const abortError = new Error("Cancelling existing WebAuthn API call for new one");
        abortError.name = "AbortError";
        this.controller.abort(abortError);
      }
      const newController = new AbortController();
      this.controller = newController;
      return newController.signal;
    }
    /**
     * Manually cancel the current WebAuthn operation.
     * Useful for cleaning up when user cancels or navigates away.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}
     */
    cancelCeremony() {
      if (this.controller) {
        const abortError = new Error("Manually cancelling existing WebAuthn API call");
        abortError.name = "AbortError";
        this.controller.abort(abortError);
        this.controller = void 0;
      }
    }
  }
  const webAuthnAbortService = new WebAuthnAbortService();
  function deserializeCredentialCreationOptions(options) {
    if (!options) {
      throw new Error("Credential creation options are required");
    }
    if (typeof PublicKeyCredential !== "undefined" && "parseCreationOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === "function") {
      return PublicKeyCredential.parseCreationOptionsFromJSON(
        /** we assert the options here as typescript still doesn't know about future webauthn types */
        options
      );
    }
    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = __rest(
      options,
      ["challenge", "user", "excludeCredentials"]
    );
    const challenge = base64UrlToUint8Array(challengeStr).buffer;
    const user = Object.assign(Object.assign({}, userOpts), { id: base64UrlToUint8Array(userOpts.id).buffer });
    const result2 = Object.assign(Object.assign({}, restOptions), {
      challenge,
      user
    });
    if (excludeCredentials && excludeCredentials.length > 0) {
      result2.excludeCredentials = new Array(excludeCredentials.length);
      for (let i = 0; i < excludeCredentials.length; i++) {
        const cred = excludeCredentials[i];
        result2.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {
          id: base64UrlToUint8Array(cred.id).buffer,
          type: cred.type || "public-key",
          // Cast transports to handle future transport types like "cable"
          transports: cred.transports
        });
      }
    }
    return result2;
  }
  function deserializeCredentialRequestOptions(options) {
    if (!options) {
      throw new Error("Credential request options are required");
    }
    if (typeof PublicKeyCredential !== "undefined" && "parseRequestOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === "function") {
      return PublicKeyCredential.parseRequestOptionsFromJSON(options);
    }
    const { challenge: challengeStr, allowCredentials } = options, restOptions = __rest(
      options,
      ["challenge", "allowCredentials"]
    );
    const challenge = base64UrlToUint8Array(challengeStr).buffer;
    const result2 = Object.assign(Object.assign({}, restOptions), { challenge });
    if (allowCredentials && allowCredentials.length > 0) {
      result2.allowCredentials = new Array(allowCredentials.length);
      for (let i = 0; i < allowCredentials.length; i++) {
        const cred = allowCredentials[i];
        result2.allowCredentials[i] = Object.assign(Object.assign({}, cred), {
          id: base64UrlToUint8Array(cred.id).buffer,
          type: cred.type || "public-key",
          // Cast transports to handle future transport types like "cable"
          transports: cred.transports
        });
      }
    }
    return result2;
  }
  function serializeCredentialCreationResponse(credential) {
    var _a2;
    if ("toJSON" in credential && typeof credential.toJSON === "function") {
      return credential.toJSON();
    }
    const credentialWithAttachment = credential;
    return {
      id: credential.id,
      rawId: credential.id,
      response: {
        attestationObject: bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),
        clientDataJSON: bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON))
      },
      type: "public-key",
      clientExtensionResults: credential.getClientExtensionResults(),
      // Convert null to undefined and cast to AuthenticatorAttachment type
      authenticatorAttachment: (_a2 = credentialWithAttachment.authenticatorAttachment) !== null && _a2 !== void 0 ? _a2 : void 0
    };
  }
  function serializeCredentialRequestResponse(credential) {
    var _a2;
    if ("toJSON" in credential && typeof credential.toJSON === "function") {
      return credential.toJSON();
    }
    const credentialWithAttachment = credential;
    const clientExtensionResults = credential.getClientExtensionResults();
    const assertionResponse = credential.response;
    return {
      id: credential.id,
      rawId: credential.id,
      // W3C spec expects rawId to match id for JSON format
      response: {
        authenticatorData: bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),
        clientDataJSON: bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),
        signature: bytesToBase64URL(new Uint8Array(assertionResponse.signature)),
        userHandle: assertionResponse.userHandle ? bytesToBase64URL(new Uint8Array(assertionResponse.userHandle)) : void 0
      },
      type: "public-key",
      clientExtensionResults,
      // Convert null to undefined and cast to AuthenticatorAttachment type
      authenticatorAttachment: (_a2 = credentialWithAttachment.authenticatorAttachment) !== null && _a2 !== void 0 ? _a2 : void 0
    };
  }
  function isValidDomain(hostname) {
    return (
      // Consider localhost valid as well since it's okay wrt Secure Contexts
      hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname)
    );
  }
  function browserSupportsWebAuthn() {
    var _a2, _b;
    return !!(isBrowser() && "PublicKeyCredential" in window && window.PublicKeyCredential && "credentials" in navigator && typeof ((_a2 = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a2 === void 0 ? void 0 : _a2.create) === "function" && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === "function");
  }
  async function createCredential(options) {
    try {
      const response = await navigator.credentials.create(
        /** we assert the type here until typescript types are updated */
        options
      );
      if (!response) {
        return {
          data: null,
          error: new WebAuthnUnknownError("Empty credential response", response)
        };
      }
      if (!(response instanceof PublicKeyCredential)) {
        return {
          data: null,
          error: new WebAuthnUnknownError("Browser returned unexpected credential type", response)
        };
      }
      return { data: response, error: null };
    } catch (err) {
      return {
        data: null,
        error: identifyRegistrationError({
          error: err,
          options
        })
      };
    }
  }
  async function getCredential(options) {
    try {
      const response = await navigator.credentials.get(
        /** we assert the type here until typescript types are updated */
        options
      );
      if (!response) {
        return {
          data: null,
          error: new WebAuthnUnknownError("Empty credential response", response)
        };
      }
      if (!(response instanceof PublicKeyCredential)) {
        return {
          data: null,
          error: new WebAuthnUnknownError("Browser returned unexpected credential type", response)
        };
      }
      return { data: response, error: null };
    } catch (err) {
      return {
        data: null,
        error: identifyAuthenticationError({
          error: err,
          options
        })
      };
    }
  }
  const DEFAULT_CREATION_OPTIONS = {
    hints: ["security-key"],
    authenticatorSelection: {
      authenticatorAttachment: "cross-platform",
      requireResidentKey: false,
      /** set to preferred because older yubikeys don't have PIN/Biometric */
      userVerification: "preferred",
      residentKey: "discouraged"
    },
    attestation: "direct"
  };
  const DEFAULT_REQUEST_OPTIONS = {
    /** set to preferred because older yubikeys don't have PIN/Biometric */
    userVerification: "preferred",
    hints: ["security-key"],
    attestation: "direct"
  };
  function deepMerge(...sources) {
    const isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);
    const result2 = {};
    for (const source of sources) {
      if (!source)
        continue;
      for (const key in source) {
        const value = source[key];
        if (value === void 0)
          continue;
        if (Array.isArray(value)) {
          result2[key] = value;
        } else if (isArrayBufferLike(value)) {
          result2[key] = value;
        } else if (isObject(value)) {
          const existing = result2[key];
          if (isObject(existing)) {
            result2[key] = deepMerge(existing, value);
          } else {
            result2[key] = deepMerge(value);
          }
        } else {
          result2[key] = value;
        }
      }
    }
    return result2;
  }
  function mergeCredentialCreationOptions(baseOptions, overrides) {
    return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});
  }
  function mergeCredentialRequestOptions(baseOptions, overrides) {
    return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});
  }
  class WebAuthnApi {
    constructor(client2) {
      this.client = client2;
      this.enroll = this._enroll.bind(this);
      this.challenge = this._challenge.bind(this);
      this.verify = this._verify.bind(this);
      this.authenticate = this._authenticate.bind(this);
      this.register = this._register.bind(this);
    }
    /**
     * Enroll a new WebAuthn factor.
     * Creates an unverified WebAuthn factor that must be verified with a credential.
     *
     * @experimental This method is experimental and may change in future releases
     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)
     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error
     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}
     */
    async _enroll(params) {
      return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: "webauthn" }));
    }
    /**
     * Challenge for WebAuthn credential creation or authentication.
     * Combines server challenge with browser credential operations.
     * Handles both registration (create) and authentication (request) flows.
     *
     * @experimental This method is experimental and may change in future releases
     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId
     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials
     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation
     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request
     * @returns {Promise<RequestResult>} Challenge response with credential or error
     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}
     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}
     */
    async _challenge({ factorId, webauthn, friendlyName, signal }, overrides) {
      try {
        const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({
          factorId,
          webauthn
        });
        if (!challengeResponse) {
          return { data: null, error: challengeError };
        }
        const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();
        if (challengeResponse.webauthn.type === "create") {
          const { user } = challengeResponse.webauthn.credential_options.publicKey;
          if (!user.name) {
            user.name = `${user.id}:${friendlyName}`;
          }
          if (!user.displayName) {
            user.displayName = user.name;
          }
        }
        switch (challengeResponse.webauthn.type) {
          case "create": {
            const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);
            const { data, error } = await createCredential({
              publicKey: options,
              signal: abortSignal
            });
            if (data) {
              return {
                data: {
                  factorId,
                  challengeId: challengeResponse.id,
                  webauthn: {
                    type: challengeResponse.webauthn.type,
                    credential_response: data
                  }
                },
                error: null
              };
            }
            return { data: null, error };
          }
          case "request": {
            const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);
            const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));
            if (data) {
              return {
                data: {
                  factorId,
                  challengeId: challengeResponse.id,
                  webauthn: {
                    type: challengeResponse.webauthn.type,
                    credential_response: data
                  }
                },
                error: null
              };
            }
            return { data: null, error };
          }
        }
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        return {
          data: null,
          error: new AuthUnknownError("Unexpected error in challenge", error)
        };
      }
    }
    /**
     * Verify a WebAuthn credential with the server.
     * Completes the WebAuthn ceremony by sending the credential to the server for verification.
     *
     * @experimental This method is experimental and may change in future releases
     * @param {Object} params - Verification parameters
     * @param {string} params.challengeId - ID of the challenge being verified
     * @param {string} params.factorId - ID of the WebAuthn factor
     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response
     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error
     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}
     * */
    async _verify({ challengeId, factorId, webauthn }) {
      return this.client.mfa.verify({
        factorId,
        challengeId,
        webauthn
      });
    }
    /**
     * Complete WebAuthn authentication flow.
     * Performs challenge and verification in a single operation for existing credentials.
     *
     * @experimental This method is experimental and may change in future releases
     * @param {Object} params - Authentication parameters
     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with
     * @param {Object} params.webauthn - WebAuthn configuration
     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)
     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)
     * @param {AbortSignal} params.webauthn.signal - Optional abort signal
     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get
     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result
     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}
     */
    async _authenticate({ factorId, webauthn: { rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal } = {} }, overrides) {
      if (!rpId) {
        return {
          data: null,
          error: new AuthError("rpId is required for WebAuthn authentication")
        };
      }
      try {
        if (!browserSupportsWebAuthn()) {
          return {
            data: null,
            error: new AuthUnknownError("Browser does not support WebAuthn", null)
          };
        }
        const { data: challengeResponse, error: challengeError } = await this.challenge({
          factorId,
          webauthn: { rpId, rpOrigins },
          signal
        }, { request: overrides });
        if (!challengeResponse) {
          return { data: null, error: challengeError };
        }
        const { webauthn } = challengeResponse;
        return this._verify({
          factorId,
          challengeId: challengeResponse.challengeId,
          webauthn: {
            type: webauthn.type,
            rpId,
            rpOrigins,
            credential_response: webauthn.credential_response
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        return {
          data: null,
          error: new AuthUnknownError("Unexpected error in authenticate", error)
        };
      }
    }
    /**
     * Complete WebAuthn registration flow.
     * Performs enrollment, challenge, and verification in a single operation for new credentials.
     *
     * @experimental This method is experimental and may change in future releases
     * @param {Object} params - Registration parameters
     * @param {string} params.friendlyName - User-friendly name for the credential
     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)
     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)
     * @param {AbortSignal} params.signal - Optional abort signal
     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create
     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result
     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}
     */
    async _register({ friendlyName, webauthn: { rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal } = {} }, overrides) {
      if (!rpId) {
        return {
          data: null,
          error: new AuthError("rpId is required for WebAuthn registration")
        };
      }
      try {
        if (!browserSupportsWebAuthn()) {
          return {
            data: null,
            error: new AuthUnknownError("Browser does not support WebAuthn", null)
          };
        }
        const { data: factor, error: enrollError } = await this._enroll({
          friendlyName
        });
        if (!factor) {
          await this.client.mfa.listFactors().then((factors) => {
            var _a2;
            return (_a2 = factors.data) === null || _a2 === void 0 ? void 0 : _a2.all.find((v) => v.factor_type === "webauthn" && v.friendly_name === friendlyName && v.status !== "unverified");
          }).then((factor2) => factor2 ? this.client.mfa.unenroll({ factorId: factor2 === null || factor2 === void 0 ? void 0 : factor2.id }) : void 0);
          return { data: null, error: enrollError };
        }
        const { data: challengeResponse, error: challengeError } = await this._challenge({
          factorId: factor.id,
          friendlyName: factor.friendly_name,
          webauthn: { rpId, rpOrigins },
          signal
        }, {
          create: overrides
        });
        if (!challengeResponse) {
          return { data: null, error: challengeError };
        }
        return this._verify({
          factorId: factor.id,
          challengeId: challengeResponse.challengeId,
          webauthn: {
            rpId,
            rpOrigins,
            type: challengeResponse.webauthn.type,
            credential_response: challengeResponse.webauthn.credential_response
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        return {
          data: null,
          error: new AuthUnknownError("Unexpected error in register", error)
        };
      }
    }
  }
  polyfillGlobalThis();
  const DEFAULT_OPTIONS = {
    url: GOTRUE_URL,
    storageKey: STORAGE_KEY$1,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    headers: DEFAULT_HEADERS,
    flowType: "implicit",
    debug: false,
    hasCustomAuthorizationHeader: false,
    throwOnError: false
  };
  async function lockNoOp(name, acquireTimeout, fn) {
    return await fn();
  }
  const GLOBAL_JWKS = {};
  class GoTrueClient {
    /**
     * The JWKS used for verifying asymmetric JWTs
     */
    get jwks() {
      var _a2, _b;
      return (_b = (_a2 = GLOBAL_JWKS[this.storageKey]) === null || _a2 === void 0 ? void 0 : _a2.jwks) !== null && _b !== void 0 ? _b : { keys: [] };
    }
    set jwks(value) {
      GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { jwks: value });
    }
    get jwks_cached_at() {
      var _a2, _b;
      return (_b = (_a2 = GLOBAL_JWKS[this.storageKey]) === null || _a2 === void 0 ? void 0 : _a2.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
    }
    set jwks_cached_at(value) {
      GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { cachedAt: value });
    }
    /**
     * Create a new client for use in the browser.
     *
     * @example
     * ```ts
     * import { GoTrueClient } from '@supabase/auth-js'
     *
     * const auth = new GoTrueClient({
     *   url: 'https://xyzcompany.supabase.co/auth/v1',
     *   headers: { apikey: 'public-anon-key' },
     *   storageKey: 'supabase-auth',
     * })
     * ```
     */
    constructor(options) {
      var _a2, _b, _c;
      this.userStorage = null;
      this.memoryStorage = null;
      this.stateChangeEmitters = /* @__PURE__ */ new Map();
      this.autoRefreshTicker = null;
      this.visibilityChangedCallback = null;
      this.refreshingDeferred = null;
      this.initializePromise = null;
      this.detectSessionInUrl = true;
      this.hasCustomAuthorizationHeader = false;
      this.suppressGetSessionWarning = false;
      this.lockAcquired = false;
      this.pendingInLock = [];
      this.broadcastChannel = null;
      this.logger = console.log;
      const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
      this.storageKey = settings.storageKey;
      this.instanceID = (_a2 = GoTrueClient.nextInstanceID[this.storageKey]) !== null && _a2 !== void 0 ? _a2 : 0;
      GoTrueClient.nextInstanceID[this.storageKey] = this.instanceID + 1;
      this.logDebugMessages = !!settings.debug;
      if (typeof settings.debug === "function") {
        this.logger = settings.debug;
      }
      if (this.instanceID > 0 && isBrowser()) {
        const message = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;
        console.warn(message);
        if (this.logDebugMessages) {
          console.trace(message);
        }
      }
      this.persistSession = settings.persistSession;
      this.autoRefreshToken = settings.autoRefreshToken;
      this.admin = new GoTrueAdminApi({
        url: settings.url,
        headers: settings.headers,
        fetch: settings.fetch
      });
      this.url = settings.url;
      this.headers = settings.headers;
      this.fetch = resolveFetch(settings.fetch);
      this.lock = settings.lock || lockNoOp;
      this.detectSessionInUrl = settings.detectSessionInUrl;
      this.flowType = settings.flowType;
      this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
      this.throwOnError = settings.throwOnError;
      if (settings.lock) {
        this.lock = settings.lock;
      } else if (isBrowser() && ((_b = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _b === void 0 ? void 0 : _b.locks)) {
        this.lock = navigatorLock;
      } else {
        this.lock = lockNoOp;
      }
      if (!this.jwks) {
        this.jwks = { keys: [] };
        this.jwks_cached_at = Number.MIN_SAFE_INTEGER;
      }
      this.mfa = {
        verify: this._verify.bind(this),
        enroll: this._enroll.bind(this),
        unenroll: this._unenroll.bind(this),
        challenge: this._challenge.bind(this),
        listFactors: this._listFactors.bind(this),
        challengeAndVerify: this._challengeAndVerify.bind(this),
        getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
        webauthn: new WebAuthnApi(this)
      };
      this.oauth = {
        getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
        approveAuthorization: this._approveAuthorization.bind(this),
        denyAuthorization: this._denyAuthorization.bind(this),
        listGrants: this._listOAuthGrants.bind(this),
        revokeGrant: this._revokeOAuthGrant.bind(this)
      };
      if (this.persistSession) {
        if (settings.storage) {
          this.storage = settings.storage;
        } else {
          if (supportsLocalStorage()) {
            this.storage = globalThis.localStorage;
          } else {
            this.memoryStorage = {};
            this.storage = memoryLocalStorageAdapter(this.memoryStorage);
          }
        }
        if (settings.userStorage) {
          this.userStorage = settings.userStorage;
        }
      } else {
        this.memoryStorage = {};
        this.storage = memoryLocalStorageAdapter(this.memoryStorage);
      }
      if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
        try {
          this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
        } catch (e) {
          console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e);
        }
        (_c = this.broadcastChannel) === null || _c === void 0 ? void 0 : _c.addEventListener("message", async (event) => {
          this._debug("received broadcast notification from other tab or client", event);
          await this._notifyAllSubscribers(event.data.event, event.data.session, false);
        });
      }
      this.initialize();
    }
    /**
     * Returns whether error throwing mode is enabled for this client.
     */
    isThrowOnErrorEnabled() {
      return this.throwOnError;
    }
    /**
     * Centralizes return handling with optional error throwing. When `throwOnError` is enabled
     * and the provided result contains a non-nullish error, the error is thrown instead of
     * being returned. This ensures consistent behavior across all public API methods.
     */
    _returnResult(result2) {
      if (this.throwOnError && result2 && result2.error) {
        throw result2.error;
      }
      return result2;
    }
    _logPrefix() {
      return `GoTrueClient@${this.storageKey}:${this.instanceID} (${version}) ${(/* @__PURE__ */ new Date()).toISOString()}`;
    }
    _debug(...args) {
      if (this.logDebugMessages) {
        this.logger(this._logPrefix(), ...args);
      }
      return this;
    }
    /**
     * Initializes the client session either from the url or from storage.
     * This method is automatically called when instantiating the client, but should also be called
     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
     */
    async initialize() {
      if (this.initializePromise) {
        return await this.initializePromise;
      }
      this.initializePromise = (async () => {
        return await this._acquireLock(-1, async () => {
          return await this._initialize();
        });
      })();
      return await this.initializePromise;
    }
    /**
     * IMPORTANT:
     * 1. Never throw in this method, as it is called from the constructor
     * 2. Never return a session from this method as it would be cached over
     *    the whole lifetime of the client
     */
    async _initialize() {
      var _a2;
      try {
        let params = {};
        let callbackUrlType = "none";
        if (isBrowser()) {
          params = parseParametersFromURL(window.location.href);
          if (this._isImplicitGrantCallback(params)) {
            callbackUrlType = "implicit";
          } else if (await this._isPKCECallback(params)) {
            callbackUrlType = "pkce";
          }
        }
        if (isBrowser() && this.detectSessionInUrl && callbackUrlType !== "none") {
          const { data, error } = await this._getSessionFromURL(params, callbackUrlType);
          if (error) {
            this._debug("#_initialize()", "error detecting session from URL", error);
            if (isAuthImplicitGrantRedirectError(error)) {
              const errorCode = (_a2 = error.details) === null || _a2 === void 0 ? void 0 : _a2.code;
              if (errorCode === "identity_already_exists" || errorCode === "identity_not_found" || errorCode === "single_identity_not_deletable") {
                return { error };
              }
            }
            await this._removeSession();
            return { error };
          }
          const { session, redirectType } = data;
          this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
          await this._saveSession(session);
          setTimeout(async () => {
            if (redirectType === "recovery") {
              await this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
            } else {
              await this._notifyAllSubscribers("SIGNED_IN", session);
            }
          }, 0);
          return { error: null };
        }
        await this._recoverAndRefresh();
        return { error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ error });
        }
        return this._returnResult({
          error: new AuthUnknownError("Unexpected error during initialization", error)
        });
      } finally {
        await this._handleVisibilityChange();
        this._debug("#_initialize()", "end");
      }
    }
    /**
     * Creates a new anonymous user.
     *
     * @returns A session where the is_anonymous claim in the access token JWT set to true
     */
    async signInAnonymously(credentials) {
      var _a2, _b, _c;
      try {
        const res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            data: (_b = (_a2 = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a2 === void 0 ? void 0 : _a2.data) !== null && _b !== void 0 ? _b : {},
            gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken }
          },
          xform: _sessionResponse
        });
        const { data, error } = res;
        if (error || !data) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        const session = data.session;
        const user = data.user;
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return this._returnResult({ data: { user, session }, error: null });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    /**
     * Creates a new user.
     *
     * Be aware that if a user account exists in the system you may get back an
     * error message that attempts to hide this information from the user.
     * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
     *
     * @returns A logged-in session if the server has "autoconfirm" ON
     * @returns A user if the server has "autoconfirm" OFF
     */
    async signUp(credentials) {
      var _a2, _b, _c;
      try {
        let res;
        if ("email" in credentials) {
          const { email, password, options } = credentials;
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce") {
            ;
            [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
          }
          res = await _request(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
            body: {
              email,
              password,
              data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
              code_challenge: codeChallenge,
              code_challenge_method: codeChallengeMethod
            },
            xform: _sessionResponse
          });
        } else if ("phone" in credentials) {
          const { phone, password, options } = credentials;
          res = await _request(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            body: {
              phone,
              password,
              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
              channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : "sms",
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponse
          });
        } else {
          throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
        }
        const { data, error } = res;
        if (error || !data) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        const session = data.session;
        const user = data.user;
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return this._returnResult({ data: { user, session }, error: null });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    /**
     * Log in an existing user with an email and password or phone and password.
     *
     * Be aware that you may get back an error message that will not distinguish
     * between the cases where the account does not exist or that the
     * email/phone and password combination is wrong or that the account can only
     * be accessed via social login.
     */
    async signInWithPassword(credentials) {
      try {
        let res;
        if ("email" in credentials) {
          const { email, password, options } = credentials;
          res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
            headers: this.headers,
            body: {
              email,
              password,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponsePassword
          });
        } else if ("phone" in credentials) {
          const { phone, password, options } = credentials;
          res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
            headers: this.headers,
            body: {
              phone,
              password,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponsePassword
          });
        } else {
          throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
        }
        const { data, error } = res;
        if (error) {
          return this._returnResult({ data: { user: null, session: null }, error });
        } else if (!data || !data.session || !data.user) {
          const invalidTokenError = new AuthInvalidTokenResponseError();
          return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
        }
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return this._returnResult({
          data: Object.assign({ user: data.user, session: data.session }, data.weak_password ? { weakPassword: data.weak_password } : null),
          error
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    /**
     * Log in an existing user via a third-party provider.
     * This method supports the PKCE flow.
     */
    async signInWithOAuth(credentials) {
      var _a2, _b, _c, _d;
      return await this._handleProviderSignIn(credentials.provider, {
        redirectTo: (_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo,
        scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
        queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
        skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
      });
    }
    /**
     * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
     */
    async exchangeCodeForSession(authCode) {
      await this.initializePromise;
      return this._acquireLock(-1, async () => {
        return this._exchangeCodeForSession(authCode);
      });
    }
    /**
     * Signs in a user by verifying a message signed by the user's private key.
     * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,
     * both of which derive from the EIP-4361 standard
     * With slight variation on Solana's side.
     * @reference https://eips.ethereum.org/EIPS/eip-4361
     */
    async signInWithWeb3(credentials) {
      const { chain: chain2 } = credentials;
      switch (chain2) {
        case "ethereum":
          return await this.signInWithEthereum(credentials);
        case "solana":
          return await this.signInWithSolana(credentials);
        default:
          throw new Error(`@supabase/auth-js: Unsupported chain "${chain2}"`);
      }
    }
    async signInWithEthereum(credentials) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      let message;
      let signature;
      if ("message" in credentials) {
        message = credentials.message;
        signature = credentials.signature;
      } else {
        const { chain: chain2, wallet, statement, options } = credentials;
        let resolvedWallet;
        if (!isBrowser()) {
          if (typeof wallet !== "object" || !(options === null || options === void 0 ? void 0 : options.url)) {
            throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
          }
          resolvedWallet = wallet;
        } else if (typeof wallet === "object") {
          resolvedWallet = wallet;
        } else {
          const windowAny = window;
          if ("ethereum" in windowAny && typeof windowAny.ethereum === "object" && "request" in windowAny.ethereum && typeof windowAny.ethereum.request === "function") {
            resolvedWallet = windowAny.ethereum;
          } else {
            throw new Error(`@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.`);
          }
        }
        const url = new URL((_a2 = options === null || options === void 0 ? void 0 : options.url) !== null && _a2 !== void 0 ? _a2 : window.location.href);
        const accounts = await resolvedWallet.request({
          method: "eth_requestAccounts"
        }).then((accs) => accs).catch(() => {
          throw new Error(`@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid`);
        });
        if (!accounts || accounts.length === 0) {
          throw new Error(`@supabase/auth-js: No accounts available. Please ensure the wallet is connected.`);
        }
        const address = getAddress(accounts[0]);
        let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;
        if (!chainId) {
          const chainIdHex = await resolvedWallet.request({
            method: "eth_chainId"
          });
          chainId = fromHex(chainIdHex);
        }
        const siweMessage = {
          domain: url.host,
          address,
          statement,
          uri: url.href,
          version: "1",
          chainId,
          nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,
          issuedAt: (_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : /* @__PURE__ */ new Date(),
          expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,
          notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,
          requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,
          resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources
        };
        message = createSiweMessage(siweMessage);
        signature = await resolvedWallet.request({
          method: "personal_sign",
          params: [toHex(message), address]
        });
      }
      try {
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
          headers: this.headers,
          body: Object.assign({
            chain: "ethereum",
            message,
            signature
          }, ((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken) ? { gotrue_meta_security: { captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken } } : null),
          xform: _sessionResponse
        });
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          const invalidTokenError = new AuthInvalidTokenResponseError();
          return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
        }
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return this._returnResult({ data: Object.assign({}, data), error });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async signInWithSolana(credentials) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      let message;
      let signature;
      if ("message" in credentials) {
        message = credentials.message;
        signature = credentials.signature;
      } else {
        const { chain: chain2, wallet, statement, options } = credentials;
        let resolvedWallet;
        if (!isBrowser()) {
          if (typeof wallet !== "object" || !(options === null || options === void 0 ? void 0 : options.url)) {
            throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
          }
          resolvedWallet = wallet;
        } else if (typeof wallet === "object") {
          resolvedWallet = wallet;
        } else {
          const windowAny = window;
          if ("solana" in windowAny && typeof windowAny.solana === "object" && ("signIn" in windowAny.solana && typeof windowAny.solana.signIn === "function" || "signMessage" in windowAny.solana && typeof windowAny.solana.signMessage === "function")) {
            resolvedWallet = windowAny.solana;
          } else {
            throw new Error(`@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`);
          }
        }
        const url = new URL((_a2 = options === null || options === void 0 ? void 0 : options.url) !== null && _a2 !== void 0 ? _a2 : window.location.href);
        if ("signIn" in resolvedWallet && resolvedWallet.signIn) {
          const output = await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({ issuedAt: (/* @__PURE__ */ new Date()).toISOString() }, options === null || options === void 0 ? void 0 : options.signInWithSolana), {
            // non-overridable properties
            version: "1",
            domain: url.host,
            uri: url.href
          }), statement ? { statement } : null));
          let outputToProcess;
          if (Array.isArray(output) && output[0] && typeof output[0] === "object") {
            outputToProcess = output[0];
          } else if (output && typeof output === "object" && "signedMessage" in output && "signature" in output) {
            outputToProcess = output;
          } else {
            throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
          }
          if ("signedMessage" in outputToProcess && "signature" in outputToProcess && (typeof outputToProcess.signedMessage === "string" || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array) {
            message = typeof outputToProcess.signedMessage === "string" ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);
            signature = outputToProcess.signature;
          } else {
            throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields");
          }
        } else {
          if (!("signMessage" in resolvedWallet) || typeof resolvedWallet.signMessage !== "function" || !("publicKey" in resolvedWallet) || typeof resolvedWallet !== "object" || !resolvedWallet.publicKey || !("toBase58" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== "function") {
            throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
          }
          message = [
            `${url.host} wants you to sign in with your Solana account:`,
            resolvedWallet.publicKey.toBase58(),
            ...statement ? ["", statement, ""] : [""],
            "Version: 1",
            `URI: ${url.href}`,
            `Issued At: ${(_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : (/* @__PURE__ */ new Date()).toISOString()}`,
            ...((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore) ? [`Not Before: ${options.signInWithSolana.notBefore}`] : [],
            ...((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? void 0 : _e.expirationTime) ? [`Expiration Time: ${options.signInWithSolana.expirationTime}`] : [],
            ...((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId) ? [`Chain ID: ${options.signInWithSolana.chainId}`] : [],
            ...((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? [`Nonce: ${options.signInWithSolana.nonce}`] : [],
            ...((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId) ? [`Request ID: ${options.signInWithSolana.requestId}`] : [],
            ...((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length) ? [
              "Resources",
              ...options.signInWithSolana.resources.map((resource) => `- ${resource}`)
            ] : []
          ].join("\n");
          const maybeSignature = await resolvedWallet.signMessage(new TextEncoder().encode(message), "utf8");
          if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {
            throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
          }
          signature = maybeSignature;
        }
      }
      try {
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
          headers: this.headers,
          body: Object.assign({ chain: "solana", message, signature: bytesToBase64URL(signature) }, ((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken) ? { gotrue_meta_security: { captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken } } : null),
          xform: _sessionResponse
        });
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          const invalidTokenError = new AuthInvalidTokenResponseError();
          return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
        }
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return this._returnResult({ data: Object.assign({}, data), error });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async _exchangeCodeForSession(authCode) {
      const storageItem = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : "").split("/");
      try {
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
          headers: this.headers,
          body: {
            auth_code: authCode,
            code_verifier: codeVerifier
          },
          xform: _sessionResponse
        });
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          const invalidTokenError = new AuthInvalidTokenResponseError();
          return this._returnResult({
            data: { user: null, session: null, redirectType: null },
            error: invalidTokenError
          });
        }
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return this._returnResult({ data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null }), error });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({
            data: { user: null, session: null, redirectType: null },
            error
          });
        }
        throw error;
      }
    }
    /**
     * Allows signing in with an OIDC ID token. The authentication provider used
     * should be enabled and configured.
     */
    async signInWithIdToken(credentials) {
      try {
        const { options, provider, token, access_token, nonce } = credentials;
        const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
          headers: this.headers,
          body: {
            provider,
            id_token: token,
            access_token,
            nonce,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
        const { data, error } = res;
        if (error) {
          return this._returnResult({ data: { user: null, session: null }, error });
        } else if (!data || !data.session || !data.user) {
          const invalidTokenError = new AuthInvalidTokenResponseError();
          return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
        }
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return this._returnResult({ data, error });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    /**
     * Log in a user using magiclink or a one-time password (OTP).
     *
     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
     *
     * Be aware that you may get back an error message that will not distinguish
     * between the cases where the account does not exist or, that the account
     * can only be accessed via social login.
     *
     * Do note that you will need to configure a Whatsapp sender on Twilio
     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
     * channel is not supported on other providers
     * at this time.
     * This method supports PKCE when an email is passed.
     */
    async signInWithOtp(credentials) {
      var _a2, _b, _c, _d, _e;
      try {
        if ("email" in credentials) {
          const { email, options } = credentials;
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce") {
            ;
            [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
          }
          const { error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
            headers: this.headers,
            body: {
              email,
              data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
              create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
              code_challenge: codeChallenge,
              code_challenge_method: codeChallengeMethod
            },
            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
          });
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        if ("phone" in credentials) {
          const { phone, options } = credentials;
          const { data, error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
            headers: this.headers,
            body: {
              phone,
              data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
              create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
              channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : "sms"
            }
          });
          return this._returnResult({
            data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id },
            error
          });
        }
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number.");
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    /**
     * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
     */
    async verifyOtp(params) {
      var _a2, _b;
      try {
        let redirectTo = void 0;
        let captchaToken = void 0;
        if ("options" in params) {
          redirectTo = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo;
          captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
        }
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/verify`, {
          headers: this.headers,
          body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),
          redirectTo,
          xform: _sessionResponse
        });
        if (error) {
          throw error;
        }
        if (!data) {
          const tokenVerificationError = new Error("An error occurred on token verification.");
          throw tokenVerificationError;
        }
        const session = data.session;
        const user = data.user;
        if (session === null || session === void 0 ? void 0 : session.access_token) {
          await this._saveSession(session);
          await this._notifyAllSubscribers(params.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
        }
        return this._returnResult({ data: { user, session }, error: null });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    /**
     * Attempts a single-sign on using an enterprise Identity Provider. A
     * successful SSO attempt will redirect the current page to the identity
     * provider authorization page. The redirect URL is implementation and SSO
     * protocol specific.
     *
     * You can use it by providing a SSO domain. Typically you can extract this
     * domain by asking users for their email address. If this domain is
     * registered on the Auth instance the redirect will use that organization's
     * currently active SSO Identity Provider for the login.
     *
     * If you have built an organization-specific login page, you can use the
     * organization's SSO Identity Provider UUID directly instead.
     */
    async signInWithSSO(params) {
      var _a2, _b, _c, _d, _e;
      try {
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        const result2 = await _request(this.fetch, "POST", `${this.url}/sso`, {
          body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? { provider_id: params.providerId } : null), "domain" in params ? { domain: params.domain } : null), { redirect_to: (_b = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo) !== null && _b !== void 0 ? _b : void 0 }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
          headers: this.headers,
          xform: _ssoResponse
        });
        if (((_d = result2.data) === null || _d === void 0 ? void 0 : _d.url) && isBrowser() && !((_e = params.options) === null || _e === void 0 ? void 0 : _e.skipBrowserRedirect)) {
          window.location.assign(result2.data.url);
        }
        return this._returnResult(result2);
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    /**
     * Sends a reauthentication OTP to the user's email or phone number.
     * Requires the user to be signed-in.
     */
    async reauthenticate() {
      await this.initializePromise;
      return await this._acquireLock(-1, async () => {
        return await this._reauthenticate();
      });
    }
    async _reauthenticate() {
      try {
        return await this._useSession(async (result2) => {
          const { data: { session }, error: sessionError } = result2;
          if (sessionError)
            throw sessionError;
          if (!session)
            throw new AuthSessionMissingError();
          const { error } = await _request(this.fetch, "GET", `${this.url}/reauthenticate`, {
            headers: this.headers,
            jwt: session.access_token
          });
          return this._returnResult({ data: { user: null, session: null }, error });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    /**
     * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
     */
    async resend(credentials) {
      try {
        const endpoint = `${this.url}/resend`;
        if ("email" in credentials) {
          const { email, type, options } = credentials;
          const { error } = await _request(this.fetch, "POST", endpoint, {
            headers: this.headers,
            body: {
              email,
              type,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
          });
          return this._returnResult({ data: { user: null, session: null }, error });
        } else if ("phone" in credentials) {
          const { phone, type, options } = credentials;
          const { data, error } = await _request(this.fetch, "POST", endpoint, {
            headers: this.headers,
            body: {
              phone,
              type,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            }
          });
          return this._returnResult({
            data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id },
            error
          });
        }
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    /**
     * Returns the session, refreshing it if necessary.
     *
     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
     *
     * **IMPORTANT:** This method loads values directly from the storage attached
     * to the client. If that storage is based on request cookies for example,
     * the values in it may not be authentic and therefore it's strongly advised
     * against using this method and its results in such circumstances. A warning
     * will be emitted if this is detected. Use {@link #getUser()} instead.
     */
    async getSession() {
      await this.initializePromise;
      const result2 = await this._acquireLock(-1, async () => {
        return this._useSession(async (result3) => {
          return result3;
        });
      });
      return result2;
    }
    /**
     * Acquires a global lock based on the storage key.
     */
    async _acquireLock(acquireTimeout, fn) {
      this._debug("#_acquireLock", "begin", acquireTimeout);
      try {
        if (this.lockAcquired) {
          const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
          const result2 = (async () => {
            await last;
            return await fn();
          })();
          this.pendingInLock.push((async () => {
            try {
              await result2;
            } catch (e) {
            }
          })());
          return result2;
        }
        return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {
          this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
          try {
            this.lockAcquired = true;
            const result2 = fn();
            this.pendingInLock.push((async () => {
              try {
                await result2;
              } catch (e) {
              }
            })());
            await result2;
            while (this.pendingInLock.length) {
              const waitOn = [...this.pendingInLock];
              await Promise.all(waitOn);
              this.pendingInLock.splice(0, waitOn.length);
            }
            return await result2;
          } finally {
            this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
            this.lockAcquired = false;
          }
        });
      } finally {
        this._debug("#_acquireLock", "end");
      }
    }
    /**
     * Use instead of {@link #getSession} inside the library. It is
     * semantically usually what you want, as getting a session involves some
     * processing afterwards that requires only one client operating on the
     * session at once across multiple tabs or processes.
     */
    async _useSession(fn) {
      this._debug("#_useSession", "begin");
      try {
        const result2 = await this.__loadSession();
        return await fn(result2);
      } finally {
        this._debug("#_useSession", "end");
      }
    }
    /**
     * NEVER USE DIRECTLY!
     *
     * Always use {@link #_useSession}.
     */
    async __loadSession() {
      this._debug("#__loadSession()", "begin");
      if (!this.lockAcquired) {
        this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
      }
      try {
        let currentSession = null;
        const maybeSession = await getItemAsync(this.storage, this.storageKey);
        this._debug("#getSession()", "session from storage", maybeSession);
        if (maybeSession !== null) {
          if (this._isValidSession(maybeSession)) {
            currentSession = maybeSession;
          } else {
            this._debug("#getSession()", "session from storage is not valid");
            await this._removeSession();
          }
        }
        if (!currentSession) {
          return { data: { session: null }, error: null };
        }
        const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1e3 - Date.now() < EXPIRY_MARGIN_MS : false;
        this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
        if (!hasExpired) {
          if (this.userStorage) {
            const maybeUser = await getItemAsync(this.userStorage, this.storageKey + "-user");
            if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {
              currentSession.user = maybeUser.user;
            } else {
              currentSession.user = userNotAvailableProxy();
            }
          }
          if (this.storage.isServer && currentSession.user && !currentSession.user.__isUserNotAvailableProxy) {
            const suppressWarningRef = { value: this.suppressGetSessionWarning };
            currentSession.user = insecureUserWarningProxy(currentSession.user, suppressWarningRef);
            if (suppressWarningRef.value) {
              this.suppressGetSessionWarning = true;
            }
          }
          return { data: { session: currentSession }, error: null };
        }
        const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return this._returnResult({ data: { session: null }, error });
        }
        return this._returnResult({ data: { session }, error: null });
      } finally {
        this._debug("#__loadSession()", "end");
      }
    }
    /**
     * Gets the current user details if there is an existing session. This method
     * performs a network request to the Supabase Auth server, so the returned
     * value is authentic and can be used to base authorization rules on.
     *
     * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
     */
    async getUser(jwt) {
      if (jwt) {
        return await this._getUser(jwt);
      }
      await this.initializePromise;
      const result2 = await this._acquireLock(-1, async () => {
        return await this._getUser();
      });
      return result2;
    }
    async _getUser(jwt) {
      try {
        if (jwt) {
          return await _request(this.fetch, "GET", `${this.url}/user`, {
            headers: this.headers,
            jwt,
            xform: _userResponse
          });
        }
        return await this._useSession(async (result2) => {
          var _a2, _b, _c;
          const { data, error } = result2;
          if (error) {
            throw error;
          }
          if (!((_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) && !this.hasCustomAuthorizationHeader) {
            return { data: { user: null }, error: new AuthSessionMissingError() };
          }
          return await _request(this.fetch, "GET", `${this.url}/user`, {
            headers: this.headers,
            jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : void 0,
            xform: _userResponse
          });
        });
      } catch (error) {
        if (isAuthError(error)) {
          if (isAuthSessionMissingError(error)) {
            await this._removeSession();
            await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
          }
          return this._returnResult({ data: { user: null }, error });
        }
        throw error;
      }
    }
    /**
     * Updates user data for a logged in user.
     */
    async updateUser(attributes, options = {}) {
      await this.initializePromise;
      return await this._acquireLock(-1, async () => {
        return await this._updateUser(attributes, options);
      });
    }
    async _updateUser(attributes, options = {}) {
      try {
        return await this._useSession(async (result2) => {
          const { data: sessionData, error: sessionError } = result2;
          if (sessionError) {
            throw sessionError;
          }
          if (!sessionData.session) {
            throw new AuthSessionMissingError();
          }
          const session = sessionData.session;
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce" && attributes.email != null) {
            ;
            [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
          }
          const { data, error: userError } = await _request(this.fetch, "PUT", `${this.url}/user`, {
            headers: this.headers,
            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
            body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
            jwt: session.access_token,
            xform: _userResponse
          });
          if (userError) {
            throw userError;
          }
          session.user = data.user;
          await this._saveSession(session);
          await this._notifyAllSubscribers("USER_UPDATED", session);
          return this._returnResult({ data: { user: session.user }, error: null });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null }, error });
        }
        throw error;
      }
    }
    /**
     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
     * If the refresh token or access token in the current session is invalid, an error will be thrown.
     * @param currentSession The current session that minimally contains an access token and refresh token.
     */
    async setSession(currentSession) {
      await this.initializePromise;
      return await this._acquireLock(-1, async () => {
        return await this._setSession(currentSession);
      });
    }
    async _setSession(currentSession) {
      try {
        if (!currentSession.access_token || !currentSession.refresh_token) {
          throw new AuthSessionMissingError();
        }
        const timeNow = Date.now() / 1e3;
        let expiresAt2 = timeNow;
        let hasExpired = true;
        let session = null;
        const { payload } = decodeJWT(currentSession.access_token);
        if (payload.exp) {
          expiresAt2 = payload.exp;
          hasExpired = expiresAt2 <= timeNow;
        }
        if (hasExpired) {
          const { data: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            return this._returnResult({ data: { user: null, session: null }, error });
          }
          if (!refreshedSession) {
            return { data: { user: null, session: null }, error: null };
          }
          session = refreshedSession;
        } else {
          const { data, error } = await this._getUser(currentSession.access_token);
          if (error) {
            throw error;
          }
          session = {
            access_token: currentSession.access_token,
            refresh_token: currentSession.refresh_token,
            user: data.user,
            token_type: "bearer",
            expires_in: expiresAt2 - timeNow,
            expires_at: expiresAt2
          };
          await this._saveSession(session);
          await this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return this._returnResult({ data: { user: session.user, session }, error: null });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { session: null, user: null }, error });
        }
        throw error;
      }
    }
    /**
     * Returns a new session, regardless of expiry status.
     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
     * If the current session's refresh token is invalid, an error will be thrown.
     * @param currentSession The current session. If passed in, it must contain a refresh token.
     */
    async refreshSession(currentSession) {
      await this.initializePromise;
      return await this._acquireLock(-1, async () => {
        return await this._refreshSession(currentSession);
      });
    }
    async _refreshSession(currentSession) {
      try {
        return await this._useSession(async (result2) => {
          var _a2;
          if (!currentSession) {
            const { data, error: error2 } = result2;
            if (error2) {
              throw error2;
            }
            currentSession = (_a2 = data.session) !== null && _a2 !== void 0 ? _a2 : void 0;
          }
          if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
            throw new AuthSessionMissingError();
          }
          const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            return this._returnResult({ data: { user: null, session: null }, error });
          }
          if (!session) {
            return this._returnResult({ data: { user: null, session: null }, error: null });
          }
          return this._returnResult({ data: { user: session.user, session }, error: null });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    /**
     * Gets the session data from a URL string
     */
    async _getSessionFromURL(params, callbackUrlType) {
      try {
        if (!isBrowser())
          throw new AuthImplicitGrantRedirectError("No browser detected.");
        if (params.error || params.error_description || params.error_code) {
          throw new AuthImplicitGrantRedirectError(params.error_description || "Error in URL with unspecified error_description", {
            error: params.error || "unspecified_error",
            code: params.error_code || "unspecified_code"
          });
        }
        switch (callbackUrlType) {
          case "implicit":
            if (this.flowType === "pkce") {
              throw new AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
            }
            break;
          case "pkce":
            if (this.flowType === "implicit") {
              throw new AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
            }
            break;
          default:
        }
        if (callbackUrlType === "pkce") {
          this._debug("#_initialize()", "begin", "is PKCE flow", true);
          if (!params.code)
            throw new AuthPKCEGrantCodeExchangeError("No code detected.");
          const { data: data2, error: error2 } = await this._exchangeCodeForSession(params.code);
          if (error2)
            throw error2;
          const url = new URL(window.location.href);
          url.searchParams.delete("code");
          window.history.replaceState(window.history.state, "", url.toString());
          return { data: { session: data2.session, redirectType: null }, error: null };
        }
        const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;
        if (!access_token || !expires_in || !refresh_token || !token_type) {
          throw new AuthImplicitGrantRedirectError("No session defined in URL");
        }
        const timeNow = Math.round(Date.now() / 1e3);
        const expiresIn = parseInt(expires_in);
        let expiresAt2 = timeNow + expiresIn;
        if (expires_at) {
          expiresAt2 = parseInt(expires_at);
        }
        const actuallyExpiresIn = expiresAt2 - timeNow;
        if (actuallyExpiresIn * 1e3 <= AUTO_REFRESH_TICK_DURATION_MS) {
          console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
        }
        const issuedAt = expiresAt2 - expiresIn;
        if (timeNow - issuedAt >= 120) {
          console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", issuedAt, expiresAt2, timeNow);
        } else if (timeNow - issuedAt < 0) {
          console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", issuedAt, expiresAt2, timeNow);
        }
        const { data, error } = await this._getUser(access_token);
        if (error)
          throw error;
        const session = {
          provider_token,
          provider_refresh_token,
          access_token,
          expires_in: expiresIn,
          expires_at: expiresAt2,
          refresh_token,
          token_type,
          user: data.user
        };
        window.location.hash = "";
        this._debug("#_getSessionFromURL()", "clearing window.location.hash");
        return this._returnResult({ data: { session, redirectType: params.type }, error: null });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { session: null, redirectType: null }, error });
        }
        throw error;
      }
    }
    /**
     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
     */
    _isImplicitGrantCallback(params) {
      return Boolean(params.access_token || params.error_description);
    }
    /**
     * Checks if the current URL and backing storage contain parameters given by a PKCE flow
     */
    async _isPKCECallback(params) {
      const currentStorageContent = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      return !!(params.code && currentStorageContent);
    }
    /**
     * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
     *
     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
     *
     * If using `others` scope, no `SIGNED_OUT` event is fired!
     */
    async signOut(options = { scope: "global" }) {
      await this.initializePromise;
      return await this._acquireLock(-1, async () => {
        return await this._signOut(options);
      });
    }
    async _signOut({ scope } = { scope: "global" }) {
      return await this._useSession(async (result2) => {
        var _a2;
        const { data, error: sessionError } = result2;
        if (sessionError) {
          return this._returnResult({ error: sessionError });
        }
        const accessToken = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token;
        if (accessToken) {
          const { error } = await this.admin.signOut(accessToken, scope);
          if (error) {
            if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {
              return this._returnResult({ error });
            }
          }
        }
        if (scope !== "others") {
          await this._removeSession();
          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        }
        return this._returnResult({ error: null });
      });
    }
    onAuthStateChange(callback) {
      const id = generateCallbackId();
      const subscription = {
        id,
        callback,
        unsubscribe: () => {
          this._debug("#unsubscribe()", "state change callback with id removed", id);
          this.stateChangeEmitters.delete(id);
        }
      };
      this._debug("#onAuthStateChange()", "registered callback with id", id);
      this.stateChangeEmitters.set(id, subscription);
      (async () => {
        await this.initializePromise;
        await this._acquireLock(-1, async () => {
          this._emitInitialSession(id);
        });
      })();
      return { data: { subscription } };
    }
    async _emitInitialSession(id) {
      return await this._useSession(async (result2) => {
        var _a2, _b;
        try {
          const { data: { session }, error } = result2;
          if (error)
            throw error;
          await ((_a2 = this.stateChangeEmitters.get(id)) === null || _a2 === void 0 ? void 0 : _a2.callback("INITIAL_SESSION", session));
          this._debug("INITIAL_SESSION", "callback id", id, "session", session);
        } catch (err) {
          await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback("INITIAL_SESSION", null));
          this._debug("INITIAL_SESSION", "callback id", id, "error", err);
          console.error(err);
        }
      });
    }
    /**
     * Sends a password reset request to an email address. This method supports the PKCE flow.
     *
     * @param email The email address of the user.
     * @param options.redirectTo The URL to send the user to after they click the password reset link.
     * @param options.captchaToken Verification token received when the user completes the captcha on the site.
     */
    async resetPasswordForEmail(email, options = {}) {
      let codeChallenge = null;
      let codeChallengeMethod = null;
      if (this.flowType === "pkce") {
        [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(
          this.storage,
          this.storageKey,
          true
          // isPasswordRecovery
        );
      }
      try {
        return await _request(this.fetch, "POST", `${this.url}/recover`, {
          body: {
            email,
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod,
            gotrue_meta_security: { captcha_token: options.captchaToken }
          },
          headers: this.headers,
          redirectTo: options.redirectTo
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    /**
     * Gets all the identities linked to a user.
     */
    async getUserIdentities() {
      var _a2;
      try {
        const { data, error } = await this.getUser();
        if (error)
          throw error;
        return this._returnResult({ data: { identities: (_a2 = data.user.identities) !== null && _a2 !== void 0 ? _a2 : [] }, error: null });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async linkIdentity(credentials) {
      if ("token" in credentials) {
        return this.linkIdentityIdToken(credentials);
      }
      return this.linkIdentityOAuth(credentials);
    }
    async linkIdentityOAuth(credentials) {
      var _a2;
      try {
        const { data, error } = await this._useSession(async (result2) => {
          var _a3, _b, _c, _d, _e;
          const { data: data2, error: error2 } = result2;
          if (error2)
            throw error2;
          const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
            redirectTo: (_a3 = credentials.options) === null || _a3 === void 0 ? void 0 : _a3.redirectTo,
            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
            skipBrowserRedirect: true
          });
          return await _request(this.fetch, "GET", url, {
            headers: this.headers,
            jwt: (_e = (_d = data2.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : void 0
          });
        });
        if (error)
          throw error;
        if (isBrowser() && !((_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.skipBrowserRedirect)) {
          window.location.assign(data === null || data === void 0 ? void 0 : data.url);
        }
        return this._returnResult({
          data: { provider: credentials.provider, url: data === null || data === void 0 ? void 0 : data.url },
          error: null
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: { provider: credentials.provider, url: null }, error });
        }
        throw error;
      }
    }
    async linkIdentityIdToken(credentials) {
      return await this._useSession(async (result2) => {
        var _a2;
        try {
          const { error: sessionError, data: { session } } = result2;
          if (sessionError)
            throw sessionError;
          const { options, provider, token, access_token, nonce } = credentials;
          const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
            headers: this.headers,
            jwt: (_a2 = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a2 !== void 0 ? _a2 : void 0,
            body: {
              provider,
              id_token: token,
              access_token,
              nonce,
              link_identity: true,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponse
          });
          const { data, error } = res;
          if (error) {
            return this._returnResult({ data: { user: null, session: null }, error });
          } else if (!data || !data.session || !data.user) {
            return this._returnResult({
              data: { user: null, session: null },
              error: new AuthInvalidTokenResponseError()
            });
          }
          if (data.session) {
            await this._saveSession(data.session);
            await this._notifyAllSubscribers("USER_UPDATED", data.session);
          }
          return this._returnResult({ data, error });
        } catch (error) {
          if (isAuthError(error)) {
            return this._returnResult({ data: { user: null, session: null }, error });
          }
          throw error;
        }
      });
    }
    /**
     * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
     */
    async unlinkIdentity(identity2) {
      try {
        return await this._useSession(async (result2) => {
          var _a2, _b;
          const { data, error } = result2;
          if (error) {
            throw error;
          }
          return await _request(this.fetch, "DELETE", `${this.url}/user/identities/${identity2.identity_id}`, {
            headers: this.headers,
            jwt: (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : void 0
          });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    /**
     * Generates a new JWT.
     * @param refreshToken A valid refresh token that was returned on login.
     */
    async _refreshAccessToken(refreshToken) {
      const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
      this._debug(debugName, "begin");
      try {
        const startedAt = Date.now();
        return await retryable(async (attempt) => {
          if (attempt > 0) {
            await sleep(200 * Math.pow(2, attempt - 1));
          }
          this._debug(debugName, "refreshing attempt", attempt);
          return await _request(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
            body: { refresh_token: refreshToken },
            headers: this.headers,
            xform: _sessionResponse
          });
        }, (attempt, error) => {
          const nextBackOffInterval = 200 * Math.pow(2, attempt);
          return error && isAuthRetryableFetchError(error) && // retryable only if the request can be sent before the backoff overflows the tick duration
          Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION_MS;
        });
      } catch (error) {
        this._debug(debugName, "error", error);
        if (isAuthError(error)) {
          return this._returnResult({ data: { session: null, user: null }, error });
        }
        throw error;
      } finally {
        this._debug(debugName, "end");
      }
    }
    _isValidSession(maybeSession) {
      const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
      return isValidSession;
    }
    async _handleProviderSignIn(provider, options) {
      const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {
        redirectTo: options.redirectTo,
        scopes: options.scopes,
        queryParams: options.queryParams
      });
      this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
      if (isBrowser() && !options.skipBrowserRedirect) {
        window.location.assign(url);
      }
      return { data: { provider, url }, error: null };
    }
    /**
     * Recovers the session from LocalStorage and refreshes the token
     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
     */
    async _recoverAndRefresh() {
      var _a2, _b;
      const debugName = "#_recoverAndRefresh()";
      this._debug(debugName, "begin");
      try {
        const currentSession = await getItemAsync(this.storage, this.storageKey);
        if (currentSession && this.userStorage) {
          let maybeUser = await getItemAsync(this.userStorage, this.storageKey + "-user");
          if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {
            maybeUser = { user: currentSession.user };
            await setItemAsync(this.userStorage, this.storageKey + "-user", maybeUser);
          }
          currentSession.user = (_a2 = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a2 !== void 0 ? _a2 : userNotAvailableProxy();
        } else if (currentSession && !currentSession.user) {
          if (!currentSession.user) {
            const separateUser = await getItemAsync(this.storage, this.storageKey + "-user");
            if (separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user)) {
              currentSession.user = separateUser.user;
              await removeItemAsync(this.storage, this.storageKey + "-user");
              await setItemAsync(this.storage, this.storageKey, currentSession);
            } else {
              currentSession.user = userNotAvailableProxy();
            }
          }
        }
        this._debug(debugName, "session from storage", currentSession);
        if (!this._isValidSession(currentSession)) {
          this._debug(debugName, "session is not valid");
          if (currentSession !== null) {
            await this._removeSession();
          }
          return;
        }
        const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1e3 - Date.now() < EXPIRY_MARGIN_MS;
        this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${EXPIRY_MARGIN_MS}s`);
        if (expiresWithMargin) {
          if (this.autoRefreshToken && currentSession.refresh_token) {
            const { error } = await this._callRefreshToken(currentSession.refresh_token);
            if (error) {
              console.error(error);
              if (!isAuthRetryableFetchError(error)) {
                this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error);
                await this._removeSession();
              }
            }
          }
        } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === true) {
          try {
            const { data, error: userError } = await this._getUser(currentSession.access_token);
            if (!userError && (data === null || data === void 0 ? void 0 : data.user)) {
              currentSession.user = data.user;
              await this._saveSession(currentSession);
              await this._notifyAllSubscribers("SIGNED_IN", currentSession);
            } else {
              this._debug(debugName, "could not get user data, skipping SIGNED_IN notification");
            }
          } catch (getUserError) {
            console.error("Error getting user data:", getUserError);
            this._debug(debugName, "error getting user data, skipping SIGNED_IN notification", getUserError);
          }
        } else {
          await this._notifyAllSubscribers("SIGNED_IN", currentSession);
        }
      } catch (err) {
        this._debug(debugName, "error", err);
        console.error(err);
        return;
      } finally {
        this._debug(debugName, "end");
      }
    }
    async _callRefreshToken(refreshToken) {
      var _a2, _b;
      if (!refreshToken) {
        throw new AuthSessionMissingError();
      }
      if (this.refreshingDeferred) {
        return this.refreshingDeferred.promise;
      }
      const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
      this._debug(debugName, "begin");
      try {
        this.refreshingDeferred = new Deferred();
        const { data, error } = await this._refreshAccessToken(refreshToken);
        if (error)
          throw error;
        if (!data.session)
          throw new AuthSessionMissingError();
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
        const result2 = { data: data.session, error: null };
        this.refreshingDeferred.resolve(result2);
        return result2;
      } catch (error) {
        this._debug(debugName, "error", error);
        if (isAuthError(error)) {
          const result2 = { data: null, error };
          if (!isAuthRetryableFetchError(error)) {
            await this._removeSession();
          }
          (_a2 = this.refreshingDeferred) === null || _a2 === void 0 ? void 0 : _a2.resolve(result2);
          return result2;
        }
        (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);
        throw error;
      } finally {
        this.refreshingDeferred = null;
        this._debug(debugName, "end");
      }
    }
    async _notifyAllSubscribers(event, session, broadcast = true) {
      const debugName = `#_notifyAllSubscribers(${event})`;
      this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
      try {
        if (this.broadcastChannel && broadcast) {
          this.broadcastChannel.postMessage({ event, session });
        }
        const errors = [];
        const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {
          try {
            await x.callback(event, session);
          } catch (e) {
            errors.push(e);
          }
        });
        await Promise.all(promises);
        if (errors.length > 0) {
          for (let i = 0; i < errors.length; i += 1) {
            console.error(errors[i]);
          }
          throw errors[0];
        }
      } finally {
        this._debug(debugName, "end");
      }
    }
    /**
     * set currentSession and currentUser
     * process to _startAutoRefreshToken if possible
     */
    async _saveSession(session) {
      this._debug("#_saveSession()", session);
      this.suppressGetSessionWarning = true;
      const sessionToProcess = Object.assign({}, session);
      const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;
      if (this.userStorage) {
        if (!userIsProxy && sessionToProcess.user) {
          await setItemAsync(this.userStorage, this.storageKey + "-user", {
            user: sessionToProcess.user
          });
        }
        const mainSessionData = Object.assign({}, sessionToProcess);
        delete mainSessionData.user;
        const clonedMainSessionData = deepClone(mainSessionData);
        await setItemAsync(this.storage, this.storageKey, clonedMainSessionData);
      } else {
        const clonedSession = deepClone(sessionToProcess);
        await setItemAsync(this.storage, this.storageKey, clonedSession);
      }
    }
    async _removeSession() {
      this._debug("#_removeSession()");
      await removeItemAsync(this.storage, this.storageKey);
      await removeItemAsync(this.storage, this.storageKey + "-code-verifier");
      await removeItemAsync(this.storage, this.storageKey + "-user");
      if (this.userStorage) {
        await removeItemAsync(this.userStorage, this.storageKey + "-user");
      }
      await this._notifyAllSubscribers("SIGNED_OUT", null);
    }
    /**
     * Removes any registered visibilitychange callback.
     *
     * {@see #startAutoRefresh}
     * {@see #stopAutoRefresh}
     */
    _removeVisibilityChangedCallback() {
      this._debug("#_removeVisibilityChangedCallback()");
      const callback = this.visibilityChangedCallback;
      this.visibilityChangedCallback = null;
      try {
        if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
          window.removeEventListener("visibilitychange", callback);
        }
      } catch (e) {
        console.error("removing visibilitychange callback failed", e);
      }
    }
    /**
     * This is the private implementation of {@link #startAutoRefresh}. Use this
     * within the library.
     */
    async _startAutoRefresh() {
      await this._stopAutoRefresh();
      this._debug("#_startAutoRefresh()");
      const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION_MS);
      this.autoRefreshTicker = ticker;
      if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") {
        ticker.unref();
      } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
        Deno.unrefTimer(ticker);
      }
      setTimeout(async () => {
        await this.initializePromise;
        await this._autoRefreshTokenTick();
      }, 0);
    }
    /**
     * This is the private implementation of {@link #stopAutoRefresh}. Use this
     * within the library.
     */
    async _stopAutoRefresh() {
      this._debug("#_stopAutoRefresh()");
      const ticker = this.autoRefreshTicker;
      this.autoRefreshTicker = null;
      if (ticker) {
        clearInterval(ticker);
      }
    }
    /**
     * Starts an auto-refresh process in the background. The session is checked
     * every few seconds. Close to the time of expiration a process is started to
     * refresh the session. If refreshing fails it will be retried for as long as
     * necessary.
     *
     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
     * to call this function, it will be called for you.
     *
     * On browsers the refresh process works only when the tab/window is in the
     * foreground to conserve resources as well as prevent race conditions and
     * flooding auth with requests. If you call this method any managed
     * visibility change callback will be removed and you must manage visibility
     * changes on your own.
     *
     * On non-browser platforms the refresh process works *continuously* in the
     * background, which may not be desirable. You should hook into your
     * platform's foreground indication mechanism and call these methods
     * appropriately to conserve resources.
     *
     * {@see #stopAutoRefresh}
     */
    async startAutoRefresh() {
      this._removeVisibilityChangedCallback();
      await this._startAutoRefresh();
    }
    /**
     * Stops an active auto refresh process running in the background (if any).
     *
     * If you call this method any managed visibility change callback will be
     * removed and you must manage visibility changes on your own.
     *
     * See {@link #startAutoRefresh} for more details.
     */
    async stopAutoRefresh() {
      this._removeVisibilityChangedCallback();
      await this._stopAutoRefresh();
    }
    /**
     * Runs the auto refresh token tick.
     */
    async _autoRefreshTokenTick() {
      this._debug("#_autoRefreshTokenTick()", "begin");
      try {
        await this._acquireLock(0, async () => {
          try {
            const now = Date.now();
            try {
              return await this._useSession(async (result2) => {
                const { data: { session } } = result2;
                if (!session || !session.refresh_token || !session.expires_at) {
                  this._debug("#_autoRefreshTokenTick()", "no session");
                  return;
                }
                const expiresInTicks = Math.floor((session.expires_at * 1e3 - now) / AUTO_REFRESH_TICK_DURATION_MS);
                this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
                if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {
                  await this._callRefreshToken(session.refresh_token);
                }
              });
            } catch (e) {
              console.error("Auto refresh tick failed with error. This is likely a transient error.", e);
            }
          } finally {
            this._debug("#_autoRefreshTokenTick()", "end");
          }
        });
      } catch (e) {
        if (e.isAcquireTimeout || e instanceof LockAcquireTimeoutError) {
          this._debug("auto refresh token tick lock not available");
        } else {
          throw e;
        }
      }
    }
    /**
     * Registers callbacks on the browser / platform, which in-turn run
     * algorithms when the browser window/tab are in foreground. On non-browser
     * platforms it assumes always foreground.
     */
    async _handleVisibilityChange() {
      this._debug("#_handleVisibilityChange()");
      if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
        if (this.autoRefreshToken) {
          this.startAutoRefresh();
        }
        return false;
      }
      try {
        this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false);
        window === null || window === void 0 ? void 0 : window.addEventListener("visibilitychange", this.visibilityChangedCallback);
        await this._onVisibilityChanged(true);
      } catch (error) {
        console.error("_handleVisibilityChange", error);
      }
    }
    /**
     * Callback registered with `window.addEventListener('visibilitychange')`.
     */
    async _onVisibilityChanged(calledFromInitialize) {
      const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
      this._debug(methodName, "visibilityState", document.visibilityState);
      if (document.visibilityState === "visible") {
        if (this.autoRefreshToken) {
          this._startAutoRefresh();
        }
        if (!calledFromInitialize) {
          await this.initializePromise;
          await this._acquireLock(-1, async () => {
            if (document.visibilityState !== "visible") {
              this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
              return;
            }
            await this._recoverAndRefresh();
          });
        }
      } else if (document.visibilityState === "hidden") {
        if (this.autoRefreshToken) {
          this._stopAutoRefresh();
        }
      }
    }
    /**
     * Generates the relevant login URL for a third-party provider.
     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
     * @param options.scopes A space-separated list of scopes granted to the OAuth application.
     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
     */
    async _getUrlForProvider(url, provider, options) {
      const urlParams = [`provider=${encodeURIComponent(provider)}`];
      if (options === null || options === void 0 ? void 0 : options.redirectTo) {
        urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
      }
      if (options === null || options === void 0 ? void 0 : options.scopes) {
        urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
      }
      if (this.flowType === "pkce") {
        const [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(this.storage, this.storageKey);
        const flowParams = new URLSearchParams({
          code_challenge: `${encodeURIComponent(codeChallenge)}`,
          code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
        });
        urlParams.push(flowParams.toString());
      }
      if (options === null || options === void 0 ? void 0 : options.queryParams) {
        const query = new URLSearchParams(options.queryParams);
        urlParams.push(query.toString());
      }
      if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
        urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
      }
      return `${url}?${urlParams.join("&")}`;
    }
    async _unenroll(params) {
      try {
        return await this._useSession(async (result2) => {
          var _a2;
          const { data: sessionData, error: sessionError } = result2;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          return await _request(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async _enroll(params) {
      try {
        return await this._useSession(async (result2) => {
          var _a2, _b;
          const { data: sessionData, error: sessionError } = result2;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          const body = Object.assign({ friendly_name: params.friendlyName, factor_type: params.factorType }, params.factorType === "phone" ? { phone: params.phone } : params.factorType === "totp" ? { issuer: params.issuer } : {});
          const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors`, {
            body,
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
          if (error) {
            return this._returnResult({ data: null, error });
          }
          if (params.factorType === "totp" && data.type === "totp" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {
            data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
          }
          return this._returnResult({ data, error: null });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async _verify(params) {
      return this._acquireLock(-1, async () => {
        try {
          return await this._useSession(async (result2) => {
            var _a2;
            const { data: sessionData, error: sessionError } = result2;
            if (sessionError) {
              return this._returnResult({ data: null, error: sessionError });
            }
            const body = Object.assign({ challenge_id: params.challengeId }, "webauthn" in params ? {
              webauthn: Object.assign(Object.assign({}, params.webauthn), { credential_response: params.webauthn.type === "create" ? serializeCredentialCreationResponse(params.webauthn.credential_response) : serializeCredentialRequestResponse(params.webauthn.credential_response) })
            } : { code: params.code });
            const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {
              body,
              headers: this.headers,
              jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
            });
            if (error) {
              return this._returnResult({ data: null, error });
            }
            await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));
            await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
            return this._returnResult({ data, error });
          });
        } catch (error) {
          if (isAuthError(error)) {
            return this._returnResult({ data: null, error });
          }
          throw error;
        }
      });
    }
    async _challenge(params) {
      return this._acquireLock(-1, async () => {
        try {
          return await this._useSession(async (result2) => {
            var _a2;
            const { data: sessionData, error: sessionError } = result2;
            if (sessionError) {
              return this._returnResult({ data: null, error: sessionError });
            }
            const response = await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {
              body: params,
              headers: this.headers,
              jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
            });
            if (response.error) {
              return response;
            }
            const { data } = response;
            if (data.type !== "webauthn") {
              return { data, error: null };
            }
            switch (data.webauthn.type) {
              case "create":
                return {
                  data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: deserializeCredentialCreationOptions(data.webauthn.credential_options.publicKey) }) }) }),
                  error: null
                };
              case "request":
                return {
                  data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: deserializeCredentialRequestOptions(data.webauthn.credential_options.publicKey) }) }) }),
                  error: null
                };
            }
          });
        } catch (error) {
          if (isAuthError(error)) {
            return this._returnResult({ data: null, error });
          }
          throw error;
        }
      });
    }
    /**
     * {@see GoTrueMFAApi#challengeAndVerify}
     */
    async _challengeAndVerify(params) {
      const { data: challengeData, error: challengeError } = await this._challenge({
        factorId: params.factorId
      });
      if (challengeError) {
        return this._returnResult({ data: null, error: challengeError });
      }
      return await this._verify({
        factorId: params.factorId,
        challengeId: challengeData.id,
        code: params.code
      });
    }
    /**
     * {@see GoTrueMFAApi#listFactors}
     */
    async _listFactors() {
      var _a2;
      const { data: { user }, error: userError } = await this.getUser();
      if (userError) {
        return { data: null, error: userError };
      }
      const data = {
        all: [],
        phone: [],
        totp: [],
        webauthn: []
      };
      for (const factor of (_a2 = user === null || user === void 0 ? void 0 : user.factors) !== null && _a2 !== void 0 ? _a2 : []) {
        data.all.push(factor);
        if (factor.status === "verified") {
          data[factor.factor_type].push(factor);
        }
      }
      return {
        data,
        error: null
      };
    }
    /**
     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
     */
    async _getAuthenticatorAssuranceLevel() {
      var _a2, _b;
      const { data: { session }, error: sessionError } = await this.getSession();
      if (sessionError) {
        return this._returnResult({ data: null, error: sessionError });
      }
      if (!session) {
        return {
          data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
          error: null
        };
      }
      const { payload } = decodeJWT(session.access_token);
      let currentLevel = null;
      if (payload.aal) {
        currentLevel = payload.aal;
      }
      let nextLevel = currentLevel;
      const verifiedFactors = (_b = (_a2 = session.user.factors) === null || _a2 === void 0 ? void 0 : _a2.filter((factor) => factor.status === "verified")) !== null && _b !== void 0 ? _b : [];
      if (verifiedFactors.length > 0) {
        nextLevel = "aal2";
      }
      const currentAuthenticationMethods = payload.amr || [];
      return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };
    }
    /**
     * Retrieves details about an OAuth authorization request.
     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
     *
     * Returns authorization details including client info, scopes, and user information.
     * If the API returns a redirect_uri, it means consent was already given - the caller
     * should handle the redirect manually if needed.
     */
    async _getAuthorizationDetails(authorizationId) {
      try {
        return await this._useSession(async (result2) => {
          const { data: { session }, error: sessionError } = result2;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          if (!session) {
            return this._returnResult({ data: null, error: new AuthSessionMissingError() });
          }
          return await _request(this.fetch, "GET", `${this.url}/oauth/authorizations/${authorizationId}`, {
            headers: this.headers,
            jwt: session.access_token,
            xform: (data) => ({ data, error: null })
          });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    /**
     * Approves an OAuth authorization request.
     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
     */
    async _approveAuthorization(authorizationId, options) {
      try {
        return await this._useSession(async (result2) => {
          const { data: { session }, error: sessionError } = result2;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          if (!session) {
            return this._returnResult({ data: null, error: new AuthSessionMissingError() });
          }
          const response = await _request(this.fetch, "POST", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {
            headers: this.headers,
            jwt: session.access_token,
            body: { action: "approve" },
            xform: (data) => ({ data, error: null })
          });
          if (response.data && response.data.redirect_url) {
            if (isBrowser() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {
              window.location.assign(response.data.redirect_url);
            }
          }
          return response;
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    /**
     * Denies an OAuth authorization request.
     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
     */
    async _denyAuthorization(authorizationId, options) {
      try {
        return await this._useSession(async (result2) => {
          const { data: { session }, error: sessionError } = result2;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          if (!session) {
            return this._returnResult({ data: null, error: new AuthSessionMissingError() });
          }
          const response = await _request(this.fetch, "POST", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {
            headers: this.headers,
            jwt: session.access_token,
            body: { action: "deny" },
            xform: (data) => ({ data, error: null })
          });
          if (response.data && response.data.redirect_url) {
            if (isBrowser() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {
              window.location.assign(response.data.redirect_url);
            }
          }
          return response;
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    /**
     * Lists all OAuth grants that the authenticated user has authorized.
     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
     */
    async _listOAuthGrants() {
      try {
        return await this._useSession(async (result2) => {
          const { data: { session }, error: sessionError } = result2;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          if (!session) {
            return this._returnResult({ data: null, error: new AuthSessionMissingError() });
          }
          return await _request(this.fetch, "GET", `${this.url}/user/oauth/grants`, {
            headers: this.headers,
            jwt: session.access_token,
            xform: (data) => ({ data, error: null })
          });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    /**
     * Revokes a user's OAuth grant for a specific client.
     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
     */
    async _revokeOAuthGrant(options) {
      try {
        return await this._useSession(async (result2) => {
          const { data: { session }, error: sessionError } = result2;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          if (!session) {
            return this._returnResult({ data: null, error: new AuthSessionMissingError() });
          }
          return await _request(this.fetch, "DELETE", `${this.url}/user/oauth/grants`, {
            headers: this.headers,
            jwt: session.access_token,
            query: { client_id: options.clientId },
            xform: () => ({ data: {}, error: null })
          });
        });
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async fetchJwk(kid, jwks = { keys: [] }) {
      let jwk = jwks.keys.find((key) => key.kid === kid);
      if (jwk) {
        return jwk;
      }
      const now = Date.now();
      jwk = this.jwks.keys.find((key) => key.kid === kid);
      if (jwk && this.jwks_cached_at + JWKS_TTL > now) {
        return jwk;
      }
      const { data, error } = await _request(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
        headers: this.headers
      });
      if (error) {
        throw error;
      }
      if (!data.keys || data.keys.length === 0) {
        return null;
      }
      this.jwks = data;
      this.jwks_cached_at = now;
      jwk = data.keys.find((key) => key.kid === kid);
      if (!jwk) {
        return null;
      }
      return jwk;
    }
    /**
     * Extracts the JWT claims present in the access token by first verifying the
     * JWT against the server's JSON Web Key Set endpoint
     * `/.well-known/jwks.json` which is often cached, resulting in significantly
     * faster responses. Prefer this method over {@link #getUser} which always
     * sends a request to the Auth server for each JWT.
     *
     * If the project is not using an asymmetric JWT signing key (like ECC or
     * RSA) it always sends a request to the Auth server (similar to {@link
     * #getUser}) to verify the JWT.
     *
     * @param jwt An optional specific JWT you wish to verify, not the one you
     *            can obtain from {@link #getSession}.
     * @param options Various additional options that allow you to customize the
     *                behavior of this method.
     */
    async getClaims(jwt, options = {}) {
      try {
        let token = jwt;
        if (!token) {
          const { data, error } = await this.getSession();
          if (error || !data.session) {
            return this._returnResult({ data: null, error });
          }
          token = data.session.access_token;
        }
        const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = decodeJWT(token);
        if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {
          validateExp(payload.exp);
        }
        const signingKey = !header.alg || header.alg.startsWith("HS") || !header.kid || !("crypto" in globalThis && "subtle" in globalThis.crypto) ? null : await this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? { keys: options.keys } : options === null || options === void 0 ? void 0 : options.jwks);
        if (!signingKey) {
          const { error } = await this.getUser(token);
          if (error) {
            throw error;
          }
          return {
            data: {
              claims: payload,
              header,
              signature
            },
            error: null
          };
        }
        const algorithm = getAlgorithm(header.alg);
        const publicKey = await crypto.subtle.importKey("jwk", signingKey, algorithm, true, [
          "verify"
        ]);
        const isValid2 = await crypto.subtle.verify(algorithm, publicKey, signature, stringToUint8Array(`${rawHeader}.${rawPayload}`));
        if (!isValid2) {
          throw new AuthInvalidJwtError("Invalid JWT signature");
        }
        return {
          data: {
            claims: payload,
            header,
            signature
          },
          error: null
        };
      } catch (error) {
        if (isAuthError(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
  }
  GoTrueClient.nextInstanceID = {};
  const AuthClient = GoTrueClient;
  class SupabaseAuthClient extends AuthClient {
    constructor(options) {
      super(options);
    }
  }
  class SupabaseClient {
    /**
     * Create a new client for use in the browser.
     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
     * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
     * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
     * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
     * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
     * @param options.realtime Options passed along to realtime-js constructor.
     * @param options.storage Options passed along to the storage-js constructor.
     * @param options.global.fetch A custom fetch implementation.
     * @param options.global.headers Any additional headers to send with each network request.
     * @example
     * ```ts
     * import { createClient } from '@supabase/supabase-js'
     *
     * const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')
     * const { data } = await supabase.from('profiles').select('*')
     * ```
     */
    constructor(supabaseUrl2, supabaseKey, options) {
      var _a2, _b, _c;
      this.supabaseUrl = supabaseUrl2;
      this.supabaseKey = supabaseKey;
      const baseUrl = validateSupabaseUrl(supabaseUrl2);
      if (!supabaseKey)
        throw new Error("supabaseKey is required.");
      this.realtimeUrl = new URL("realtime/v1", baseUrl);
      this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws");
      this.authUrl = new URL("auth/v1", baseUrl);
      this.storageUrl = new URL("storage/v1", baseUrl);
      this.functionsUrl = new URL("functions/v1", baseUrl);
      const defaultStorageKey = `sb-${baseUrl.hostname.split(".")[0]}-auth-token`;
      const DEFAULTS2 = {
        db: DEFAULT_DB_OPTIONS,
        realtime: DEFAULT_REALTIME_OPTIONS,
        auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),
        global: DEFAULT_GLOBAL_OPTIONS
      };
      const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS2);
      this.storageKey = (_a2 = settings.auth.storageKey) !== null && _a2 !== void 0 ? _a2 : "";
      this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};
      if (!settings.accessToken) {
        this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);
      } else {
        this.accessToken = settings.accessToken;
        this.auth = new Proxy({}, {
          get: (_, prop) => {
            throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
          }
        });
      }
      this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
      this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, settings.realtime));
      if (this.accessToken) {
        this.accessToken().then((token) => this.realtime.setAuth(token)).catch((e) => console.warn("Failed to set initial Realtime auth token:", e));
      }
      this.rest = new PostgrestClient(new URL("rest/v1", baseUrl).href, {
        headers: this.headers,
        schema: settings.db.schema,
        fetch: this.fetch
      });
      this.storage = new StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);
      if (!settings.accessToken) {
        this._listenForAuthEvents();
      }
    }
    /**
     * Supabase Functions allows you to deploy and invoke edge functions.
     */
    get functions() {
      return new FunctionsClient(this.functionsUrl.href, {
        headers: this.headers,
        customFetch: this.fetch
      });
    }
    /**
     * Perform a query on a table or a view.
     *
     * @param relation - The table or view name to query
     */
    from(relation) {
      return this.rest.from(relation);
    }
    // NOTE: signatures must be kept in sync with PostgrestClient.schema
    /**
     * Select a schema to query or perform an function (rpc) call.
     *
     * The schema needs to be on the list of exposed schemas inside Supabase.
     *
     * @param schema - The schema to query
     */
    schema(schema) {
      return this.rest.schema(schema);
    }
    // NOTE: signatures must be kept in sync with PostgrestClient.rpc
    /**
     * Perform a function call.
     *
     * @param fn - The function name to call
     * @param args - The arguments to pass to the function call
     * @param options - Named parameters
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     * @param options.get - When set to `true`, the function will be called with
     * read-only access mode.
     * @param options.count - Count algorithm to use to count rows returned by the
     * function. Only applicable for [set-returning
     * functions](https://www.postgresql.org/docs/current/functions-srf.html).
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    rpc(fn, args = {}, options = {
      head: false,
      get: false,
      count: void 0
    }) {
      return this.rest.rpc(fn, args, options);
    }
    /**
     * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
     *
     * @param {string} name - The name of the Realtime channel.
     * @param {Object} opts - The options to pass to the Realtime channel.
     *
     */
    channel(name, opts = { config: {} }) {
      return this.realtime.channel(name, opts);
    }
    /**
     * Returns all Realtime channels.
     */
    getChannels() {
      return this.realtime.getChannels();
    }
    /**
     * Unsubscribes and removes Realtime channel from Realtime client.
     *
     * @param {RealtimeChannel} channel - The name of the Realtime channel.
     *
     */
    removeChannel(channel) {
      return this.realtime.removeChannel(channel);
    }
    /**
     * Unsubscribes and removes all Realtime channels from Realtime client.
     */
    removeAllChannels() {
      return this.realtime.removeAllChannels();
    }
    async _getAccessToken() {
      var _a2, _b;
      if (this.accessToken) {
        return await this.accessToken();
      }
      const { data } = await this.auth.getSession();
      return (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;
    }
    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage: storage2, userStorage, storageKey, flowType, lock, debug: debug2, throwOnError }, headers, fetch2) {
      const authHeaders = {
        Authorization: `Bearer ${this.supabaseKey}`,
        apikey: `${this.supabaseKey}`
      };
      return new SupabaseAuthClient({
        url: this.authUrl.href,
        headers: Object.assign(Object.assign({}, authHeaders), headers),
        storageKey,
        autoRefreshToken,
        persistSession,
        detectSessionInUrl,
        storage: storage2,
        userStorage,
        flowType,
        lock,
        debug: debug2,
        throwOnError,
        fetch: fetch2,
        // auth checks if there is a custom authorizaiton header using this flag
        // so it knows whether to return an error when getUser is called with no session
        hasCustomAuthorizationHeader: Object.keys(this.headers).some((key) => key.toLowerCase() === "authorization")
      });
    }
    _initRealtimeClient(options) {
      return new RealtimeClient(this.realtimeUrl.href, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));
    }
    _listenForAuthEvents() {
      const data = this.auth.onAuthStateChange((event, session) => {
        this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
      });
      return data;
    }
    _handleTokenChanged(event, source, token) {
      if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
        this.changedAccessToken = token;
        this.realtime.setAuth(token);
      } else if (event === "SIGNED_OUT") {
        this.realtime.setAuth();
        if (source == "STORAGE")
          this.auth.signOut();
        this.changedAccessToken = void 0;
      }
    }
  }
  const createClient = (supabaseUrl2, supabaseKey, options) => {
    return new SupabaseClient(supabaseUrl2, supabaseKey, options);
  };
  function shouldShowDeprecationWarning() {
    if (typeof window !== "undefined") {
      return false;
    }
    if (typeof process === "undefined") {
      return false;
    }
    const processVersion = process["version"];
    if (processVersion === void 0 || processVersion === null) {
      return false;
    }
    const versionMatch = processVersion.match(/^v(\d+)\./);
    if (!versionMatch) {
      return false;
    }
    const majorVersion = parseInt(versionMatch[1], 10);
    return majorVersion <= 18;
  }
  if (shouldShowDeprecationWarning()) {
    console.warn(`âš ï¸  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217`);
  }
  const supabaseUrl = "https://placeholder.supabase.co";
  const supabaseAnonKey = "placeholder-key";
  const chromeStorageAdapter = {
    async getItem(key) {
      const value = await StorageManager.getSession(key);
      return value;
    },
    async setItem(key, value) {
      await StorageManager.setSession(key, value);
    },
    async removeItem(key) {
      await StorageManager.removeSession(key);
    }
  };
  const supabase = createClient(supabaseUrl, supabaseAnonKey, {
    auth: {
      storage: chromeStorageAdapter,
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: false
    }
  });
  class AuthService {
    /**
     * Sign in with email and password
     */
    static async signInWithEmail(email, password) {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password
      });
      if (error) throw error;
      return data;
    }
    /**
     * Sign up with email and password
     */
    static async signUpWithEmail(email, password) {
      const { data, error } = await supabase.auth.signUp({
        email,
        password
      });
      if (error) throw error;
      return data;
    }
    /**
     * Sign in with Google using chrome.identity
     */
    static async signInWithGoogle() {
      try {
        const redirectUrl = chrome.identity.getRedirectURL();
        const clientId = void 0;
        const scopes = ["email", "profile"];
        const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${clientId}&response_type=token&redirect_uri=${encodeURIComponent(redirectUrl)}&scope=${encodeURIComponent(scopes.join(" "))}`;
        const responseUrl = await chrome.identity.launchWebAuthFlow({
          url: authUrl,
          interactive: true
        });
        const url = new URL(responseUrl);
        const params = new URLSearchParams(url.hash.substring(1));
        const accessToken = params.get("access_token");
        if (!accessToken) {
          throw new Error("No access token received");
        }
        const { data, error } = await supabase.auth.signInWithIdToken({
          provider: "google",
          token: accessToken
        });
        if (error) throw error;
        return data;
      } catch (error) {
        console.error("Google sign-in error:", error);
        throw error;
      }
    }
    /**
     * Sign out
     */
    static async signOut() {
      const { error } = await supabase.auth.signOut();
      if (error) throw error;
      const settings = await StorageManager.getLocal("app_settings");
      if (settings && typeof settings === "object" && "privacy" in settings) {
        const appSettings = settings;
        if (appSettings.privacy?.clearDataOnLogout) {
          await StorageManager.clearLocal();
        }
      }
    }
    /**
     * Get current session
     */
    static async getSession() {
      const { data, error } = await supabase.auth.getSession();
      if (error) throw error;
      return data.session;
    }
    /**
     * Get current user
     */
    static async getUser() {
      const { data, error } = await supabase.auth.getUser();
      if (error) throw error;
      return data.user;
    }
    /**
     * Refresh session
     */
    static async refreshSession() {
      const { data, error } = await supabase.auth.refreshSession();
      if (error) throw error;
      return data.session;
    }
    /**
     * Listen to auth state changes
     */
    static onAuthStateChange(callback) {
      return supabase.auth.onAuthStateChange(callback);
    }
  }
  content;
  const useAuthStore = create((set, get2) => ({
    user: null,
    isAuthenticated: false,
    isLoading: false,
    error: null,
    checkAuth: async () => {
      set({ isLoading: true, error: null });
      try {
        const session = await AuthService.getSession();
        if (session) {
          const user = await AuthService.getUser();
          const profile = await StorageManager.getLocal("user_profile");
          set({
            user: profile || null,
            isAuthenticated: !!user,
            isLoading: false
          });
        } else {
          set({
            user: null,
            isAuthenticated: false,
            isLoading: false
          });
        }
      } catch (error) {
        console.error("Auth check error:", error);
        set({
          user: null,
          isAuthenticated: false,
          isLoading: false,
          error: error.message
        });
      }
    },
    signIn: async (email, password) => {
      set({ isLoading: true, error: null });
      try {
        const __authResult = await AuthService.signInWithEmail(email, password);
        const profile = await StorageManager.getLocal("user_profile");
        set({
          user: profile || null,
          isAuthenticated: true,
          isLoading: false
        });
      } catch (error) {
        console.error("Sign in error:", error);
        set({
          isLoading: false,
          error: error.message
        });
        throw error;
      }
    },
    signUp: async (email, password) => {
      set({ isLoading: true, error: null });
      try {
        const { user } = await AuthService.signUpWithEmail(email, password);
        const defaultProfile = {
          id: user?.id,
          email: user?.email || email,
          subscriptionTier: "free",
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        await StorageManager.setLocal("user_profile", defaultProfile);
        set({
          user: defaultProfile,
          isAuthenticated: true,
          isLoading: false
        });
      } catch (error) {
        console.error("Sign up error:", error);
        set({
          isLoading: false,
          error: error.message
        });
        throw error;
      }
    },
    signInWithGoogle: async () => {
      set({ isLoading: true, error: null });
      try {
        const { user } = await AuthService.signInWithGoogle();
        let profile = await StorageManager.getLocal("user_profile");
        if (!profile) {
          profile = {
            id: user?.id || "",
            email: user?.email || "",
            subscriptionTier: "free",
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          await StorageManager.setLocal("user_profile", profile);
        }
        set({
          user: profile,
          isAuthenticated: true,
          isLoading: false
        });
      } catch (error) {
        console.error("Google sign in error:", error);
        set({
          isLoading: false,
          error: error.message
        });
        throw error;
      }
    },
    signOut: async () => {
      set({ isLoading: true, error: null });
      try {
        await AuthService.signOut();
        set({
          user: null,
          isAuthenticated: false,
          isLoading: false
        });
      } catch (error) {
        console.error("Sign out error:", error);
        set({
          isLoading: false,
          error: error.message
        });
        throw error;
      }
    },
    updateProfile: async (updates) => {
      const currentUser = get2().user;
      if (!currentUser) return;
      const updatedUser = {
        ...currentUser,
        ...updates,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      await StorageManager.setLocal("user_profile", updatedUser);
      set({ user: updatedUser });
    }
  }));
  content;
  function useAccountSettings() {
    const theme = useSettingsStore((state) => state.theme);
    const updateTheme = useSettingsStore((state) => state.updateTheme);
    const user = useAuthStore((state) => state.user);
    const isElite = user?.subscriptionTier === "elite";
    const [localTheme, setLocalTheme] = reactExports.useState(theme);
    const [hasUnsavedChanges, setHasUnsavedChanges] = reactExports.useState(false);
    const [saveMessage, setSaveMessage] = reactExports.useState("");
    const [storageUsage, setStorageUsage] = reactExports.useState({
      used: 0,
      total: 0
    });
    const [extensionVersion, setExtensionVersion] = reactExports.useState("");
    reactExports.useEffect(() => {
      loadExtensionInfo();
      loadStorageUsage();
    }, []);
    reactExports.useEffect(() => {
      setLocalTheme(theme);
    }, [theme]);
    reactExports.useEffect(() => {
      const localThemeWithoutRealtime = {
        ...localTheme,
        blurIntensity: theme.blurIntensity,
        accentColor: theme.accentColor
      };
      const themeChanges = JSON.stringify(localThemeWithoutRealtime) !== JSON.stringify(theme);
      setHasUnsavedChanges(themeChanges);
    }, [localTheme, theme]);
    const loadExtensionInfo = () => {
      const version2 = chrome.runtime.getManifest().version;
      setExtensionVersion(version2);
    };
    const loadStorageUsage = async () => {
      try {
        const usage = await chrome.storage.local.getBytesInUse();
        const total = chrome.storage.local.QUOTA_BYTES || 5242880;
        setStorageUsage({ used: usage, total });
      } catch (error) {
        console.error("[useAccountSettings] Error loading storage usage:", error);
      }
    };
    const handleSave = reactExports.useCallback(async () => {
      try {
        await updateTheme(localTheme);
        setSaveMessage(" Settings saved successfully!");
        setHasUnsavedChanges(false);
        setTimeout(() => setSaveMessage(""), 3e3);
      } catch (error) {
        console.error("[useAccountSettings] Error saving settings:", error);
        setSaveMessage(" Failed to save settings. Please try again.");
        setTimeout(() => setSaveMessage(""), 3e3);
      }
    }, [localTheme, updateTheme]);
    const handleDiscard = reactExports.useCallback(() => {
      setLocalTheme(theme);
      setHasUnsavedChanges(false);
      setSaveMessage("");
    }, [theme]);
    const handleExportData = reactExports.useCallback(async () => {
      try {
        const allData = await chrome.storage.local.get(null);
        const dataStr = JSON.stringify(allData, null, 2);
        const dataBlob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `uproot-data-export-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        setSaveMessage(" Data exported successfully!");
        setTimeout(() => setSaveMessage(""), 3e3);
      } catch (error) {
        console.error("[useAccountSettings] Error exporting data:", error);
        setSaveMessage(" Failed to export data.");
        setTimeout(() => setSaveMessage(""), 3e3);
      }
    }, []);
    const handleClearAllData = reactExports.useCallback(async () => {
      const confirmed = window.confirm(
        'ï¿½ WARNING: This will delete ALL your data including:\n\n" Professional profile\n" Job analyses\n" Generated resumes\n" Watchlists\n" Feed items\n" Settings\n\nThis action CANNOT be undone!\n\nAre you absolutely sure you want to continue?'
      );
      if (!confirmed) return;
      const doubleConfirm = window.confirm(
        'This is your last chance!\n\nType "DELETE" in the next prompt to confirm deletion.'
      );
      if (!doubleConfirm) return;
      const userInput = window.prompt("Type DELETE to confirm:");
      if (userInput !== "DELETE") {
        alert("Deletion cancelled - input did not match.");
        return;
      }
      try {
        await chrome.storage.local.clear();
        setSaveMessage(" All data cleared successfully!");
        setTimeout(() => {
          setSaveMessage("");
          window.location.reload();
        }, 2e3);
      } catch (error) {
        console.error("[useAccountSettings] Error clearing data:", error);
        setSaveMessage(" Failed to clear data.");
        setTimeout(() => setSaveMessage(""), 3e3);
      }
    }, []);
    const handleResetTheme = reactExports.useCallback(async () => {
      const confirmed = window.confirm(
        "Reset theme to default settings?\n\nThis will revert all color and blur customizations."
      );
      if (!confirmed) return;
      try {
        const defaultTheme = {
          mode: "system",
          accentColor: "#0A66C2",
          blurIntensity: 10,
          curvePreset: "moderate"
        };
        await updateTheme(defaultTheme);
        setLocalTheme(defaultTheme);
        setSaveMessage(" Theme reset to defaults!");
        setTimeout(() => setSaveMessage(""), 3e3);
      } catch (error) {
        console.error("[useAccountSettings] Error resetting theme:", error);
        setSaveMessage(" Failed to reset theme.");
        setTimeout(() => setSaveMessage(""), 3e3);
      }
    }, [updateTheme]);
    const handleResetAllSettings = reactExports.useCallback(async () => {
      const resetSettings = useSettingsStore.getState().resetSettings;
      try {
        await resetSettings();
        setSaveMessage(" Settings reset to defaults!");
        await loadStorageUsage();
        setTimeout(() => setSaveMessage(""), 3e3);
      } catch (error) {
        console.error("[useAccountSettings] Error resetting settings:", error);
        setSaveMessage(" Failed to reset settings.");
        setTimeout(() => setSaveMessage(""), 3e3);
      }
    }, []);
    return {
      // State
      theme,
      hasUnsavedChanges,
      saveMessage,
      storageUsage,
      extensionVersion,
      isElite,
      // Save/discard handlers
      handleSave,
      handleDiscard,
      // Data handlers
      handleExportData,
      handleClearAllData,
      // Theme handlers
      handleResetTheme,
      updateTheme,
      // Reset handlers
      handleResetAllSettings
    };
  }
  content;
  function SaveBar({
    hasUnsavedChanges,
    saveMessage,
    onSave,
    onDiscard,
    accentColor,
    backgroundColor,
    textColor
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      hasUnsavedChanges && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            backgroundColor: `${backgroundColor}e6`,
            backdropFilter: "blur(10px)",
            WebkitBackdropFilter: "blur(10px)",
            border: `1px solid ${accentColor}`,
            borderRadius: "8px",
            padding: "12px 16px",
            marginBottom: "16px",
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            gap: "12px",
            transition: "all 250ms cubic-bezier(0.4, 0.0, 0.2, 1)",
            transform: "translateY(0)",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "13px", color: textColor, fontWeight: "500" }, children: "You have unsaved changes" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: onDiscard,
                  style: {
                    padding: "6px 12px",
                    backgroundColor: "transparent",
                    color: textColor,
                    opacity: 0.6,
                    border: `1px solid ${textColor}40`,
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: "pointer",
                    transition: "all 150ms"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.opacity = "1";
                    e.currentTarget.style.backgroundColor = `${textColor}10`;
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.opacity = "0.6";
                    e.currentTarget.style.backgroundColor = "transparent";
                  },
                  children: "Discard"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: onSave,
                  style: {
                    padding: "6px 12px",
                    backgroundColor: accentColor,
                    color: "#FFFFFF",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: "pointer",
                    transition: "all 150ms"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.opacity = "0.85";
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.opacity = "1";
                  },
                  children: "Save Changes"
                }
              )
            ] })
          ]
        }
      ),
      saveMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            backgroundColor: `${backgroundColor}e6`,
            backdropFilter: "blur(10px)",
            WebkitBackdropFilter: "blur(10px)",
            border: `1px solid ${saveMessage.startsWith("") ? "#4CAF50" : "#F44336"}`,
            borderRadius: "8px",
            padding: "12px 16px",
            marginBottom: "16px",
            fontSize: "13px",
            color: textColor,
            fontWeight: "500",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)"
          },
          children: saveMessage
        }
      )
    ] });
  }
  content;
  function Section({ title, icon, children, accentColor, backgroundColor, textColor }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          backgroundColor: `${backgroundColor}e6`,
          backdropFilter: "blur(10px)",
          WebkitBackdropFilter: "blur(10px)",
          borderRadius: "12px",
          padding: "16px",
          marginBottom: "16px",
          border: `1px solid ${textColor}15`,
          boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)",
          transition: "all 250ms cubic-bezier(0.4, 0.0, 0.2, 1)",
          transform: "translateY(0)"
        },
        onMouseEnter: (e) => {
          e.currentTarget.style.transform = "translateY(-2px)";
          e.currentTarget.style.boxShadow = "0 8px 16px rgba(0, 0, 0, 0.15)";
        },
        onMouseLeave: (e) => {
          e.currentTarget.style.transform = "translateY(0)";
          e.currentTarget.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.08)";
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "center",
                gap: "8px",
                marginBottom: "16px",
                paddingBottom: "12px",
                borderBottom: `1px solid ${textColor}20`
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: accentColor }, children: icon }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "h3",
                  {
                    style: {
                      fontSize: "16px",
                      fontWeight: "700",
                      margin: 0,
                      color: textColor
                    },
                    children: title
                  }
                )
              ]
            }
          ),
          children
        ]
      }
    );
  }
  content;
  content;
  function InfoRow({ label, value, textColor }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          padding: "8px 0",
          borderBottom: `1px solid ${textColor}10`
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "13px", color: `${textColor}80` }, children: label }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "13px", fontWeight: "600", color: textColor }, children: value })
        ]
      }
    );
  }
  content;
  function ActionButton({ icon, label, description, onClick, variant, accentColor, textColor: _textColor }) {
    const darkenColor = (hex, percent = 20) => {
      const num = parseInt(hex.slice(1), 16);
      const r2 = Math.max(0, (num >> 16 & 255) * (1 - percent / 100));
      const g = Math.max(0, (num >> 8 & 255) * (1 - percent / 100));
      const b = Math.max(0, (num & 255) * (1 - percent / 100));
      return `#${Math.round(r2).toString(16).padStart(2, "0")}${Math.round(g).toString(16).padStart(2, "0")}${Math.round(b).toString(16).padStart(2, "0")}`;
    };
    const colors = {
      primary: {
        bg: accentColor,
        bgHover: darkenColor(accentColor, 15),
        text: "#FFFFFF"
      },
      danger: {
        bg: "#F44336",
        bgHover: "#D32F2F",
        text: "#FFFFFF"
      }
    };
    const [isHovered, setIsHovered] = reactExports.useState(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick,
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        style: {
          display: "flex",
          alignItems: "center",
          gap: "12px",
          padding: "12px 16px",
          backgroundColor: isHovered ? colors[variant].bgHover : colors[variant].bg,
          color: colors[variant].text,
          border: "none",
          borderRadius: "8px",
          cursor: "pointer",
          transition: "background-color 150ms",
          width: "100%",
          textAlign: "left"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { flexShrink: 0 }, children: icon }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "14px", fontWeight: "600", marginBottom: "2px" }, children: label }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "12px", opacity: 0.9 }, children: description })
          ] })
        ]
      }
    );
  }
  content;
  function TextLink({ label, href, accentColor }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "a",
      {
        href,
        target: "_blank",
        rel: "noopener noreferrer",
        style: {
          fontSize: "13px",
          color: accentColor,
          textDecoration: "none",
          padding: "8px 0",
          display: "block",
          borderBottom: `1px solid ${accentColor}20`
        },
        onMouseEnter: (e) => {
          e.currentTarget.style.textDecoration = "underline";
        },
        onMouseLeave: (e) => {
          e.currentTarget.style.textDecoration = "none";
        },
        children: [
          label,
          " â†’"
        ]
      }
    );
  }
  content;
  function SliderControl({ label, description, value, min, max, onChange, accentColor }) {
    const textColor = "#1d1d1f";
    const handleMouseDown = (e) => {
      e.stopPropagation();
    };
    const handleTouchStart = (e) => {
      e.stopPropagation();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "flex-start",
            marginBottom: "12px"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    fontSize: "14px",
                    fontWeight: "600",
                    color: textColor,
                    marginBottom: "4px"
                  },
                  children: label
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    fontSize: "12px",
                    color: `${textColor}80`,
                    lineHeight: "1.4"
                  },
                  children: description
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  fontSize: "14px",
                  fontWeight: "600",
                  color: accentColor,
                  minWidth: "32px",
                  textAlign: "right"
                },
                children: value
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "range",
          min,
          max,
          value,
          onChange: (e) => onChange(Number(e.target.value)),
          onMouseDown: handleMouseDown,
          onTouchStart: handleTouchStart,
          style: {
            width: "100%",
            height: "6px",
            borderRadius: "3px",
            background: `linear-gradient(to right, ${accentColor} 0%, ${accentColor} ${(value - min) / (max - min) * 100}%, #d1d1d6 ${(value - min) / (max - min) * 100}%, #d1d1d6 100%)`,
            outline: "none",
            WebkitAppearance: "none",
            appearance: "none",
            cursor: "pointer"
          }
        }
      )
    ] });
  }
  content;
  function ColorPicker({ label, description, value, onChange }) {
    const textColor = "#1d1d1f";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "flex-start",
            marginBottom: "12px"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    fontSize: "14px",
                    fontWeight: "600",
                    color: textColor,
                    marginBottom: "4px"
                  },
                  children: label
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    fontSize: "12px",
                    color: `${textColor}80`,
                    lineHeight: "1.4"
                  },
                  children: description
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  fontSize: "12px",
                  fontWeight: "600",
                  color: textColor,
                  minWidth: "80px",
                  textAlign: "right",
                  fontFamily: "monospace"
                },
                children: value
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "color",
          value,
          onChange: (e) => onChange(e.target.value),
          style: {
            width: "100%",
            height: "40px",
            border: `1px solid ${textColor}20`,
            borderRadius: "8px",
            cursor: "pointer"
          }
        }
      )
    ] });
  }
  content;
  function ConfirmDialog({
    isOpen,
    title,
    message,
    confirmLabel = "Confirm",
    cancelLabel = "Cancel",
    onConfirm,
    onCancel,
    variant = "warning",
    accentColor,
    backgroundColor,
    textColor
  }) {
    if (!isOpen) return null;
    const colors = {
      danger: "#F44336",
      warning: "#F59E0B",
      info: accentColor
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          position: "fixed",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: "rgba(0, 0, 0, 0.5)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          zIndex: 9999
        },
        onClick: onCancel,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              backgroundColor,
              borderRadius: "12px",
              padding: "24px",
              maxWidth: "400px",
              width: "90%",
              boxShadow: "0 20px 25px -5px rgba(0, 0, 0, 0.3)",
              border: `1px solid ${textColor}15`
            },
            onClick: (e) => e.stopPropagation(),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", justifyContent: "center", marginBottom: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 48, color: colors[variant] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "h2",
                {
                  style: {
                    fontSize: "18px",
                    fontWeight: 600,
                    color: textColor,
                    marginBottom: "8px",
                    textAlign: "center"
                  },
                  children: title
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  style: {
                    fontSize: "14px",
                    color: `${textColor}cc`,
                    marginBottom: "24px",
                    textAlign: "center",
                    lineHeight: 1.5
                  },
                  children: message
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "12px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: onCancel,
                    style: {
                      flex: 1,
                      padding: "10px 16px",
                      backgroundColor: `${textColor}10`,
                      color: textColor,
                      border: `1px solid ${textColor}30`,
                      borderRadius: "6px",
                      fontSize: "14px",
                      fontWeight: 500,
                      cursor: "pointer",
                      transition: "all 150ms"
                    },
                    onMouseEnter: (e) => {
                      e.currentTarget.style.backgroundColor = `${textColor}20`;
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.backgroundColor = `${textColor}10`;
                    },
                    children: cancelLabel
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: onConfirm,
                    style: {
                      flex: 1,
                      padding: "10px 16px",
                      backgroundColor: colors[variant],
                      color: "#FFFFFF",
                      border: "none",
                      borderRadius: "6px",
                      fontSize: "14px",
                      fontWeight: 500,
                      cursor: "pointer",
                      transition: "all 150ms"
                    },
                    onMouseEnter: (e) => {
                      e.currentTarget.style.opacity = "0.9";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.opacity = "1";
                    },
                    children: confirmLabel
                  }
                )
              ] })
            ]
          }
        )
      }
    );
  }
  content;
  content;
  function ExtensionInfo({
    extensionVersion,
    storageUsage,
    accentColor,
    backgroundColor,
    textColor
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Section,
      {
        title: "Extension Info",
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Info, { size: 18 }),
        accentColor,
        backgroundColor,
        textColor,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "column",
              gap: "12px"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRow, { label: "Version", value: `v${extensionVersion}`, textColor }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                InfoRow,
                {
                  label: "Storage Used",
                  value: `${(storageUsage.used / 1024).toFixed(1)} KB / ${(storageUsage.total / 1024).toFixed(0)} KB`,
                  textColor
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                InfoRow,
                {
                  label: "Storage %",
                  value: `${(storageUsage.used / storageUsage.total * 100).toFixed(1)}%`,
                  textColor
                }
              )
            ]
          }
        )
      }
    );
  }
  content;
  function DesignCustomization({
    isElite,
    theme,
    onThemeUpdate,
    onResetTheme,
    accentColor,
    backgroundColor,
    textColor
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Section,
      {
        title: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Design Customization" }),
          isElite && /* @__PURE__ */ jsxRuntimeExports.jsx(Crown, { size: 14, style: { color: "#FFD700" }, fill: "#FFD700" })
        ] }),
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Palette, { size: 18 }),
        accentColor,
        backgroundColor,
        textColor,
        children: !isElite ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "center",
              padding: "24px",
              backgroundColor: `${accentColor}10`,
              borderRadius: "8px",
              border: `1px dashed ${accentColor}40`,
              textAlign: "center"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Lock, { size: 32, color: accentColor, style: { marginBottom: "12px" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "h4",
                {
                  style: {
                    fontSize: "15px",
                    fontWeight: "600",
                    margin: "0 0 6px 0",
                    color: textColor
                  },
                  children: "Elite Feature"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  style: {
                    fontSize: "13px",
                    color: `${textColor}80`,
                    margin: "0 0 16px 0",
                    lineHeight: "1.5"
                  },
                  children: "Customize colors and frosted glass effects with an Elite subscription"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  style: {
                    padding: "8px 16px",
                    backgroundColor: accentColor,
                    color: "#FFFFFF",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "13px",
                    fontWeight: "600",
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    gap: "6px"
                  },
                  onClick: () => alert("Upgrade to Elite coming soon!"),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Crown, { size: 14 }),
                    "Upgrade to Elite"
                  ]
                }
              )
            ]
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "20px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ColorPicker,
            {
              label: "Accent Color",
              description: "Accent color for highlights and interactive elements",
              value: theme.accentColor,
              onChange: (color) => {
                onThemeUpdate({ accentColor: color });
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderControl,
            {
              label: "Frosted Glass Intensity",
              description: "Adjust the blur and transparency effect (5-15)",
              value: theme.blurIntensity,
              min: 5,
              max: 15,
              onChange: (value) => {
                onThemeUpdate({ blurIntensity: value });
              },
              accentColor
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                marginTop: "16px",
                paddingTop: "16px",
                borderTop: `1px solid ${textColor}15`
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: onResetTheme,
                  style: {
                    width: "100%",
                    padding: "10px 16px",
                    backgroundColor: "transparent",
                    color: accentColor,
                    border: `1px solid ${accentColor}`,
                    borderRadius: "8px",
                    fontSize: "13px",
                    fontWeight: "600",
                    cursor: "pointer",
                    transition: "all 150ms",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    gap: "8px"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.backgroundColor = `${accentColor}15`;
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "transparent";
                  },
                  children: "ï¿½ Revert to Default Settings"
                }
              )
            }
          )
        ] })
      }
    );
  }
  content;
  function DataManagement({
    onExportData,
    onClearAllData,
    accentColor,
    backgroundColor,
    textColor
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Section,
      {
        title: "Data Management",
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Database, { size: 18 }),
        accentColor,
        backgroundColor,
        textColor,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ActionButton,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { size: 16 }),
              label: "Export All Data",
              description: "Download all your data as a JSON file",
              onClick: onExportData,
              variant: "primary",
              accentColor,
              textColor
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ActionButton,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 16 }),
              label: "Clear All Data",
              description: "Permanently delete all your local data",
              onClick: onClearAllData,
              variant: "danger",
              accentColor,
              textColor
            }
          )
        ] })
      }
    );
  }
  content;
  async function checkJobPreferencesSync() {
    const issues = [];
    try {
      const onboardingResult = await chrome.storage.local.get("onboarding_state");
      const onboardingPrefs = onboardingResult.onboarding_state?.preferences;
      const { feedPreferences } = useSettingsStore.getState();
      if (!onboardingPrefs) {
        issues.push("No job preferences found in onboarding state");
        return { isSynced: false, lastChecked: Date.now(), issues };
      }
      const onboardingKeywords = onboardingPrefs.jobTitles || [];
      const feedKeywords = feedPreferences.globalFilters?.keywords || [];
      if (!arraysMatch(onboardingKeywords, feedKeywords)) {
        issues.push("Job titles/keywords are out of sync");
      }
      const onboardingExp = onboardingPrefs.experienceLevel || [];
      const feedExp = feedPreferences.globalFilters?.experienceLevel || [];
      if (!arraysMatch(onboardingExp, feedExp)) {
        issues.push("Experience levels are out of sync");
      }
      const onboardingRemote = onboardingPrefs.workLocation?.includes("remote");
      const feedRemote = feedPreferences.globalFilters?.remote;
      if (onboardingRemote !== feedRemote) {
        issues.push("Remote preference is out of sync");
      }
      const onboardingLocs = onboardingPrefs.locations || [];
      const feedLocs = feedPreferences.globalFilters?.locations || [];
      if (!arraysMatch(onboardingLocs, feedLocs)) {
        issues.push("Locations are out of sync");
      }
      return {
        isSynced: issues.length === 0,
        lastChecked: Date.now(),
        issues
      };
    } catch (error) {
      console.error("[SyncChecker] Error checking job preferences sync:", error);
      return {
        isSynced: false,
        lastChecked: Date.now(),
        issues: ["Error checking sync status"]
      };
    }
  }
  async function checkWatchlistSync() {
    const issues = [];
    try {
      const watchlistCompanies = await getCompanyWatchlist();
      const enabledWatchlistIds = watchlistCompanies.filter((c) => c.jobAlertEnabled).map((c) => c.id);
      const { feedPreferences } = useSettingsStore.getState();
      const enabledCompanies = feedPreferences.enabledCompanies || [];
      if (!arraysMatch(enabledWatchlistIds, enabledCompanies)) {
        const missing = enabledWatchlistIds.filter((id) => !enabledCompanies.includes(id));
        const extra = enabledCompanies.filter((id) => !enabledWatchlistIds.includes(id));
        if (missing.length > 0) {
          issues.push(`${missing.length} watchlist companies missing from enabled companies`);
        }
        if (extra.length > 0) {
          issues.push(`${extra.length} extra companies in enabled list`);
        }
      }
      return {
        isSynced: issues.length === 0,
        lastChecked: Date.now(),
        issues
      };
    } catch (error) {
      console.error("[SyncChecker] Error checking watchlist sync:", error);
      return {
        isSynced: false,
        lastChecked: Date.now(),
        issues: ["Error checking sync status"]
      };
    }
  }
  async function checkAllSync() {
    const jobPreferences = await checkJobPreferencesSync();
    const watchlistCompanies = await checkWatchlistSync();
    const overall = jobPreferences.isSynced && watchlistCompanies.isSynced ? "synced" : "out-of-sync";
    return {
      jobPreferences,
      watchlistCompanies,
      overall
    };
  }
  async function manualSync() {
    console.log("[SyncChecker] Manual sync triggered");
    try {
      const onboardingResult = await chrome.storage.local.get("onboarding_state");
      const preferences = onboardingResult.onboarding_state?.preferences;
      if (preferences) {
        const { updateFeedPreferences: updateFeedPreferences2 } = useSettingsStore.getState();
        await updateFeedPreferences2({
          globalFilters: {
            keywords: preferences.jobTitles || [],
            experienceLevel: preferences.experienceLevel || [],
            remote: preferences.workLocation?.includes("remote"),
            locations: preferences.locations || []
          }
        });
        console.log("[SyncChecker] Job preferences synced");
      }
      const watchlistCompanies = await getCompanyWatchlist();
      const enabledCompanyIds = watchlistCompanies.filter((c) => c.jobAlertEnabled).map((c) => c.id);
      const { updateFeedPreferences } = useSettingsStore.getState();
      await updateFeedPreferences({
        enabledCompanies: enabledCompanyIds
      });
      console.log("[SyncChecker] Watchlist companies synced");
      console.log("[SyncChecker] Manual sync complete");
    } catch (error) {
      console.error("[SyncChecker] Error during manual sync:", error);
      throw error;
    }
  }
  function arraysMatch(arr1, arr2) {
    if (arr1.length !== arr2.length) return false;
    const sorted1 = [...arr1].sort();
    const sorted2 = [...arr2].sort();
    return sorted1.every((val, idx) => val === sorted2[idx]);
  }
  content;
  function StorageSyncStatus() {
    const [syncStatus, setSyncStatus] = reactExports.useState(null);
    const [isChecking, setIsChecking] = reactExports.useState(false);
    const [isSyncing, setIsSyncing] = reactExports.useState(false);
    const [lastSyncTime, setLastSyncTime] = reactExports.useState(null);
    reactExports.useEffect(() => {
      checkStatus();
    }, []);
    const checkStatus = async () => {
      setIsChecking(true);
      try {
        const status = await checkAllSync();
        setSyncStatus(status);
      } catch (error) {
        console.error("[StorageSyncStatus] Error checking sync:", error);
      } finally {
        setIsChecking(false);
      }
    };
    const handleManualSync = async () => {
      setIsSyncing(true);
      try {
        await manualSync();
        setLastSyncTime(Date.now());
        setTimeout(checkStatus, 500);
      } catch (error) {
        console.error("[StorageSyncStatus] Error syncing:", error);
      } finally {
        setIsSyncing(false);
      }
    };
    const getStatusColor = () => {
      if (!syncStatus) return COLORS.text.secondary;
      return syncStatus.overall === "synced" ? "#10B981" : "#F59E0B";
    };
    const getStatusIcon = () => {
      if (!syncStatus) return /* @__PURE__ */ jsxRuntimeExports.jsx(Database, { size: 20, color: COLORS.text.secondary });
      return syncStatus.overall === "synced" ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 20, color: "#10B981" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 20, color: "#F59E0B" });
    };
    const formatTime = (timestamp) => {
      const date = new Date(timestamp);
      return date.toLocaleTimeString();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
      padding: "24px",
      borderTop: `1px solid ${COLORS.border.default}`
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        marginBottom: "16px"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: {
            fontSize: "14px",
            fontWeight: 600,
            color: COLORS.text.primary,
            marginBottom: "4px"
          }, children: "Storage Sync Status" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: {
            fontSize: "12px",
            color: COLORS.text.secondary
          }, children: "Synchronization between job preferences, watchlist, and feed settings" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: handleManualSync,
            disabled: isSyncing,
            style: {
              display: "flex",
              alignItems: "center",
              gap: "6px",
              padding: "8px 12px",
              backgroundColor: COLORS.accent.default,
              color: "white",
              border: "none",
              borderRadius: "6px",
              fontSize: "13px",
              fontWeight: 500,
              cursor: isSyncing ? "not-allowed" : "pointer",
              opacity: isSyncing ? 0.6 : 1
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 14, style: { animation: isSyncing ? "spin 1s linear infinite" : "none" } }),
              isSyncing ? "Syncing..." : "Sync Now"
            ]
          }
        )
      ] }),
      syncStatus && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        display: "flex",
        alignItems: "center",
        gap: "12px",
        padding: "16px",
        backgroundColor: COLORS.background.secondary,
        borderRadius: "8px",
        marginBottom: "16px"
      }, children: [
        getStatusIcon(),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            fontSize: "14px",
            fontWeight: 500,
            color: getStatusColor(),
            marginBottom: "4px"
          }, children: syncStatus.overall === "synced" ? "All Systems Synced" : "Out of Sync" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            fontSize: "12px",
            color: COLORS.text.secondary
          }, children: lastSyncTime ? `Last synced at ${formatTime(lastSyncTime)}` : `Last checked at ${formatTime(syncStatus.jobPreferences.lastChecked)}` })
        ] })
      ] }),
      syncStatus && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          padding: "12px",
          backgroundColor: COLORS.background.primary,
          border: `1px solid ${COLORS.border.default}`,
          borderRadius: "6px"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
            display: "flex",
            alignItems: "center",
            gap: "8px",
            marginBottom: "8px"
          }, children: [
            syncStatus.jobPreferences.isSynced ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 16, color: "#10B981" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 16, color: "#F59E0B" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
              fontSize: "13px",
              fontWeight: 500,
              color: COLORS.text.primary
            }, children: "Job Preferences" })
          ] }),
          syncStatus.jobPreferences.issues.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { style: {
            margin: 0,
            paddingLeft: "24px",
            fontSize: "12px",
            color: COLORS.text.secondary
          }, children: syncStatus.jobPreferences.issues.map((issue, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: issue }, idx)) }),
          syncStatus.jobPreferences.isSynced && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            fontSize: "12px",
            color: COLORS.text.secondary,
            paddingLeft: "24px"
          }, children: "âœ“ Synced with feed preferences" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          padding: "12px",
          backgroundColor: COLORS.background.primary,
          border: `1px solid ${COLORS.border.default}`,
          borderRadius: "6px"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
            display: "flex",
            alignItems: "center",
            gap: "8px",
            marginBottom: "8px"
          }, children: [
            syncStatus.watchlistCompanies.isSynced ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 16, color: "#10B981" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 16, color: "#F59E0B" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
              fontSize: "13px",
              fontWeight: 500,
              color: COLORS.text.primary
            }, children: "Watchlist Companies" })
          ] }),
          syncStatus.watchlistCompanies.issues.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { style: {
            margin: 0,
            paddingLeft: "24px",
            fontSize: "12px",
            color: COLORS.text.secondary
          }, children: syncStatus.watchlistCompanies.issues.map((issue, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: issue }, idx)) }),
          syncStatus.watchlistCompanies.isSynced && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            fontSize: "12px",
            color: COLORS.text.secondary,
            paddingLeft: "24px"
          }, children: "âœ“ Synced with enabled companies" })
        ] })
      ] }),
      isChecking && !syncStatus && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        padding: "32px",
        textAlign: "center",
        color: COLORS.text.secondary
      }, children: "Checking sync status..." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
      ` })
    ] });
  }
  content;
  function ResetSettings({
    onResetSettings,
    accentColor,
    backgroundColor,
    textColor
  }) {
    const [showResetConfirm, setShowResetConfirm] = reactExports.useState(false);
    const [showResetSuccess, setShowResetSuccess] = reactExports.useState(false);
    const handleResetToDefaults = async () => {
      await onResetSettings();
      setShowResetConfirm(false);
      setShowResetSuccess(true);
      setTimeout(() => setShowResetSuccess(false), 3e3);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Section,
        {
          title: "Reset Settings",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCcw, { size: 18 }),
          accentColor,
          backgroundColor,
          textColor,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: "12px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "p",
              {
                style: {
                  fontSize: "13px",
                  color: `${textColor}cc`,
                  lineHeight: 1.5,
                  margin: 0
                },
                children: "Return all settings to their default values. This will reset theme preferences, notifications, privacy settings, and feed preferences."
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ActionButton,
              {
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCcw, { size: 16 }),
                label: "Return to Default Settings",
                description: "Reset all settings to factory defaults",
                onClick: () => setShowResetConfirm(true),
                variant: "danger",
                accentColor,
                textColor
              }
            ),
            showResetSuccess && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "8px",
                  marginTop: "12px",
                  padding: "12px",
                  backgroundColor: "#10B981",
                  color: "white",
                  borderRadius: "6px",
                  fontSize: "14px",
                  fontWeight: 500
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 16 }),
                  "Settings reset to defaults successfully!"
                ]
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ConfirmDialog,
        {
          isOpen: showResetConfirm,
          title: "Reset All Settings?",
          message: "Are you sure you want to reset all settings to their default values? This will reset theme, notifications, privacy, and feed preferences. This action cannot be undone.",
          confirmLabel: "Reset to Defaults",
          cancelLabel: "Cancel",
          variant: "danger",
          onConfirm: handleResetToDefaults,
          onCancel: () => setShowResetConfirm(false),
          accentColor,
          backgroundColor,
          textColor
        }
      )
    ] });
  }
  content;
  function LegalSupport({
    accentColor,
    backgroundColor,
    textColor
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Section,
      {
        title: "Legal & Support",
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Info, { size: 18 }),
        accentColor,
        backgroundColor,
        textColor,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TextLink, { label: "Privacy Policy", href: "https://uproot.app/privacy", accentColor }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TextLink, { label: "Terms of Service", href: "https://uproot.app/terms", accentColor }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TextLink, { label: "Help & Support", href: "https://uproot.app/support", accentColor }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextLink,
            {
              label: "Report a Bug",
              href: "https://github.com/your-repo/issues/new",
              accentColor
            }
          )
        ] })
      }
    );
  }
  content;
  function AccountSettings({ panelWidth = 400 }) {
    const {
      theme,
      hasUnsavedChanges,
      saveMessage,
      storageUsage,
      extensionVersion,
      isElite,
      handleSave,
      handleDiscard,
      handleExportData,
      handleClearAllData,
      handleResetTheme,
      handleResetAllSettings,
      updateTheme
    } = useAccountSettings();
    const backgroundColor = "#FFFFFF";
    const textColor = "#1d1d1f";
    const accentColor = "#0077B5";
    const isCompact = panelWidth < 360;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "settings-scrollable-container",
        style: {
          height: "100%",
          overflow: "auto",
          padding: isCompact ? "12px" : "16px"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
        .settings-scrollable-container::-webkit-scrollbar {
          width: 8px;
        }
        .settings-scrollable-container::-webkit-scrollbar-track {
          background: ${backgroundColor}40;
          border-radius: 4px;
        }
        .settings-scrollable-container::-webkit-scrollbar-thumb {
          background: ${accentColor};
          border-radius: 4px;
          transition: background 200ms;
        }
        .settings-scrollable-container::-webkit-scrollbar-thumb:hover {
          background: ${accentColor}cc;
        }
        /* Firefox scrollbar styling */
        .settings-scrollable-container {
          scrollbar-width: thin;
          scrollbar-color: ${accentColor} ${backgroundColor}40;
        }
      ` }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SaveBar,
            {
              hasUnsavedChanges,
              saveMessage,
              onSave: handleSave,
              onDiscard: handleDiscard,
              accentColor,
              backgroundColor,
              textColor
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ExtensionInfo,
            {
              extensionVersion,
              storageUsage,
              accentColor,
              backgroundColor,
              textColor
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DesignCustomization,
            {
              isElite,
              theme,
              onThemeUpdate: updateTheme,
              onResetTheme: handleResetTheme,
              accentColor,
              backgroundColor,
              textColor
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DataManagement,
            {
              onExportData: handleExportData,
              onClearAllData: handleClearAllData,
              accentColor,
              backgroundColor,
              textColor
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(StorageSyncStatus, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ResetSettings,
            {
              onResetSettings: handleResetAllSettings,
              accentColor,
              backgroundColor,
              textColor
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            LegalSupport,
            {
              accentColor,
              backgroundColor,
              textColor
            }
          )
        ]
      }
    );
  }
  content;
  content;
  function SettingsTab({ panelWidth = 400 }) {
    const [activeView, setActiveView] = reactExports.useState("preferences");
    const accentColor = "#0077B5";
    const textColor = "#1d1d1f";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "hidden"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: "20px 20px 16px 20px",
                borderBottom: "1px solid rgba(0, 0, 0, 0.08)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "h2",
                  {
                    style: {
                      fontSize: "20px",
                      fontWeight: "700",
                      margin: "0 0 4px 0",
                      color: textColor
                    },
                    children: "Settings"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "p",
                  {
                    style: {
                      fontSize: "13px",
                      color: textColor,
                      opacity: 0.7,
                      margin: 0
                    },
                    children: "Manage your preferences and account"
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SettingsNavigation,
            {
              activeView,
              onViewChange: setActiveView,
              panelWidth,
              accentColor
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                flex: 1,
                overflow: "hidden"
              },
              children: [
                activeView === "preferences" && /* @__PURE__ */ jsxRuntimeExports.jsx(JobPreferencesSettings, { panelWidth }),
                activeView === "notifications" && /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationSettings, { panelWidth }),
                activeView === "account" && /* @__PURE__ */ jsxRuntimeExports.jsx(AccountSettings, { panelWidth }),
                activeView === "subscription" && /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionSettings, {})
              ]
            }
          )
        ]
      }
    );
  }
  function SettingsNavigation({ activeView, onViewChange, panelWidth = 400, accentColor }) {
    const textColor = "#1d1d1f";
    const backgroundColor = "#FFFFFF";
    const getHoverColor = (_bg) => "rgba(0, 0, 0, 0.04)";
    const isNarrow = panelWidth < 360;
    const isCompact = panelWidth < 400;
    const showIcons = true;
    const fontSize = isNarrow ? "11px" : isCompact ? "13px" : "14px";
    const padding = isNarrow ? "8px 6px" : isCompact ? "9px 12px" : "10px 14px";
    const gap = isNarrow ? "4px" : "8px";
    const iconSize = isNarrow ? 14 : 16;
    const showLabels = panelWidth >= 360;
    const hexToRgba = (hex, alpha) => {
      const r2 = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r2}, ${g}, ${b}, ${alpha})`;
    };
    const accentColorBg = hexToRgba(accentColor, 0.03);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          padding: "16px",
          borderBottom: "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: accentColorBg
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SettingsNavButton,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: iconSize, strokeWidth: 2 }),
              label: "Job Preferences",
              shortLabel: "Jobs",
              isActive: activeView === "preferences",
              onClick: () => onViewChange("preferences"),
              showIcon: showIcons,
              showLabel: showLabels,
              fontSize,
              padding,
              primaryColor: accentColor,
              textColor,
              backgroundColor,
              getHoverColor
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SettingsNavButton,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Bell, { size: iconSize, strokeWidth: 2 }),
              label: "Notifications",
              shortLabel: "Alerts",
              isActive: activeView === "notifications",
              onClick: () => onViewChange("notifications"),
              showIcon: showIcons,
              showLabel: showLabels,
              fontSize,
              padding,
              primaryColor: accentColor,
              textColor,
              backgroundColor,
              getHoverColor
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SettingsNavButton,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: iconSize, strokeWidth: 2 }),
              label: "Account",
              shortLabel: "Account",
              isActive: activeView === "account",
              onClick: () => onViewChange("account"),
              showIcon: showIcons,
              showLabel: showLabels,
              fontSize,
              padding,
              primaryColor: accentColor,
              textColor,
              backgroundColor,
              getHoverColor
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SettingsNavButton,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCard, { size: iconSize, strokeWidth: 2 }),
              label: "Subscription",
              shortLabel: "Plan",
              isActive: activeView === "subscription",
              onClick: () => onViewChange("subscription"),
              showIcon: showIcons,
              showLabel: showLabels,
              fontSize,
              padding,
              primaryColor: accentColor,
              textColor,
              backgroundColor,
              getHoverColor
            }
          )
        ] })
      }
    );
  }
  function SettingsNavButton({
    icon,
    label,
    shortLabel,
    isActive,
    onClick,
    showIcon,
    showLabel,
    fontSize,
    padding,
    primaryColor,
    textColor,
    backgroundColor,
    getHoverColor
  }) {
    const displayLabel = shortLabel || label;
    const hoverColor = getHoverColor(backgroundColor);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick,
        style: {
          flex: 1,
          padding,
          backgroundColor: isActive ? primaryColor : "transparent",
          color: isActive ? "#FFFFFF" : textColor,
          opacity: isActive ? 1 : 0.6,
          border: isActive ? "none" : "1px solid rgba(0, 0, 0, 0.12)",
          borderRadius: "8px",
          fontSize,
          fontWeight: "600",
          cursor: "pointer",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          gap: "6px",
          transition: "all 150ms",
          minWidth: 0
          // Allow flex shrinking
        },
        onMouseEnter: (e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = hoverColor;
            e.currentTarget.style.opacity = "0.8";
          }
        },
        onMouseLeave: (e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = "transparent";
            e.currentTarget.style.opacity = "0.6";
          }
        },
        children: [
          showIcon && icon,
          showLabel && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }, children: displayLabel })
        ]
      }
    );
  }
  function SubscriptionSettings() {
    const textColor = "#1d1d1f";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "40px 24px",
          textAlign: "center",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          height: "100%"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCard, { size: 48, color: textColor, strokeWidth: 1.5, style: { opacity: 0.5 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "h3",
            {
              style: {
                fontSize: "18px",
                fontWeight: "600",
                margin: "16px 0 8px 0",
                color: textColor
              },
              children: "Subscription"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                fontSize: "14px",
                color: textColor,
                opacity: 0.6,
                margin: 0
              },
              children: "Coming soon..."
            }
          )
        ]
      }
    );
  }
  content;
  const initialStats = {
    totalItems: 0,
    unreadCount: 0,
    jobAlerts: 0,
    companyUpdates: 0,
    connectionUpdates: 0,
    warmPaths: 0
  };
  function useFeed() {
    const [feedItems, setFeedItems] = reactExports.useState([]);
    const [stats, setStats] = reactExports.useState(initialStats);
    const [isLoading, setIsLoading] = reactExports.useState(true);
    const [error, setError] = reactExports.useState(null);
    const loadFeed = reactExports.useCallback(async () => {
      try {
        setIsLoading(true);
        setError(null);
        const items = await getFeedItems();
        const feedStats = await getFeedStats();
        setFeedItems(items);
        setStats(feedStats);
      } catch (err) {
        console.error("[Uproot] Error loading feed:", err);
        setError("Failed to load feed");
      } finally {
        setIsLoading(false);
      }
    }, []);
    reactExports.useEffect(() => {
      loadFeed();
    }, [loadFeed]);
    reactExports.useEffect(() => {
      const handleStorageChange = (changes, areaName) => {
        if (areaName === "local" && changes[FEED_STORAGE_KEY]) {
          loadFeed();
        }
      };
      chrome.storage.onChanged.addListener(handleStorageChange);
      return () => {
        chrome.storage.onChanged.removeListener(handleStorageChange);
      };
    }, [loadFeed]);
    const addFeedItem$1 = reactExports.useCallback(async (item) => {
      try {
        const newItem = await addFeedItem(item);
        await loadFeed();
        return newItem;
      } catch (err) {
        console.error("[Uproot] Error adding feed item:", err);
        setError("Failed to add feed item");
        throw err;
      }
    }, [loadFeed]);
    const toggleRead = reactExports.useCallback(async (itemId) => {
      try {
        await toggleFeedItemRead(itemId);
        setFeedItems(
          (prevItems) => prevItems.map(
            (item) => item.id === itemId ? { ...item, read: !item.read } : item
          )
        );
        const feedStats = await getFeedStats();
        setStats(feedStats);
      } catch (err) {
        console.error("[Uproot] Error toggling read status:", err);
        setError("Failed to update read status");
        await loadFeed();
      }
    }, [loadFeed]);
    const markAllAsRead = reactExports.useCallback(async () => {
      try {
        await markAllFeedItemsAsRead();
        setFeedItems(
          (prevItems) => prevItems.map((item) => ({ ...item, read: true }))
        );
        setStats((prevStats) => ({ ...prevStats, unreadCount: 0 }));
      } catch (err) {
        console.error("[Uproot] Error marking all as read:", err);
        setError("Failed to mark all as read");
        await loadFeed();
      }
    }, [loadFeed]);
    const deleteFeedItem$1 = reactExports.useCallback(async (itemId) => {
      try {
        await deleteFeedItem(itemId);
        await loadFeed();
      } catch (err) {
        console.error("[Uproot] Error deleting feed item:", err);
        setError("Failed to delete feed item");
        throw err;
      }
    }, [loadFeed]);
    return {
      feedItems,
      stats,
      isLoading,
      error,
      addFeedItem: addFeedItem$1,
      toggleRead,
      markAllAsRead,
      deleteFeedItem: deleteFeedItem$1,
      reload: loadFeed
    };
  }
  content;
  function FeedTab({ panelWidth = 400 }) {
    const [activeFilter, setActiveFilter] = reactExports.useState("all");
    const [currentPage, setCurrentPage] = reactExports.useState(1);
    const { feedItems, stats, isLoading, error, toggleRead, markAllAsRead, reload } = useFeed();
    const hasItems = feedItems.length > 0;
    const filteredItems = reactExports.useMemo(() => {
      console.log("[FeedTab] Filtering items...", { feedItemsCount: feedItems.length, activeFilter });
      return feedItems.filter((item) => {
        if (activeFilter === "all") return true;
        if (activeFilter === "unread") return !item.read;
        if (activeFilter === "jobs") return item.type === "job_alert";
        if (activeFilter === "companies") return item.type === "company_update";
        if (activeFilter === "people")
          return item.type === "person_update" || item.type === "connection_update";
        return true;
      });
    }, [feedItems, activeFilter]);
    const ITEMS_PER_PAGE = 20;
    const totalPages = Math.ceil(filteredItems.length / ITEMS_PER_PAGE);
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    const paginatedItems = filteredItems.slice(startIndex, endIndex);
    const unreadCount = stats.unreadCount;
    React.useEffect(() => {
      setCurrentPage(1);
    }, [activeFilter]);
    if (error) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            flexDirection: "column",
            gap: "16px",
            padding: "40px 20px",
            textAlign: "center"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TriangleAlert,
              {
                size: 48,
                color: "#FF3B30",
                strokeWidth: 2
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "h3",
                {
                  style: {
                    fontSize: "16px",
                    fontWeight: "600",
                    color: "#1d1d1f",
                    marginBottom: "8px"
                  },
                  children: "Failed to load feed"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  style: {
                    fontSize: "14px",
                    color: "#6e6e73",
                    marginBottom: "0"
                  },
                  children: error
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: reload,
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "8px",
                  padding: "10px 20px",
                  backgroundColor: "#0077B5",
                  color: "#FFFFFF",
                  border: "none",
                  borderRadius: "8px",
                  fontSize: "14px",
                  fontWeight: "600",
                  cursor: "pointer",
                  transition: "background-color 150ms"
                },
                onMouseEnter: (e) => {
                  e.currentTarget.style.backgroundColor = "#005885";
                },
                onMouseLeave: (e) => {
                  e.currentTarget.style.backgroundColor = "#0077B5";
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 16 }),
                  "Try Again"
                ]
              }
            )
          ]
        }
      );
    }
    if (isLoading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            color: "#6e6e73",
            flexDirection: "column",
            gap: "12px"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 32, className: "animate-spin", strokeWidth: 2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "14px", fontWeight: "500" }, children: "Loading feed..." })
          ]
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "hidden",
          backgroundColor: "#FFFFFF"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: panelWidth < 360 ? "16px 16px 12px 16px" : "20px 20px 16px 20px",
                borderBottom: "1px solid rgba(0, 0, 0, 0.08)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "4px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h2",
                    {
                      style: {
                        fontSize: panelWidth < 360 ? "18px" : "20px",
                        fontWeight: "700",
                        margin: 0,
                        color: "#1d1d1f"
                      },
                      children: panelWidth < 360 ? "Feed" : "Activity Feed"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: unreadCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "div",
                      {
                        style: {
                          padding: "4px 10px",
                          backgroundColor: "rgba(255, 149, 0, 0.1)",
                          borderRadius: "12px",
                          fontSize: panelWidth < 360 ? "11px" : "12px",
                          fontWeight: "600",
                          color: "#FF9500",
                          whiteSpace: "nowrap"
                        },
                        children: [
                          unreadCount,
                          " new"
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "button",
                      {
                        onClick: markAllAsRead,
                        style: {
                          padding: panelWidth < 360 ? "4px 8px" : "6px 10px",
                          backgroundColor: "#0077B5",
                          color: "#FFFFFF",
                          border: "none",
                          borderRadius: "8px",
                          fontSize: panelWidth < 360 ? "10px" : "11px",
                          fontWeight: "600",
                          cursor: "pointer",
                          display: "flex",
                          alignItems: "center",
                          gap: "4px",
                          transition: "all 150ms",
                          whiteSpace: "nowrap"
                        },
                        onMouseEnter: (e) => {
                          e.currentTarget.style.backgroundColor = "#005885";
                        },
                        onMouseLeave: (e) => {
                          e.currentTarget.style.backgroundColor = "#0077B5";
                        },
                        title: "Mark all as read",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: panelWidth < 360 ? 10 : 12 }),
                          panelWidth >= 360 && "Mark all read"
                        ]
                      }
                    )
                  ] }) })
                ] }),
                panelWidth >= 360 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "p",
                  {
                    style: {
                      fontSize: "13px",
                      color: "#6e6e73",
                      margin: 0
                    },
                    children: "All notifications, job alerts, and updates in one place"
                  }
                )
              ]
            }
          ),
          hasItems && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FeedFilters,
            {
              activeFilter,
              onFilterChange: setActiveFilter,
              unreadCount,
              panelWidth
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                flex: 1,
                overflowY: "auto",
                backgroundColor: "#FAFAFA"
              },
              children: !hasItems ? /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState$1, {}) : filteredItems.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyFilterState, { filter: activeFilter }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: panelWidth < 360 ? "12px" : "16px", display: "flex", flexDirection: "column", gap: panelWidth < 360 ? "10px" : "12px" }, children: paginatedItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(FeedCard, { item, panelWidth, onToggleRead: toggleRead }, item.id)) }),
                totalPages > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  PaginationControls,
                  {
                    currentPage,
                    totalPages,
                    onPageChange: setCurrentPage,
                    panelWidth
                  }
                )
              ] })
            }
          )
        ]
      }
    );
  }
  function FeedFilters({ activeFilter, onFilterChange, unreadCount, panelWidth = 400 }) {
    const isVeryNarrow = panelWidth < 360;
    const isNarrow = panelWidth < 400;
    const fontSize = isVeryNarrow ? "10px" : isNarrow ? "11px" : "12px";
    const padding = isVeryNarrow ? "6px 8px" : isNarrow ? "6px 10px" : "8px 12px";
    const gap = isVeryNarrow ? "4px" : "6px";
    const iconSize = isVeryNarrow ? 10 : 12;
    const showLabels = panelWidth >= 360;
    const filters = [
      { value: "all", label: "All", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Filter, { size: iconSize }) },
      { value: "unread", label: `Unread${unreadCount > 0 ? ` (${unreadCount})` : ""}`, shortLabel: "New", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Circle, { size: iconSize }) },
      { value: "jobs", label: "Jobs", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: iconSize }) },
      { value: "companies", label: "Companies", shortLabel: "Co.", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { size: iconSize }) },
      { value: "people", label: "People", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: iconSize }) }
    ];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          padding: isVeryNarrow ? "8px 12px" : "12px 16px",
          borderBottom: "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: "#FFFFFF"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap, flexWrap: "wrap", justifyContent: "flex-start" }, children: filters.map(({ value, label, shortLabel, icon }) => {
          const displayLabel = showLabels ? label : shortLabel || "";
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => onFilterChange(value),
              style: {
                padding,
                backgroundColor: activeFilter === value ? "#0077B5" : "rgba(0, 0, 0, 0.05)",
                color: activeFilter === value ? "#FFFFFF" : "#1d1d1f",
                border: "none",
                borderRadius: "16px",
                fontSize,
                fontWeight: "500",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: showLabels ? "4px" : "0",
                transition: "all 150ms",
                whiteSpace: "nowrap",
                minWidth: showLabels ? "auto" : "32px",
                flexShrink: 0
              },
              onMouseEnter: (e) => {
                if (activeFilter !== value) {
                  e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.08)";
                }
              },
              onMouseLeave: (e) => {
                if (activeFilter !== value) {
                  e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.05)";
                }
              },
              title: !showLabels ? label : void 0,
              children: [
                icon,
                showLabels && displayLabel
              ]
            },
            value
          );
        }) })
      }
    );
  }
  function PaginationControls({
    currentPage,
    totalPages,
    onPageChange,
    panelWidth = 400
  }) {
    const isVeryNarrow = panelWidth < 360;
    const isNarrow = panelWidth < 400;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          gap: isVeryNarrow ? "6px" : "12px",
          padding: isVeryNarrow ? "12px" : "16px",
          borderTop: "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: "#FFFFFF"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => onPageChange(Math.max(1, currentPage - 1)),
              disabled: currentPage === 1,
              style: {
                padding: isVeryNarrow ? "6px" : "8px 12px",
                backgroundColor: currentPage === 1 ? "rgba(0, 0, 0, 0.05)" : "#0077B5",
                color: currentPage === 1 ? "#86868b" : "#FFFFFF",
                border: "none",
                borderRadius: "8px",
                cursor: currentPage === 1 ? "not-allowed" : "pointer",
                fontSize: isVeryNarrow ? "11px" : "13px",
                fontWeight: "600",
                display: "flex",
                alignItems: "center",
                gap: "4px",
                transition: "all 150ms",
                opacity: currentPage === 1 ? 0.5 : 1
              },
              onMouseEnter: (e) => {
                if (currentPage !== 1) {
                  e.currentTarget.style.backgroundColor = "#005885";
                }
              },
              onMouseLeave: (e) => {
                if (currentPage !== 1) {
                  e.currentTarget.style.backgroundColor = "#0077B5";
                }
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeft, { size: isVeryNarrow ? 14 : 16 }),
                !isVeryNarrow && "Previous"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                color: "#1d1d1f",
                fontSize: isVeryNarrow ? "11px" : "13px",
                fontWeight: "500",
                minWidth: isVeryNarrow ? "60px" : "80px",
                textAlign: "center"
              },
              children: isVeryNarrow ? `${currentPage}/${totalPages}` : `Page ${currentPage} of ${totalPages}`
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => onPageChange(Math.min(totalPages, currentPage + 1)),
              disabled: currentPage === totalPages,
              style: {
                padding: isVeryNarrow ? "6px" : "8px 12px",
                backgroundColor: currentPage === totalPages ? "rgba(0, 0, 0, 0.05)" : "#0077B5",
                color: currentPage === totalPages ? "#86868b" : "#FFFFFF",
                border: "none",
                borderRadius: "8px",
                cursor: currentPage === totalPages ? "not-allowed" : "pointer",
                fontSize: isVeryNarrow ? "11px" : "13px",
                fontWeight: "600",
                display: "flex",
                alignItems: "center",
                gap: "4px",
                transition: "all 150ms",
                opacity: currentPage === totalPages ? 0.5 : 1
              },
              onMouseEnter: (e) => {
                if (currentPage !== totalPages) {
                  e.currentTarget.style.backgroundColor = "#005885";
                }
              },
              onMouseLeave: (e) => {
                if (currentPage !== totalPages) {
                  e.currentTarget.style.backgroundColor = "#0077B5";
                }
              },
              children: [
                !isVeryNarrow && "Next",
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { size: isVeryNarrow ? 14 : 16 })
              ]
            }
          ),
          !isNarrow && totalPages <= 10 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "select",
            {
              value: currentPage,
              onChange: (e) => onPageChange(Number(e.target.value)),
              style: {
                padding: "8px",
                borderRadius: "6px",
                border: "1px solid rgba(0, 0, 0, 0.1)",
                backgroundColor: "#FFFFFF",
                color: "#1d1d1f",
                fontSize: "13px",
                fontWeight: "500",
                cursor: "pointer"
              },
              children: Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => /* @__PURE__ */ jsxRuntimeExports.jsxs("option", { value: page, children: [
                "Page ",
                page
              ] }, page))
            }
          )
        ]
      }
    );
  }
  function FeedCard({ item, panelWidth = 400, onToggleRead }) {
    const isNarrow = panelWidth < 360;
    const getResponsiveSize = () => {
      if (panelWidth < 320) {
        return { iconBox: 28, borderRadius: "6px", padding: "10px", gap: "8px", marginBottom: "8px" };
      } else if (panelWidth < 360) {
        return { iconBox: 32, borderRadius: "8px", padding: "12px", gap: "10px", marginBottom: "10px" };
      } else if (panelWidth < 400) {
        return { iconBox: 36, borderRadius: "10px", padding: "14px", gap: "12px", marginBottom: "12px" };
      } else {
        return { iconBox: 40, borderRadius: "12px", padding: "16px", gap: "12px", marginBottom: "12px" };
      }
    };
    const sizes = getResponsiveSize();
    const handleToggleRead = () => {
      onToggleRead(item.id);
    };
    const getTypeIcon = () => {
      let iconSize = 16;
      if (panelWidth < 320) {
        iconSize = 12;
      } else if (panelWidth < 360) {
        iconSize = 14;
      } else if (panelWidth < 400) {
        iconSize = 16;
      } else {
        iconSize = 18;
      }
      switch (item.type) {
        case "job_alert":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: iconSize, color: "#0077B5" });
        case "application_status":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: iconSize, color: "#FF3B30" });
        case "company_update":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { size: iconSize, color: "#FF9500" });
        case "connection_update":
        case "person_update":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: iconSize, color: "#34C759" });
        case "recommendation":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: iconSize, color: "#AF52DE" });
        case "hiring_heat":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Flame, { size: iconSize, color: "#FF3B30" });
        case "deadline_alert":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: iconSize, color: "#FF9500" });
        default:
          return /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: iconSize, color: "#6e6e73" });
      }
    };
    const getTypeColor = () => {
      switch (item.type) {
        case "job_alert":
          return "rgba(0, 119, 181, 0.1)";
        case "application_status":
          return "rgba(255, 59, 48, 0.1)";
        case "company_update":
          return "rgba(255, 149, 0, 0.1)";
        case "connection_update":
        case "person_update":
          return "rgba(52, 199, 89, 0.1)";
        case "recommendation":
          return "rgba(175, 82, 222, 0.1)";
        case "hiring_heat":
          return "rgba(255, 59, 48, 0.1)";
        case "deadline_alert":
          return "rgba(255, 149, 0, 0.1)";
        default:
          return "rgba(0, 0, 0, 0.05)";
      }
    };
    const formatTimestamp = (timestamp) => {
      const diff = Date.now() - timestamp;
      const minutes = Math.floor(diff / (1e3 * 60));
      const hours = Math.floor(diff / (1e3 * 60 * 60));
      const days = Math.floor(diff / (1e3 * 60 * 60 * 24));
      if (minutes < 60) return `${minutes}m ago`;
      if (hours < 24) return `${hours}h ago`;
      return `${days}d ago`;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          backgroundColor: "#FFFFFF",
          borderRadius: sizes.borderRadius,
          padding: sizes.padding,
          border: `2px solid ${item.read ? "transparent" : "#0077B5"}`,
          boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)",
          transition: "all 150ms",
          position: "relative"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: sizes.gap, marginBottom: sizes.marginBottom }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  width: `${sizes.iconBox}px`,
                  height: `${sizes.iconBox}px`,
                  borderRadius: "8px",
                  backgroundColor: getTypeColor(),
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  flexShrink: 0
                },
                children: getTypeIcon()
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "4px", flexWrap: "wrap" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "h3",
                  {
                    style: {
                      fontSize: isNarrow ? "13px" : "14px",
                      fontWeight: "600",
                      margin: 0,
                      color: "#1d1d1f"
                    },
                    children: item.title
                  }
                ),
                item.matchScore != null && item.matchScore > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "span",
                  {
                    style: {
                      padding: "2px 6px",
                      backgroundColor: "rgba(52, 199, 89, 0.1)",
                      borderRadius: "4px",
                      fontSize: isNarrow ? "10px" : "11px",
                      fontWeight: "600",
                      color: "#34C759"
                    },
                    children: [
                      item.matchScore,
                      "%"
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  style: {
                    fontSize: isNarrow ? "12px" : "13px",
                    color: "#1d1d1f",
                    margin: "0 0 8px 0",
                    fontWeight: "500"
                  },
                  children: item.description
                }
              ),
              (item.company != null || item.location != null) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", flexWrap: "wrap" }, children: [
                item.company != null && item.company.trim() !== "" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: isNarrow ? "11px" : "12px", color: "#6e6e73" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { size: isNarrow ? 10 : 12, style: { display: "inline", marginRight: "4px", verticalAlign: "middle" } }),
                  item.company
                ] }),
                item.location != null && item.location.trim() !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: isNarrow ? "11px" : "12px", color: "#6e6e73" }, children: item.location })
              ] })
            ] }),
            !isNarrow && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: handleToggleRead,
                style: {
                  background: "none",
                  border: "none",
                  cursor: "pointer",
                  padding: "4px",
                  display: "flex",
                  alignItems: "center",
                  borderRadius: "50%",
                  transition: "background-color 150ms"
                },
                onMouseEnter: (e) => {
                  e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.05)";
                },
                onMouseLeave: (e) => {
                  e.currentTarget.style.backgroundColor = "transparent";
                },
                title: item.read ? "Mark as unread" : "Mark as read",
                children: item.read ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 14, color: "#34C759" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Circle, { size: 14, color: "#6e6e73" })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", gap: "8px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px", fontSize: isNarrow ? "11px" : "12px", color: "#86868b" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { size: isNarrow ? 10 : 12 }),
              formatTimestamp(item.timestamp)
            ] }),
            item.actionUrl != null && item.actionUrl.trim() !== "" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "a",
              {
                href: item.actionUrl,
                target: "_blank",
                rel: "noopener noreferrer",
                style: {
                  fontSize: isNarrow ? "12px" : "13px",
                  fontWeight: "600",
                  color: "#0077B5",
                  textDecoration: "none",
                  display: "flex",
                  alignItems: "center",
                  gap: "4px",
                  transition: "color 150ms",
                  whiteSpace: "nowrap"
                },
                onMouseEnter: (e) => {
                  e.currentTarget.style.color = "#005885";
                },
                onMouseLeave: (e) => {
                  e.currentTarget.style.color = "#0077B5";
                },
                children: [
                  item.actionLabel ?? "View",
                  /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { size: isNarrow ? 10 : 12 })
                ]
              }
            )
          ] })
        ]
      }
    );
  }
  function EmptyState$1() {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          padding: "40px 24px",
          textAlign: "center"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 48, color: "#86868b", strokeWidth: 1.5 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "h3",
            {
              style: {
                fontSize: "18px",
                fontWeight: "600",
                margin: "16px 0 8px 0",
                color: "#1d1d1f"
              },
              children: "No Activity Yet"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                fontSize: "14px",
                color: "#6e6e73",
                margin: "0 0 16px 0",
                maxWidth: "280px"
              },
              children: "Add companies and people to your watchlist to start tracking job opportunities and updates"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                fontSize: "12px",
                color: "#8e8e93",
                margin: 0
              },
              children: "ðŸ’¡ Tip: Use Alt+2 to open your Watchlist"
            }
          )
        ]
      }
    );
  }
  function EmptyFilterState({ filter }) {
    const getFilterMessage = () => {
      switch (filter) {
        case "unread":
          return "All caught up! No unread items.";
        case "jobs":
          return "No job alerts yet. Add companies to your watchlist!";
        case "companies":
          return "No company updates yet.";
        case "people":
          return "No people updates yet.";
        default:
          return "No items found.";
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          padding: "40px 24px",
          textAlign: "center"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Filter, { size: 40, color: "#86868b", strokeWidth: 1.5 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                fontSize: "14px",
                color: "#6e6e73",
                margin: "16px 0 0 0"
              },
              children: getFilterMessage()
            }
          )
        ]
      }
    );
  }
  content;
  function SubTabButton({ icon, label, isActive, onClick, panelWidth }) {
    const isIconOnly = panelWidth < 360;
    const isSmall = panelWidth < 420;
    const shortLabel = label === "Experience" ? "Exp" : label === "Education" ? "Edu" : label === "Generate" ? "Gen" : label;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick,
        title: label,
        style: {
          flex: 1,
          padding: isIconOnly ? "10px 8px" : isSmall ? "8px 10px" : "10px 14px",
          background: isActive ? "#0077B5" : "white",
          color: isActive ? "white" : "#6e6e73",
          border: isActive ? "none" : "1px solid rgba(0, 0, 0, 0.12)",
          borderRadius: isSmall ? "6px" : "8px",
          fontSize: "13px",
          fontWeight: "600",
          cursor: "pointer",
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "center",
          gap: "6px",
          transition: "all 0.2s",
          minWidth: 0
        },
        onMouseEnter: (e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = "#f9fafb";
            e.currentTarget.style.borderColor = "rgba(0, 0, 0, 0.16)";
          }
        },
        onMouseLeave: (e) => {
          if (!isActive) {
            e.currentTarget.style.backgroundColor = "white";
            e.currentTarget.style.borderColor = "rgba(0, 0, 0, 0.12)";
          }
        },
        children: [
          icon,
          !isIconOnly && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
            whiteSpace: "nowrap",
            overflow: "hidden",
            textOverflow: "ellipsis"
          }, children: isSmall ? shortLabel : label })
        ]
      }
    );
  }
  content;
  function SectionButton({ label, isActive, onClick }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick,
        style: {
          flex: 1,
          padding: "8px 12px",
          background: isActive ? "white" : "transparent",
          color: isActive ? "#1d1d1f" : "#6e6e73",
          border: "none",
          borderRadius: "6px",
          fontSize: "13px",
          fontWeight: "600",
          cursor: "pointer",
          transition: "all 0.2s",
          boxShadow: isActive ? "0 1px 3px rgba(0, 0, 0, 0.08)" : "none"
        },
        children: label
      }
    );
  }
  content;
  function EmptyState({ message }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", padding: "48px 20px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: 48, strokeWidth: 1.5, style: { color: "#d1d5db", margin: "0 auto 16px auto" } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "14px", color: "#6e6e73", margin: 0 }, children: message })
    ] });
  }
  content;
  function JobForm({ type, existingData, onSave, onCancel }) {
    const [formData, setFormData] = reactExports.useState({
      title: existingData?.title || existingData?.role || "",
      company: existingData?.company || existingData?.organization || "",
      location: existingData?.location || "",
      startDate: existingData?.startDate || "",
      endDate: existingData?.endDate || "",
      current: existingData?.current || false,
      employmentType: existingData?.employmentType || "full-time",
      bullets: existingData?.bullets || [],
      technologies: existingData?.technologies || existingData?.skills || []
    });
    const [bulletText, setBulletText] = reactExports.useState("");
    const handleSubmit = (e) => {
      e.preventDefault();
      const dataToSave = {
        location: formData.location,
        startDate: formData.startDate,
        endDate: formData.endDate,
        current: formData.current,
        bullets: formData.bullets
      };
      if (type === "volunteer") {
        dataToSave.role = formData.title;
        dataToSave.organization = formData.company;
        dataToSave.skills = formData.technologies;
      } else {
        dataToSave.title = formData.title;
        dataToSave.company = formData.company;
        dataToSave.technologies = formData.technologies;
        if (type === "jobs") {
          dataToSave.employmentType = formData.employmentType;
        }
      }
      onSave(dataToSave);
    };
    const addBullet = () => {
      if (!bulletText.trim()) return;
      const newBullet = {
        id: `bullet_${Date.now()}`,
        text: bulletText.trim(),
        keywords: [],
        order: formData.bullets.length
      };
      setFormData({
        ...formData,
        bullets: [...formData.bullets, newBullet]
      });
      setBulletText("");
    };
    const removeBullet = (id) => {
      setFormData({
        ...formData,
        bullets: formData.bullets.filter((b) => b.id !== id)
      });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "form",
      {
        onSubmit: handleSubmit,
        style: {
          backgroundColor: "white",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          borderRadius: "8px",
          padding: "16px",
          marginBottom: "16px"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: [
              type === "jobs" ? "Job Title" : type === "internships" ? "Internship Title" : "Role",
              " *"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: formData.title,
                onChange: (e) => setFormData({ ...formData, title: e.target.value }),
                required: true,
                placeholder: "e.g., Senior Software Engineer",
                style: {
                  width: "100%",
                  padding: "10px 12px",
                  border: "1px solid rgba(0, 0, 0, 0.12)",
                  borderRadius: "6px",
                  fontSize: "14px",
                  fontFamily: "inherit"
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: [
              type === "volunteer" ? "Organization" : "Company",
              " *"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: formData.company,
                onChange: (e) => setFormData({ ...formData, company: e.target.value }),
                required: true,
                placeholder: "e.g., Google",
                style: {
                  width: "100%",
                  padding: "10px 12px",
                  border: "1px solid rgba(0, 0, 0, 0.12)",
                  borderRadius: "6px",
                  fontSize: "14px",
                  fontFamily: "inherit"
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Location *" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: formData.location,
                onChange: (e) => setFormData({ ...formData, location: e.target.value }),
                required: true,
                placeholder: "e.g., San Francisco, CA or Remote",
                style: {
                  width: "100%",
                  padding: "10px 12px",
                  border: "1px solid rgba(0, 0, 0, 0.12)",
                  borderRadius: "6px",
                  fontSize: "14px",
                  fontFamily: "inherit"
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Start Date *" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "month",
                  value: formData.startDate,
                  onChange: (e) => setFormData({ ...formData, startDate: e.target.value }),
                  required: true,
                  style: {
                    width: "100%",
                    padding: "10px 12px",
                    border: "1px solid rgba(0, 0, 0, 0.12)",
                    borderRadius: "6px",
                    fontSize: "14px",
                    fontFamily: "inherit"
                  }
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "End Date" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "month",
                  value: formData.endDate,
                  onChange: (e) => setFormData({ ...formData, endDate: e.target.value }),
                  disabled: formData.current,
                  style: {
                    width: "100%",
                    padding: "10px 12px",
                    border: "1px solid rgba(0, 0, 0, 0.12)",
                    borderRadius: "6px",
                    fontSize: "14px",
                    fontFamily: "inherit",
                    opacity: formData.current ? 0.5 : 1
                  }
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { display: "flex", alignItems: "center", gap: "8px", fontSize: "13px", color: "#1d1d1f", cursor: "pointer" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                checked: formData.current,
                onChange: (e) => setFormData({ ...formData, current: e.target.checked, endDate: e.target.checked ? "" : formData.endDate }),
                style: { width: "16px", height: "16px" }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "I currently ",
              type === "volunteer" ? "volunteer" : "work",
              " here"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Key Accomplishments" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "12px", color: "#6e6e73", margin: "0 0 8px 0" }, children: "Use APR format: Action + Project/Problem + Result. Include metrics!" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "12px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: bulletText,
                  onChange: (e) => setBulletText(e.target.value),
                  onKeyPress: (e) => {
                    if (e.key === "Enter") {
                      e.preventDefault();
                      addBullet();
                    }
                  },
                  placeholder: "e.g., Led migration of 50+ microservices to Kubernetes, reducing infrastructure costs by 40%",
                  style: {
                    flex: 1,
                    padding: "10px 12px",
                    border: "1px solid rgba(0, 0, 0, 0.12)",
                    borderRadius: "6px",
                    fontSize: "13px",
                    fontFamily: "inherit"
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: addBullet,
                  style: {
                    padding: "10px 16px",
                    background: "#0077B5",
                    color: "white",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "13px",
                    fontWeight: "600",
                    cursor: "pointer"
                  },
                  children: "Add"
                }
              )
            ] }),
            formData.bullets.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: formData.bullets.map((bullet) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  display: "flex",
                  alignItems: "flex-start",
                  gap: "8px",
                  padding: "10px",
                  backgroundColor: "#f9fafb",
                  borderRadius: "6px"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: "13px", color: "#1d1d1f", flex: 1, lineHeight: "1.5" }, children: [
                    "â€¢ ",
                    bullet.text
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      onClick: () => removeBullet(bullet.id),
                      style: {
                        padding: "4px",
                        background: "transparent",
                        border: "none",
                        color: "#dc2626",
                        cursor: "pointer"
                      },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 14, strokeWidth: 2 })
                    }
                  )
                ]
              },
              bullet.id
            )) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginTop: "8px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                type: "submit",
                style: {
                  flex: 1,
                  padding: "12px 16px",
                  background: "#0077B5",
                  color: "white",
                  border: "none",
                  borderRadius: "8px",
                  fontSize: "14px",
                  fontWeight: "600",
                  cursor: "pointer",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  gap: "8px"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Save, { size: 16, strokeWidth: 2 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Save" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                type: "button",
                onClick: onCancel,
                style: {
                  flex: 1,
                  padding: "12px 16px",
                  background: "white",
                  color: "#6e6e73",
                  border: "1px solid rgba(0, 0, 0, 0.12)",
                  borderRadius: "8px",
                  fontSize: "14px",
                  fontWeight: "600",
                  cursor: "pointer",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  gap: "8px"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 16, strokeWidth: 2 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Cancel" })
                ]
              }
            )
          ] })
        ] })
      }
    );
  }
  content;
  function JobCard$3({ job, onEdit, onDelete }) {
    const formatDate = (date) => {
      if (!date) return "";
      const [year, month] = date.split("-");
      const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      return `${monthNames[parseInt(month) - 1]} ${year}`;
    };
    const dateRange = `${formatDate(job.startDate)} - ${job.current ? "Present" : formatDate(job.endDate || "")}`;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          backgroundColor: "white",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          borderRadius: "8px",
          padding: "16px"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", marginBottom: "8px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 4px 0" }, children: job.title }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", fontSize: "13px", color: "#6e6e73", marginBottom: "4px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { size: 12, strokeWidth: 2 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: job.company })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "12px", fontSize: "12px", color: "#6e6e73" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Calendar, { size: 12, strokeWidth: 2 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: dateRange })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { size: 12, strokeWidth: 2 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: job.location })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "4px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: onEdit,
                  style: {
                    padding: "8px",
                    background: "transparent",
                    border: "none",
                    color: "#0077B5",
                    cursor: "pointer",
                    borderRadius: "6px",
                    transition: "background 0.2s"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.backgroundColor = "rgba(0, 119, 181, 0.1)";
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "transparent";
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pen, { size: 16, strokeWidth: 2 })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: onDelete,
                  style: {
                    padding: "8px",
                    background: "transparent",
                    border: "none",
                    color: "#dc2626",
                    cursor: "pointer",
                    borderRadius: "6px",
                    transition: "background 0.2s"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.backgroundColor = "#fef2f2";
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "transparent";
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 16, strokeWidth: 2 })
                }
              )
            ] })
          ] }),
          job.bullets.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: "12px", paddingTop: "12px", borderTop: "1px solid rgba(0, 0, 0, 0.08)" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { style: { margin: 0, padding: 0, listStyle: "none", display: "flex", flexDirection: "column", gap: "6px" }, children: job.bullets.slice(0, 3).map((bullet) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { style: { fontSize: "13px", color: "#1d1d1f", display: "flex", gap: "8px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#0077B5" }, children: "â€¢" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { flex: 1 }, children: bullet.text })
            ] }, bullet.id)) }),
            job.bullets.length > 3 && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: "12px", color: "#6e6e73", margin: "8px 0 0 0" }, children: [
              "+",
              job.bullets.length - 3,
              " more accomplishment",
              job.bullets.length - 3 !== 1 ? "s" : ""
            ] })
          ] })
        ]
      }
    );
  }
  content;
  function InternshipCard({
    internship,
    onEdit,
    onDelete
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(JobCard$3, { job: internship, onEdit, onDelete });
  }
  content;
  function VolunteerCard({
    volunteer,
    onEdit,
    onDelete
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      JobCard$3,
      {
        job: { ...volunteer, title: volunteer.role, company: volunteer.organization },
        onEdit,
        onDelete
      }
    );
  }
  content;
  function ExperienceTab({ profile, onUpdate }) {
    const [activeSection, setActiveSection] = reactExports.useState("jobs");
    const [isAdding, setIsAdding] = reactExports.useState(false);
    const [editingId, setEditingId] = reactExports.useState(null);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "20px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            gap: "8px",
            marginBottom: "20px",
            padding: "4px",
            backgroundColor: "#f9fafb",
            borderRadius: "8px"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SectionButton,
              {
                label: "Jobs",
                isActive: activeSection === "jobs",
                onClick: () => setActiveSection("jobs")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SectionButton,
              {
                label: "Internships",
                isActive: activeSection === "internships",
                onClick: () => setActiveSection("internships")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SectionButton,
              {
                label: "Volunteer",
                isActive: activeSection === "volunteer",
                onClick: () => setActiveSection("volunteer")
              }
            )
          ]
        }
      ),
      !isAdding && !editingId && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: () => setIsAdding(true),
          style: {
            width: "100%",
            padding: "12px 16px",
            background: "#0077B5",
            color: "white",
            border: "none",
            borderRadius: "8px",
            fontSize: "14px",
            fontWeight: "600",
            cursor: "pointer",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            gap: "8px",
            marginBottom: "16px",
            transition: "background 0.2s"
          },
          onMouseEnter: (e) => {
            e.currentTarget.style.background = "#006399";
          },
          onMouseLeave: (e) => {
            e.currentTarget.style.background = "#0077B5";
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { size: 18, strokeWidth: 2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "Add ",
              activeSection === "jobs" ? "Job" : activeSection === "internships" ? "Internship" : "Volunteer Work"
            ] })
          ]
        }
      ),
      (isAdding || editingId) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        JobForm,
        {
          type: activeSection,
          existingData: editingId ? activeSection === "jobs" ? profile.jobs.find((j) => j.id === editingId) : activeSection === "internships" ? profile.internships.find((i) => i.id === editingId) : profile.volunteerWork.find((v) => v.id === editingId) : void 0,
          onSave: async (data) => {
            if (editingId) {
              if (activeSection === "jobs") {
                await updateJobExperience(editingId, data);
              }
              setEditingId(null);
            } else {
              if (activeSection === "jobs") {
                await addJobExperience(data);
              } else if (activeSection === "internships") {
                await addInternshipExperience(data);
              } else {
                await addVolunteerExperience(data);
              }
              setIsAdding(false);
            }
            onUpdate();
          },
          onCancel: () => {
            setIsAdding(false);
            setEditingId(null);
          }
        }
      ),
      !isAdding && !editingId && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: [
        activeSection === "jobs" && profile.jobs.map((job) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          JobCard$3,
          {
            job,
            onEdit: () => setEditingId(job.id),
            onDelete: async () => {
              if (confirm(`Delete ${job.title} at ${job.company}?`)) {
                await deleteJobExperience(job.id);
                onUpdate();
              }
            }
          },
          job.id
        )),
        activeSection === "internships" && profile.internships.map((internship) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          InternshipCard,
          {
            internship,
            onEdit: () => setEditingId(internship.id),
            onDelete: async () => {
              if (confirm(`Delete ${internship.title} at ${internship.company}?`)) {
                await deleteInternshipExperience(internship.id);
                onUpdate();
              }
            }
          },
          internship.id
        )),
        activeSection === "volunteer" && profile.volunteerWork.map((volunteer) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          VolunteerCard,
          {
            volunteer,
            onEdit: () => setEditingId(volunteer.id),
            onDelete: async () => {
              if (confirm(`Delete ${volunteer.role} at ${volunteer.organization}?`)) {
                await deleteVolunteerExperience(volunteer.id);
                onUpdate();
              }
            }
          },
          volunteer.id
        )),
        activeSection === "jobs" && profile.jobs.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, { message: "No jobs added yet" }),
        activeSection === "internships" && profile.internships.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, { message: "No internships added yet" }),
        activeSection === "volunteer" && profile.volunteerWork.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, { message: "No volunteer work added yet" })
      ] })
    ] });
  }
  content;
  function SkillForm({ existingData, onSave, onCancel }) {
    const [formData, setFormData] = reactExports.useState({
      name: existingData?.name || "",
      category: existingData?.category || "other",
      proficiency: existingData?.proficiency || "intermediate",
      yearsOfExperience: existingData?.yearsOfExperience || 0,
      synonyms: existingData?.synonyms || []
    });
    const [synonymInput, setSynonymInput] = reactExports.useState("");
    const handleSubmit = (e) => {
      e.preventDefault();
      if (!formData.name.trim()) return;
      onSave(formData);
    };
    const addSynonym = () => {
      if (!synonymInput.trim()) return;
      setFormData({
        ...formData,
        synonyms: [...formData.synonyms || [], synonymInput.trim()]
      });
      setSynonymInput("");
    };
    const removeSynonym = (index2) => {
      setFormData({
        ...formData,
        synonyms: formData.synonyms?.filter((_, i) => i !== index2) || []
      });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, style: { backgroundColor: "white", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "8px", padding: "16px", marginBottom: "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 16px 0" }, children: existingData ? "Edit Skill" : "Add Technical Skill" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Skill Name *" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.name,
            onChange: (e) => setFormData({ ...formData, name: e.target.value }),
            placeholder: "e.g., React, Python, Machine Learning",
            required: true,
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px", marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Category" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: formData.category,
              onChange: (e) => setFormData({ ...formData, category: e.target.value }),
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit", backgroundColor: "white" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "frontend", children: "Frontend" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "backend", children: "Backend" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "devops", children: "DevOps" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "data", children: "Data/ML" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "design", children: "Design" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "management", children: "Management" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "other", children: "Other" })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Proficiency" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: formData.proficiency,
              onChange: (e) => setFormData({ ...formData, proficiency: e.target.value }),
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit", backgroundColor: "white" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "beginner", children: "Beginner" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "intermediate", children: "Intermediate" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "advanced", children: "Advanced" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "expert", children: "Expert" })
              ]
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Years of Experience (optional)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "number",
            min: "0",
            max: "50",
            value: formData.yearsOfExperience || "",
            onChange: (e) => setFormData({ ...formData, yearsOfExperience: parseInt(e.target.value) || 0 }),
            placeholder: "e.g., 3",
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Synonyms (for ATS matching)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "12px", color: "#6e6e73", margin: "0 0 8px 0" }, children: "Add variations: React.js, ReactJS, etc." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: synonymInput,
              onChange: (e) => setSynonymInput(e.target.value),
              onKeyPress: (e) => {
                if (e.key === "Enter") {
                  e.preventDefault();
                  addSynonym();
                }
              },
              placeholder: "e.g., React.js",
              style: { flex: 1, padding: "8px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: addSynonym, style: { padding: "8px 16px", background: "#0077B5", color: "white", border: "none", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Add" })
        ] }),
        formData.synonyms && formData.synonyms.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px" }, children: formData.synonyms.map((syn, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px", padding: "4px 8px", backgroundColor: "#f0f9ff", borderRadius: "4px", fontSize: "12px", color: "#0077B5" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: syn }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: () => removeSynonym(i), style: { padding: "0", background: "transparent", border: "none", color: "#0077B5", cursor: "pointer", fontSize: "14px", lineHeight: "1" }, children: "Ã—" })
        ] }, i)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", justifyContent: "flex-end" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: onCancel, style: { padding: "10px 16px", background: "white", color: "#6e6e73", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { type: "submit", style: { padding: "10px 16px", background: "#0077B5", color: "white", border: "none", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: [
          existingData ? "Update" : "Add",
          " Skill"
        ] })
      ] })
    ] });
  }
  content;
  function SkillCard({ skill, onEdit, onDelete }) {
    const proficiencyColors = {
      beginner: "#94a3b8",
      intermediate: "#60a5fa",
      advanced: "#0077B5",
      expert: "#7c3aed"
    };
    const categoryIcons = {
      frontend: "ðŸŽ¨",
      backend: "âš™ï¸",
      devops: "ðŸš€",
      data: "ðŸ“Š",
      design: "âœ¨",
      management: "ðŸ‘”",
      other: "ðŸ’¡"
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { backgroundColor: "white", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "8px", padding: "14px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "flex-start" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "6px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "16px" }, children: categoryIcons[skill.category] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: 0 }, children: skill.name })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexWrap: "wrap", gap: "8px", alignItems: "center" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                padding: "4px 10px",
                backgroundColor: `${proficiencyColors[skill.proficiency]}15`,
                color: proficiencyColors[skill.proficiency],
                borderRadius: "4px",
                fontSize: "12px",
                fontWeight: "600",
                textTransform: "capitalize"
              },
              children: skill.proficiency
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "12px", color: "#6e6e73", textTransform: "capitalize" }, children: skill.category.replace("-", " ") }),
          skill.yearsOfExperience && skill.yearsOfExperience > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: "12px", color: "#6e6e73" }, children: [
            "â€¢ ",
            skill.yearsOfExperience,
            " ",
            skill.yearsOfExperience === 1 ? "year" : "years"
          ] })
        ] }),
        skill.synonyms && skill.synonyms.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: "8px", fontSize: "11px", color: "#9ca3af" }, children: [
          "ATS: ",
          skill.synonyms.join(", ")
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "4px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onEdit, style: { padding: "6px", background: "transparent", border: "none", color: "#0077B5", cursor: "pointer", borderRadius: "4px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pen, { size: 14, strokeWidth: 2 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onDelete, style: { padding: "6px", background: "transparent", border: "none", color: "#dc2626", cursor: "pointer", borderRadius: "4px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 14, strokeWidth: 2 }) })
      ] })
    ] }) });
  }
  content;
  function ToolForm({ existingData, onSave, onCancel }) {
    const [formData, setFormData] = reactExports.useState({
      name: existingData?.name || "",
      category: existingData?.category || "tool",
      proficiency: existingData?.proficiency || "intermediate",
      version: existingData?.version || "",
      synonyms: existingData?.synonyms || []
    });
    const [synonymInput, setSynonymInput] = reactExports.useState("");
    const handleSubmit = (e) => {
      e.preventDefault();
      if (!formData.name.trim()) return;
      onSave(formData);
    };
    const addSynonym = () => {
      if (!synonymInput.trim()) return;
      setFormData({
        ...formData,
        synonyms: [...formData.synonyms || [], synonymInput.trim()]
      });
      setSynonymInput("");
    };
    const removeSynonym = (index2) => {
      setFormData({
        ...formData,
        synonyms: formData.synonyms?.filter((_, i) => i !== index2) || []
      });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, style: { backgroundColor: "white", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "8px", padding: "16px", marginBottom: "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 16px 0" }, children: existingData ? "Edit Tool" : "Add Tool/Software" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Tool/Software Name *" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.name,
            onChange: (e) => setFormData({ ...formData, name: e.target.value }),
            placeholder: "e.g., Docker, AWS, PostgreSQL",
            required: true,
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px", marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Category" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: formData.category,
              onChange: (e) => setFormData({ ...formData, category: e.target.value }),
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit", backgroundColor: "white" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "language", children: "Language" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "framework", children: "Framework" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "database", children: "Database" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "cloud", children: "Cloud Platform" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "tool", children: "Tool" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "platform", children: "Platform" })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Proficiency" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: formData.proficiency,
              onChange: (e) => setFormData({ ...formData, proficiency: e.target.value }),
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit", backgroundColor: "white" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "beginner", children: "Beginner" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "intermediate", children: "Intermediate" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "advanced", children: "Advanced" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "expert", children: "Expert" })
              ]
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Version (optional)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.version,
            onChange: (e) => setFormData({ ...formData, version: e.target.value }),
            placeholder: "e.g., React 18, Python 3.11",
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Synonyms (for ATS matching)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: synonymInput,
              onChange: (e) => setSynonymInput(e.target.value),
              onKeyPress: (e) => {
                if (e.key === "Enter") {
                  e.preventDefault();
                  addSynonym();
                }
              },
              placeholder: "e.g., PostgreSQL, Postgres",
              style: { flex: 1, padding: "8px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: addSynonym, style: { padding: "8px 16px", background: "#0077B5", color: "white", border: "none", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Add" })
        ] }),
        formData.synonyms && formData.synonyms.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px" }, children: formData.synonyms.map((syn, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px", padding: "4px 8px", backgroundColor: "#f0f9ff", borderRadius: "4px", fontSize: "12px", color: "#0077B5" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: syn }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: () => removeSynonym(i), style: { padding: "0", background: "transparent", border: "none", color: "#0077B5", cursor: "pointer", fontSize: "14px", lineHeight: "1" }, children: "Ã—" })
        ] }, i)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", justifyContent: "flex-end" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: onCancel, style: { padding: "10px 16px", background: "white", color: "#6e6e73", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { type: "submit", style: { padding: "10px 16px", background: "#0077B5", color: "white", border: "none", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: [
          existingData ? "Update" : "Add",
          " Tool"
        ] })
      ] })
    ] });
  }
  content;
  function ToolCard({ tool, onEdit, onDelete }) {
    const proficiencyColors = {
      beginner: "#94a3b8",
      intermediate: "#60a5fa",
      advanced: "#0077B5",
      expert: "#7c3aed"
    };
    const categoryIcons = {
      language: "ðŸ“",
      framework: "ðŸ—ï¸",
      database: "ðŸ—„ï¸",
      cloud: "â˜ï¸",
      tool: "ðŸ”§",
      platform: "ðŸŒ"
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { backgroundColor: "white", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "8px", padding: "14px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "flex-start" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "6px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "16px" }, children: categoryIcons[tool.category] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: 0 }, children: tool.name }),
          tool.version && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: "12px", color: "#6e6e73", fontWeight: "500" }, children: [
            "v",
            tool.version
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexWrap: "wrap", gap: "8px", alignItems: "center" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                padding: "4px 10px",
                backgroundColor: `${proficiencyColors[tool.proficiency]}15`,
                color: proficiencyColors[tool.proficiency],
                borderRadius: "4px",
                fontSize: "12px",
                fontWeight: "600",
                textTransform: "capitalize"
              },
              children: tool.proficiency
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "12px", color: "#6e6e73", textTransform: "capitalize" }, children: tool.category })
        ] }),
        tool.synonyms && tool.synonyms.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: "8px", fontSize: "11px", color: "#9ca3af" }, children: [
          "ATS: ",
          tool.synonyms.join(", ")
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "4px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onEdit, style: { padding: "6px", background: "transparent", border: "none", color: "#0077B5", cursor: "pointer", borderRadius: "4px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pen, { size: 14, strokeWidth: 2 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onDelete, style: { padding: "6px", background: "transparent", border: "none", color: "#dc2626", cursor: "pointer", borderRadius: "4px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 14, strokeWidth: 2 }) })
      ] })
    ] }) });
  }
  content;
  function CertificationForm({ onSave, onCancel }) {
    const [formData, setFormData] = reactExports.useState({
      name: "",
      issuer: "",
      issueDate: "",
      expiryDate: "",
      credentialId: "",
      credentialUrl: "",
      acronym: ""
    });
    const handleSubmit = (e) => {
      e.preventDefault();
      if (!formData.name.trim() || !formData.issuer.trim()) return;
      onSave(formData);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, style: { backgroundColor: "white", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "8px", padding: "16px", marginBottom: "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 16px 0" }, children: "Add Certification" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Certification Name *" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.name,
            onChange: (e) => setFormData({ ...formData, name: e.target.value }),
            placeholder: "e.g., AWS Certified Solutions Architect",
            required: true,
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px", marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Issuer *" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.issuer,
              onChange: (e) => setFormData({ ...formData, issuer: e.target.value }),
              placeholder: "e.g., Amazon Web Services",
              required: true,
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Acronym" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.acronym,
              onChange: (e) => setFormData({ ...formData, acronym: e.target.value }),
              placeholder: "e.g., SAA-C03",
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px", marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Issue Date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "month",
              value: formData.issueDate,
              onChange: (e) => setFormData({ ...formData, issueDate: e.target.value }),
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Expiry Date (optional)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "month",
              value: formData.expiryDate,
              onChange: (e) => setFormData({ ...formData, expiryDate: e.target.value }),
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Credential ID" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.credentialId,
            onChange: (e) => setFormData({ ...formData, credentialId: e.target.value }),
            placeholder: "e.g., ABC123XYZ",
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Credential URL" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "url",
            value: formData.credentialUrl,
            onChange: (e) => setFormData({ ...formData, credentialUrl: e.target.value }),
            placeholder: "https://...",
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", justifyContent: "flex-end" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: onCancel, style: { padding: "10px 16px", background: "white", color: "#6e6e73", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", style: { padding: "10px 16px", background: "#0077B5", color: "white", border: "none", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Add Certification" })
      ] })
    ] });
  }
  content;
  function CertificationCard({ certification, onDelete }) {
    const formatDate = (dateStr) => {
      if (!dateStr) return "";
      const [year, month] = dateStr.split("-");
      const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      return `${monthNames[parseInt(month) - 1]} ${year}`;
    };
    const isExpired = certification.expiryDate && new Date(certification.expiryDate) < /* @__PURE__ */ new Date();
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { backgroundColor: "white", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "8px", padding: "14px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "flex-start" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "6px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "16px" }, children: "ðŸŽ“" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: 0 }, children: certification.name }),
          certification.acronym && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: "12px", color: "#6e6e73", fontWeight: "600" }, children: [
            "(",
            certification.acronym,
            ")"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "13px", color: "#6e6e73", marginBottom: "6px" }, children: certification.issuer }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexWrap: "wrap", gap: "12px", alignItems: "center", fontSize: "12px", color: "#6e6e73" }, children: [
          certification.issueDate && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            "Issued: ",
            formatDate(certification.issueDate)
          ] }),
          certification.expiryDate && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: isExpired ? "#dc2626" : "#6e6e73" }, children: [
            isExpired ? "âš ï¸ Expired" : "Expires",
            ": ",
            formatDate(certification.expiryDate)
          ] })
        ] }),
        (certification.credentialId || certification.credentialUrl) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: "8px", fontSize: "11px", color: "#9ca3af" }, children: [
          certification.credentialId && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            "ID: ",
            certification.credentialId
          ] }),
          certification.credentialUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: certification.credentialUrl, target: "_blank", rel: "noopener noreferrer", style: { color: "#0077B5", textDecoration: "none" }, children: "View Credential â†’" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onDelete, style: { padding: "6px", background: "transparent", border: "none", color: "#dc2626", cursor: "pointer", borderRadius: "4px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 14, strokeWidth: 2 }) })
    ] }) });
  }
  content;
  function LanguageForm({ onSave, onCancel }) {
    const [formData, setFormData] = reactExports.useState({
      name: "",
      proficiency: "professional-working"
    });
    const handleSubmit = (e) => {
      e.preventDefault();
      if (!formData.name.trim()) return;
      onSave(formData);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, style: { backgroundColor: "white", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "8px", padding: "16px", marginBottom: "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 16px 0" }, children: "Add Language" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Language *" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.name,
            onChange: (e) => setFormData({ ...formData, name: e.target.value }),
            placeholder: "e.g., Spanish, Mandarin, French",
            required: true,
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Proficiency" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "select",
          {
            value: formData.proficiency,
            onChange: (e) => setFormData({ ...formData, proficiency: e.target.value }),
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit", backgroundColor: "white" },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "elementary", children: "Elementary" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "limited-working", children: "Limited Working" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "professional-working", children: "Professional Working" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "full-professional", children: "Full Professional" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "native", children: "Native / Bilingual" })
            ]
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", justifyContent: "flex-end" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: onCancel, style: { padding: "10px 16px", background: "white", color: "#6e6e73", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", style: { padding: "10px 16px", background: "#0077B5", color: "white", border: "none", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Add Language" })
      ] })
    ] });
  }
  content;
  function LanguageCard({ language, onDelete }) {
    const proficiencyLabels = {
      "elementary": "Elementary",
      "limited-working": "Limited Working",
      "professional-working": "Professional Working",
      "full-professional": "Full Professional",
      "native": "Native / Bilingual"
    };
    const proficiencyColors = {
      "elementary": "#94a3b8",
      "limited-working": "#64748b",
      "professional-working": "#0077B5",
      "full-professional": "#0ea5e9",
      "native": "#7c3aed"
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { backgroundColor: "white", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "8px", padding: "14px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, display: "flex", alignItems: "center", gap: "12px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "20px" }, children: "ðŸŒ" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 4px 0" }, children: language.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                padding: "4px 10px",
                backgroundColor: `${proficiencyColors[language.proficiency]}15`,
                color: proficiencyColors[language.proficiency],
                borderRadius: "4px",
                fontSize: "12px",
                fontWeight: "600"
              },
              children: proficiencyLabels[language.proficiency]
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onDelete, style: { padding: "6px", background: "transparent", border: "none", color: "#dc2626", cursor: "pointer", borderRadius: "4px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 14, strokeWidth: 2 }) })
    ] }) });
  }
  content;
  function SkillsTab({ profile, onUpdate }) {
    const [activeSection, setActiveSection] = reactExports.useState("skills");
    const [isAdding, setIsAdding] = reactExports.useState(false);
    const [editingId, setEditingId] = reactExports.useState(null);
    if (!profile) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "20px", textAlign: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Code, { size: 48, strokeWidth: 1.5, style: { color: "#d1d5db", margin: "0 auto 16px auto" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "14px", color: "#6e6e73", margin: 0 }, children: "Loading profile..." })
      ] });
    }
    const handleAddSkill = async (skillData) => {
      try {
        await addTechnicalSkill(skillData);
        setIsAdding(false);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error adding skill:", error);
      }
    };
    const handleUpdateSkill = async (id, updates) => {
      try {
        await updateTechnicalSkill(id, updates);
        setEditingId(null);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error updating skill:", error);
      }
    };
    const handleDeleteSkill = async (id) => {
      if (!confirm("Delete this skill?")) return;
      try {
        await deleteTechnicalSkill(id);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error deleting skill:", error);
      }
    };
    const handleAddTool = async (toolData) => {
      try {
        await addTool(toolData);
        setIsAdding(false);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error adding tool:", error);
      }
    };
    const handleUpdateTool = async (id, updates) => {
      try {
        await updateTool(id, updates);
        setEditingId(null);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error updating tool:", error);
      }
    };
    const handleDeleteTool = async (id) => {
      if (!confirm("Delete this tool?")) return;
      try {
        await deleteTool(id);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error deleting tool:", error);
      }
    };
    const handleAddCertification = async (certData) => {
      try {
        await addCertification(certData);
        setIsAdding(false);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error adding certification:", error);
      }
    };
    const handleDeleteCertification = async (id) => {
      if (!confirm("Delete this certification?")) return;
      try {
        await deleteCertification(id);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error deleting certification:", error);
      }
    };
    const handleAddLanguage = async (langData) => {
      try {
        const updatedProfile = await getProfessionalProfile();
        const newLang = {
          ...langData,
          id: `lang_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        };
        updatedProfile.languages.push(newLang);
        await saveProfessionalProfile(updatedProfile);
        setIsAdding(false);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error adding language:", error);
      }
    };
    const handleDeleteLanguage = async (id) => {
      if (!confirm("Delete this language?")) return;
      try {
        const updatedProfile = await getProfessionalProfile();
        updatedProfile.languages = updatedProfile.languages.filter((l) => l.id !== id);
        await saveProfessionalProfile(updatedProfile);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error deleting language:", error);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "20px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "20px", padding: "4px", backgroundColor: "#f9fafb", borderRadius: "8px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SectionButton, { label: "Skills", isActive: activeSection === "skills", onClick: () => {
          setActiveSection("skills");
          setIsAdding(false);
          setEditingId(null);
        } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SectionButton, { label: "Tools", isActive: activeSection === "tools", onClick: () => {
          setActiveSection("tools");
          setIsAdding(false);
          setEditingId(null);
        } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SectionButton, { label: "Certs", isActive: activeSection === "certifications", onClick: () => {
          setActiveSection("certifications");
          setIsAdding(false);
          setEditingId(null);
        } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SectionButton, { label: "Languages", isActive: activeSection === "languages", onClick: () => {
          setActiveSection("languages");
          setIsAdding(false);
          setEditingId(null);
        } })
      ] }),
      activeSection === "skills" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !isAdding && !editingId && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => setIsAdding(true),
            style: {
              width: "100%",
              padding: "12px",
              background: "white",
              color: "#0077B5",
              border: "1px dashed rgba(0, 119, 181, 0.3)",
              borderRadius: "8px",
              fontSize: "13px",
              fontWeight: "600",
              cursor: "pointer",
              marginBottom: "16px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "8px",
              transition: "all 0.2s"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { size: 16, strokeWidth: 2 }),
              "Add Technical Skill"
            ]
          }
        ),
        isAdding && /* @__PURE__ */ jsxRuntimeExports.jsx(SkillForm, { onSave: handleAddSkill, onCancel: () => setIsAdding(false) }),
        editingId && /* @__PURE__ */ jsxRuntimeExports.jsx(
          SkillForm,
          {
            existingData: profile.technicalSkills.find((s) => s.id === editingId),
            onSave: (data) => handleUpdateSkill(editingId, data),
            onCancel: () => setEditingId(null)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: profile.technicalSkills.map((skill) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          SkillCard,
          {
            skill,
            onEdit: () => setEditingId(skill.id),
            onDelete: () => handleDeleteSkill(skill.id)
          },
          skill.id
        )) }),
        profile.technicalSkills.length === 0 && !isAdding && /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, { message: "No technical skills added yet. Click above to add your first skill!" })
      ] }),
      activeSection === "tools" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !isAdding && !editingId && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => setIsAdding(true),
            style: {
              width: "100%",
              padding: "12px",
              background: "white",
              color: "#0077B5",
              border: "1px dashed rgba(0, 119, 181, 0.3)",
              borderRadius: "8px",
              fontSize: "13px",
              fontWeight: "600",
              cursor: "pointer",
              marginBottom: "16px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "8px"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { size: 16, strokeWidth: 2 }),
              "Add Tool/Software"
            ]
          }
        ),
        isAdding && /* @__PURE__ */ jsxRuntimeExports.jsx(ToolForm, { onSave: handleAddTool, onCancel: () => setIsAdding(false) }),
        editingId && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToolForm,
          {
            existingData: profile.tools.find((t) => t.id === editingId),
            onSave: (data) => handleUpdateTool(editingId, data),
            onCancel: () => setEditingId(null)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: profile.tools.map((tool) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToolCard,
          {
            tool,
            onEdit: () => setEditingId(tool.id),
            onDelete: () => handleDeleteTool(tool.id)
          },
          tool.id
        )) }),
        profile.tools.length === 0 && !isAdding && /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, { message: "No tools added yet. Add frameworks, platforms, and software you use!" })
      ] }),
      activeSection === "certifications" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !isAdding && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => setIsAdding(true),
            style: {
              width: "100%",
              padding: "12px",
              background: "white",
              color: "#0077B5",
              border: "1px dashed rgba(0, 119, 181, 0.3)",
              borderRadius: "8px",
              fontSize: "13px",
              fontWeight: "600",
              cursor: "pointer",
              marginBottom: "16px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "8px"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { size: 16, strokeWidth: 2 }),
              "Add Certification"
            ]
          }
        ),
        isAdding && /* @__PURE__ */ jsxRuntimeExports.jsx(CertificationForm, { onSave: handleAddCertification, onCancel: () => setIsAdding(false) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: profile.certifications.map((cert) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CertificationCard,
          {
            certification: cert,
            onDelete: () => handleDeleteCertification(cert.id)
          },
          cert.id
        )) }),
        profile.certifications.length === 0 && !isAdding && /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, { message: "No certifications added yet. Add your AWS, Google, Microsoft, or other certs!" })
      ] }),
      activeSection === "languages" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !isAdding && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => setIsAdding(true),
            style: {
              width: "100%",
              padding: "12px",
              background: "white",
              color: "#0077B5",
              border: "1px dashed rgba(0, 119, 181, 0.3)",
              borderRadius: "8px",
              fontSize: "13px",
              fontWeight: "600",
              cursor: "pointer",
              marginBottom: "16px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "8px"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { size: 16, strokeWidth: 2 }),
              "Add Language"
            ]
          }
        ),
        isAdding && /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageForm, { onSave: handleAddLanguage, onCancel: () => setIsAdding(false) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: profile.languages.map((lang) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          LanguageCard,
          {
            language: lang,
            onDelete: () => handleDeleteLanguage(lang.id)
          },
          lang.id
        )) }),
        profile.languages.length === 0 && !isAdding && /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, { message: "No languages added yet. Add languages you speak!" })
      ] })
    ] });
  }
  content;
  function EducationForm({ onSave, onCancel }) {
    const [formData, setFormData] = reactExports.useState({
      institution: "",
      degree: "",
      field: "",
      location: "",
      startDate: "",
      endDate: "",
      current: false,
      gpa: "",
      honors: [],
      relevantCoursework: []
    });
    const [honorInput, setHonorInput] = reactExports.useState("");
    const [courseInput, setCourseInput] = reactExports.useState("");
    const handleSubmit = (e) => {
      e.preventDefault();
      if (!formData.institution.trim() || !formData.degree.trim() || !formData.field.trim()) return;
      onSave(formData);
    };
    const addHonor = () => {
      if (!honorInput.trim()) return;
      setFormData({ ...formData, honors: [...formData.honors || [], honorInput.trim()] });
      setHonorInput("");
    };
    const removeHonor = (index2) => {
      setFormData({ ...formData, honors: formData.honors?.filter((_, i) => i !== index2) || [] });
    };
    const addCourse = () => {
      if (!courseInput.trim()) return;
      setFormData({ ...formData, relevantCoursework: [...formData.relevantCoursework || [], courseInput.trim()] });
      setCourseInput("");
    };
    const removeCourse = (index2) => {
      setFormData({ ...formData, relevantCoursework: formData.relevantCoursework?.filter((_, i) => i !== index2) || [] });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, style: { backgroundColor: "white", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "8px", padding: "16px", marginBottom: "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 16px 0" }, children: "Add Education" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Institution *" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.institution,
            onChange: (e) => setFormData({ ...formData, institution: e.target.value }),
            placeholder: "e.g., Stanford University",
            required: true,
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px", marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Degree *" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.degree,
              onChange: (e) => setFormData({ ...formData, degree: e.target.value }),
              placeholder: "e.g., Bachelor of Science",
              required: true,
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Field of Study *" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.field,
              onChange: (e) => setFormData({ ...formData, field: e.target.value }),
              placeholder: "e.g., Computer Science",
              required: true,
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Location" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.location,
            onChange: (e) => setFormData({ ...formData, location: e.target.value }),
            placeholder: "e.g., Stanford, CA",
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px", marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Start Date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "month",
              value: formData.startDate,
              onChange: (e) => setFormData({ ...formData, startDate: e.target.value }),
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "End Date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "month",
              value: formData.endDate,
              onChange: (e) => setFormData({ ...formData, endDate: e.target.value }),
              disabled: formData.current,
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit", opacity: formData.current ? 0.5 : 1 }
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { display: "flex", alignItems: "center", gap: "8px", cursor: "pointer" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            checked: formData.current,
            onChange: (e) => setFormData({ ...formData, current: e.target.checked, endDate: e.target.checked ? "" : formData.endDate }),
            style: { cursor: "pointer" }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "13px", fontWeight: "600", color: "#1d1d1f" }, children: "Currently attending" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "GPA (optional)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.gpa,
            onChange: (e) => setFormData({ ...formData, gpa: e.target.value }),
            placeholder: "e.g., 3.8/4.0",
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Honors & Awards" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: honorInput,
              onChange: (e) => setHonorInput(e.target.value),
              onKeyPress: (e) => {
                if (e.key === "Enter") {
                  e.preventDefault();
                  addHonor();
                }
              },
              placeholder: "e.g., Dean's List",
              style: { flex: 1, padding: "8px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: addHonor, style: { padding: "8px 16px", background: "#0077B5", color: "white", border: "none", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Add" })
        ] }),
        formData.honors && formData.honors.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "4px" }, children: formData.honors.map((honor, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", padding: "6px 10px", backgroundColor: "#f0f9ff", borderRadius: "4px", fontSize: "12px", color: "#0077B5" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            "â€¢ ",
            honor
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: () => removeHonor(i), style: { padding: "0", background: "transparent", border: "none", color: "#0077B5", cursor: "pointer", fontSize: "16px", lineHeight: "1" }, children: "Ã—" })
        ] }, i)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Relevant Coursework" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: courseInput,
              onChange: (e) => setCourseInput(e.target.value),
              onKeyPress: (e) => {
                if (e.key === "Enter") {
                  e.preventDefault();
                  addCourse();
                }
              },
              placeholder: "e.g., Data Structures",
              style: { flex: 1, padding: "8px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: addCourse, style: { padding: "8px 16px", background: "#0077B5", color: "white", border: "none", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Add" })
        ] }),
        formData.relevantCoursework && formData.relevantCoursework.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px" }, children: formData.relevantCoursework.map((course, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px", padding: "4px 8px", backgroundColor: "#f0f9ff", borderRadius: "4px", fontSize: "12px", color: "#0077B5" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: course }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: () => removeCourse(i), style: { padding: "0", background: "transparent", border: "none", color: "#0077B5", cursor: "pointer", fontSize: "14px", lineHeight: "1" }, children: "Ã—" })
        ] }, i)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", justifyContent: "flex-end" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: onCancel, style: { padding: "10px 16px", background: "white", color: "#6e6e73", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", style: { padding: "10px 16px", background: "#0077B5", color: "white", border: "none", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Add Education" })
      ] })
    ] });
  }
  content;
  function EducationCard({ education, onDelete }) {
    const formatDate = (dateStr) => {
      if (!dateStr) return "";
      const [year, month] = dateStr.split("-");
      const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      return `${monthNames[parseInt(month) - 1]} ${year}`;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { backgroundColor: "white", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "8px", padding: "14px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "flex-start" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "6px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "16px" }, children: "ðŸŽ“" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: 0 }, children: [
            education.degree,
            " in ",
            education.field
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "13px", color: "#6e6e73", marginBottom: "6px" }, children: [
          education.institution,
          " â€¢ ",
          education.location
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "12px", color: "#9ca3af", marginBottom: "8px" }, children: [
          formatDate(education.startDate),
          " - ",
          education.current ? "Present" : formatDate(education.endDate || ""),
          education.gpa && ` â€¢ GPA: ${education.gpa}`
        ] }),
        education.honors && education.honors.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "12px", fontWeight: "600", color: "#1d1d1f", marginBottom: "4px" }, children: "Honors:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "2px" }, children: education.honors.map((honor, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "12px", color: "#059669" }, children: [
            "â€¢ ",
            honor
          ] }, i)) })
        ] }),
        education.relevantCoursework && education.relevantCoursework.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "12px", fontWeight: "600", color: "#1d1d1f", marginBottom: "4px" }, children: "Relevant Coursework:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "11px", color: "#9ca3af" }, children: education.relevantCoursework.join(", ") })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onDelete, style: { padding: "6px", background: "transparent", border: "none", color: "#dc2626", cursor: "pointer", borderRadius: "4px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 14, strokeWidth: 2 }) })
    ] }) });
  }
  content;
  function ProjectForm({ onSave, onCancel }) {
    const [formData, setFormData] = reactExports.useState({
      name: "",
      description: "",
      bullets: [],
      technologies: [],
      links: {
        github: "",
        demo: "",
        youtube: "",
        website: "",
        other: ""
      },
      startDate: "",
      endDate: "",
      tags: []
    });
    const [techInput, setTechInput] = reactExports.useState("");
    const [tagInput, setTagInput] = reactExports.useState("");
    const handleSubmit = (e) => {
      e.preventDefault();
      if (!formData.name.trim() || !formData.description.trim()) return;
      onSave(formData);
    };
    const addTech = () => {
      if (!techInput.trim()) return;
      setFormData({ ...formData, technologies: [...formData.technologies, techInput.trim()] });
      setTechInput("");
    };
    const removeTech = (index2) => {
      setFormData({ ...formData, technologies: formData.technologies.filter((_, i) => i !== index2) });
    };
    const addTag = () => {
      if (!tagInput.trim()) return;
      setFormData({ ...formData, tags: [...formData.tags, tagInput.trim()] });
      setTagInput("");
    };
    const removeTag = (index2) => {
      setFormData({ ...formData, tags: formData.tags.filter((_, i) => i !== index2) });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, style: { backgroundColor: "white", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "8px", padding: "16px", marginBottom: "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 16px 0" }, children: "Add Project" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Project Name *" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.name,
            onChange: (e) => setFormData({ ...formData, name: e.target.value }),
            placeholder: "e.g., AI Resume Builder",
            required: true,
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Description *" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            value: formData.description,
            onChange: (e) => setFormData({ ...formData, description: e.target.value }),
            placeholder: "Brief 1-2 sentence description of the project",
            required: true,
            rows: 3,
            style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit", resize: "vertical" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Technologies Used" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: techInput,
              onChange: (e) => setTechInput(e.target.value),
              onKeyPress: (e) => {
                if (e.key === "Enter") {
                  e.preventDefault();
                  addTech();
                }
              },
              placeholder: "e.g., React, TypeScript",
              style: { flex: 1, padding: "8px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: addTech, style: { padding: "8px 16px", background: "#0077B5", color: "white", border: "none", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Add" })
        ] }),
        formData.technologies.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px" }, children: formData.technologies.map((tech, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px", padding: "4px 8px", backgroundColor: "#f0f9ff", borderRadius: "4px", fontSize: "12px", color: "#0077B5" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: tech }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: () => removeTech(i), style: { padding: "0", background: "transparent", border: "none", color: "#0077B5", cursor: "pointer", fontSize: "14px", lineHeight: "1" }, children: "Ã—" })
        ] }, i)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Links (optional)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "url",
              value: formData.links.github,
              onChange: (e) => setFormData({ ...formData, links: { ...formData.links, github: e.target.value } }),
              placeholder: "GitHub URL",
              style: { padding: "8px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "url",
              value: formData.links.demo,
              onChange: (e) => setFormData({ ...formData, links: { ...formData.links, demo: e.target.value } }),
              placeholder: "Live Demo URL",
              style: { padding: "8px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "url",
              value: formData.links.website,
              onChange: (e) => setFormData({ ...formData, links: { ...formData.links, website: e.target.value } }),
              placeholder: "Website URL",
              style: { padding: "8px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "url",
              value: formData.links.youtube,
              onChange: (e) => setFormData({ ...formData, links: { ...formData.links, youtube: e.target.value } }),
              placeholder: "YouTube URL",
              style: { padding: "8px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px", marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Start Date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "month",
              value: formData.startDate,
              onChange: (e) => setFormData({ ...formData, startDate: e.target.value }),
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "End Date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "month",
              value: formData.endDate,
              onChange: (e) => setFormData({ ...formData, endDate: e.target.value }),
              style: { width: "100%", padding: "10px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Tags" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "11px", color: "#6e6e73", margin: "0 0 8px 0" }, children: "e.g., open-source, hackathon, personal" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: tagInput,
              onChange: (e) => setTagInput(e.target.value),
              onKeyPress: (e) => {
                if (e.key === "Enter") {
                  e.preventDefault();
                  addTag();
                }
              },
              placeholder: "e.g., hackathon",
              style: { flex: 1, padding: "8px 12px", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontFamily: "inherit" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: addTag, style: { padding: "8px 16px", background: "#0077B5", color: "white", border: "none", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Add" })
        ] }),
        formData.tags.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px" }, children: formData.tags.map((tag, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px", padding: "4px 8px", backgroundColor: "#fef3c7", borderRadius: "4px", fontSize: "12px", color: "#f59e0b" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: tag }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: () => removeTag(i), style: { padding: "0", background: "transparent", border: "none", color: "#f59e0b", cursor: "pointer", fontSize: "14px", lineHeight: "1" }, children: "Ã—" })
        ] }, i)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", justifyContent: "flex-end" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick: onCancel, style: { padding: "10px 16px", background: "white", color: "#6e6e73", border: "1px solid rgba(0, 0, 0, 0.12)", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", style: { padding: "10px 16px", background: "#0077B5", color: "white", border: "none", borderRadius: "6px", fontSize: "13px", fontWeight: "600", cursor: "pointer" }, children: "Add Project" })
      ] })
    ] });
  }
  content;
  function ProjectCard({ project, onDelete }) {
    const formatDate = (dateStr) => {
      if (!dateStr) return "";
      const [year, month] = dateStr.split("-");
      const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      return `${monthNames[parseInt(month) - 1]} ${year}`;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { backgroundColor: "white", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "8px", padding: "14px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "flex-start" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "6px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "16px" }, children: "ðŸ’»" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "15px", fontWeight: "600", color: "#1d1d1f", margin: 0 }, children: project.name })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "13px", color: "#6e6e73", marginBottom: "8px", lineHeight: "1.4" }, children: project.description }),
        project.startDate && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "12px", color: "#9ca3af", marginBottom: "8px" }, children: [
          formatDate(project.startDate),
          " ",
          project.endDate && `- ${formatDate(project.endDate)}`
        ] }),
        project.technologies.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "4px", marginBottom: "8px" }, children: project.technologies.map((tech, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { padding: "3px 8px", backgroundColor: "#f0f9ff", color: "#0077B5", borderRadius: "4px", fontSize: "11px", fontWeight: "600" }, children: tech }, i)) }),
        project.tags.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "4px", marginBottom: "8px" }, children: project.tags.map((tag, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { padding: "3px 8px", backgroundColor: "#fef3c7", color: "#f59e0b", borderRadius: "4px", fontSize: "11px", fontWeight: "600" }, children: [
          "#",
          tag
        ] }, i)) }),
        (project.links.github || project.links.demo || project.links.website || project.links.youtube) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexWrap: "wrap", gap: "8px", marginTop: "8px" }, children: [
          project.links.github && /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: project.links.github, target: "_blank", rel: "noopener noreferrer", style: { fontSize: "11px", color: "#0077B5", textDecoration: "none", display: "flex", alignItems: "center", gap: "4px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "GitHub â†’" }) }),
          project.links.demo && /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: project.links.demo, target: "_blank", rel: "noopener noreferrer", style: { fontSize: "11px", color: "#0077B5", textDecoration: "none", display: "flex", alignItems: "center", gap: "4px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Demo â†’" }) }),
          project.links.website && /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: project.links.website, target: "_blank", rel: "noopener noreferrer", style: { fontSize: "11px", color: "#0077B5", textDecoration: "none", display: "flex", alignItems: "center", gap: "4px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Website â†’" }) }),
          project.links.youtube && /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: project.links.youtube, target: "_blank", rel: "noopener noreferrer", style: { fontSize: "11px", color: "#0077B5", textDecoration: "none", display: "flex", alignItems: "center", gap: "4px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Video â†’" }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onDelete, style: { padding: "6px", background: "transparent", border: "none", color: "#dc2626", cursor: "pointer", borderRadius: "4px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 14, strokeWidth: 2 }) })
    ] }) });
  }
  content;
  function EducationTab({ profile, onUpdate }) {
    const [activeSection, setActiveSection] = reactExports.useState("education");
    const [isAdding, setIsAdding] = reactExports.useState(false);
    const [editingId, setEditingId] = reactExports.useState(null);
    if (!profile) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "20px", textAlign: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GraduationCap, { size: 48, strokeWidth: 1.5, style: { color: "#d1d5db", margin: "0 auto 16px auto" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "14px", color: "#6e6e73", margin: 0 }, children: "Loading profile..." })
      ] });
    }
    const handleAddEducation = async (eduData) => {
      try {
        await addEducation(eduData);
        setIsAdding(false);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error adding education:", error);
      }
    };
    const handleDeleteEducation = async (id) => {
      if (!confirm("Delete this education entry?")) return;
      try {
        await deleteEducation(id);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error deleting education:", error);
      }
    };
    const handleAddProject = async (projectData) => {
      try {
        await addProject(projectData);
        setIsAdding(false);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error adding project:", error);
      }
    };
    const handleDeleteProject = async (id) => {
      if (!confirm("Delete this project?")) return;
      try {
        await deleteProject(id);
        onUpdate();
      } catch (error) {
        console.error("[Uproot] Error deleting project:", error);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "20px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "20px", padding: "4px", backgroundColor: "#f9fafb", borderRadius: "8px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SectionButton,
          {
            label: "Education",
            isActive: activeSection === "education",
            onClick: () => {
              setActiveSection("education");
              setIsAdding(false);
              setEditingId(null);
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SectionButton,
          {
            label: "Projects",
            isActive: activeSection === "projects",
            onClick: () => {
              setActiveSection("projects");
              setIsAdding(false);
              setEditingId(null);
            }
          }
        )
      ] }),
      activeSection === "education" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !isAdding && !editingId && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => setIsAdding(true),
            style: {
              width: "100%",
              padding: "12px",
              background: "white",
              color: "#0077B5",
              border: "1px dashed rgba(0, 119, 181, 0.3)",
              borderRadius: "8px",
              fontSize: "13px",
              fontWeight: "600",
              cursor: "pointer",
              marginBottom: "16px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "8px",
              transition: "all 0.2s"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { size: 16, strokeWidth: 2 }),
              "Add Education"
            ]
          }
        ),
        isAdding && /* @__PURE__ */ jsxRuntimeExports.jsx(EducationForm, { onSave: handleAddEducation, onCancel: () => setIsAdding(false) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: profile.education.map((edu) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          EducationCard,
          {
            education: edu,
            onDelete: () => handleDeleteEducation(edu.id)
          },
          edu.id
        )) }),
        profile.education.length === 0 && !isAdding && /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, { message: "No education added yet. Add your degrees and certifications!" })
      ] }),
      activeSection === "projects" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !isAdding && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => setIsAdding(true),
            style: {
              width: "100%",
              padding: "12px",
              background: "white",
              color: "#0077B5",
              border: "1px dashed rgba(0, 119, 181, 0.3)",
              borderRadius: "8px",
              fontSize: "13px",
              fontWeight: "600",
              cursor: "pointer",
              marginBottom: "16px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "8px"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { size: 16, strokeWidth: 2 }),
              "Add Project"
            ]
          }
        ),
        isAdding && /* @__PURE__ */ jsxRuntimeExports.jsx(ProjectForm, { onSave: handleAddProject, onCancel: () => setIsAdding(false) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: profile.projects.map((project) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          ProjectCard,
          {
            project,
            onDelete: () => handleDeleteProject(project.id)
          },
          project.id
        )) }),
        profile.projects.length === 0 && !isAdding && /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyState, { message: "No projects added yet. Showcase your work and side projects!" })
      ] })
    ] });
  }
  content;
  function GenerateTab({ profile }) {
    const [step, setStep] = reactExports.useState("input");
    const [jobTitle, setJobTitle] = reactExports.useState("");
    const [company, setCompany] = reactExports.useState("");
    const [jobDescription, setJobDescription] = reactExports.useState("");
    const [isAnalyzing, setIsAnalyzing] = reactExports.useState(false);
    const [isGenerating, setIsGenerating] = reactExports.useState(false);
    const [error, setError] = reactExports.useState("");
    const [analysis, setAnalysis] = reactExports.useState(null);
    const [generatedResume, setGeneratedResume] = reactExports.useState(null);
    const handleReset = () => {
      setStep("input");
      setJobTitle("");
      setCompany("");
      setJobDescription("");
      setError("");
      setAnalysis(null);
      setGeneratedResume(null);
    };
    const handleAnalyzeJob = async () => {
      if (!jobTitle.trim() || !company.trim() || !jobDescription.trim()) {
        setError("Please fill in all fields");
        return;
      }
      setIsAnalyzing(true);
      setError("");
      try {
        const { extractKeywordsFromJobDescription: extractKeywordsFromJobDescription2, categorizeJobRequirements: categorizeJobRequirements2 } = await Promise.resolve().then(() => keywordExtractor);
        const extractedKeywords = extractKeywordsFromJobDescription2(jobDescription);
        const { required, preferred } = categorizeJobRequirements2(jobDescription);
        const jobAnalysis = {
          id: `job_${Date.now()}`,
          rawText: jobDescription,
          jobTitle,
          company,
          extractedKeywords,
          requiredSkills: required,
          preferredSkills: preferred,
          analyzedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        setAnalysis(jobAnalysis);
        setStep("analysis");
      } catch (err) {
        console.error("[Uproot] Error analyzing job:", err);
        setError("Failed to analyze job description. Please try again.");
      } finally {
        setIsAnalyzing(false);
      }
    };
    const handleGenerateResume = async () => {
      if (!analysis) return;
      setIsGenerating(true);
      setError("");
      try {
        const { generateResumeWithAI: generateResumeWithAI2 } = await Promise.resolve().then(() => aiResumeGenerator);
        const resume = await generateResumeWithAI2(analysis, profile);
        setGeneratedResume(resume);
        setStep("generated");
      } catch (err) {
        console.error("[Uproot] Error generating resume:", err);
        setError("Failed to generate resume. Please try again.");
      } finally {
        setIsGenerating(false);
      }
    };
    const handleCopyToClipboard = () => {
      if (!generatedResume) return;
      const resumeText = formatResumeForClipboard(generatedResume);
      navigator.clipboard.writeText(resumeText).then(() => {
        alert("Resume copied to clipboard!");
      });
    };
    const formatResumeForClipboard = (resume) => {
      const { content: content2 } = resume;
      let text = "";
      if (content2.professionalSummary) {
        text += `${content2.professionalSummary}

`;
      }
      if (content2.technicalSkills && content2.technicalSkills.length > 0) {
        text += "TECHNICAL SKILLS\n";
        text += content2.technicalSkills.join(" â€¢ ") + "\n\n";
      }
      if (content2.experience && content2.experience.length > 0) {
        text += "EXPERIENCE\n\n";
        content2.experience.forEach((exp) => {
          text += `${exp.title} | ${exp.company}
`;
          text += `${exp.startDate} - ${exp.endDate || "Present"}${exp.location ? ` | ${exp.location}` : ""}
`;
          if (exp.bullets && exp.bullets.length > 0) {
            exp.bullets.forEach((bullet) => {
              text += `â€¢ ${bullet.text}
`;
            });
          }
          text += "\n";
        });
      }
      if (content2.education && content2.education.length > 0) {
        text += "EDUCATION\n\n";
        content2.education.forEach((edu) => {
          text += `${edu.degree} in ${edu.field}
`;
          text += `${edu.institution}${edu.location ? ` | ${edu.location}` : ""}
`;
          text += `${edu.startDate} - ${edu.endDate || "Present"}${edu.gpa ? ` | GPA: ${edu.gpa}` : ""}

`;
        });
      }
      if (content2.projects && content2.projects.length > 0) {
        text += "PROJECTS\n\n";
        content2.projects.forEach((proj) => {
          text += `${proj.name}
`;
          if (proj.description) {
            text += `${proj.description}
`;
          }
          if (proj.technologies && proj.technologies.length > 0) {
            text += `Technologies: ${proj.technologies.join(", ")}
`;
          }
          text += "\n";
        });
      }
      return text;
    };
    const getATSScoreStyle = (score) => {
      if (score >= 80) return { color: "#34C759", label: "Excellent" };
      if (score >= 65) return { color: "#0077B5", label: "Good" };
      if (score >= 50) return { color: "#FF9500", label: "Needs Work" };
      return { color: "#FF3B30", label: "Poor" };
    };
    if (step === "input") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
            @keyframes spin {
              from { transform: rotate(0deg); }
              to { transform: rotate(360deg); }
            }
          ` }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "20px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "20px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 20, strokeWidth: 2, style: { color: "#0077B5" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "16px", fontWeight: "600", color: "#1d1d1f", margin: 0 }, children: "Generate ATS-Optimized Resume" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "13px", color: "#6e6e73", margin: 0 }, children: "Paste a job description to generate a tailored resume with ATS optimization" })
          ] }),
          error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            padding: "12px",
            backgroundColor: "#fef2f2",
            border: "1px solid #fecaca",
            borderRadius: "8px",
            marginBottom: "16px"
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "13px", color: "#dc2626", margin: 0 }, children: error }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Job Title *" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: jobTitle,
                onChange: (e) => setJobTitle(e.target.value),
                placeholder: "e.g., Senior Software Engineer",
                style: {
                  width: "100%",
                  padding: "10px 12px",
                  border: "1px solid rgba(0, 0, 0, 0.12)",
                  borderRadius: "6px",
                  fontSize: "14px",
                  fontFamily: "inherit"
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Company *" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: company,
                onChange: (e) => setCompany(e.target.value),
                placeholder: "e.g., Google",
                style: {
                  width: "100%",
                  padding: "10px 12px",
                  border: "1px solid rgba(0, 0, 0, 0.12)",
                  borderRadius: "6px",
                  fontSize: "14px",
                  fontFamily: "inherit"
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { display: "block", fontSize: "13px", fontWeight: "600", color: "#1d1d1f", marginBottom: "6px" }, children: "Job Description *" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "textarea",
              {
                value: jobDescription,
                onChange: (e) => setJobDescription(e.target.value),
                placeholder: "Paste the full job description here...",
                rows: 12,
                style: {
                  width: "100%",
                  padding: "12px",
                  border: "1px solid rgba(0, 0, 0, 0.12)",
                  borderRadius: "6px",
                  fontSize: "13px",
                  fontFamily: "inherit",
                  resize: "vertical",
                  lineHeight: "1.5"
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: "12px", color: "#6e6e73", margin: "6px 0 0 0" }, children: [
              jobDescription.length,
              " characters"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleAnalyzeJob,
              disabled: isAnalyzing,
              style: {
                width: "100%",
                padding: "14px 16px",
                background: isAnalyzing ? "#d1d5db" : "#0077B5",
                color: "white",
                border: "none",
                borderRadius: "8px",
                fontSize: "14px",
                fontWeight: "600",
                cursor: isAnalyzing ? "not-allowed" : "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "8px",
                transition: "background 0.2s"
              },
              onMouseEnter: (e) => {
                if (!isAnalyzing) e.currentTarget.style.background = "#006399";
              },
              onMouseLeave: (e) => {
                if (!isAnalyzing) e.currentTarget.style.background = "#0077B5";
              },
              children: isAnalyzing ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 18, strokeWidth: 2, style: { animation: "spin 1s linear infinite" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Analyzing..." })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 18, strokeWidth: 2 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Analyze Job Description" })
              ] })
            }
          )
        ] })
      ] });
    }
    if (step === "analysis" && analysis) {
      const topKeywords = analysis.extractedKeywords.filter((k) => k.importance > 0.3).slice(0, 15);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
            @keyframes spin {
              from { transform: rotate(0deg); }
              to { transform: rotate(360deg); }
            }
          ` }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "20px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "20px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "8px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 20, strokeWidth: 2, style: { color: "#34C759" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "16px", fontWeight: "600", color: "#1d1d1f", margin: 0 }, children: "Analysis Complete" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: handleReset,
                  style: {
                    padding: "6px 12px",
                    background: "white",
                    color: "#6e6e73",
                    border: "1px solid rgba(0, 0, 0, 0.12)",
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: "pointer"
                  },
                  children: "Start Over"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: "13px", color: "#6e6e73", margin: 0 }, children: [
              analysis.jobTitle,
              " at ",
              analysis.company
            ] })
          ] }),
          error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            padding: "12px",
            backgroundColor: "#fef2f2",
            border: "1px solid #fecaca",
            borderRadius: "8px",
            marginBottom: "16px"
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "13px", color: "#dc2626", margin: 0 }, children: error }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "20px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { style: { fontSize: "14px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 10px 0" }, children: [
              "Top Keywords Extracted (",
              analysis.extractedKeywords.length,
              " total)"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px" }, children: topKeywords.map((keyword, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                style: {
                  padding: "6px 10px",
                  backgroundColor: keyword.category === "technical-skill" ? "rgba(0, 119, 181, 0.1)" : keyword.category === "soft-skill" ? "rgba(52, 199, 89, 0.1)" : "rgba(0, 0, 0, 0.05)",
                  color: keyword.category === "technical-skill" ? "#0077B5" : keyword.category === "soft-skill" ? "#34C759" : "#1d1d1f",
                  borderRadius: "6px",
                  fontSize: "12px",
                  fontWeight: "500"
                },
                children: keyword.keyword
              },
              index2
            )) })
          ] }),
          analysis.requiredSkills.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "20px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { style: { fontSize: "14px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 10px 0" }, children: [
              "Required Skills (",
              analysis.requiredSkills.length,
              ")"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px" }, children: analysis.requiredSkills.map((skill, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                style: {
                  padding: "6px 10px",
                  backgroundColor: "#fef2f2",
                  color: "#dc2626",
                  borderRadius: "6px",
                  fontSize: "12px",
                  fontWeight: "500",
                  border: "1px solid #fecaca"
                },
                children: skill
              },
              index2
            )) })
          ] }),
          analysis.preferredSkills.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "20px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { style: { fontSize: "14px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 10px 0" }, children: [
              "Preferred Skills (",
              analysis.preferredSkills.length,
              ")"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px" }, children: analysis.preferredSkills.map((skill, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                style: {
                  padding: "6px 10px",
                  backgroundColor: "rgba(0, 119, 181, 0.05)",
                  color: "#0077B5",
                  borderRadius: "6px",
                  fontSize: "12px",
                  fontWeight: "500",
                  border: "1px solid rgba(0, 119, 181, 0.2)"
                },
                children: skill
              },
              index2
            )) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleGenerateResume,
              disabled: isGenerating,
              style: {
                width: "100%",
                padding: "14px 16px",
                background: isGenerating ? "#d1d5db" : "#0077B5",
                color: "white",
                border: "none",
                borderRadius: "8px",
                fontSize: "14px",
                fontWeight: "600",
                cursor: isGenerating ? "not-allowed" : "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "8px",
                transition: "background 0.2s"
              },
              onMouseEnter: (e) => {
                if (!isGenerating) e.currentTarget.style.background = "#006399";
              },
              onMouseLeave: (e) => {
                if (!isGenerating) e.currentTarget.style.background = "#0077B5";
              },
              children: isGenerating ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 18, strokeWidth: 2, style: { animation: "spin 1s linear infinite" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Generating Resume..." })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 18, strokeWidth: 2 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Generate Optimized Resume" })
              ] })
            }
          )
        ] })
      ] });
    }
    if (step === "generated" && generatedResume) {
      const atsScore = generatedResume.atsOptimization.overallATSScore;
      const scoreStyle = getATSScoreStyle(atsScore);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "20px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "20px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "8px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 20, strokeWidth: 2, style: { color: "#0077B5" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "16px", fontWeight: "600", color: "#1d1d1f", margin: 0 }, children: "Resume Generated" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: handleReset,
                style: {
                  padding: "6px 12px",
                  background: "white",
                  color: "#6e6e73",
                  border: "1px solid rgba(0, 0, 0, 0.12)",
                  borderRadius: "6px",
                  fontSize: "12px",
                  fontWeight: "600",
                  cursor: "pointer"
                },
                children: "New Resume"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: "13px", color: "#6e6e73", margin: 0 }, children: [
            generatedResume.jobTitle,
            " at ",
            generatedResume.company
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          padding: "16px",
          backgroundColor: "white",
          border: `2px solid ${scoreStyle.color}`,
          borderRadius: "12px",
          marginBottom: "20px"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "12px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { style: { fontSize: "14px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 4px 0" }, children: "ATS Compatibility Score" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: "12px", color: "#6e6e73", margin: 0 }, children: [
                generatedResume.atsOptimization.keywordsUsed.length,
                " of ",
                generatedResume.atsOptimization.totalKeywords,
                " keywords matched"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "right" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "32px", fontWeight: "700", color: scoreStyle.color }, children: atsScore }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "12px", fontWeight: "600", color: scoreStyle.color }, children: scoreStyle.label })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: "12px", paddingTop: "12px", borderTop: "1px solid rgba(0, 0, 0, 0.08)" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "11px", color: "#6e6e73", marginBottom: "2px" }, children: "Match Rate" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "14px", fontWeight: "600", color: "#1d1d1f" }, children: [
                Math.round(generatedResume.atsOptimization.keywordMatchRate),
                "%"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "11px", color: "#6e6e73", marginBottom: "2px" }, children: "Format" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "14px", fontWeight: "600", color: "#1d1d1f" }, children: [
                generatedResume.atsOptimization.formatCompliance.score,
                "%"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "11px", color: "#6e6e73", marginBottom: "2px" }, children: "Quality" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "14px", fontWeight: "600", color: "#1d1d1f" }, children: [
                generatedResume.atsOptimization.contentQuality.score,
                "%"
              ] })
            ] })
          ] })
        ] }),
        generatedResume.atsOptimization.recommendations.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "20px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { style: { fontSize: "14px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 10px 0" }, children: "Optimization Tips" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: generatedResume.atsOptimization.recommendations.slice(0, 5).map((rec, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                padding: "10px 12px",
                backgroundColor: rec.startsWith("âœ…") ? "rgba(52, 199, 89, 0.05)" : rec.startsWith("âŒ") ? "rgba(220, 38, 38, 0.05)" : "rgba(255, 149, 0, 0.05)",
                borderLeft: `3px solid ${rec.startsWith("âœ…") ? "#34C759" : rec.startsWith("âŒ") ? "#dc2626" : "#FF9500"}`,
                borderRadius: "6px",
                fontSize: "12px",
                color: "#1d1d1f",
                lineHeight: "1.5"
              },
              children: rec
            },
            index2
          )) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "20px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { style: { fontSize: "14px", fontWeight: "600", color: "#1d1d1f", margin: "0 0 10px 0" }, children: "Resume Content" }),
          generatedResume.professionalSummary && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { style: { fontSize: "13px", fontWeight: "600", color: "#0077B5", margin: "0 0 6px 0", textTransform: "uppercase" }, children: "Professional Summary" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "13px", color: "#1d1d1f", margin: 0, lineHeight: "1.6" }, children: generatedResume.professionalSummary })
          ] }),
          generatedResume.selectedExperiences && generatedResume.selectedExperiences.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h5", { style: { fontSize: "13px", fontWeight: "600", color: "#0077B5", margin: "0 0 10px 0", textTransform: "uppercase" }, children: [
              "Experience (",
              generatedResume.selectedExperiences.length,
              ")"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: [
              generatedResume.selectedExperiences.slice(0, 3).map((exp, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { paddingLeft: "12px", borderLeft: "2px solid rgba(0, 119, 181, 0.2)" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "13px", fontWeight: "600", color: "#1d1d1f" }, children: [
                  exp.title,
                  " â€¢ ",
                  exp.company
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "11px", color: "#6e6e73", marginBottom: "6px" }, children: [
                  exp.selectedBullets.length,
                  " bullet",
                  exp.selectedBullets.length !== 1 ? "s" : "",
                  " selected â€¢ ",
                  Math.round(exp.relevanceScore * 100),
                  "% match"
                ] })
              ] }, index2)),
              generatedResume.selectedExperiences.length > 3 && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: "12px", color: "#6e6e73", margin: 0 }, children: [
                "+",
                generatedResume.selectedExperiences.length - 3,
                " more"
              ] })
            ] })
          ] }),
          generatedResume.selectedSkills && generatedResume.selectedSkills.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h5", { style: { fontSize: "13px", fontWeight: "600", color: "#0077B5", margin: "0 0 8px 0", textTransform: "uppercase" }, children: [
              "Skills (",
              generatedResume.selectedSkills.length,
              ")"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px" }, children: [
              generatedResume.selectedSkills.slice(0, 12).map((skill, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  style: {
                    padding: "4px 8px",
                    backgroundColor: "rgba(0, 119, 181, 0.1)",
                    color: "#0077B5",
                    borderRadius: "4px",
                    fontSize: "11px",
                    fontWeight: "500"
                  },
                  children: skill
                },
                index2
              )),
              generatedResume.selectedSkills.length > 12 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: "11px", color: "#6e6e73", alignSelf: "center" }, children: [
                "+",
                generatedResume.selectedSkills.length - 12,
                " more"
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: handleCopyToClipboard,
            style: {
              width: "100%",
              padding: "14px 16px",
              background: "#34C759",
              color: "white",
              border: "none",
              borderRadius: "8px",
              fontSize: "14px",
              fontWeight: "600",
              cursor: "pointer",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "8px",
              transition: "background 0.2s"
            },
            onMouseEnter: (e) => {
              e.currentTarget.style.background = "#2fb350";
            },
            onMouseLeave: (e) => {
              e.currentTarget.style.background = "#34C759";
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { size: 18, strokeWidth: 2 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Copy Resume to Clipboard" })
            ]
          }
        )
      ] });
    }
    return null;
  }
  content;
  function ResumeTab({ panelWidth = 400 }) {
    const [activeSubTab, setActiveSubTab] = reactExports.useState("experience");
    const [profile, setProfile] = reactExports.useState(null);
    const [isLoading, setIsLoading] = reactExports.useState(true);
    reactExports.useEffect(() => {
      loadProfile();
    }, []);
    const loadProfile = async () => {
      setIsLoading(true);
      try {
        const profileData = await getProfessionalProfile();
        setProfile(profileData);
      } catch (error) {
        console.error("[Uproot] Error loading profile:", error);
      } finally {
        setIsLoading(false);
      }
    };
    if (isLoading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            color: "#6e6e73",
            flexDirection: "column",
            gap: "12px"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 32, className: "animate-spin", strokeWidth: 2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "14px", fontWeight: "500" }, children: "Loading profile..." })
          ]
        }
      );
    }
    if (!profile) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            padding: "40px 20px",
            gap: "16px"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "#991B1B", fontSize: "14px", fontWeight: "600", margin: 0 }, children: "Unable to load your profile" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: loadProfile,
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "8px",
                  padding: "10px 16px",
                  backgroundColor: "#0077B5",
                  color: "white",
                  border: "none",
                  borderRadius: "8px",
                  fontSize: "14px",
                  fontWeight: "600",
                  cursor: "pointer",
                  transition: "background-color 150ms"
                },
                onMouseEnter: (e) => {
                  e.currentTarget.style.backgroundColor = "#005885";
                },
                onMouseLeave: (e) => {
                  e.currentTarget.style.backgroundColor = "#0077B5";
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 16 }),
                  "Try Again"
                ]
              }
            )
          ]
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "hidden"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: "20px 20px 16px 20px",
                borderBottom: "1px solid rgba(0, 0, 0, 0.08)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "h2",
                  {
                    style: {
                      fontSize: "20px",
                      fontWeight: "700",
                      margin: "0 0 4px 0",
                      color: "#1d1d1f"
                    },
                    children: "Professional Profile"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "p",
                  {
                    style: {
                      fontSize: "13px",
                      color: "#6e6e73",
                      margin: 0
                    },
                    children: "Optional: Build your career database for AI resume generation"
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                padding: panelWidth < 360 ? "12px" : "16px",
                borderBottom: "1px solid rgba(0, 0, 0, 0.08)",
                backgroundColor: "rgba(0, 119, 181, 0.03)"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: panelWidth < 360 ? "4px" : "8px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SubTabButton,
                  {
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: 14, strokeWidth: 2 }),
                    label: "Experience",
                    isActive: activeSubTab === "experience",
                    onClick: () => setActiveSubTab("experience"),
                    panelWidth
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SubTabButton,
                  {
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Code, { size: 14, strokeWidth: 2 }),
                    label: "Skills",
                    isActive: activeSubTab === "skills",
                    onClick: () => setActiveSubTab("skills"),
                    panelWidth
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SubTabButton,
                  {
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(GraduationCap, { size: 14, strokeWidth: 2 }),
                    label: "Education",
                    isActive: activeSubTab === "education",
                    onClick: () => setActiveSubTab("education"),
                    panelWidth
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SubTabButton,
                  {
                    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 14, strokeWidth: 2 }),
                    label: "Generate",
                    isActive: activeSubTab === "generate",
                    onClick: () => setActiveSubTab("generate"),
                    panelWidth
                  }
                )
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, overflow: "auto" }, children: [
            activeSubTab === "experience" && /* @__PURE__ */ jsxRuntimeExports.jsx(ExperienceTab, { profile, onUpdate: loadProfile }),
            activeSubTab === "skills" && /* @__PURE__ */ jsxRuntimeExports.jsx(SkillsTab, { profile, onUpdate: loadProfile }),
            activeSubTab === "education" && /* @__PURE__ */ jsxRuntimeExports.jsx(EducationTab, { profile, onUpdate: loadProfile }),
            activeSubTab === "generate" && /* @__PURE__ */ jsxRuntimeExports.jsx(GenerateTab, { profile })
          ] })
        ]
      }
    );
  }
  content;
  function calculateATSScore(content2, extractedKeywords, jobKeywords) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "calculateATSScore", {
      contentLength: content2.length,
      extractedKeywords: extractedKeywords.length,
      jobKeywords: jobKeywords.length
    });
    try {
      log$1.debug(LogCategory.SERVICE, "Starting ATS score calculation", {
        resumeWordCount: content2.split(/\s+/).length,
        jobKeywordsToMatch: jobKeywords.length
      });
      log$1.debug(LogCategory.SERVICE, "Analyzing keyword matches");
      const keywordsUsed = findKeywordsInContent(content2, jobKeywords);
      const keywordMatchRate = jobKeywords.length > 0 ? keywordsUsed.length / jobKeywords.length * 100 : 0;
      const totalWords = content2.split(/\s+/).length;
      const keywordDensity = totalWords > 0 ? keywordsUsed.length / totalWords * 100 : 0;
      log$1.info(LogCategory.SERVICE, "Keyword analysis complete", {
        keywordsUsed: keywordsUsed.length,
        matchRate: `${keywordMatchRate.toFixed(1)}%`,
        density: `${keywordDensity.toFixed(2)}%`
      });
      log$1.debug(LogCategory.SERVICE, "Checking format compliance");
      const formatCompliance = checkFormatCompliance(content2);
      log$1.info(LogCategory.SERVICE, "Format compliance checked", {
        score: formatCompliance.score,
        issues: Object.entries(formatCompliance).filter(([k, v]) => k !== "score" && v === false).map(([k]) => k)
      });
      log$1.debug(LogCategory.SERVICE, "Checking content quality");
      const contentQuality = checkContentQuality(content2);
      log$1.info(LogCategory.SERVICE, "Content quality checked", {
        score: contentQuality.score,
        hasMetrics: contentQuality.hasMetrics,
        usesActionVerbs: contentQuality.usesActionVerbs,
        aprFormatUsed: contentQuality.aprFormatUsed
      });
      log$1.debug(LogCategory.SERVICE, "Calculating overall ATS score (weighted average)");
      const overallATSScore = Math.round(
        keywordMatchRate * 0.4 + // 40% weight on keyword matching
        formatCompliance.score * 0.3 + // 30% weight on format
        contentQuality.score * 0.3
        // 30% weight on content quality
      );
      log$1.info(LogCategory.SERVICE, "Overall ATS score calculated", {
        score: overallATSScore,
        breakdown: {
          keywords: `${keywordMatchRate.toFixed(1)}% (40% weight)`,
          format: `${formatCompliance.score} (30% weight)`,
          quality: `${contentQuality.score} (30% weight)`
        }
      });
      log$1.debug(LogCategory.SERVICE, "Generating recommendations");
      const recommendations = generateRecommendations$1({
        keywordMatchRate,
        keywordDensity,
        formatCompliance,
        contentQuality
      });
      log$1.info(LogCategory.SERVICE, `Generated ${recommendations.length} recommendations`);
      const result2 = {
        keywordDensity,
        keywordMatchRate,
        totalKeywords: extractedKeywords.length,
        keywordsUsed,
        formatCompliance,
        contentQuality,
        overallATSScore,
        recommendations
      };
      log$1.info(LogCategory.SERVICE, "ATS score calculation completed", {
        overallScore: overallATSScore,
        recommendationsCount: recommendations.length
      });
      endTrace(result2);
      return result2;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "ATS score calculation failed", error);
      endTrace();
      throw error;
    }
  }
  function findKeywordsInContent(content2, keywords) {
    const found = [];
    for (const keyword of keywords) {
      const lowerKeyword = keyword.toLowerCase();
      const regex = new RegExp(`\\b${escapeRegex$1(lowerKeyword)}\\b`, "i");
      if (regex.test(content2)) {
        found.push(keyword);
      }
    }
    return found;
  }
  function escapeRegex$1(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function checkFormatCompliance(content2) {
    const checks = {
      singleColumn: true,
      // Assume true if content is plain text
      noHeadersFooters: true,
      // Assume true for plain text
      standardFont: true,
      // Assume true for plain text
      noGraphics: !content2.match(/\[image\]|\[graphic\]|\[photo\]/i),
      noTables: !content2.match(/\|.*\||\t.*\t/)
      // Simple table detection
    };
    let score = 0;
    score += 20;
    score += 20;
    score += 20;
    if (checks.noGraphics) score += 20;
    if (checks.noTables) score += 20;
    return {
      ...checks,
      score
    };
  }
  function checkContentQuality(content2) {
    const bullets = extractBullets(content2);
    const bulletsWithMetrics = bullets.filter(
      (bullet) => hasQuantifiableMetric(bullet)
    );
    const hasMetrics = bulletsWithMetrics.length >= bullets.length * 0.7;
    const usesActionVerbs = checkActionVerbs(bullets);
    const aprFormatUsed = checkAPRFormat(bullets);
    const bulletLengths = bullets.map((b) => b.split(/\s+/).length);
    const avgLength = bulletLengths.length > 0 ? bulletLengths.reduce((a, b) => a + b, 0) / bulletLengths.length : 0;
    const averageBulletLength = Math.round(avgLength);
    let score = 0;
    if (hasMetrics) score += 30;
    if (usesActionVerbs) score += 30;
    if (aprFormatUsed) score += 25;
    if (averageBulletLength >= 15 && averageBulletLength <= 20) {
      score += 15;
    } else if (averageBulletLength >= 10 && averageBulletLength <= 25) {
      score += 10;
    } else if (averageBulletLength > 0) {
      score += 5;
    }
    return {
      hasMetrics,
      usesActionVerbs,
      aprFormatUsed,
      averageBulletLength,
      score
    };
  }
  function extractBullets(content2) {
    const bullets = [];
    const lines = content2.split("\n");
    for (const line of lines) {
      const trimmed = line.trim();
      if (/^[â€¢\-*]/.test(trimmed)) {
        bullets.push(trimmed.replace(/^[â€¢\-*]\s*/, ""));
      }
    }
    return bullets;
  }
  function hasQuantifiableMetric(text) {
    const patterns = [
      /\d+%/,
      // Percentages: 40%, 2.5%
      /\$[\d,]+/,
      // Dollar amounts: $2M, $50,000
      /\d+[KMB]/,
      // Abbreviated numbers: 50K, 2M, 1B
      /\d+[\s-]?(users|people|members|customers|clients)/i,
      /\d+x/,
      // Multipliers: 2x, 10x
      /\d+[\s-]?(seconds|minutes|hours|days|weeks|months|years)/i,
      /increased|decreased|improved|reduced.*?\d+/i
    ];
    return patterns.some((pattern) => pattern.test(text));
  }
  function checkActionVerbs(bullets) {
    if (bullets.length === 0) return false;
    const strongVerbs = [
      // Leadership
      "led",
      "managed",
      "directed",
      "orchestrated",
      "spearheaded",
      "championed",
      "coordinated",
      "supervised",
      "mentored",
      "coached",
      "trained",
      // Achievement
      "achieved",
      "exceeded",
      "surpassed",
      "outperformed",
      "delivered",
      "generated",
      "produced",
      "increased",
      "improved",
      "enhanced",
      "optimized",
      "boosted",
      "accelerated",
      "maximized",
      // Innovation
      "pioneered",
      "innovated",
      "designed",
      "launched",
      "created",
      "developed",
      "engineered",
      "architected",
      "transformed",
      "revolutionized",
      // Problem-solving
      "resolved",
      "streamlined",
      "simplified",
      "restructured",
      "overhauled",
      "diagnosed",
      "analyzed",
      "evaluated",
      // Technical
      "implemented",
      "deployed",
      "automated",
      "integrated",
      "programmed",
      "coded",
      "built",
      "configured",
      "migrated"
    ];
    const bulletsWithStrongVerbs = bullets.filter((bullet) => {
      const firstWord = bullet.split(/\s+/)[0].toLowerCase();
      return strongVerbs.includes(firstWord);
    });
    return bulletsWithStrongVerbs.length >= bullets.length * 0.6;
  }
  function checkAPRFormat(bullets) {
    if (bullets.length === 0) return false;
    const bulletsWithAPR = bullets.filter((bullet) => {
      const hasAction = /^[A-Z][a-z]+/.test(bullet);
      const hasProject = bullet.split(/\s+/).length >= 10;
      const hasResult = hasQuantifiableMetric(bullet) || /resulting in|leading to|which|thereby/i.test(bullet);
      return hasAction && hasProject && hasResult;
    });
    return bulletsWithAPR.length >= bullets.length * 0.5;
  }
  function generateRecommendations$1(analysis) {
    const recommendations = [];
    if (analysis.keywordMatchRate < 65) {
      recommendations.push(
        `âŒ Low keyword match (${Math.round(analysis.keywordMatchRate)}%). Add more keywords from job description.`
      );
    } else if (analysis.keywordMatchRate < 75) {
      recommendations.push(
        `âš ï¸ Keyword match could be better (${Math.round(analysis.keywordMatchRate)}%). Target 75-80%.`
      );
    } else {
      recommendations.push(
        `âœ… Excellent keyword match (${Math.round(analysis.keywordMatchRate)}%)!`
      );
    }
    if (analysis.keywordDensity < 2) {
      recommendations.push("âš ï¸ Keyword density too low. Naturally incorporate more relevant keywords.");
    } else if (analysis.keywordDensity > 3.5) {
      recommendations.push("âš ï¸ Keyword density too high. Avoid keyword stuffing.");
    }
    if (!analysis.formatCompliance.noTables) {
      recommendations.push("âŒ Remove tables - they confuse ATS parsers.");
    }
    if (!analysis.formatCompliance.noGraphics) {
      recommendations.push("âŒ Remove graphics/images - ATS cannot read them.");
    }
    if (!analysis.contentQuality.hasMetrics) {
      recommendations.push("âŒ Add quantifiable metrics to at least 70% of bullets (numbers, %, $, timeframes).");
    }
    if (!analysis.contentQuality.usesActionVerbs) {
      recommendations.push("âš ï¸ Use stronger action verbs (led, achieved, increased, etc.).");
    }
    if (!analysis.contentQuality.aprFormatUsed) {
      recommendations.push("âš ï¸ Use APR format: Action + Project + Result for better impact.");
    }
    const { averageBulletLength } = analysis.contentQuality;
    if (averageBulletLength < 10) {
      recommendations.push("âš ï¸ Bullets too short. Add more context (15-20 words ideal).");
    } else if (averageBulletLength > 25) {
      recommendations.push("âš ï¸ Bullets too long. Condense to 15-20 words for readability.");
    }
    if (recommendations.length === 1 && recommendations[0].startsWith("âœ…")) {
      recommendations.push("âœ… Format compliance looks great!");
      recommendations.push("âœ… Content quality is excellent!");
    }
    return recommendations;
  }
  function getATSScoreLevel(score) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "getATSScoreLevel", { score });
    try {
      let result2;
      if (score >= 80) {
        result2 = { level: "excellent", color: "#34C759", label: "Excellent" };
      } else if (score >= 65) {
        result2 = { level: "good", color: "#0077B5", label: "Good" };
      } else if (score >= 50) {
        result2 = { level: "fair", color: "#FF9500", label: "Needs Work" };
      } else {
        result2 = { level: "poor", color: "#FF3B30", label: "Poor" };
      }
      log$1.debug(LogCategory.SERVICE, "ATS score level determined", {
        score,
        level: result2.level,
        label: result2.label
      });
      endTrace(result2);
      return result2;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "ATS score level determination failed", error);
      endTrace();
      throw error;
    }
  }
  content;
  async function generateResumeWithAI(job, profile) {
    return log$1.trackAsync(LogCategory.SERVICE, "generateResumeWithAI", async () => {
      console.log("[Uproot] Generating resume for:", job.jobTitle, "at", job.company);
      log$1.debug(LogCategory.SERVICE, "Starting resume generation", {
        jobTitle: job.jobTitle,
        company: job.company,
        jobKeywords: job.extractedKeywords.length,
        profileJobs: profile.jobs.length,
        profileSkills: profile.technicalSkills.length
      });
      log$1.debug(LogCategory.SERVICE, "Selecting relevant experiences");
      const relevantJobs = selectRelevantExperiences(profile, job);
      log$1.info(LogCategory.SERVICE, `Selected ${relevantJobs.length} most relevant experiences`);
      log$1.debug(LogCategory.SERVICE, "Selecting matching skills");
      const relevantSkills = selectRelevantSkills(profile, job);
      log$1.info(LogCategory.SERVICE, `Selected ${relevantSkills.length} matching skills`);
      log$1.debug(LogCategory.SERVICE, "Generating professional summary");
      const professionalSummary = await generateProfessionalSummary(profile, job);
      log$1.info(LogCategory.SERVICE, "Professional summary generated", { length: professionalSummary.length });
      log$1.debug(LogCategory.SERVICE, "Building resume content");
      const content2 = buildResumeContent(
        profile,
        relevantJobs,
        relevantSkills,
        professionalSummary
      );
      log$1.info(LogCategory.SERVICE, "Resume content built", { sections: content2.sections.length });
      log$1.debug(LogCategory.SERVICE, "Calculating ATS score");
      const atsOptimization = calculateATSScore(
        content2.formattedText || "",
        job.extractedKeywords.map((k) => k.phrase),
        job.extractedKeywords.map((k) => k.phrase)
      );
      log$1.info(LogCategory.SERVICE, "ATS score calculated", { score: atsOptimization.overallATSScore });
      const now = Date.now();
      const resume = {
        id: `resume_${now}`,
        jobDescriptionId: job.id,
        jobTitle: job.jobTitle,
        company: job.company,
        selectedExperiences: relevantJobs.map((j) => ({
          type: "job",
          id: j.id,
          selectedBullets: j.bullets.map((b) => b.id),
          bulletOrder: j.bullets.map((_, i) => i)
        })),
        selectedSkills: relevantSkills.map((s) => s.id),
        selectedProjects: [],
        selectedEducation: profile.education.map((e) => e.id),
        professionalSummary,
        content: content2,
        atsOptimization,
        generatedAt: now,
        version: 1
      };
      console.log("[Uproot] Resume generated with ATS score:", atsOptimization.overallATSScore);
      log$1.info(LogCategory.SERVICE, "Resume generation completed successfully", {
        resumeId: resume.id,
        atsScore: atsOptimization.overallATSScore,
        experiencesSelected: relevantJobs.length,
        skillsSelected: relevantSkills.length
      });
      return resume;
    });
  }
  function selectRelevantExperiences(profile, job) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "selectRelevantExperiences", {
      totalJobs: profile.jobs.length,
      jobKeywords: job.extractedKeywords.length
    });
    try {
      const jobKeywords = job.extractedKeywords.map((k) => k.phrase.toLowerCase());
      log$1.debug(LogCategory.SERVICE, "Scoring experiences against job keywords", {
        keywordsToMatch: jobKeywords.length
      });
      const scoredJobs = profile.jobs.map((jobExp) => {
        let score = 0;
        for (const tech of jobExp.technologies) {
          if (jobKeywords.some((k) => k.includes(tech.toLowerCase()) || tech.toLowerCase().includes(k))) {
            score += 10;
          }
        }
        for (const bullet of jobExp.bullets) {
          for (const keyword of bullet.keywords) {
            if (jobKeywords.some((k) => k.includes(keyword.toLowerCase()))) {
              score += 5;
            }
          }
        }
        if (jobExp.current) {
          score += 20;
        }
        return { job: jobExp, score };
      });
      const selected = scoredJobs.sort((a, b) => b.score - a.score).slice(0, 3).map((item) => item.job);
      log$1.info(LogCategory.SERVICE, "Selected most relevant experiences", {
        selectedCount: selected.length,
        topScores: scoredJobs.slice(0, 3).map((s) => ({ title: s.job.title, score: s.score }))
      });
      endTrace(selected);
      return selected;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Experience selection failed", error);
      endTrace();
      throw error;
    }
  }
  function selectRelevantSkills(profile, job) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "selectRelevantSkills", {
      technicalSkills: profile.technicalSkills.length,
      softSkills: profile.softSkills.length,
      jobKeywords: job.extractedKeywords.length
    });
    try {
      const jobKeywords = job.extractedKeywords.map((k) => k.phrase.toLowerCase());
      const allSkills = [...profile.technicalSkills, ...profile.softSkills];
      log$1.debug(LogCategory.SERVICE, "Matching skills against job keywords", {
        totalSkills: allSkills.length
      });
      const matchingSkills = allSkills.filter((skill) => {
        if (!skill || !skill.name) return false;
        const skillName = skill.name.toLowerCase();
        return jobKeywords.some(
          (k) => k.includes(skillName) || skillName.includes(k) || skill.synonyms?.some((s) => k.includes(s.toLowerCase()))
        );
      });
      log$1.debug(LogCategory.SERVICE, `Found ${matchingSkills.length} matching skills, sorting by proficiency`);
      const selected = matchingSkills.sort((a, b) => {
        const proficiencyOrder = { expert: 4, advanced: 3, intermediate: 2, beginner: 1 };
        return proficiencyOrder[b.proficiency] - proficiencyOrder[a.proficiency];
      }).slice(0, 15);
      log$1.info(LogCategory.SERVICE, "Selected most relevant skills", {
        matchingCount: matchingSkills.length,
        selectedCount: selected.length,
        topSkills: selected.slice(0, 5).filter((s) => s && s.name).map((s) => s.name)
      });
      endTrace(selected);
      return selected;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Skill selection failed", error);
      endTrace();
      throw error;
    }
  }
  async function generateProfessionalSummary(profile, job) {
    return log$1.trackAsync(LogCategory.SERVICE, "generateProfessionalSummary", async () => {
      const apiKey = process.env.VITE_ANTHROPIC_API_KEY;
      if (!apiKey) {
        throw new Error("VITE_ANTHROPIC_API_KEY environment variable not set");
      }
      const anthropic = new Anthropic({ apiKey });
      const yearsExp = calculateYearsOfExperience$1(profile);
      const topSkills = profile.technicalSkills.slice(0, 3).filter((s) => s && s.name).map((s) => s.name).join(", ");
      const requiredSkills = job.requiredSkills.slice(0, 3).join(", ");
      const recentJobs = profile.jobs.slice(0, 2).map((j) => `${j.title} at ${j.company}`).join("; ");
      const prompt = `STRICT RULES:
1. DO NOT invent experiences, achievements, or skills not provided
2. ONLY use facts from the candidate profile below
3. DO keep it 2-3 sentences maximum
4. DO emphasize matching skills from job requirements
5. DO use strong action words
6. DO NOT add fake metrics, team sizes, or accomplishments

CANDIDATE PROFILE:
- Years of Experience: ${yearsExp}
- Technical Skills: ${topSkills}
- Recent Jobs: ${recentJobs}

JOB REQUIREMENTS:
- Job Title: ${job.jobTitle}
- Company: ${job.company}
- Required Skills: ${requiredSkills}
- Preferred Skills: ${job.preferredSkills.slice(0, 3).join(", ")}

Write a professional summary (2-3 sentences) that highlights relevant experience matching the job requirements. Use ATS-optimized keywords.

Begin:`;
      log$1.debug(LogCategory.SERVICE, "Generating professional summary with Claude API", {
        jobTitle: job.jobTitle,
        requiredSkills: job.requiredSkills.length,
        yearsExperience: yearsExp
      });
      const message = await anthropic.messages.create({
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 300,
        temperature: 0.4,
        messages: [
          {
            role: "user",
            content: prompt
          }
        ]
      });
      const summary = message.content[0].type === "text" ? message.content[0].text.trim() : "";
      log$1.info(LogCategory.SERVICE, "Professional summary generated", {
        summaryLength: summary.length,
        wordCount: summary.split(/\s+/).length
      });
      return summary;
    });
  }
  function calculateYearsOfExperience$1(profile) {
    if (profile.jobs.length === 0) return 0;
    let totalMonths = 0;
    for (const job of profile.jobs) {
      const startDate = parseDate(job.startDate);
      const endDate = job.endDate ? parseDate(job.endDate) : /* @__PURE__ */ new Date();
      if (startDate && endDate) {
        const months = Math.max(
          0,
          (endDate.getFullYear() - startDate.getFullYear()) * 12 + (endDate.getMonth() - startDate.getMonth())
        );
        totalMonths += months;
      }
    }
    return Math.round(totalMonths / 12);
  }
  function parseDate(dateStr) {
    const match = dateStr.match(/^(\d{4})-(\d{2})$/);
    if (!match) return null;
    const year = parseInt(match[1]);
    const month = parseInt(match[2]) - 1;
    return new Date(year, month, 1);
  }
  function buildResumeContent(profile, selectedJobs, selectedSkills, professionalSummary) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "buildResumeContent", {
      selectedJobs: selectedJobs.length,
      selectedSkills: selectedSkills.length,
      educationItems: profile.education.length
    });
    try {
      log$1.debug(LogCategory.SERVICE, "Building resume sections");
      const sections = [];
      sections.push({
        type: "summary",
        title: "Professional Summary",
        content: professionalSummary,
        order: 0
      });
      const experienceItems = selectedJobs.map((job) => ({
        title: job.title,
        subtitle: job.company,
        location: job.location,
        dates: formatDateRange(job.startDate, job.endDate, job.current),
        bullets: job.bullets.slice(0, 4).map((b) => b.text)
      }));
      sections.push({
        type: "experience",
        title: "Professional Experience",
        content: experienceItems,
        order: 1
      });
      const skillsContent = selectedSkills.filter((s) => s && s.name).map((s) => s.name).join(" â€¢ ");
      sections.push({
        type: "skills",
        title: "Technical Skills",
        content: skillsContent,
        order: 2
      });
      const educationItems = profile.education.map((edu) => ({
        title: `${edu.degree} in ${edu.field}`,
        subtitle: edu.institution,
        location: edu.location,
        dates: formatDateRange(edu.startDate, edu.endDate, edu.current),
        bullets: edu.honors || []
      }));
      if (educationItems.length > 0) {
        sections.push({
          type: "education",
          title: "Education",
          content: educationItems,
          order: 3
        });
      }
      log$1.debug(LogCategory.SERVICE, "Formatting resume as plain text for ATS");
      const formattedText = formatResumeAsText(profile, sections);
      const content2 = {
        sections,
        formattedText
      };
      log$1.info(LogCategory.SERVICE, "Resume content built successfully", {
        totalSections: sections.length,
        textLength: formattedText?.length || 0,
        wordCount: formattedText ? formattedText.split(/\s+/).length : 0
      });
      endTrace(content2);
      return content2;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Resume content building failed", error);
      endTrace();
      throw error;
    }
  }
  function formatDateRange(start, end, current) {
    const formatDate = (dateStr) => {
      const date = parseDate(dateStr);
      if (!date) return dateStr;
      return date.toLocaleDateString("en-US", { month: "short", year: "numeric" });
    };
    const startFormatted = formatDate(start);
    const endFormatted = current ? "Present" : end ? formatDate(end) : "Present";
    return `${startFormatted} - ${endFormatted}`;
  }
  function formatResumeAsText(profile, sections) {
    let text = "";
    text += `${profile.personalInfo.fullName}
`;
    if (profile.personalInfo.email) text += `${profile.personalInfo.email}
`;
    if (profile.personalInfo.phone) text += `${profile.personalInfo.phone}
`;
    if (profile.personalInfo.location) text += `${profile.personalInfo.location}
`;
    if (profile.personalInfo.linkedinUrl) text += `${profile.personalInfo.linkedinUrl}
`;
    text += "\n";
    for (const section of sections.sort((a, b) => a.order - b.order)) {
      text += `${section.title.toUpperCase()}
`;
      text += "â”€".repeat(50) + "\n\n";
      if (typeof section.content === "string") {
        text += `${section.content}

`;
      } else {
        for (const item of section.content) {
          text += `${item.title}
`;
          if (item.subtitle) text += `${item.subtitle}`;
          if (item.location) text += ` | ${item.location}`;
          if (item.dates) text += ` | ${item.dates}`;
          text += "\n";
          if (item.bullets && item.bullets.length > 0) {
            for (const bullet of item.bullets) {
              text += `â€¢ ${bullet}
`;
            }
          }
          text += "\n";
        }
      }
    }
    return text;
  }
  content;
  const aiResumeGenerator = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    generateResumeWithAI
  }, Symbol.toStringTag, { value: "Module" }));
  const SKILLS_DATA = [
    // Programming Languages (50)
    {
      id: "python",
      name: "Python",
      category: "programming-language",
      synonyms: ["py", "python3", "python 3"],
      popularity: 95
    },
    {
      id: "javascript",
      name: "JavaScript",
      category: "programming-language",
      synonyms: ["js", "javascript es6", "ecmascript", "es6"],
      popularity: 98
    },
    {
      id: "typescript",
      name: "TypeScript",
      category: "programming-language",
      synonyms: ["ts", "typescript lang"],
      popularity: 92
    },
    {
      id: "java",
      name: "Java",
      category: "programming-language",
      synonyms: ["java se", "java ee", "jdk"],
      popularity: 90
    },
    {
      id: "c++",
      name: "C++",
      category: "programming-language",
      synonyms: ["cpp", "c plus plus", "cplusplus"],
      popularity: 85
    },
    {
      id: "c#",
      name: "C#",
      category: "programming-language",
      synonyms: ["csharp", "c sharp", "c-sharp"],
      popularity: 82
    },
    {
      id: "go",
      name: "Go",
      category: "programming-language",
      synonyms: ["golang", "go lang"],
      popularity: 88
    },
    {
      id: "rust",
      name: "Rust",
      category: "programming-language",
      synonyms: ["rust lang", "rust-lang"],
      popularity: 78
    },
    {
      id: "php",
      name: "PHP",
      category: "programming-language",
      synonyms: ["php7", "php8", "php 7", "php 8"],
      popularity: 75
    },
    {
      id: "ruby",
      name: "Ruby",
      category: "programming-language",
      synonyms: ["ruby lang", "ruby on rails"],
      popularity: 72
    },
    {
      id: "swift",
      name: "Swift",
      category: "programming-language",
      synonyms: ["swift lang", "swift language"],
      popularity: 80
    },
    {
      id: "kotlin",
      name: "Kotlin",
      category: "programming-language",
      synonyms: ["kotlin lang", "kotlin language"],
      popularity: 79
    },
    {
      id: "scala",
      name: "Scala",
      category: "programming-language",
      synonyms: ["scala lang", "scala language"],
      popularity: 68
    },
    {
      id: "r",
      name: "R",
      category: "programming-language",
      synonyms: ["r lang", "r language", "r programming"],
      popularity: 70
    },
    {
      id: "matlab",
      name: "MATLAB",
      category: "programming-language",
      synonyms: ["matlab language", "mat lab"],
      popularity: 65
    },
    {
      id: "perl",
      name: "Perl",
      category: "programming-language",
      synonyms: ["perl5", "perl 5"],
      popularity: 55
    },
    {
      id: "shell",
      name: "Shell",
      category: "programming-language",
      synonyms: ["bash", "shell scripting", "bash scripting", "sh"],
      popularity: 82
    },
    {
      id: "powershell",
      name: "PowerShell",
      category: "programming-language",
      synonyms: ["power shell", "pwsh", "powershell core"],
      popularity: 70
    },
    {
      id: "sql",
      name: "SQL",
      category: "programming-language",
      synonyms: ["structured query language", "sql queries"],
      popularity: 94
    },
    {
      id: "objective-c",
      name: "Objective-C",
      category: "programming-language",
      synonyms: ["objc", "objective c"],
      popularity: 60
    },
    {
      id: "dart",
      name: "Dart",
      category: "programming-language",
      synonyms: ["dart lang", "dart language"],
      popularity: 74
    },
    {
      id: "elixir",
      name: "Elixir",
      category: "programming-language",
      synonyms: ["elixir lang", "elixir language"],
      popularity: 64
    },
    {
      id: "haskell",
      name: "Haskell",
      category: "programming-language",
      synonyms: ["haskell lang", "haskell language"],
      popularity: 58
    },
    {
      id: "clojure",
      name: "Clojure",
      category: "programming-language",
      synonyms: ["clojure lang", "clojure language"],
      popularity: 60
    },
    {
      id: "lua",
      name: "Lua",
      category: "programming-language",
      synonyms: ["lua lang", "lua language"],
      popularity: 62
    },
    {
      id: "groovy",
      name: "Groovy",
      category: "programming-language",
      synonyms: ["groovy lang", "groovy language"],
      popularity: 63
    },
    {
      id: "f#",
      name: "F#",
      category: "programming-language",
      synonyms: ["fsharp", "f sharp", "f-sharp"],
      popularity: 59
    },
    {
      id: "vba",
      name: "VBA",
      category: "programming-language",
      synonyms: ["visual basic", "vb", "visual basic for applications"],
      popularity: 50
    },
    {
      id: "solidity",
      name: "Solidity",
      category: "programming-language",
      synonyms: ["solidity lang", "solidity language"],
      popularity: 67
    },
    {
      id: "assembly",
      name: "Assembly",
      category: "programming-language",
      synonyms: ["asm", "assembly language", "assembler"],
      popularity: 52
    },
    {
      id: "c",
      name: "C",
      category: "programming-language",
      synonyms: ["c lang", "c language", "ansi c"],
      popularity: 81
    },
    {
      id: "fortran",
      name: "Fortran",
      category: "programming-language",
      synonyms: ["fortran lang", "fortran language"],
      popularity: 48
    },
    {
      id: "cobol",
      name: "COBOL",
      category: "programming-language",
      synonyms: ["cobol lang", "cobol language"],
      popularity: 45
    },
    {
      id: "julia",
      name: "Julia",
      category: "programming-language",
      synonyms: ["julia lang", "julia language"],
      popularity: 66
    },
    {
      id: "racket",
      name: "Racket",
      category: "programming-language",
      synonyms: ["racket lang", "racket language"],
      popularity: 54
    },
    {
      id: "erlang",
      name: "Erlang",
      category: "programming-language",
      synonyms: ["erlang lang", "erlang language"],
      popularity: 61
    },
    {
      id: "ocaml",
      name: "OCaml",
      category: "programming-language",
      synonyms: ["ocaml lang", "ocaml language"],
      popularity: 56
    },
    {
      id: "nim",
      name: "Nim",
      category: "programming-language",
      synonyms: ["nim lang", "nim language"],
      popularity: 57
    },
    {
      id: "crystal",
      name: "Crystal",
      category: "programming-language",
      synonyms: ["crystal lang", "crystal language"],
      popularity: 58
    },
    {
      id: "zig",
      name: "Zig",
      category: "programming-language",
      synonyms: ["zig lang", "zig language"],
      popularity: 65
    },
    {
      id: "v",
      name: "V",
      category: "programming-language",
      synonyms: ["vlang", "v lang", "v language"],
      popularity: 55
    },
    {
      id: "verilog",
      name: "Verilog",
      category: "programming-language",
      synonyms: ["verilog hdl", "verilog language"],
      popularity: 53
    },
    {
      id: "vhdl",
      name: "VHDL",
      category: "programming-language",
      synonyms: ["vhdl language", "vhsic hardware description language"],
      popularity: 52
    },
    {
      id: "coffeescript",
      name: "CoffeeScript",
      category: "programming-language",
      synonyms: ["coffee script", "coffee"],
      popularity: 51
    },
    {
      id: "elm",
      name: "Elm",
      category: "programming-language",
      synonyms: ["elm lang", "elm language"],
      popularity: 59
    },
    {
      id: "purescript",
      name: "PureScript",
      category: "programming-language",
      synonyms: ["pure script", "purescript lang"],
      popularity: 56
    },
    {
      id: "reasonml",
      name: "ReasonML",
      category: "programming-language",
      synonyms: ["reason", "reason ml", "reasonml lang"],
      popularity: 60
    },
    {
      id: "hack",
      name: "Hack",
      category: "programming-language",
      synonyms: ["hack lang", "hacklang", "hhvm"],
      popularity: 57
    },
    {
      id: "abap",
      name: "ABAP",
      category: "programming-language",
      synonyms: ["abap lang", "sap abap"],
      popularity: 49
    },
    {
      id: "apex",
      name: "Apex",
      category: "programming-language",
      synonyms: ["salesforce apex", "apex language"],
      popularity: 62
    },
    // Frontend Frameworks (30)
    {
      id: "react",
      name: "React",
      category: "frontend-framework",
      synonyms: ["react.js", "reactjs", "react js"],
      popularity: 97
    },
    {
      id: "vue",
      name: "Vue",
      category: "frontend-framework",
      synonyms: ["vue.js", "vuejs", "vue js"],
      popularity: 89
    },
    {
      id: "angular",
      name: "Angular",
      category: "frontend-framework",
      synonyms: ["angularjs", "angular.js", "angular 2+"],
      popularity: 86
    },
    {
      id: "svelte",
      name: "Svelte",
      category: "frontend-framework",
      synonyms: ["svelte.js", "sveltejs", "svelte js"],
      popularity: 83
    },
    {
      id: "next.js",
      name: "Next.js",
      category: "frontend-framework",
      synonyms: ["nextjs", "next js", "next"],
      popularity: 94
    },
    {
      id: "nuxt",
      name: "Nuxt",
      category: "frontend-framework",
      synonyms: ["nuxt.js", "nuxtjs", "nuxt js"],
      popularity: 81
    },
    {
      id: "gatsby",
      name: "Gatsby",
      category: "frontend-framework",
      synonyms: ["gatsby.js", "gatsbyjs", "gatsby js"],
      popularity: 77
    },
    {
      id: "ember",
      name: "Ember",
      category: "frontend-framework",
      synonyms: ["ember.js", "emberjs", "ember js"],
      popularity: 68
    },
    {
      id: "backbone",
      name: "Backbone",
      category: "frontend-framework",
      synonyms: ["backbone.js", "backbonejs", "backbone js"],
      popularity: 60
    },
    {
      id: "preact",
      name: "Preact",
      category: "frontend-framework",
      synonyms: ["preact.js", "preactjs", "preact js"],
      popularity: 75
    },
    {
      id: "solid",
      name: "Solid",
      category: "frontend-framework",
      synonyms: ["solid.js", "solidjs", "solid js"],
      popularity: 79
    },
    {
      id: "alpine.js",
      name: "Alpine.js",
      category: "frontend-framework",
      synonyms: ["alpine", "alpinejs", "alpine js"],
      popularity: 74
    },
    {
      id: "htmx",
      name: "HTMX",
      category: "frontend-framework",
      synonyms: ["htmx.org", "htmx library"],
      popularity: 76
    },
    {
      id: "qwik",
      name: "Qwik",
      category: "frontend-framework",
      synonyms: ["qwik.js", "qwikjs", "qwik framework"],
      popularity: 72
    },
    {
      id: "astro",
      name: "Astro",
      category: "frontend-framework",
      synonyms: ["astro.build", "astro framework"],
      popularity: 80
    },
    {
      id: "remix",
      name: "Remix",
      category: "frontend-framework",
      synonyms: ["remix.run", "remix framework"],
      popularity: 82
    },
    {
      id: "lit",
      name: "Lit",
      category: "frontend-framework",
      synonyms: ["lit-element", "lit-html", "lit framework"],
      popularity: 71
    },
    {
      id: "stencil",
      name: "Stencil",
      category: "frontend-framework",
      synonyms: ["stencil.js", "stenciljs"],
      popularity: 69
    },
    {
      id: "aurelia",
      name: "Aurelia",
      category: "frontend-framework",
      synonyms: ["aurelia.io", "aurelia framework"],
      popularity: 64
    },
    {
      id: "mithril",
      name: "Mithril",
      category: "frontend-framework",
      synonyms: ["mithril.js", "mithriljs"],
      popularity: 63
    },
    {
      id: "marko",
      name: "Marko",
      category: "frontend-framework",
      synonyms: ["marko.js", "markojs"],
      popularity: 62
    },
    {
      id: "polymer",
      name: "Polymer",
      category: "frontend-framework",
      synonyms: ["polymer.js", "polymerjs", "polymer project"],
      popularity: 61
    },
    {
      id: "knockout",
      name: "Knockout",
      category: "frontend-framework",
      synonyms: ["knockout.js", "knockoutjs", "ko.js"],
      popularity: 58
    },
    {
      id: "inferno",
      name: "Inferno",
      category: "frontend-framework",
      synonyms: ["inferno.js", "infernojs"],
      popularity: 65
    },
    {
      id: "hyperapp",
      name: "Hyperapp",
      category: "frontend-framework",
      synonyms: ["hyper app", "hyperapp.js"],
      popularity: 64
    },
    {
      id: "petite-vue",
      name: "Petite Vue",
      category: "frontend-framework",
      synonyms: ["petite vue", "petite-vue", "petitevue"],
      popularity: 66
    },
    {
      id: "react-native",
      name: "React Native",
      category: "frontend-framework",
      synonyms: ["reactnative", "react native framework", "rn"],
      popularity: 91
    },
    {
      id: "flutter",
      name: "Flutter",
      category: "frontend-framework",
      synonyms: ["flutter framework", "flutter sdk"],
      popularity: 88
    },
    {
      id: "electron",
      name: "Electron",
      category: "frontend-framework",
      synonyms: ["electron.js", "electronjs"],
      popularity: 84
    },
    {
      id: "ionic",
      name: "Ionic",
      category: "frontend-framework",
      synonyms: ["ionic framework", "ionic mobile"],
      popularity: 78
    },
    // Backend Frameworks (40)
    {
      id: "express",
      name: "Express",
      category: "backend-framework",
      synonyms: ["express.js", "expressjs", "express js"],
      popularity: 93
    },
    {
      id: "django",
      name: "Django",
      category: "backend-framework",
      synonyms: ["django framework", "django python"],
      popularity: 90
    },
    {
      id: "flask",
      name: "Flask",
      category: "backend-framework",
      synonyms: ["flask framework", "flask python"],
      popularity: 87
    },
    {
      id: "fastapi",
      name: "FastAPI",
      category: "backend-framework",
      synonyms: ["fast api", "fastapi framework"],
      popularity: 89
    },
    {
      id: "spring-boot",
      name: "Spring Boot",
      category: "backend-framework",
      synonyms: ["springboot", "spring boot framework", "spring"],
      popularity: 91
    },
    {
      id: "nest.js",
      name: "NestJS",
      category: "backend-framework",
      synonyms: ["nestjs", "nest js", "nest"],
      popularity: 86
    },
    {
      id: "ruby-on-rails",
      name: "Ruby on Rails",
      category: "backend-framework",
      synonyms: ["rails", "ror", "ruby rails"],
      popularity: 82
    },
    {
      id: "laravel",
      name: "Laravel",
      category: "backend-framework",
      synonyms: ["laravel framework", "laravel php"],
      popularity: 85
    },
    {
      id: "asp.net",
      name: "ASP.NET",
      category: "backend-framework",
      synonyms: ["asp.net core", "aspnet", "asp net"],
      popularity: 84
    },
    {
      id: "koa",
      name: "Koa",
      category: "backend-framework",
      synonyms: ["koa.js", "koajs", "koa js"],
      popularity: 76
    },
    {
      id: "hapi",
      name: "Hapi",
      category: "backend-framework",
      synonyms: ["hapi.js", "hapijs", "hapi js"],
      popularity: 72
    },
    {
      id: "phoenix",
      name: "Phoenix",
      category: "backend-framework",
      synonyms: ["phoenix framework", "phoenix elixir"],
      popularity: 78
    },
    {
      id: "gin",
      name: "Gin",
      category: "backend-framework",
      synonyms: ["gin-gonic", "gin framework", "gin go"],
      popularity: 83
    },
    {
      id: "echo",
      name: "Echo",
      category: "backend-framework",
      synonyms: ["echo framework", "echo go"],
      popularity: 77
    },
    {
      id: "fiber",
      name: "Fiber",
      category: "backend-framework",
      synonyms: ["gofiber", "fiber go", "fiber framework"],
      popularity: 79
    },
    {
      id: "actix",
      name: "Actix",
      category: "backend-framework",
      synonyms: ["actix-web", "actix framework", "actix rust"],
      popularity: 75
    },
    {
      id: "rocket",
      name: "Rocket",
      category: "backend-framework",
      synonyms: ["rocket.rs", "rocket framework", "rocket rust"],
      popularity: 74
    },
    {
      id: "axum",
      name: "Axum",
      category: "backend-framework",
      synonyms: ["axum framework", "axum rust"],
      popularity: 76
    },
    {
      id: "symfony",
      name: "Symfony",
      category: "backend-framework",
      synonyms: ["symfony framework", "symfony php"],
      popularity: 80
    },
    {
      id: "codeigniter",
      name: "CodeIgniter",
      category: "backend-framework",
      synonyms: ["code igniter", "codeigniter php"],
      popularity: 70
    },
    {
      id: "cakephp",
      name: "CakePHP",
      category: "backend-framework",
      synonyms: ["cake php", "cakephp framework"],
      popularity: 68
    },
    {
      id: "yii",
      name: "Yii",
      category: "backend-framework",
      synonyms: ["yii2", "yii framework", "yii php"],
      popularity: 69
    },
    {
      id: "slim",
      name: "Slim",
      category: "backend-framework",
      synonyms: ["slim framework", "slim php"],
      popularity: 67
    },
    {
      id: "lumen",
      name: "Lumen",
      category: "backend-framework",
      synonyms: ["lumen framework", "lumen php"],
      popularity: 71
    },
    {
      id: "sails",
      name: "Sails",
      category: "backend-framework",
      synonyms: ["sails.js", "sailsjs", "sails js"],
      popularity: 73
    },
    {
      id: "adonis",
      name: "Adonis",
      category: "backend-framework",
      synonyms: ["adonis.js", "adonisjs", "adonis js"],
      popularity: 75
    },
    {
      id: "loopback",
      name: "LoopBack",
      category: "backend-framework",
      synonyms: ["loopback.js", "loopbackjs", "loop back"],
      popularity: 70
    },
    {
      id: "meteor",
      name: "Meteor",
      category: "backend-framework",
      synonyms: ["meteor.js", "meteorjs", "meteor js"],
      popularity: 72
    },
    {
      id: "grails",
      name: "Grails",
      category: "backend-framework",
      synonyms: ["grails framework", "grails groovy"],
      popularity: 66
    },
    {
      id: "play",
      name: "Play",
      category: "backend-framework",
      synonyms: ["play framework", "playframework", "play scala"],
      popularity: 71
    },
    {
      id: "micronaut",
      name: "Micronaut",
      category: "backend-framework",
      synonyms: ["micronaut framework", "micronaut java"],
      popularity: 73
    },
    {
      id: "quarkus",
      name: "Quarkus",
      category: "backend-framework",
      synonyms: ["quarkus framework", "quarkus java"],
      popularity: 77
    },
    {
      id: "ktor",
      name: "Ktor",
      category: "backend-framework",
      synonyms: ["ktor framework", "ktor kotlin"],
      popularity: 74
    },
    {
      id: "bottle",
      name: "Bottle",
      category: "backend-framework",
      synonyms: ["bottle.py", "bottle python"],
      popularity: 65
    },
    {
      id: "tornado",
      name: "Tornado",
      category: "backend-framework",
      synonyms: ["tornado framework", "tornado python"],
      popularity: 69
    },
    {
      id: "falcon",
      name: "Falcon",
      category: "backend-framework",
      synonyms: ["falcon framework", "falcon python"],
      popularity: 70
    },
    {
      id: "aiohttp",
      name: "aiohttp",
      category: "backend-framework",
      synonyms: ["aio http", "aiohttp python"],
      popularity: 72
    },
    {
      id: "sinatra",
      name: "Sinatra",
      category: "backend-framework",
      synonyms: ["sinatra framework", "sinatra ruby"],
      popularity: 68
    },
    {
      id: "hanami",
      name: "Hanami",
      category: "backend-framework",
      synonyms: ["hanami framework", "hanami ruby"],
      popularity: 64
    },
    {
      id: "padrino",
      name: "Padrino",
      category: "backend-framework",
      synonyms: ["padrino framework", "padrino ruby"],
      popularity: 63
    },
    // Databases (30)
    {
      id: "postgresql",
      name: "PostgreSQL",
      category: "database",
      synonyms: ["postgres", "psql", "pg"],
      popularity: 92
    },
    {
      id: "mysql",
      name: "MySQL",
      category: "database",
      synonyms: ["my sql", "mysql db"],
      popularity: 90
    },
    {
      id: "mongodb",
      name: "MongoDB",
      category: "database",
      synonyms: ["mongo", "mongo db"],
      popularity: 89
    },
    {
      id: "redis",
      name: "Redis",
      category: "database",
      synonyms: ["redis db", "redis cache"],
      popularity: 88
    },
    {
      id: "cassandra",
      name: "Cassandra",
      category: "database",
      synonyms: ["apache cassandra", "cassandra db"],
      popularity: 76
    },
    {
      id: "sqlite",
      name: "SQLite",
      category: "database",
      synonyms: ["sql lite", "sqlite3"],
      popularity: 80
    },
    {
      id: "mariadb",
      name: "MariaDB",
      category: "database",
      synonyms: ["maria db", "mariadb database"],
      popularity: 78
    },
    {
      id: "oracle",
      name: "Oracle",
      category: "database",
      synonyms: ["oracle db", "oracle database", "oracle rdbms"],
      popularity: 82
    },
    {
      id: "mssql",
      name: "MS SQL Server",
      category: "database",
      synonyms: ["sql server", "microsoft sql server", "mssql", "t-sql"],
      popularity: 83
    },
    {
      id: "dynamodb",
      name: "DynamoDB",
      category: "database",
      synonyms: ["dynamo db", "aws dynamodb", "amazon dynamodb"],
      popularity: 85
    },
    {
      id: "couchdb",
      name: "CouchDB",
      category: "database",
      synonyms: ["couch db", "apache couchdb"],
      popularity: 70
    },
    {
      id: "neo4j",
      name: "Neo4j",
      category: "database",
      synonyms: ["neo4j graph", "neo4j database"],
      popularity: 77
    },
    {
      id: "elasticsearch",
      name: "Elasticsearch",
      category: "database",
      synonyms: ["elastic search", "es", "elasticsearch db"],
      popularity: 86
    },
    {
      id: "couchbase",
      name: "Couchbase",
      category: "database",
      synonyms: ["couch base", "couchbase server"],
      popularity: 72
    },
    {
      id: "influxdb",
      name: "InfluxDB",
      category: "database",
      synonyms: ["influx db", "influx database"],
      popularity: 74
    },
    {
      id: "timescaledb",
      name: "TimescaleDB",
      category: "database",
      synonyms: ["timescale db", "timescale"],
      popularity: 73
    },
    {
      id: "rethinkdb",
      name: "RethinkDB",
      category: "database",
      synonyms: ["rethink db", "rethink database"],
      popularity: 68
    },
    {
      id: "arangodb",
      name: "ArangoDB",
      category: "database",
      synonyms: ["arango db", "arango database"],
      popularity: 69
    },
    {
      id: "firestore",
      name: "Firestore",
      category: "database",
      synonyms: ["firebase firestore", "cloud firestore", "google firestore"],
      popularity: 81
    },
    {
      id: "fauna",
      name: "FaunaDB",
      category: "database",
      synonyms: ["fauna db", "fauna database"],
      popularity: 71
    },
    {
      id: "supabase",
      name: "Supabase",
      category: "database",
      synonyms: ["supabase db", "supabase database"],
      popularity: 79
    },
    {
      id: "planetscale",
      name: "PlanetScale",
      category: "database",
      synonyms: ["planet scale", "planetscale db"],
      popularity: 75
    },
    {
      id: "cockroachdb",
      name: "CockroachDB",
      category: "database",
      synonyms: ["cockroach db", "cockroach database"],
      popularity: 74
    },
    {
      id: "memcached",
      name: "Memcached",
      category: "database",
      synonyms: ["mem cached", "memcached cache"],
      popularity: 77
    },
    {
      id: "ravendb",
      name: "RavenDB",
      category: "database",
      synonyms: ["raven db", "raven database"],
      popularity: 67
    },
    {
      id: "orientdb",
      name: "OrientDB",
      category: "database",
      synonyms: ["orient db", "orient database"],
      popularity: 66
    },
    {
      id: "dgraph",
      name: "Dgraph",
      category: "database",
      synonyms: ["d graph", "dgraph database"],
      popularity: 68
    },
    {
      id: "scylladb",
      name: "ScyllaDB",
      category: "database",
      synonyms: ["scylla db", "scylla database"],
      popularity: 70
    },
    {
      id: "yugabytedb",
      name: "YugabyteDB",
      category: "database",
      synonyms: ["yugabyte db", "yugabyte"],
      popularity: 72
    },
    {
      id: "clickhouse",
      name: "ClickHouse",
      category: "database",
      synonyms: ["click house", "clickhouse db"],
      popularity: 76
    },
    // Cloud Platforms (20)
    {
      id: "aws",
      name: "AWS",
      category: "cloud-platform",
      synonyms: ["amazon web services", "amazon aws", "aws cloud"],
      popularity: 96
    },
    {
      id: "azure",
      name: "Azure",
      category: "cloud-platform",
      synonyms: ["microsoft azure", "azure cloud", "ms azure"],
      popularity: 92
    },
    {
      id: "gcp",
      name: "GCP",
      category: "cloud-platform",
      synonyms: ["google cloud platform", "google cloud", "gcp cloud"],
      popularity: 90
    },
    {
      id: "digitalocean",
      name: "DigitalOcean",
      category: "cloud-platform",
      synonyms: ["digital ocean", "do cloud"],
      popularity: 78
    },
    {
      id: "heroku",
      name: "Heroku",
      category: "cloud-platform",
      synonyms: ["heroku platform", "heroku cloud"],
      popularity: 80
    },
    {
      id: "vercel",
      name: "Vercel",
      category: "cloud-platform",
      synonyms: ["vercel platform", "vercel cloud"],
      popularity: 84
    },
    {
      id: "netlify",
      name: "Netlify",
      category: "cloud-platform",
      synonyms: ["netlify platform", "netlify cloud"],
      popularity: 82
    },
    {
      id: "cloudflare",
      name: "Cloudflare",
      category: "cloud-platform",
      synonyms: ["cloudflare workers", "cloudflare pages", "cf"],
      popularity: 85
    },
    {
      id: "railway",
      name: "Railway",
      category: "cloud-platform",
      synonyms: ["railway.app", "railway platform"],
      popularity: 76
    },
    {
      id: "render",
      name: "Render",
      category: "cloud-platform",
      synonyms: ["render.com", "render platform"],
      popularity: 77
    },
    {
      id: "fly.io",
      name: "Fly.io",
      category: "cloud-platform",
      synonyms: ["fly", "flyio", "fly platform"],
      popularity: 75
    },
    {
      id: "linode",
      name: "Linode",
      category: "cloud-platform",
      synonyms: ["akamai linode", "linode cloud"],
      popularity: 74
    },
    {
      id: "vultr",
      name: "Vultr",
      category: "cloud-platform",
      synonyms: ["vultr cloud", "vultr platform"],
      popularity: 72
    },
    {
      id: "alibaba-cloud",
      name: "Alibaba Cloud",
      category: "cloud-platform",
      synonyms: ["aliyun", "alibaba aliyun", "alibaba cloud platform"],
      popularity: 73
    },
    {
      id: "ibm-cloud",
      name: "IBM Cloud",
      category: "cloud-platform",
      synonyms: ["ibm cloud platform", "ibm bluemix"],
      popularity: 71
    },
    {
      id: "oracle-cloud",
      name: "Oracle Cloud",
      category: "cloud-platform",
      synonyms: ["oci", "oracle cloud infrastructure"],
      popularity: 70
    },
    {
      id: "openstack",
      name: "OpenStack",
      category: "cloud-platform",
      synonyms: ["open stack", "openstack cloud"],
      popularity: 68
    },
    {
      id: "cloudways",
      name: "Cloudways",
      category: "cloud-platform",
      synonyms: ["cloudways platform", "cloudways hosting"],
      popularity: 67
    },
    {
      id: "scaleway",
      name: "Scaleway",
      category: "cloud-platform",
      synonyms: ["scale way", "scaleway cloud"],
      popularity: 69
    },
    {
      id: "ovh",
      name: "OVH",
      category: "cloud-platform",
      synonyms: ["ovh cloud", "ovhcloud"],
      popularity: 68
    },
    // DevOps Tools (50)
    {
      id: "docker",
      name: "Docker",
      category: "devops-tool",
      synonyms: ["docker container", "docker engine", "dockerfile"],
      popularity: 95
    },
    {
      id: "kubernetes",
      name: "Kubernetes",
      category: "devops-tool",
      synonyms: ["k8s", "kube", "k8s cluster"],
      popularity: 94
    },
    {
      id: "jenkins",
      name: "Jenkins",
      category: "devops-tool",
      synonyms: ["jenkins ci", "jenkins cd", "jenkins pipeline"],
      popularity: 87
    },
    {
      id: "github-actions",
      name: "GitHub Actions",
      category: "devops-tool",
      synonyms: ["gh actions", "github action", "gha"],
      popularity: 91
    },
    {
      id: "gitlab-ci",
      name: "GitLab CI",
      category: "devops-tool",
      synonyms: ["gitlab ci/cd", "gitlab pipeline", "gitlab cicd"],
      popularity: 85
    },
    {
      id: "circleci",
      name: "CircleCI",
      category: "devops-tool",
      synonyms: ["circle ci", "circleci pipeline"],
      popularity: 81
    },
    {
      id: "travis-ci",
      name: "Travis CI",
      category: "devops-tool",
      synonyms: ["travis", "travisci", "travis-ci"],
      popularity: 76
    },
    {
      id: "terraform",
      name: "Terraform",
      category: "devops-tool",
      synonyms: ["terraform iac", "terraform hcl", "tf"],
      popularity: 90
    },
    {
      id: "ansible",
      name: "Ansible",
      category: "devops-tool",
      synonyms: ["ansible automation", "ansible playbook"],
      popularity: 86
    },
    {
      id: "puppet",
      name: "Puppet",
      category: "devops-tool",
      synonyms: ["puppet automation", "puppet labs"],
      popularity: 74
    },
    {
      id: "chef",
      name: "Chef",
      category: "devops-tool",
      synonyms: ["chef automation", "chef infra"],
      popularity: 72
    },
    {
      id: "vagrant",
      name: "Vagrant",
      category: "devops-tool",
      synonyms: ["vagrant vm", "vagrant box"],
      popularity: 75
    },
    {
      id: "prometheus",
      name: "Prometheus",
      category: "devops-tool",
      synonyms: ["prometheus monitoring", "prometheus metrics"],
      popularity: 84
    },
    {
      id: "grafana",
      name: "Grafana",
      category: "devops-tool",
      synonyms: ["grafana dashboard", "grafana monitoring"],
      popularity: 85
    },
    {
      id: "datadog",
      name: "Datadog",
      category: "devops-tool",
      synonyms: ["datadog monitoring", "datadog apm"],
      popularity: 82
    },
    {
      id: "new-relic",
      name: "New Relic",
      category: "devops-tool",
      synonyms: ["newrelic", "new relic apm"],
      popularity: 80
    },
    {
      id: "splunk",
      name: "Splunk",
      category: "devops-tool",
      synonyms: ["splunk enterprise", "splunk monitoring"],
      popularity: 79
    },
    {
      id: "elk",
      name: "ELK Stack",
      category: "devops-tool",
      synonyms: ["elasticsearch logstash kibana", "elk", "elastic stack"],
      popularity: 83
    },
    {
      id: "nagios",
      name: "Nagios",
      category: "devops-tool",
      synonyms: ["nagios monitoring", "nagios core"],
      popularity: 73
    },
    {
      id: "zabbix",
      name: "Zabbix",
      category: "devops-tool",
      synonyms: ["zabbix monitoring", "zabbix server"],
      popularity: 72
    },
    {
      id: "helm",
      name: "Helm",
      category: "devops-tool",
      synonyms: ["helm charts", "helm k8s", "helm kubernetes"],
      popularity: 84
    },
    {
      id: "argocd",
      name: "ArgoCD",
      category: "devops-tool",
      synonyms: ["argo cd", "argo continuous delivery"],
      popularity: 82
    },
    {
      id: "flux",
      name: "Flux",
      category: "devops-tool",
      synonyms: ["flux cd", "fluxcd", "flux gitops"],
      popularity: 78
    },
    {
      id: "spinnaker",
      name: "Spinnaker",
      category: "devops-tool",
      synonyms: ["spinnaker cd", "spinnaker deployment"],
      popularity: 74
    },
    {
      id: "packer",
      name: "Packer",
      category: "devops-tool",
      synonyms: ["hashicorp packer", "packer io"],
      popularity: 76
    },
    {
      id: "consul",
      name: "Consul",
      category: "devops-tool",
      synonyms: ["hashicorp consul", "consul service mesh"],
      popularity: 77
    },
    {
      id: "vault",
      name: "Vault",
      category: "devops-tool",
      synonyms: ["hashicorp vault", "vault secrets"],
      popularity: 81
    },
    {
      id: "nomad",
      name: "Nomad",
      category: "devops-tool",
      synonyms: ["hashicorp nomad", "nomad orchestration"],
      popularity: 73
    },
    {
      id: "istio",
      name: "Istio",
      category: "devops-tool",
      synonyms: ["istio service mesh", "istio k8s"],
      popularity: 79
    },
    {
      id: "linkerd",
      name: "Linkerd",
      category: "devops-tool",
      synonyms: ["linkerd service mesh", "linkerd2"],
      popularity: 75
    },
    {
      id: "nginx",
      name: "Nginx",
      category: "devops-tool",
      synonyms: ["nginx web server", "nginx reverse proxy"],
      popularity: 89
    },
    {
      id: "apache",
      name: "Apache",
      category: "devops-tool",
      synonyms: ["apache http server", "apache web server", "httpd"],
      popularity: 84
    },
    {
      id: "haproxy",
      name: "HAProxy",
      category: "devops-tool",
      synonyms: ["ha proxy", "haproxy load balancer"],
      popularity: 77
    },
    {
      id: "traefik",
      name: "Traefik",
      category: "devops-tool",
      synonyms: ["traefik proxy", "traefik load balancer"],
      popularity: 78
    },
    {
      id: "envoy",
      name: "Envoy",
      category: "devops-tool",
      synonyms: ["envoy proxy", "envoy service mesh"],
      popularity: 76
    },
    {
      id: "sonarqube",
      name: "SonarQube",
      category: "devops-tool",
      synonyms: ["sonar qube", "sonarqube scanner"],
      popularity: 80
    },
    {
      id: "nexus",
      name: "Nexus",
      category: "devops-tool",
      synonyms: ["nexus repository", "sonatype nexus"],
      popularity: 77
    },
    {
      id: "artifactory",
      name: "Artifactory",
      category: "devops-tool",
      synonyms: ["jfrog artifactory", "artifactory repository"],
      popularity: 78
    },
    {
      id: "maven",
      name: "Maven",
      category: "devops-tool",
      synonyms: ["apache maven", "maven build"],
      popularity: 82
    },
    {
      id: "gradle",
      name: "Gradle",
      category: "devops-tool",
      synonyms: ["gradle build", "gradle tool"],
      popularity: 83
    },
    {
      id: "git",
      name: "Git",
      category: "devops-tool",
      synonyms: ["git vcs", "git version control"],
      popularity: 98
    },
    {
      id: "github",
      name: "GitHub",
      category: "devops-tool",
      synonyms: ["github platform", "gh", "github.com"],
      popularity: 96
    },
    {
      id: "gitlab",
      name: "GitLab",
      category: "devops-tool",
      synonyms: ["gitlab platform", "gitlab.com"],
      popularity: 87
    },
    {
      id: "bitbucket",
      name: "Bitbucket",
      category: "devops-tool",
      synonyms: ["bitbucket platform", "atlassian bitbucket"],
      popularity: 79
    },
    {
      id: "azure-devops",
      name: "Azure DevOps",
      category: "devops-tool",
      synonyms: ["azure devops services", "ado", "azure pipelines"],
      popularity: 83
    },
    {
      id: "jira",
      name: "Jira",
      category: "devops-tool",
      synonyms: ["atlassian jira", "jira software"],
      popularity: 88
    },
    {
      id: "confluence",
      name: "Confluence",
      category: "devops-tool",
      synonyms: ["atlassian confluence", "confluence wiki"],
      popularity: 80
    },
    {
      id: "slack",
      name: "Slack",
      category: "devops-tool",
      synonyms: ["slack workspace", "slack platform"],
      popularity: 86
    },
    {
      id: "pagerduty",
      name: "PagerDuty",
      category: "devops-tool",
      synonyms: ["pager duty", "pagerduty incident"],
      popularity: 78
    },
    {
      id: "sentry",
      name: "Sentry",
      category: "devops-tool",
      synonyms: ["sentry.io", "sentry error tracking"],
      popularity: 81
    },
    // Testing Frameworks (30)
    {
      id: "jest",
      name: "Jest",
      category: "testing-framework",
      synonyms: ["jestjs", "jest testing", "jest framework"],
      popularity: 92
    },
    {
      id: "pytest",
      name: "Pytest",
      category: "testing-framework",
      synonyms: ["py.test", "pytest framework"],
      popularity: 89
    },
    {
      id: "junit",
      name: "JUnit",
      category: "testing-framework",
      synonyms: ["junit5", "junit 5", "junit testing"],
      popularity: 88
    },
    {
      id: "cypress",
      name: "Cypress",
      category: "testing-framework",
      synonyms: ["cypress.io", "cypress testing", "cypress e2e"],
      popularity: 90
    },
    {
      id: "selenium",
      name: "Selenium",
      category: "testing-framework",
      synonyms: ["selenium webdriver", "selenium automation"],
      popularity: 86
    },
    {
      id: "mocha",
      name: "Mocha",
      category: "testing-framework",
      synonyms: ["mocha.js", "mochajs", "mocha testing"],
      popularity: 83
    },
    {
      id: "jasmine",
      name: "Jasmine",
      category: "testing-framework",
      synonyms: ["jasmine.js", "jasminejs", "jasmine testing"],
      popularity: 80
    },
    {
      id: "karma",
      name: "Karma",
      category: "testing-framework",
      synonyms: ["karma.js", "karmajs", "karma runner"],
      popularity: 77
    },
    {
      id: "playwright",
      name: "Playwright",
      category: "testing-framework",
      synonyms: ["playwright testing", "playwright automation"],
      popularity: 88
    },
    {
      id: "puppeteer",
      name: "Puppeteer",
      category: "testing-framework",
      synonyms: ["puppeteer testing", "puppeteer automation"],
      popularity: 84
    },
    {
      id: "testng",
      name: "TestNG",
      category: "testing-framework",
      synonyms: ["test ng", "testng framework"],
      popularity: 79
    },
    {
      id: "rspec",
      name: "RSpec",
      category: "testing-framework",
      synonyms: ["rspec testing", "rspec ruby"],
      popularity: 78
    },
    {
      id: "chai",
      name: "Chai",
      category: "testing-framework",
      synonyms: ["chai.js", "chaijs", "chai assertion"],
      popularity: 81
    },
    {
      id: "vitest",
      name: "Vitest",
      category: "testing-framework",
      synonyms: ["vitest testing", "vite test"],
      popularity: 85
    },
    {
      id: "ava",
      name: "AVA",
      category: "testing-framework",
      synonyms: ["ava.js", "avajs", "ava testing"],
      popularity: 74
    },
    {
      id: "tape",
      name: "Tape",
      category: "testing-framework",
      synonyms: ["tape.js", "tapejs", "tape testing"],
      popularity: 71
    },
    {
      id: "enzyme",
      name: "Enzyme",
      category: "testing-framework",
      synonyms: ["enzyme.js", "enzymejs", "enzyme react"],
      popularity: 76
    },
    {
      id: "react-testing-library",
      name: "React Testing Library",
      category: "testing-framework",
      synonyms: ["rtl", "testing library", "react-testing-lib"],
      popularity: 89
    },
    {
      id: "vue-test-utils",
      name: "Vue Test Utils",
      category: "testing-framework",
      synonyms: ["vue testing library", "@vue/test-utils"],
      popularity: 82
    },
    {
      id: "cucumber",
      name: "Cucumber",
      category: "testing-framework",
      synonyms: ["cucumber bdd", "cucumber testing"],
      popularity: 77
    },
    {
      id: "specflow",
      name: "SpecFlow",
      category: "testing-framework",
      synonyms: ["spec flow", "specflow bdd"],
      popularity: 73
    },
    {
      id: "postman",
      name: "Postman",
      category: "testing-framework",
      synonyms: ["postman api", "postman testing"],
      popularity: 87
    },
    {
      id: "insomnia",
      name: "Insomnia",
      category: "testing-framework",
      synonyms: ["insomnia api", "insomnia rest"],
      popularity: 79
    },
    {
      id: "k6",
      name: "k6",
      category: "testing-framework",
      synonyms: ["k6 load testing", "grafana k6"],
      popularity: 78
    },
    {
      id: "jmeter",
      name: "JMeter",
      category: "testing-framework",
      synonyms: ["apache jmeter", "jmeter load testing"],
      popularity: 80
    },
    {
      id: "gatling",
      name: "Gatling",
      category: "testing-framework",
      synonyms: ["gatling load testing", "gatling performance"],
      popularity: 76
    },
    {
      id: "locust",
      name: "Locust",
      category: "testing-framework",
      synonyms: ["locust.io", "locust load testing"],
      popularity: 75
    },
    {
      id: "supertest",
      name: "SuperTest",
      category: "testing-framework",
      synonyms: ["super-test", "supertest.js"],
      popularity: 80
    },
    {
      id: "nock",
      name: "Nock",
      category: "testing-framework",
      synonyms: ["nock.js", "nock http"],
      popularity: 74
    },
    {
      id: "mockito",
      name: "Mockito",
      category: "testing-framework",
      synonyms: ["mockito java", "mockito framework"],
      popularity: 82
    },
    // Methodologies (20)
    {
      id: "agile",
      name: "Agile",
      category: "methodology",
      synonyms: ["agile methodology", "agile development", "agile practices"],
      popularity: 94
    },
    {
      id: "scrum",
      name: "Scrum",
      category: "methodology",
      synonyms: ["scrum framework", "scrum methodology", "scrum master"],
      popularity: 92
    },
    {
      id: "kanban",
      name: "Kanban",
      category: "methodology",
      synonyms: ["kanban board", "kanban methodology"],
      popularity: 88
    },
    {
      id: "ci/cd",
      name: "CI/CD",
      category: "methodology",
      synonyms: ["continuous integration", "continuous deployment", "continuous delivery", "cicd"],
      popularity: 95
    },
    {
      id: "tdd",
      name: "TDD",
      category: "methodology",
      synonyms: ["test driven development", "test-driven development"],
      popularity: 84
    },
    {
      id: "bdd",
      name: "BDD",
      category: "methodology",
      synonyms: ["behavior driven development", "behaviour driven development"],
      popularity: 80
    },
    {
      id: "ddd",
      name: "DDD",
      category: "methodology",
      synonyms: ["domain driven design", "domain-driven design"],
      popularity: 78
    },
    {
      id: "microservices",
      name: "Microservices",
      category: "methodology",
      synonyms: ["microservice architecture", "micro services", "microservices pattern"],
      popularity: 90
    },
    {
      id: "graphql",
      name: "GraphQL",
      category: "methodology",
      synonyms: ["graph ql", "graphql api"],
      popularity: 87
    },
    {
      id: "rest",
      name: "REST",
      category: "methodology",
      synonyms: ["rest api", "restful", "restful api", "rest architecture"],
      popularity: 93
    },
    {
      id: "grpc",
      name: "gRPC",
      category: "methodology",
      synonyms: ["grpc api", "grpc framework"],
      popularity: 82
    },
    {
      id: "soap",
      name: "SOAP",
      category: "methodology",
      synonyms: ["soap api", "soap protocol"],
      popularity: 72
    },
    {
      id: "oauth",
      name: "OAuth",
      category: "methodology",
      synonyms: ["oauth2", "oauth 2.0", "oauth authentication"],
      popularity: 86
    },
    {
      id: "jwt",
      name: "JWT",
      category: "methodology",
      synonyms: ["json web token", "jwt token", "jwt authentication"],
      popularity: 88
    },
    {
      id: "solid",
      name: "SOLID",
      category: "methodology",
      synonyms: ["solid principles", "solid design"],
      popularity: 81
    },
    {
      id: "clean-architecture",
      name: "Clean Architecture",
      category: "methodology",
      synonyms: ["clean code architecture", "clean arch"],
      popularity: 79
    },
    {
      id: "mvc",
      name: "MVC",
      category: "methodology",
      synonyms: ["model view controller", "mvc pattern"],
      popularity: 85
    },
    {
      id: "mvvm",
      name: "MVVM",
      category: "methodology",
      synonyms: ["model view viewmodel", "mvvm pattern"],
      popularity: 80
    },
    {
      id: "event-driven",
      name: "Event-Driven Architecture",
      category: "methodology",
      synonyms: ["event driven", "eda", "event-driven design"],
      popularity: 83
    },
    {
      id: "serverless",
      name: "Serverless",
      category: "methodology",
      synonyms: ["serverless architecture", "serverless computing", "faas"],
      popularity: 85
    },
    // Other Tools & Technologies (230)
    {
      id: "webpack",
      name: "Webpack",
      category: "other",
      synonyms: ["webpack.js", "webpack bundler"],
      popularity: 87
    },
    {
      id: "vite",
      name: "Vite",
      category: "other",
      synonyms: ["vite.js", "vitejs", "vite build"],
      popularity: 89
    },
    {
      id: "rollup",
      name: "Rollup",
      category: "other",
      synonyms: ["rollup.js", "rollupjs"],
      popularity: 80
    },
    {
      id: "parcel",
      name: "Parcel",
      category: "other",
      synonyms: ["parcel.js", "parceljs", "parcel bundler"],
      popularity: 76
    },
    {
      id: "esbuild",
      name: "esbuild",
      category: "other",
      synonyms: ["es build", "esbuild bundler"],
      popularity: 82
    },
    {
      id: "babel",
      name: "Babel",
      category: "other",
      synonyms: ["babel.js", "babeljs", "babel transpiler"],
      popularity: 85
    },
    {
      id: "swc",
      name: "SWC",
      category: "other",
      synonyms: ["speedy web compiler", "swc compiler"],
      popularity: 81
    },
    {
      id: "eslint",
      name: "ESLint",
      category: "other",
      synonyms: ["es lint", "eslint linter"],
      popularity: 90
    },
    {
      id: "prettier",
      name: "Prettier",
      category: "other",
      synonyms: ["prettier formatter", "prettier code"],
      popularity: 88
    },
    {
      id: "stylelint",
      name: "Stylelint",
      category: "other",
      synonyms: ["style lint", "stylelint css"],
      popularity: 78
    },
    {
      id: "tailwindcss",
      name: "Tailwind CSS",
      category: "other",
      synonyms: ["tailwind", "tailwindcss", "tailwind css framework"],
      popularity: 93
    },
    {
      id: "bootstrap",
      name: "Bootstrap",
      category: "other",
      synonyms: ["bootstrap css", "bootstrap framework"],
      popularity: 86
    },
    {
      id: "material-ui",
      name: "Material-UI",
      category: "other",
      synonyms: ["mui", "material ui", "materialui", "@mui"],
      popularity: 87
    },
    {
      id: "chakra-ui",
      name: "Chakra UI",
      category: "other",
      synonyms: ["chakra", "chakraui", "@chakra-ui"],
      popularity: 84
    },
    {
      id: "ant-design",
      name: "Ant Design",
      category: "other",
      synonyms: ["antd", "ant design react", "ant-design"],
      popularity: 83
    },
    {
      id: "shadcn-ui",
      name: "shadcn/ui",
      category: "other",
      synonyms: ["shadcn", "shadcn ui", "shadcnui"],
      popularity: 86
    },
    {
      id: "sass",
      name: "Sass",
      category: "other",
      synonyms: ["scss", "sass css", "sass preprocessor"],
      popularity: 84
    },
    {
      id: "less",
      name: "Less",
      category: "other",
      synonyms: ["less css", "less preprocessor"],
      popularity: 75
    },
    {
      id: "stylus",
      name: "Stylus",
      category: "other",
      synonyms: ["stylus css", "stylus preprocessor"],
      popularity: 70
    },
    {
      id: "postcss",
      name: "PostCSS",
      category: "other",
      synonyms: ["post css", "postcss processor"],
      popularity: 81
    },
    {
      id: "redux",
      name: "Redux",
      category: "other",
      synonyms: ["redux.js", "reduxjs", "redux state"],
      popularity: 88
    },
    {
      id: "mobx",
      name: "MobX",
      category: "other",
      synonyms: ["mobx state", "mobx.js"],
      popularity: 79
    },
    {
      id: "zustand",
      name: "Zustand",
      category: "other",
      synonyms: ["zustand state", "zustand store"],
      popularity: 83
    },
    {
      id: "recoil",
      name: "Recoil",
      category: "other",
      synonyms: ["recoil.js", "recoiljs", "recoil state"],
      popularity: 78
    },
    {
      id: "jotai",
      name: "Jotai",
      category: "other",
      synonyms: ["jotai state", "jotai atoms"],
      popularity: 77
    },
    {
      id: "valtio",
      name: "Valtio",
      category: "other",
      synonyms: ["valtio state", "valtio proxy"],
      popularity: 76
    },
    {
      id: "xstate",
      name: "XState",
      category: "other",
      synonyms: ["xstate machine", "x state"],
      popularity: 75
    },
    {
      id: "react-query",
      name: "React Query",
      category: "other",
      synonyms: ["tanstack query", "react-query", "reactquery"],
      popularity: 87
    },
    {
      id: "swr",
      name: "SWR",
      category: "other",
      synonyms: ["swr react", "stale-while-revalidate"],
      popularity: 82
    },
    {
      id: "apollo",
      name: "Apollo",
      category: "other",
      synonyms: ["apollo client", "apollo graphql", "apollo server"],
      popularity: 84
    },
    {
      id: "urql",
      name: "urql",
      category: "other",
      synonyms: ["urql graphql", "urql client"],
      popularity: 76
    },
    {
      id: "relay",
      name: "Relay",
      category: "other",
      synonyms: ["relay graphql", "relay framework"],
      popularity: 74
    },
    {
      id: "prisma",
      name: "Prisma",
      category: "other",
      synonyms: ["prisma orm", "prisma.io"],
      popularity: 88
    },
    {
      id: "typeorm",
      name: "TypeORM",
      category: "other",
      synonyms: ["type orm", "typeorm.io"],
      popularity: 83
    },
    {
      id: "sequelize",
      name: "Sequelize",
      category: "other",
      synonyms: ["sequelize orm", "sequelize.js"],
      popularity: 81
    },
    {
      id: "drizzle",
      name: "Drizzle",
      category: "other",
      synonyms: ["drizzle orm", "drizzle-orm"],
      popularity: 80
    },
    {
      id: "knex",
      name: "Knex",
      category: "other",
      synonyms: ["knex.js", "knexjs", "knex query"],
      popularity: 78
    },
    {
      id: "mongoose",
      name: "Mongoose",
      category: "other",
      synonyms: ["mongoose.js", "mongoosejs", "mongoose odm"],
      popularity: 85
    },
    {
      id: "sqlalchemy",
      name: "SQLAlchemy",
      category: "other",
      synonyms: ["sql alchemy", "sqlalchemy orm"],
      popularity: 84
    },
    {
      id: "hibernate",
      name: "Hibernate",
      category: "other",
      synonyms: ["hibernate orm", "hibernate java"],
      popularity: 82
    },
    {
      id: "entity-framework",
      name: "Entity Framework",
      category: "other",
      synonyms: ["ef core", "entity framework core", "ef"],
      popularity: 81
    },
    {
      id: "dapper",
      name: "Dapper",
      category: "other",
      synonyms: ["dapper orm", "dapper micro-orm"],
      popularity: 77
    },
    {
      id: "numpy",
      name: "NumPy",
      category: "other",
      synonyms: ["numpy python", "numpy array"],
      popularity: 90
    },
    {
      id: "pandas",
      name: "Pandas",
      category: "other",
      synonyms: ["pandas python", "pandas dataframe"],
      popularity: 91
    },
    {
      id: "matplotlib",
      name: "Matplotlib",
      category: "other",
      synonyms: ["matplotlib python", "matplotlib plot"],
      popularity: 85
    },
    {
      id: "seaborn",
      name: "Seaborn",
      category: "other",
      synonyms: ["seaborn python", "seaborn visualization"],
      popularity: 82
    },
    {
      id: "plotly",
      name: "Plotly",
      category: "other",
      synonyms: ["plotly python", "plotly.js", "plotly visualization"],
      popularity: 83
    },
    {
      id: "scikit-learn",
      name: "Scikit-learn",
      category: "other",
      synonyms: ["sklearn", "scikit learn", "sklearn python"],
      popularity: 89
    },
    {
      id: "tensorflow",
      name: "TensorFlow",
      category: "other",
      synonyms: ["tensor flow", "tensorflow ml", "tf"],
      popularity: 91
    },
    {
      id: "pytorch",
      name: "PyTorch",
      category: "other",
      synonyms: ["pytorch ml", "torch"],
      popularity: 92
    },
    {
      id: "keras",
      name: "Keras",
      category: "other",
      synonyms: ["keras ml", "keras deep learning"],
      popularity: 86
    },
    {
      id: "opencv",
      name: "OpenCV",
      category: "other",
      synonyms: ["open cv", "opencv computer vision"],
      popularity: 84
    },
    {
      id: "huggingface",
      name: "Hugging Face",
      category: "other",
      synonyms: ["huggingface transformers", "hf", "hugging face"],
      popularity: 87
    },
    {
      id: "langchain",
      name: "LangChain",
      category: "other",
      synonyms: ["lang chain", "langchain llm"],
      popularity: 85
    },
    {
      id: "llamaindex",
      name: "LlamaIndex",
      category: "other",
      synonyms: ["llama index", "llamaindex gpt"],
      popularity: 81
    },
    {
      id: "openai",
      name: "OpenAI",
      category: "other",
      synonyms: ["openai api", "openai gpt", "open ai"],
      popularity: 88
    },
    {
      id: "pinecone",
      name: "Pinecone",
      category: "other",
      synonyms: ["pinecone vector", "pinecone db"],
      popularity: 79
    },
    {
      id: "weaviate",
      name: "Weaviate",
      category: "other",
      synonyms: ["weaviate vector", "weaviate db"],
      popularity: 76
    },
    {
      id: "chromadb",
      name: "ChromaDB",
      category: "other",
      synonyms: ["chroma db", "chroma vector"],
      popularity: 78
    },
    {
      id: "apache-spark",
      name: "Apache Spark",
      category: "other",
      synonyms: ["spark", "pyspark", "apache spark"],
      popularity: 86
    },
    {
      id: "apache-kafka",
      name: "Apache Kafka",
      category: "other",
      synonyms: ["kafka", "kafka streaming"],
      popularity: 88
    },
    {
      id: "rabbitmq",
      name: "RabbitMQ",
      category: "other",
      synonyms: ["rabbit mq", "rabbitmq messaging"],
      popularity: 83
    },
    {
      id: "apache-airflow",
      name: "Apache Airflow",
      category: "other",
      synonyms: ["airflow", "airflow orchestration"],
      popularity: 84
    },
    {
      id: "dbt",
      name: "dbt",
      category: "other",
      synonyms: ["data build tool", "dbt analytics"],
      popularity: 82
    },
    {
      id: "snowflake",
      name: "Snowflake",
      category: "other",
      synonyms: ["snowflake db", "snowflake data warehouse"],
      popularity: 85
    },
    {
      id: "databricks",
      name: "Databricks",
      category: "other",
      synonyms: ["databricks platform", "databricks spark"],
      popularity: 83
    },
    {
      id: "tableau",
      name: "Tableau",
      category: "other",
      synonyms: ["tableau visualization", "tableau bi"],
      popularity: 81
    },
    {
      id: "power-bi",
      name: "Power BI",
      category: "other",
      synonyms: ["powerbi", "microsoft power bi", "power bi"],
      popularity: 84
    },
    {
      id: "looker",
      name: "Looker",
      category: "other",
      synonyms: ["looker bi", "google looker"],
      popularity: 78
    },
    {
      id: "metabase",
      name: "Metabase",
      category: "other",
      synonyms: ["metabase bi", "metabase analytics"],
      popularity: 75
    },
    {
      id: "superset",
      name: "Superset",
      category: "other",
      synonyms: ["apache superset", "superset bi"],
      popularity: 77
    },
    {
      id: "redash",
      name: "Redash",
      category: "other",
      synonyms: ["redash visualization", "redash analytics"],
      popularity: 74
    },
    {
      id: "d3",
      name: "D3.js",
      category: "other",
      synonyms: ["d3", "d3js", "d3 visualization"],
      popularity: 82
    },
    {
      id: "chart.js",
      name: "Chart.js",
      category: "other",
      synonyms: ["chartjs", "chart js"],
      popularity: 80
    },
    {
      id: "recharts",
      name: "Recharts",
      category: "other",
      synonyms: ["recharts react", "recharts.js"],
      popularity: 79
    },
    {
      id: "visx",
      name: "visx",
      category: "other",
      synonyms: ["visx react", "airbnb visx"],
      popularity: 75
    },
    {
      id: "three.js",
      name: "Three.js",
      category: "other",
      synonyms: ["threejs", "three js", "3d.js"],
      popularity: 84
    },
    {
      id: "webgl",
      name: "WebGL",
      category: "other",
      synonyms: ["web gl", "webgl graphics"],
      popularity: 78
    },
    {
      id: "gsap",
      name: "GSAP",
      category: "other",
      synonyms: ["greensock", "gsap animation"],
      popularity: 80
    },
    {
      id: "framer-motion",
      name: "Framer Motion",
      category: "other",
      synonyms: ["framer", "framer-motion", "framermotion"],
      popularity: 85
    },
    {
      id: "socket.io",
      name: "Socket.IO",
      category: "other",
      synonyms: ["socketio", "socket io", "socket.io websocket"],
      popularity: 83
    },
    {
      id: "websocket",
      name: "WebSocket",
      category: "other",
      synonyms: ["web socket", "ws protocol"],
      popularity: 84
    },
    {
      id: "webrtc",
      name: "WebRTC",
      category: "other",
      synonyms: ["web rtc", "webrtc real-time"],
      popularity: 79
    },
    {
      id: "pwa",
      name: "PWA",
      category: "other",
      synonyms: ["progressive web app", "progressive web application"],
      popularity: 81
    },
    {
      id: "service-worker",
      name: "Service Worker",
      category: "other",
      synonyms: ["serviceworker", "sw api"],
      popularity: 77
    },
    {
      id: "wasm",
      name: "WebAssembly",
      category: "other",
      synonyms: ["wasm", "web assembly"],
      popularity: 80
    },
    {
      id: "oauth2",
      name: "OAuth 2.0",
      category: "other",
      synonyms: ["oauth2", "oauth 2", "oauth2.0"],
      popularity: 85
    },
    {
      id: "saml",
      name: "SAML",
      category: "other",
      synonyms: ["saml2", "saml authentication"],
      popularity: 74
    },
    {
      id: "openid",
      name: "OpenID",
      category: "other",
      synonyms: ["openid connect", "oidc"],
      popularity: 76
    },
    {
      id: "auth0",
      name: "Auth0",
      category: "other",
      synonyms: ["auth0 authentication", "auth zero"],
      popularity: 82
    },
    {
      id: "firebase",
      name: "Firebase",
      category: "other",
      synonyms: ["firebase platform", "google firebase"],
      popularity: 87
    },
    {
      id: "amplify",
      name: "AWS Amplify",
      category: "other",
      synonyms: ["amplify", "aws amplify"],
      popularity: 80
    },
    {
      id: "clerk",
      name: "Clerk",
      category: "other",
      synonyms: ["clerk.dev", "clerk authentication"],
      popularity: 78
    },
    {
      id: "nextauth",
      name: "NextAuth",
      category: "other",
      synonyms: ["next-auth", "nextauth.js", "auth.js"],
      popularity: 83
    },
    {
      id: "passport",
      name: "Passport",
      category: "other",
      synonyms: ["passport.js", "passportjs", "passport authentication"],
      popularity: 81
    },
    {
      id: "jsonwebtoken",
      name: "jsonwebtoken",
      category: "other",
      synonyms: ["jsonwebtoken npm", "jwt library"],
      popularity: 84
    },
    {
      id: "bcrypt",
      name: "bcrypt",
      category: "other",
      synonyms: ["bcrypt.js", "bcryptjs", "bcrypt hash"],
      popularity: 82
    },
    {
      id: "axios",
      name: "Axios",
      category: "other",
      synonyms: ["axios http", "axios.js"],
      popularity: 89
    },
    {
      id: "fetch",
      name: "Fetch API",
      category: "other",
      synonyms: ["fetch", "fetch api", "fetch request"],
      popularity: 88
    },
    {
      id: "got",
      name: "Got",
      category: "other",
      synonyms: ["got http", "got.js"],
      popularity: 75
    },
    {
      id: "node-fetch",
      name: "node-fetch",
      category: "other",
      synonyms: ["nodefetch", "node fetch"],
      popularity: 79
    },
    {
      id: "undici",
      name: "Undici",
      category: "other",
      synonyms: ["undici http", "undici client"],
      popularity: 76
    },
    {
      id: "express-validator",
      name: "express-validator",
      category: "other",
      synonyms: ["expressvalidator", "express validator"],
      popularity: 78
    },
    {
      id: "joi",
      name: "Joi",
      category: "other",
      synonyms: ["joi validation", "joi schema"],
      popularity: 81
    },
    {
      id: "yup",
      name: "Yup",
      category: "other",
      synonyms: ["yup validation", "yup schema"],
      popularity: 83
    },
    {
      id: "zod",
      name: "Zod",
      category: "other",
      synonyms: ["zod validation", "zod schema"],
      popularity: 86
    },
    {
      id: "ajv",
      name: "Ajv",
      category: "other",
      synonyms: ["ajv validator", "ajv json schema"],
      popularity: 79
    },
    {
      id: "class-validator",
      name: "class-validator",
      category: "other",
      synonyms: ["classvalidator", "class validator"],
      popularity: 77
    },
    {
      id: "react-hook-form",
      name: "React Hook Form",
      category: "other",
      synonyms: ["rhf", "react-hook-form", "reacthookform"],
      popularity: 88
    },
    {
      id: "formik",
      name: "Formik",
      category: "other",
      synonyms: ["formik react", "formik forms"],
      popularity: 82
    },
    {
      id: "final-form",
      name: "Final Form",
      category: "other",
      synonyms: ["react-final-form", "final form"],
      popularity: 74
    },
    {
      id: "lodash",
      name: "Lodash",
      category: "other",
      synonyms: ["lodash.js", "lodashjs", "lodash utility"],
      popularity: 87
    },
    {
      id: "ramda",
      name: "Ramda",
      category: "other",
      synonyms: ["ramda.js", "ramdajs", "ramda fp"],
      popularity: 76
    },
    {
      id: "underscore",
      name: "Underscore",
      category: "other",
      synonyms: ["underscore.js", "underscorejs"],
      popularity: 73
    },
    {
      id: "moment",
      name: "Moment.js",
      category: "other",
      synonyms: ["momentjs", "moment js"],
      popularity: 78
    },
    {
      id: "dayjs",
      name: "Day.js",
      category: "other",
      synonyms: ["dayjs", "day js"],
      popularity: 82
    },
    {
      id: "date-fns",
      name: "date-fns",
      category: "other",
      synonyms: ["datefns", "date fns"],
      popularity: 84
    },
    {
      id: "luxon",
      name: "Luxon",
      category: "other",
      synonyms: ["luxon.js", "luxonjs"],
      popularity: 77
    },
    {
      id: "immutable",
      name: "Immutable.js",
      category: "other",
      synonyms: ["immutablejs", "immutable js"],
      popularity: 76
    },
    {
      id: "immer",
      name: "Immer",
      category: "other",
      synonyms: ["immer.js", "immerjs", "immer immutable"],
      popularity: 81
    },
    {
      id: "rxjs",
      name: "RxJS",
      category: "other",
      synonyms: ["reactive extensions", "rxjs reactive"],
      popularity: 80
    },
    {
      id: "node.js",
      name: "Node.js",
      category: "other",
      synonyms: ["nodejs", "node js", "node"],
      popularity: 95
    },
    {
      id: "deno",
      name: "Deno",
      category: "other",
      synonyms: ["deno runtime", "deno.land"],
      popularity: 79
    },
    {
      id: "bun",
      name: "Bun",
      category: "other",
      synonyms: ["bun runtime", "bun.sh"],
      popularity: 81
    },
    {
      id: "npm",
      name: "npm",
      category: "other",
      synonyms: ["npm package manager", "npmjs"],
      popularity: 92
    },
    {
      id: "yarn",
      name: "Yarn",
      category: "other",
      synonyms: ["yarn package manager", "yarnpkg"],
      popularity: 86
    },
    {
      id: "pnpm",
      name: "pnpm",
      category: "other",
      synonyms: ["pnpm package manager", "performant npm"],
      popularity: 83
    },
    {
      id: "pip",
      name: "pip",
      category: "other",
      synonyms: ["pip package manager", "pip python"],
      popularity: 89
    },
    {
      id: "conda",
      name: "Conda",
      category: "other",
      synonyms: ["conda package manager", "anaconda"],
      popularity: 82
    },
    {
      id: "poetry",
      name: "Poetry",
      category: "other",
      synonyms: ["poetry python", "poetry package manager"],
      popularity: 80
    },
    {
      id: "virtualenv",
      name: "virtualenv",
      category: "other",
      synonyms: ["virtual env", "python virtualenv"],
      popularity: 81
    },
    {
      id: "pipenv",
      name: "Pipenv",
      category: "other",
      synonyms: ["pip env", "pipenv python"],
      popularity: 77
    },
    {
      id: "composer",
      name: "Composer",
      category: "other",
      synonyms: ["composer php", "composer package manager"],
      popularity: 79
    },
    {
      id: "rubygems",
      name: "RubyGems",
      category: "other",
      synonyms: ["ruby gems", "gem package manager"],
      popularity: 74
    },
    {
      id: "bundler",
      name: "Bundler",
      category: "other",
      synonyms: ["bundler ruby", "bundler gem"],
      popularity: 75
    },
    {
      id: "nuget",
      name: "NuGet",
      category: "other",
      synonyms: ["nuget package manager", "nuget .net"],
      popularity: 78
    },
    {
      id: "cargo",
      name: "Cargo",
      category: "other",
      synonyms: ["cargo rust", "cargo package manager"],
      popularity: 79
    },
    {
      id: "homebrew",
      name: "Homebrew",
      category: "other",
      synonyms: ["brew", "homebrew mac"],
      popularity: 80
    },
    {
      id: "chocolatey",
      name: "Chocolatey",
      category: "other",
      synonyms: ["choco", "chocolatey windows"],
      popularity: 72
    },
    {
      id: "apt",
      name: "APT",
      category: "other",
      synonyms: ["apt-get", "apt package manager", "debian apt"],
      popularity: 77
    },
    {
      id: "yum",
      name: "YUM",
      category: "other",
      synonyms: ["yum package manager", "yellowdog updater"],
      popularity: 73
    },
    {
      id: "linux",
      name: "Linux",
      category: "other",
      synonyms: ["linux os", "gnu/linux"],
      popularity: 88
    },
    {
      id: "ubuntu",
      name: "Ubuntu",
      category: "other",
      synonyms: ["ubuntu linux", "ubuntu os"],
      popularity: 84
    },
    {
      id: "debian",
      name: "Debian",
      category: "other",
      synonyms: ["debian linux", "debian os"],
      popularity: 79
    },
    {
      id: "centos",
      name: "CentOS",
      category: "other",
      synonyms: ["centos linux", "centos os"],
      popularity: 76
    },
    {
      id: "rhel",
      name: "RHEL",
      category: "other",
      synonyms: ["red hat enterprise linux", "rhel linux"],
      popularity: 77
    },
    {
      id: "alpine",
      name: "Alpine Linux",
      category: "other",
      synonyms: ["alpine", "alpine os"],
      popularity: 78
    },
    {
      id: "arch",
      name: "Arch Linux",
      category: "other",
      synonyms: ["arch", "arch os"],
      popularity: 74
    },
    {
      id: "fedora",
      name: "Fedora",
      category: "other",
      synonyms: ["fedora linux", "fedora os"],
      popularity: 75
    },
    {
      id: "macos",
      name: "macOS",
      category: "other",
      synonyms: ["mac os", "osx", "os x"],
      popularity: 83
    },
    {
      id: "windows",
      name: "Windows",
      category: "other",
      synonyms: ["windows os", "microsoft windows"],
      popularity: 86
    },
    {
      id: "wsl",
      name: "WSL",
      category: "other",
      synonyms: ["windows subsystem for linux", "wsl2"],
      popularity: 80
    },
    {
      id: "vim",
      name: "Vim",
      category: "other",
      synonyms: ["vim editor", "vi"],
      popularity: 79
    },
    {
      id: "neovim",
      name: "Neovim",
      category: "other",
      synonyms: ["nvim", "neovim editor"],
      popularity: 78
    },
    {
      id: "emacs",
      name: "Emacs",
      category: "other",
      synonyms: ["emacs editor", "gnu emacs"],
      popularity: 72
    },
    {
      id: "vscode",
      name: "VS Code",
      category: "other",
      synonyms: ["visual studio code", "vscode", "vs code"],
      popularity: 94
    },
    {
      id: "intellij",
      name: "IntelliJ IDEA",
      category: "other",
      synonyms: ["intellij", "idea ide"],
      popularity: 85
    },
    {
      id: "pycharm",
      name: "PyCharm",
      category: "other",
      synonyms: ["pycharm ide", "pycharm python"],
      popularity: 82
    },
    {
      id: "webstorm",
      name: "WebStorm",
      category: "other",
      synonyms: ["webstorm ide", "webstorm jetbrains"],
      popularity: 78
    },
    {
      id: "sublime",
      name: "Sublime Text",
      category: "other",
      synonyms: ["sublime", "sublime text editor"],
      popularity: 77
    },
    {
      id: "atom",
      name: "Atom",
      category: "other",
      synonyms: ["atom editor", "atom ide"],
      popularity: 70
    },
    {
      id: "jupyter",
      name: "Jupyter",
      category: "other",
      synonyms: ["jupyter notebook", "jupyter lab"],
      popularity: 86
    },
    {
      id: "colab",
      name: "Google Colab",
      category: "other",
      synonyms: ["colab", "google colaboratory", "colaboratory"],
      popularity: 81
    },
    {
      id: "databricks-notebooks",
      name: "Databricks Notebooks",
      category: "other",
      synonyms: ["databricks notebook", "databricks notebooks"],
      popularity: 76
    },
    {
      id: "postman-api",
      name: "Postman",
      category: "other",
      synonyms: ["postman tool", "postman client"],
      popularity: 88
    },
    {
      id: "swagger",
      name: "Swagger",
      category: "other",
      synonyms: ["swagger api", "openapi", "swagger ui"],
      popularity: 85
    },
    {
      id: "openapi",
      name: "OpenAPI",
      category: "other",
      synonyms: ["openapi spec", "openapi specification"],
      popularity: 84
    },
    {
      id: "api-gateway",
      name: "API Gateway",
      category: "other",
      synonyms: ["apigateway", "api gateway pattern"],
      popularity: 82
    },
    {
      id: "kong",
      name: "Kong",
      category: "other",
      synonyms: ["kong gateway", "kong api gateway"],
      popularity: 78
    },
    {
      id: "apigee",
      name: "Apigee",
      category: "other",
      synonyms: ["apigee api", "google apigee"],
      popularity: 74
    },
    {
      id: "mulesoft",
      name: "MuleSoft",
      category: "other",
      synonyms: ["mule soft", "mulesoft api"],
      popularity: 75
    },
    {
      id: "tyk",
      name: "Tyk",
      category: "other",
      synonyms: ["tyk gateway", "tyk api"],
      popularity: 72
    },
    {
      id: "strapi",
      name: "Strapi",
      category: "other",
      synonyms: ["strapi cms", "strapi headless"],
      popularity: 79
    },
    {
      id: "contentful",
      name: "Contentful",
      category: "other",
      synonyms: ["contentful cms", "contentful headless"],
      popularity: 78
    },
    {
      id: "sanity",
      name: "Sanity",
      category: "other",
      synonyms: ["sanity.io", "sanity cms"],
      popularity: 80
    },
    {
      id: "wordpress",
      name: "WordPress",
      category: "other",
      synonyms: ["wordpress cms", "wp"],
      popularity: 82
    },
    {
      id: "drupal",
      name: "Drupal",
      category: "other",
      synonyms: ["drupal cms", "drupal platform"],
      popularity: 73
    },
    {
      id: "joomla",
      name: "Joomla",
      category: "other",
      synonyms: ["joomla cms", "joomla platform"],
      popularity: 68
    },
    {
      id: "shopify",
      name: "Shopify",
      category: "other",
      synonyms: ["shopify platform", "shopify ecommerce"],
      popularity: 81
    },
    {
      id: "magento",
      name: "Magento",
      category: "other",
      synonyms: ["magento ecommerce", "adobe magento"],
      popularity: 74
    },
    {
      id: "woocommerce",
      name: "WooCommerce",
      category: "other",
      synonyms: ["woo commerce", "woocommerce plugin"],
      popularity: 77
    },
    {
      id: "stripe",
      name: "Stripe",
      category: "other",
      synonyms: ["stripe payments", "stripe api"],
      popularity: 87
    },
    {
      id: "paypal",
      name: "PayPal",
      category: "other",
      synonyms: ["paypal payments", "paypal api"],
      popularity: 80
    },
    {
      id: "square",
      name: "Square",
      category: "other",
      synonyms: ["square payments", "square api"],
      popularity: 76
    },
    {
      id: "twilio",
      name: "Twilio",
      category: "other",
      synonyms: ["twilio api", "twilio sms"],
      popularity: 81
    },
    {
      id: "sendgrid",
      name: "SendGrid",
      category: "other",
      synonyms: ["sendgrid email", "sendgrid api"],
      popularity: 78
    },
    {
      id: "mailchimp",
      name: "Mailchimp",
      category: "other",
      synonyms: ["mailchimp email", "mailchimp api"],
      popularity: 76
    },
    {
      id: "algolia",
      name: "Algolia",
      category: "other",
      synonyms: ["algolia search", "algolia api"],
      popularity: 79
    },
    {
      id: "meilisearch",
      name: "Meilisearch",
      category: "other",
      synonyms: ["meili search", "meilisearch engine"],
      popularity: 75
    },
    {
      id: "typesense",
      name: "Typesense",
      category: "other",
      synonyms: ["typesense search", "typesense engine"],
      popularity: 74
    },
    {
      id: "mapbox",
      name: "Mapbox",
      category: "other",
      synonyms: ["mapbox maps", "mapbox api"],
      popularity: 77
    },
    {
      id: "google-maps",
      name: "Google Maps",
      category: "other",
      synonyms: ["google maps api", "gmaps", "google maps platform"],
      popularity: 83
    },
    {
      id: "leaflet",
      name: "Leaflet",
      category: "other",
      synonyms: ["leaflet.js", "leafletjs", "leaflet maps"],
      popularity: 76
    },
    {
      id: "openlayers",
      name: "OpenLayers",
      category: "other",
      synonyms: ["open layers", "openlayers maps"],
      popularity: 73
    },
    {
      id: "data-structures",
      name: "Data Structures",
      category: "other",
      synonyms: ["data structure", "ds", "data structures algorithms"],
      popularity: 90
    },
    {
      id: "algorithms",
      name: "Algorithms",
      category: "other",
      synonyms: ["algorithm", "algo", "algorithmic"],
      popularity: 91
    },
    {
      id: "oop",
      name: "OOP",
      category: "other",
      synonyms: ["object oriented programming", "object-oriented programming", "oop principles"],
      popularity: 88
    },
    {
      id: "functional-programming",
      name: "Functional Programming",
      category: "other",
      synonyms: ["fp", "functional programming paradigm", "functional paradigm"],
      popularity: 82
    },
    {
      id: "design-patterns",
      name: "Design Patterns",
      category: "other",
      synonyms: ["design pattern", "software design patterns", "gof patterns"],
      popularity: 85
    },
    {
      id: "system-design",
      name: "System Design",
      category: "other",
      synonyms: ["systems design", "distributed systems", "system architecture"],
      popularity: 89
    },
    {
      id: "low-level-design",
      name: "Low Level Design",
      category: "other",
      synonyms: ["lld", "low-level design", "object oriented design"],
      popularity: 80
    },
    {
      id: "high-level-design",
      name: "High Level Design",
      category: "other",
      synonyms: ["hld", "high-level design", "architecture design"],
      popularity: 81
    },
    {
      id: "concurrency",
      name: "Concurrency",
      category: "other",
      synonyms: ["concurrent programming", "concurrency patterns", "multithreading"],
      popularity: 83
    },
    {
      id: "multithreading",
      name: "Multithreading",
      category: "other",
      synonyms: ["multi-threading", "threading", "parallel programming"],
      popularity: 82
    },
    {
      id: "networking",
      name: "Networking",
      category: "other",
      synonyms: ["computer networking", "network protocols", "tcp/ip"],
      popularity: 84
    },
    {
      id: "security",
      name: "Security",
      category: "other",
      synonyms: ["cybersecurity", "application security", "infosec"],
      popularity: 87
    },
    {
      id: "cryptography",
      name: "Cryptography",
      category: "other",
      synonyms: ["encryption", "crypto", "cryptographic"],
      popularity: 79
    },
    {
      id: "blockchain",
      name: "Blockchain",
      category: "other",
      synonyms: ["blockchain technology", "distributed ledger"],
      popularity: 76
    },
    {
      id: "smart-contracts",
      name: "Smart Contracts",
      category: "other",
      synonyms: ["smart contract", "ethereum contracts"],
      popularity: 73
    },
    {
      id: "web3",
      name: "Web3",
      category: "other",
      synonyms: ["web3.js", "web3js", "web 3.0"],
      popularity: 77
    },
    {
      id: "ethers",
      name: "Ethers.js",
      category: "other",
      synonyms: ["ethers", "ethersjs", "ethers.js"],
      popularity: 75
    },
    {
      id: "hardhat",
      name: "Hardhat",
      category: "other",
      synonyms: ["hardhat ethereum", "hardhat framework"],
      popularity: 74
    },
    {
      id: "truffle",
      name: "Truffle",
      category: "other",
      synonyms: ["truffle suite", "truffle framework"],
      popularity: 72
    },
    {
      id: "machine-learning",
      name: "Machine Learning",
      category: "other",
      synonyms: ["ml", "machine learning algorithms", "ml algorithms"],
      popularity: 92
    },
    {
      id: "deep-learning",
      name: "Deep Learning",
      category: "other",
      synonyms: ["dl", "deep learning models", "neural networks"],
      popularity: 90
    },
    {
      id: "computer-vision",
      name: "Computer Vision",
      category: "other",
      synonyms: ["cv", "computer vision algorithms", "image processing"],
      popularity: 86
    },
    {
      id: "nlp",
      name: "NLP",
      category: "other",
      synonyms: ["natural language processing", "nlp algorithms", "text processing"],
      popularity: 88
    },
    {
      id: "reinforcement-learning",
      name: "Reinforcement Learning",
      category: "other",
      synonyms: ["rl", "reinforcement learning algorithms", "rl algorithms"],
      popularity: 80
    },
    {
      id: "generative-ai",
      name: "Generative AI",
      category: "other",
      synonyms: ["genai", "gen ai", "generative artificial intelligence"],
      popularity: 89
    },
    {
      id: "llm",
      name: "LLM",
      category: "other",
      synonyms: ["large language model", "llms", "large language models"],
      popularity: 87
    },
    {
      id: "prompt-engineering",
      name: "Prompt Engineering",
      category: "other",
      synonyms: ["prompt engineer", "prompt design", "prompt crafting"],
      popularity: 83
    },
    {
      id: "rag",
      name: "RAG",
      category: "other",
      synonyms: ["retrieval augmented generation", "rag pattern", "retrieval-augmented generation"],
      popularity: 82
    },
    {
      id: "fine-tuning",
      name: "Fine-tuning",
      category: "other",
      synonyms: ["model fine-tuning", "finetuning", "model training"],
      popularity: 81
    },
    // Soft Skills & Leadership (30 skills)
    {
      id: "communication",
      name: "Communication",
      category: "other",
      synonyms: ["written communication", "verbal communication", "interpersonal communication"],
      popularity: 95
    },
    {
      id: "leadership",
      name: "Leadership",
      category: "other",
      synonyms: ["team leadership", "leading teams", "leadership skills"],
      popularity: 92
    },
    {
      id: "problem-solving",
      name: "Problem Solving",
      category: "other",
      synonyms: ["problem-solving skills", "analytical thinking", "critical thinking"],
      popularity: 94
    },
    {
      id: "collaboration",
      name: "Collaboration",
      category: "other",
      synonyms: ["teamwork", "team collaboration", "cross-functional collaboration"],
      popularity: 93
    },
    {
      id: "project-management",
      name: "Project Management",
      category: "methodology",
      synonyms: ["managing projects", "project planning", "project coordination"],
      popularity: 90
    },
    {
      id: "time-management",
      name: "Time Management",
      category: "other",
      synonyms: ["prioritization", "task management", "deadline management"],
      popularity: 88
    },
    {
      id: "adaptability",
      name: "Adaptability",
      category: "other",
      synonyms: ["flexibility", "adaptable", "flexible"],
      popularity: 87
    },
    {
      id: "attention-to-detail",
      name: "Attention to Detail",
      category: "other",
      synonyms: ["detail-oriented", "meticulous", "thorough"],
      popularity: 89
    },
    {
      id: "mentoring",
      name: "Mentoring",
      category: "other",
      synonyms: ["coaching", "mentorship", "coaching team members"],
      popularity: 85
    },
    {
      id: "stakeholder-management",
      name: "Stakeholder Management",
      category: "other",
      synonyms: ["managing stakeholders", "client relations", "stakeholder communication"],
      popularity: 84
    },
    {
      id: "technical-writing",
      name: "Technical Writing",
      category: "other",
      synonyms: ["documentation", "writing documentation", "technical documentation"],
      popularity: 86
    },
    {
      id: "code-review",
      name: "Code Review",
      category: "other",
      synonyms: ["reviewing code", "peer review", "code reviews"],
      popularity: 88
    },
    {
      id: "debugging",
      name: "Debugging",
      category: "other",
      synonyms: ["troubleshooting", "bug fixing", "problem diagnosis"],
      popularity: 91
    },
    {
      id: "performance-optimization",
      name: "Performance Optimization",
      category: "other",
      synonyms: ["optimization", "performance tuning", "speed optimization"],
      popularity: 87
    },
    {
      id: "security-best-practices",
      name: "Security Best Practices",
      category: "other",
      synonyms: ["application security", "secure coding", "security awareness"],
      popularity: 90
    },
    // Modern Cloud & Infrastructure (15 skills)
    {
      id: "terraform",
      name: "Terraform",
      category: "devops-tool",
      synonyms: ["terraform iac", "infrastructure as code terraform"],
      popularity: 89
    },
    {
      id: "cloudformation",
      name: "CloudFormation",
      category: "devops-tool",
      synonyms: ["aws cloudformation", "cloud formation"],
      popularity: 82
    },
    {
      id: "pulumi",
      name: "Pulumi",
      category: "devops-tool",
      synonyms: ["pulumi iac"],
      popularity: 75
    },
    {
      id: "datadog",
      name: "Datadog",
      category: "devops-tool",
      synonyms: ["datadog monitoring", "datadog apm"],
      popularity: 83
    },
    {
      id: "new-relic",
      name: "New Relic",
      category: "devops-tool",
      synonyms: ["newrelic", "new relic apm"],
      popularity: 80
    },
    {
      id: "splunk",
      name: "Splunk",
      category: "devops-tool",
      synonyms: ["splunk monitoring", "splunk logging"],
      popularity: 81
    },
    {
      id: "lambda",
      name: "AWS Lambda",
      category: "cloud-platform",
      synonyms: ["lambda functions", "serverless lambda", "aws lambda functions"],
      popularity: 88
    },
    {
      id: "s3",
      name: "AWS S3",
      category: "cloud-platform",
      synonyms: ["s3 storage", "amazon s3", "simple storage service"],
      popularity: 90
    },
    {
      id: "ec2",
      name: "AWS EC2",
      category: "cloud-platform",
      synonyms: ["ec2 instances", "amazon ec2", "elastic compute cloud"],
      popularity: 87
    },
    {
      id: "rds",
      name: "AWS RDS",
      category: "cloud-platform",
      synonyms: ["rds database", "amazon rds", "relational database service"],
      popularity: 85
    },
    {
      id: "azure-functions",
      name: "Azure Functions",
      category: "cloud-platform",
      synonyms: ["serverless azure", "azure serverless"],
      popularity: 82
    },
    {
      id: "gcp-cloud-functions",
      name: "Google Cloud Functions",
      category: "cloud-platform",
      synonyms: ["cloud functions", "gcp functions"],
      popularity: 80
    },
    {
      id: "snowflake",
      name: "Snowflake",
      category: "database",
      synonyms: ["snowflake data warehouse", "snowflake db"],
      popularity: 86
    },
    {
      id: "databricks",
      name: "Databricks",
      category: "other",
      synonyms: ["databricks platform", "databricks spark"],
      popularity: 84
    },
    {
      id: "airflow",
      name: "Apache Airflow",
      category: "other",
      synonyms: ["airflow", "airflow orchestration", "apache airflow dags"],
      popularity: 85
    }
  ];
  content;
  class SkillsDatabase {
    constructor(skillsData = []) {
      __publicField(this, "skills");
      __publicField(this, "synonymIndex");
      this.skills = /* @__PURE__ */ new Map();
      this.synonymIndex = /* @__PURE__ */ new Map();
      skillsData.forEach((skill) => {
        this.addSkill(skill);
      });
    }
    /**
     * Add a skill to the database with its synonyms indexed
     * @param skill - Skill object to add
     */
    addSkill(skill) {
      const normalizedId = skill.id.toLowerCase();
      this.skills.set(normalizedId, skill);
      this.synonymIndex.set(skill.name.toLowerCase(), normalizedId);
      if (skill.synonyms && Array.isArray(skill.synonyms)) {
        skill.synonyms.forEach((synonym) => {
          this.synonymIndex.set(synonym.toLowerCase(), normalizedId);
        });
      }
    }
    /**
     * Find a skill by name or synonym
     * @param term - Skill name or synonym (case-insensitive)
     * @returns Skill object or null if not found
     */
    findSkill(term) {
      if (!term || typeof term !== "string") {
        return null;
      }
      const normalizedTerm = term.toLowerCase().trim();
      const skillId = this.synonymIndex.get(normalizedTerm);
      if (!skillId) {
        return null;
      }
      return this.skills.get(skillId) || null;
    }
    /**
     * Find all skills matching a specific category
     * @param category - Skill category to filter by
     * @returns Array of skills in the category
     */
    findSkillsByCategory(category) {
      const results = [];
      this.skills.forEach((skill) => {
        if (skill.category === category) {
          results.push(skill);
        }
      });
      return results;
    }
    /**
     * Get all skills in the database
     * @returns Array of all skills
     */
    getAllSkills() {
      return Array.from(this.skills.values());
    }
    /**
     * Get the canonical skill ID for a term
     * @param term - Skill name or synonym (case-insensitive)
     * @returns Canonical skill ID or null if not found
     */
    getCanonicalName(term) {
      if (!term || typeof term !== "string") {
        return null;
      }
      const normalizedTerm = term.toLowerCase().trim();
      return this.synonymIndex.get(normalizedTerm) || null;
    }
    /**
     * Check if a term is a known skill
     * Fast boolean check for skill existence
     * @param term - Skill name or synonym (case-insensitive)
     * @returns True if skill exists in database
     */
    isKnownSkill(term) {
      if (!term || typeof term !== "string") {
        return false;
      }
      const normalizedTerm = term.toLowerCase().trim();
      return this.synonymIndex.has(normalizedTerm);
    }
    /**
     * Get total number of skills in database
     * @returns Count of unique skills
     */
    getTotalSkills() {
      return this.skills.size;
    }
    /**
     * Get all synonyms for a skill
     * @param skillId - Skill ID
     * @returns Array of all synonyms including the skill name
     */
    getSynonyms(skillId) {
      const normalizedId = skillId.toLowerCase();
      const skill = this.skills.get(normalizedId);
      if (!skill) {
        return [];
      }
      const synonyms = [skill.name];
      if (skill.synonyms && Array.isArray(skill.synonyms)) {
        synonyms.push(...skill.synonyms);
      }
      return synonyms;
    }
    /**
     * Find multiple skills by an array of terms
     * @param terms - Array of skill names or synonyms
     * @returns Array of found skills (null entries for not found)
     */
    findMultipleSkills(terms) {
      return terms.map((term) => this.findSkill(term));
    }
  }
  const skillsDatabase = new SkillsDatabase(SKILLS_DATA);
  content;
  function extractKeywordsFromJobDescription(jobDescription) {
    if (!jobDescription || typeof jobDescription !== "string") {
      log$1.warn(LogCategory.SERVICE, "Invalid job description input", { jobDescription });
      return [];
    }
    const endTrace = log$1.trace(LogCategory.SERVICE, "extractKeywordsFromJobDescription", {
      descriptionLength: jobDescription.length
    });
    try {
      log$1.debug(LogCategory.SERVICE, "Starting keyword extraction", {
        textLength: jobDescription.length,
        wordCount: jobDescription.split(/\s+/).length
      });
      const keywords = /* @__PURE__ */ new Map();
      log$1.debug(LogCategory.SERVICE, "Extracting known skills from skills database");
      const allSkills = skillsDatabase.getAllSkills();
      let knownSkillsFound = 0;
      for (const skill of allSkills) {
        if (!skill || !skill.name) continue;
        const termsToCheck = [skill.id, skill.name, ...skill.synonyms];
        for (const term of termsToCheck) {
          const termPattern = new RegExp(`\\b${escapeRegex(term)}\\b`, "i");
          if (termPattern.test(jobDescription)) {
            const canonicalTerm = skill.name;
            const frequency = (jobDescription.match(termPattern) || []).length;
            const required = isRequiredSkill(canonicalTerm, jobDescription);
            const weight = calculateKeywordWeight(canonicalTerm, frequency, jobDescription, required) + 20;
            if (weight >= 30) {
              keywords.set(canonicalTerm.toLowerCase(), {
                phrase: canonicalTerm,
                score: weight,
                occurrences: frequency,
                category: skill.category,
                required,
                frequency,
                // Optional, for backwards compatibility
                context: findKeywordContext(canonicalTerm, jobDescription),
                synonyms: skill.synonyms
              });
              log$1.debug(LogCategory.SERVICE, `Added keyword: "${canonicalTerm}"`, {
                required,
                weight,
                frequency
              });
              knownSkillsFound++;
            } else {
              log$1.debug(LogCategory.SERVICE, `Filtered out "${canonicalTerm}" (weight too low)`, {
                required,
                weight,
                threshold: 20
              });
            }
            break;
          }
        }
      }
      log$1.info(LogCategory.SERVICE, `Found ${knownSkillsFound} known skills from database`);
      log$1.debug(LogCategory.SERVICE, "Extracting acronyms and technical patterns");
      const acronyms = extractAcronyms(jobDescription);
      for (const acronym of acronyms) {
        if (keywords.has(acronym.toLowerCase())) {
          continue;
        }
        const frequency = (jobDescription.match(new RegExp(`\\b${escapeRegex(acronym)}\\b`, "gi")) || []).length;
        const required = isRequiredSkill(acronym, jobDescription);
        const weight = calculateKeywordWeight(acronym, frequency, jobDescription, required) + 10;
        if (weight >= 30) {
          const category = categorizeKeyword(acronym);
          keywords.set(acronym.toLowerCase(), {
            phrase: acronym,
            score: weight,
            occurrences: frequency,
            category,
            required,
            frequency,
            context: [],
            synonyms: []
          });
        }
      }
      log$1.info(LogCategory.SERVICE, `Found ${acronyms.length} acronyms/technical patterns`);
      log$1.debug(LogCategory.SERVICE, "Sorting keywords by score");
      const sortedKeywords = Array.from(keywords.values()).sort((a, b) => b.score - a.score);
      const topN = Math.min(30, sortedKeywords.length);
      for (let i = 0; i < topN; i++) {
        sortedKeywords[i].context = findKeywordContext(sortedKeywords[i].phrase, jobDescription);
      }
      log$1.info(LogCategory.SERVICE, "Keyword extraction completed", {
        totalExtracted: sortedKeywords.length,
        requiredCount: sortedKeywords.filter((k) => k.required).length,
        preferredCount: sortedKeywords.filter((k) => !k.required).length,
        topKeywords: sortedKeywords.slice(0, 10).map((k) => k.phrase)
      });
      endTrace(sortedKeywords);
      return sortedKeywords;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Keyword extraction failed", error);
      endTrace();
      throw error;
    }
  }
  function extractAcronyms(text) {
    const acronyms = /* @__PURE__ */ new Set();
    const allCapsPattern = /\b[A-Z]{2,6}\b/g;
    const allCapsMatches = text.match(allCapsPattern) || [];
    const nonTechnical = /* @__PURE__ */ new Set([
      // Geography
      "US",
      "USA",
      "UK",
      "EU",
      "CA",
      "AU",
      "NZ",
      "JP",
      "CN",
      "IN",
      // Time zones
      "PM",
      "AM",
      "EST",
      "PST",
      "CST",
      "MST",
      "UTC",
      "GMT",
      // Common words
      "IT",
      "OR",
      "AND",
      "NOT",
      "FOR",
      "THE",
      "WE",
      "OUR",
      "YOU",
      "ALL",
      // Business fluff
      "LLC",
      "INC",
      "LTD",
      "CORP",
      "CO",
      "PLC",
      "EOE",
      // Months
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG",
      "SEP",
      "OCT",
      "NOV",
      "DEC"
    ]);
    for (const match of allCapsMatches) {
      if (!nonTechnical.has(match)) {
        acronyms.add(match);
      }
    }
    const specialPatterns = [
      /\bCI\/CD\b/gi,
      /\bC\+\+\b/gi,
      /\bC#\b/gi,
      /\bF#\b/gi,
      /\b\.NET\b/gi,
      /\bNode\.js\b/gi,
      /\bReact\.js\b/gi,
      /\bVue\.js\b/gi,
      /\bNext\.js\b/gi,
      /\bExpress\.js\b/gi,
      /\bAngular\.js\b/gi
    ];
    for (const pattern of specialPatterns) {
      const matches = text.match(pattern) || [];
      for (const match of matches) {
        acronyms.add(match);
      }
    }
    const compoundPatterns = [
      // AI/ML
      /\bMachine Learning\b/gi,
      /\bArtificial Intelligence\b/gi,
      /\bNatural Language Processing\b/gi,
      /\bDeep Learning\b/gi,
      /\bComputer Vision\b/gi,
      /\bData Science\b/gi,
      /\bLarge Language Model(s)?\b/gi,
      // Development
      /\bWeb Development\b/gi,
      /\bFull[- ]?Stack\b/gi,
      /\bFront[- ]?End\b/gi,
      /\bBack[- ]?End\b/gi,
      /\bMobile Development\b/gi,
      /\bSoftware Engineering\b/gi,
      // DevOps & Cloud
      /\bDevOps\b/gi,
      /\bCloud Computing\b/gi,
      /\bInfrastructure as Code\b/gi,
      /\bContinuous Integration\b/gi,
      /\bContinuous Deployment\b/gi,
      /\bContinuous Delivery\b/gi,
      // Architecture
      /\bMicroservices\b/gi,
      /\bServerless\b/gi,
      /\bEvent[- ]?Driven\b/gi,
      /\bService[- ]?Oriented Architecture\b/gi,
      // Methodologies
      /\bAgile Development\b/gi,
      /\bTest[- ]?Driven Development\b/gi,
      /\bBehavior[- ]?Driven Development\b/gi
    ];
    for (const pattern of compoundPatterns) {
      const matches = text.match(pattern) || [];
      for (const match of matches) {
        acronyms.add(match);
      }
    }
    const kpiPatterns = [
      /\bMTTR\b/g,
      // Mean Time To Recovery
      /\bMTBF\b/g,
      // Mean Time Between Failures
      /\bSLA\b/g,
      // Service Level Agreement
      /\bSLO\b/g,
      // Service Level Objective
      /\bSLI\b/g,
      // Service Level Indicator
      /\bKPI(s)?\b/gi,
      // Key Performance Indicator
      /\bOKR(s)?\b/gi,
      // Objectives and Key Results
      /\bROI\b/g,
      // Return on Investment
      /\bRPO\b/g,
      // Recovery Point Objective
      /\bRTO\b/g
      // Recovery Time Objective
    ];
    for (const pattern of kpiPatterns) {
      const matches = text.match(pattern) || [];
      for (const match of matches) {
        acronyms.add(match);
      }
    }
    const industryPatterns = [
      // Healthcare
      /\bHIPAA\b/g,
      /\bHL7\b/g,
      /\bFHIR\b/g,
      /\bEHR\b/g,
      /\bEMR\b/g,
      // Finance
      /\bPCI[- ]?DSS\b/gi,
      /\bGDPR\b/g,
      /\bSOX\b/g,
      /\bKYC\b/g,
      /\bAML\b/g,
      // Government/Defense
      /\bFedRAMP\b/g,
      /\bFISMA\b/g,
      /\bITAR\b/g,
      // Security
      /\bOWASP\b/g,
      /\bCVE\b/g,
      /\bSOC 2\b/g,
      /\bISO 27001\b/g
    ];
    for (const pattern of industryPatterns) {
      const matches = text.match(pattern) || [];
      for (const match of matches) {
        acronyms.add(match);
      }
    }
    return Array.from(acronyms);
  }
  function parseJobSections(jobDescription) {
    const sections = {
      rawText: jobDescription
    };
    const patterns = {
      requiredQualifications: [
        /^\s*(required\s+qualifications?)\s*:?/im,
        /^\s*(requirements?)\s*:?/im,
        /^\s*(must\s+have)\s*:?/im,
        /^\s*(required\s+skills?)\s*:?/im,
        /^\s*(minimum\s+qualifications?)\s*:?/im
      ],
      preferredQualifications: [
        /^\s*(preferred\s+qualifications?)\s*:?/im,
        /^\s*(nice\s+to\s+have)\s*:?/im,
        /^\s*(bonus)\s*:?/im,
        /^\s*(plus)\s*:?/im,
        /^\s*(ideal\s+candidate)\s*:?/im,
        /^\s*(preferred\s+skills?)\s*:?/im,
        /^\s*(optional)\s*:?/im
      ],
      responsibilities: [
        /^\s*(responsibilities?)\s*:?/im,
        /^\s*(what\s+you'?ll\s+do)\s*:?/im,
        /^\s*(role\s+overview)\s*:?/im,
        /^\s*(your\s+role)\s*:?/im,
        /^\s*(duties)\s*:?/im
      ],
      benefits: [
        /^\s*(benefits)\s*:?/im,
        /^\s*(what\s+we\s+offer)\s*:?/im,
        /^\s*(perks)\s*:?/im,
        /^\s*(compensation)\s*:?/im
      ]
    };
    const lines = jobDescription.split("\n");
    let currentSection = null;
    let sectionText = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;
      let matchedSection = null;
      for (const [section, regexes] of Object.entries(patterns)) {
        if (regexes.some((regex) => regex.test(line))) {
          matchedSection = section;
          break;
        }
      }
      if (matchedSection) {
        if (currentSection && sectionText) {
          sections[currentSection] = sectionText.trim();
        }
        currentSection = matchedSection;
        sectionText = "";
      } else if (currentSection) {
        sectionText += line + " ";
      }
    }
    if (currentSection && sectionText) {
      sections[currentSection] = sectionText.trim();
    }
    log$1.debug(LogCategory.SERVICE, "Job sections parsed", {
      hasRequired: !!sections.requiredQualifications,
      hasPreferred: !!sections.preferredQualifications,
      hasResponsibilities: !!sections.responsibilities,
      hasBenefits: !!sections.benefits,
      requiredLength: sections.requiredQualifications?.length || 0,
      preferredLength: sections.preferredQualifications?.length || 0
    });
    return sections;
  }
  function isRequiredSkill(term, jobDescription) {
    const sections = parseJobSections(jobDescription);
    const lowerTerm = term.toLowerCase();
    const regex = new RegExp(`\\b${escapeRegex(lowerTerm)}\\b`, "i");
    const inRequired = sections.requiredQualifications && regex.test(sections.requiredQualifications);
    const inPreferred = sections.preferredQualifications && regex.test(sections.preferredQualifications);
    const inResponsibilities = sections.responsibilities && regex.test(sections.responsibilities);
    if (inRequired) {
      log$1.debug(LogCategory.SERVICE, `[isRequiredSkill] "${term}" â†’ REQUIRED (Priority 1: in required section)`, {
        inRequired,
        inPreferred,
        inResponsibilities
      });
      return true;
    }
    if (inPreferred) {
      log$1.debug(LogCategory.SERVICE, `[isRequiredSkill] "${term}" â†’ PREFERRED (Priority 2: in preferred section)`, {
        inRequired,
        inPreferred,
        inResponsibilities
      });
      return false;
    }
    if (inResponsibilities) {
      log$1.debug(LogCategory.SERVICE, `[isRequiredSkill] "${term}" â†’ REQUIRED (Priority 2.5: in responsibilities section)`, {
        inRequired,
        inPreferred,
        inResponsibilities
      });
      return true;
    }
    const requiredIndicators = [
      "required",
      "must have",
      "must possess",
      "essential",
      "mandatory",
      "necessary",
      "require",
      "requires",
      "requiring"
    ];
    const preferredIndicators = [
      "preferred",
      "nice to have",
      "bonus",
      "plus",
      "desired",
      "ideal",
      "would be great"
    ];
    const sentences = jobDescription.toLowerCase().split(/[.!?]+/);
    const relevantSentences = sentences.filter((s) => s.includes(lowerTerm));
    const hasRequiredIndicator = relevantSentences.some(
      (sentence) => requiredIndicators.some((indicator) => sentence.includes(indicator))
    );
    const hasPreferredIndicator = relevantSentences.some(
      (sentence) => preferredIndicators.some((indicator) => sentence.includes(indicator))
    );
    if (hasRequiredIndicator) {
      log$1.debug(LogCategory.SERVICE, `[isRequiredSkill] "${term}" â†’ REQUIRED (Priority 3: has required indicator)`, {
        inRequired,
        inPreferred,
        inResponsibilities,
        hasRequiredIndicator
      });
      return true;
    }
    if (hasPreferredIndicator) {
      log$1.debug(LogCategory.SERVICE, `[isRequiredSkill] "${term}" â†’ PREFERRED (Priority 3: has preferred indicator)`, {
        inRequired,
        inPreferred,
        inResponsibilities,
        hasPreferredIndicator
      });
      return false;
    }
    const frequency = (jobDescription.toLowerCase().match(new RegExp(`\\b${escapeRegex(lowerTerm)}\\b`, "g")) || []).length;
    const isFrequent = frequency >= 3;
    log$1.debug(LogCategory.SERVICE, `[isRequiredSkill] "${term}" â†’ ${isFrequent ? "REQUIRED" : "PREFERRED"} (Priority 4: frequency=${frequency})`, {
      inRequired,
      inPreferred,
      inResponsibilities,
      frequency,
      isFrequent
    });
    return isFrequent;
  }
  function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function calculateKeywordWeight(term, frequency, jobDescription, required) {
    let weight = 0;
    weight += Math.min(30, frequency * 5);
    if (required) {
      weight += 20;
    } else {
      weight += 10;
    }
    const positionScore = calculatePositionScore(term, jobDescription);
    weight += positionScore;
    if (isTechnicalTerm(term)) {
      weight += 15;
    }
    const wordCount = term.split(/\s+/).length;
    const isKnownSkill = skillsDatabase.isKnownSkill(term);
    const hasStopWords = /\b(with|using|and|or|the|a|an|in|on|at|for|of|to|from)\b/i.test(term);
    const fillerWords = /* @__PURE__ */ new Set([
      // Job posting meta words
      "position",
      "candidate",
      "requirements",
      "required",
      "preferred",
      "responsibilities",
      "qualifications",
      "opportunity",
      "role",
      "job",
      // Generic experience words
      "experience",
      "experienced",
      "years",
      "level",
      "senior",
      "junior",
      "associate",
      "entry",
      "mid",
      "range",
      "background",
      // Generic action words (not specific skills)
      "ability",
      "knowledge",
      "understanding",
      "familiarity",
      "proficiency",
      // Company/team words
      "company",
      "team",
      "organization",
      "department",
      "group",
      "culture",
      // Generic nouns
      "skills",
      "degree",
      "education",
      "certification",
      "training"
    ]);
    if (wordCount === 1 && fillerWords.has(term.toLowerCase())) {
      return 0;
    }
    const genericTechTerms = /* @__PURE__ */ new Set([
      "software",
      "data",
      "design",
      "development",
      "engineer",
      "engineering",
      "system",
      "project",
      "code",
      "build",
      "implement",
      "create"
    ]);
    if (genericTechTerms.has(term.toLowerCase())) {
      if (wordCount === 1) {
        weight -= 20;
      } else if (!isKnownSkill) {
        weight -= 10;
      }
    }
    if (isKnownSkill && wordCount >= 2) {
      weight += 15;
    } else if (hasStopWords) {
      weight -= 20;
    } else if (wordCount >= 2) {
      weight += 5;
    }
    return Math.min(100, weight);
  }
  function calculatePositionScore(term, jobDescription) {
    const index2 = jobDescription.toLowerCase().indexOf(term);
    if (index2 === -1) return 0;
    const docLength = jobDescription.length;
    const relativePosition = index2 / docLength;
    if (relativePosition < 0.25) return 20;
    if (relativePosition < 0.5) return 15;
    if (relativePosition < 0.75) return 10;
    return 5;
  }
  function isTechnicalTerm(term) {
    const technicalPatterns = [
      /^[a-z]+\.js$/i,
      // JavaScript frameworks: react.js, vue.js
      /^[a-z]+#$/,
      // Languages with #: c#, f#
      /\+\+$/,
      // C++
      /^aws|azure|gcp/i,
      // Cloud platforms
      /sql|nosql|database/i,
      // Databases
      /python|java|ruby|php|go|rust|swift|kotlin/i,
      // Languages
      /react|angular|vue|svelte/i,
      // Frontend frameworks
      /node|express|django|flask|spring/i,
      // Backend frameworks
      /docker|kubernetes|jenkins|ci\/cd/i,
      // DevOps
      /api|rest|graphql|grpc/i
      // API technologies
    ];
    return technicalPatterns.some((pattern) => pattern.test(term));
  }
  function findKeywordContext(term, jobDescription) {
    const sentences = jobDescription.split(/[.!?]+/);
    const contexts = [];
    for (const sentence of sentences) {
      if (sentence.toLowerCase().includes(term)) {
        contexts.push(sentence.trim());
        if (contexts.length >= 3) break;
      }
    }
    return contexts;
  }
  function categorizeKeyword(term) {
    if (/python|java|ruby|php|go|rust|swift|kotlin|javascript|typescript|c\+\+|c#/i.test(term)) {
      return "language";
    }
    if (/react|angular|vue|svelte|node|express|django|flask|spring|rails/i.test(term)) {
      return "framework";
    }
    if (/aws|azure|gcp|google cloud|amazon web services/i.test(term)) {
      return "cloud";
    }
    if (/docker|kubernetes|jenkins|ci\/cd|terraform|ansible|cicd/i.test(term)) {
      return "devops";
    }
    if (/sql|mongodb|postgres|mysql|redis|elasticsearch|database/i.test(term)) {
      return "db";
    }
    if (/rest|graphql|grpc|http|snmp|api/i.test(term)) {
      return "protocol";
    }
    if (/agile|scrum|kanban|waterfall|lean|tdd/i.test(term)) {
      return "methodology";
    }
    const softSkills = [
      "communication",
      "leadership",
      "teamwork",
      "collaboration",
      "problem solving",
      "analytical",
      "creative",
      "detail oriented",
      "time management",
      "adaptable",
      "flexible"
    ];
    if (softSkills.some((skill) => term.toLowerCase().includes(skill))) {
      return "soft";
    }
    if (/engineer|developer|architect|manager|lead|analyst/i.test(term)) {
      return "role";
    }
    if (/tool|software|platform|system|suite/.test(term)) {
      return "tool";
    }
    return "other";
  }
  function categorizeJobRequirements(jobDescription) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "categorizeJobRequirements", {
      descriptionLength: jobDescription.length
    });
    try {
      log$1.debug(LogCategory.SERVICE, "Categorizing job requirements into required vs preferred");
      const keywords = extractKeywordsFromJobDescription(jobDescription);
      const required = keywords.filter((k) => k.required).map((k) => k.phrase);
      const preferred = keywords.filter((k) => !k.required).map((k) => k.phrase);
      const result2 = { required, preferred };
      log$1.info(LogCategory.SERVICE, "Job requirements categorized", {
        requiredCount: required.length,
        preferredCount: preferred.length,
        topRequired: required.slice(0, 5),
        topPreferred: preferred.slice(0, 5)
      });
      endTrace(result2);
      return result2;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Job requirements categorization failed", error);
      endTrace();
      throw error;
    }
  }
  content;
  const keywordExtractor = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    categorizeJobRequirements,
    extractKeywordsFromJobDescription
  }, Symbol.toStringTag, { value: "Module" }));
  function JobsTab({ panelWidth: _panelWidth = 400 }) {
    const [jobs, setJobs] = reactExports.useState([]);
    const [resumes, setResumes] = reactExports.useState([]);
    const [selectedJob, setSelectedJob] = reactExports.useState(null);
    const [generatedResume, setGeneratedResume] = reactExports.useState(null);
    const [loading, setLoading] = reactExports.useState(true);
    const [generating, setGenerating] = reactExports.useState(false);
    const [analyzing, setAnalyzing] = reactExports.useState(false);
    const [error, setError] = reactExports.useState("");
    const [success, setSuccess] = reactExports.useState("");
    reactExports.useEffect(() => {
      loadData();
    }, []);
    const loadData = async () => {
      try {
        setLoading(true);
        const [jobsData, resumesData] = await Promise.all([
          getJobDescriptionAnalyses(),
          getGeneratedResumes()
        ]);
        jobsData.sort((a, b) => b.analyzedAt - a.analyzedAt);
        resumesData.sort((a, b) => b.generatedAt - a.generatedAt);
        setJobs(jobsData);
        setResumes(resumesData);
      } catch (err) {
        console.error("[Uproot] Error loading jobs:", err);
        setError("Failed to load jobs");
      } finally {
        setLoading(false);
      }
    };
    const handleGenerateResume = async (job) => {
      try {
        setGenerating(true);
        setError("");
        const profile = await getProfessionalProfile();
        if (!profile) {
          throw new Error("Please build your professional profile first");
        }
        console.log("[Uproot] Generating resume for:", job.jobTitle);
        const resume = await generateResumeWithAI(job, profile);
        await saveGeneratedResume(resume);
        setGeneratedResume(resume);
        setResumes([resume, ...resumes]);
        console.log("[Uproot] Resume generated successfully");
      } catch (err) {
        console.error("[Uproot] Error generating resume:", err);
        setError(err instanceof Error ? err.message : "Failed to generate resume");
      } finally {
        setGenerating(false);
      }
    };
    const handleDeleteJob = async (id) => {
      try {
        await deleteJobDescriptionAnalysis(id);
        setJobs(jobs.filter((j) => j.id !== id));
        if (selectedJob?.id === id) {
          setSelectedJob(null);
          setGeneratedResume(null);
        }
      } catch (err) {
        console.error("[Uproot] Error deleting job:", err);
      }
    };
    const handleDownloadPDF = async (_resume) => {
      alert("PDF export coming in v0.2.0! For now, use Copy to Clipboard.");
    };
    const handleDownloadDOCX = async (_resume) => {
      alert("DOCX export coming in v0.2.0! For now, use Copy to Clipboard.");
    };
    const handleCopyToClipboard = (resume) => {
      if (!resume.content.formattedText) return;
      navigator.clipboard.writeText(resume.content.formattedText);
      alert("Resume copied to clipboard!");
    };
    const handleAnalyzeCurrentPage = async () => {
      try {
        setAnalyzing(true);
        setError("");
        setSuccess("");
        console.log("[Uproot] Requesting job analysis from background script...");
        const response = await Promise.race([
          chrome.runtime.sendMessage({ type: "ANALYZE_CURRENT_JOB" }),
          new Promise(
            (_, reject) => setTimeout(() => reject(new Error("Job analysis timed out after 35 seconds. Please try again.")), 35e3)
          )
        ]);
        if (!response.success) {
          throw new Error(response.error || "Failed to analyze job");
        }
        console.log("[Uproot] Received job data:", response.data);
        if (!response.data || typeof response.data !== "object") {
          throw new Error("Invalid response: Missing or invalid response data");
        }
        const { description, jobTitle, company, location: location2, url } = response.data;
        if (!description || typeof description !== "string" || description.trim().length === 0) {
          throw new Error("Invalid response: Job description is required and must be a non-empty string");
        }
        if (!jobTitle || typeof jobTitle !== "string" || jobTitle.trim().length === 0) {
          throw new Error("Invalid response: Job title is required and must be a non-empty string");
        }
        if (!company || typeof company !== "string" || company.trim().length === 0) {
          throw new Error("Invalid response: Company name is required and must be a non-empty string");
        }
        const keywords = extractKeywordsFromJobDescription(description);
        const requirements = categorizeJobRequirements(description);
        const jobAnalysis = {
          id: `job_${Date.now()}`,
          rawText: description,
          jobTitle,
          company,
          location: location2,
          // Optional field
          jobUrl: url,
          // Optional field
          extractedKeywords: keywords,
          requiredSkills: requirements.required,
          preferredSkills: requirements.preferred,
          requiredExperience: [],
          preferredExperience: [],
          analyzedAt: Date.now()
        };
        await saveJobDescriptionAnalysis(jobAnalysis);
        setJobs([jobAnalysis, ...jobs]);
        setSuccess(`âœ“ Job analyzed: ${jobAnalysis.jobTitle} at ${jobAnalysis.company}`);
        console.log("[Uproot] Job saved successfully");
        setTimeout(() => setSuccess(""), 3e3);
      } catch (err) {
        console.error("[Uproot] Error analyzing job:", err);
        let errorMessage = "Failed to analyze job";
        if (err instanceof Error) {
          if (err.message.includes("Job details failed to load within timeout")) {
            errorMessage = "Job details are taking too long to load. This might be due to:\nâ€¢ Slow internet connection\nâ€¢ LinkedIn page still loading\nâ€¢ LinkedIn changed their page structure\n\nTry: Wait a few seconds for the page to fully load, then click Analyze again.";
          } else if (err.message.includes("timed out after 35 seconds")) {
            errorMessage = "Analysis timed out. The job page may be slow to respond.\n\nTry: Refresh the LinkedIn page and try again.";
          } else if (err.message.includes("Invalid response")) {
            errorMessage = "Unable to extract job information from this page.\n\nMake sure you're on a LinkedIn job posting page and the job description is visible.";
          } else {
            errorMessage = err.message;
          }
        }
        setError(errorMessage);
      } finally {
        setAnalyzing(false);
      }
    };
    const getATSScoreStyle = (score) => {
      if (score >= 80) return { color: "#059669", backgroundColor: "#ecfdf5" };
      if (score >= 65) return { color: "#0077B5", backgroundColor: "#eff6ff" };
      if (score >= 50) return { color: "#ea580c", backgroundColor: "#fff7ed" };
      return { color: "#dc2626", backgroundColor: "#fef2f2" };
    };
    const formatDate = (timestamp) => {
      const date = new Date(timestamp);
      return date.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
    };
    if (loading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            color: "#6e6e73"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { size: 24, strokeWidth: 2, style: { animation: "spin 1s linear infinite" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
            @keyframes spin {
              from { transform: rotate(0deg); }
              to { transform: rotate(360deg); }
            }
          ` })
          ]
        }
      );
    }
    if (jobs.length === 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
            @keyframes spin {
              from { transform: rotate(0deg); }
              to { transform: rotate(360deg); }
            }
          ` }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "column",
              height: "100%",
              overflow: "auto"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    padding: "20px 20px 16px 20px",
                    borderBottom: "1px solid rgba(0, 0, 0, 0.08)"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h2",
                    {
                      style: {
                        fontSize: "20px",
                        fontWeight: "700",
                        margin: 0,
                        color: "#1d1d1f"
                      },
                      children: "Your Jobs"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, padding: "20px", overflow: "auto" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: handleAnalyzeCurrentPage,
                    disabled: analyzing,
                    style: {
                      width: "100%",
                      padding: "14px 20px",
                      background: analyzing ? "#9ca3af" : "#0077B5",
                      color: "white",
                      border: "none",
                      borderRadius: "8px",
                      fontSize: "14px",
                      fontWeight: "600",
                      cursor: analyzing ? "not-allowed" : "pointer",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      gap: "10px",
                      transition: "background 0.2s, transform 0.1s",
                      marginBottom: "16px"
                    },
                    onMouseEnter: (e) => {
                      if (!analyzing) {
                        e.currentTarget.style.background = "#006399";
                        e.currentTarget.style.transform = "translateY(-1px)";
                      }
                    },
                    onMouseLeave: (e) => {
                      if (!analyzing) {
                        e.currentTarget.style.background = "#0077B5";
                        e.currentTarget.style.transform = "translateY(0)";
                      }
                    },
                    children: analyzing ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { size: 18, strokeWidth: 2, style: { animation: "spin 1s linear infinite" } }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Analyzing Job..." })
                    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Scan, { size: 18, strokeWidth: 2 }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Analyze Current LinkedIn Job Page" })
                    ] })
                  }
                ),
                error && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      padding: "12px 16px",
                      backgroundColor: "#fef2f2",
                      border: "1px solid #fecaca",
                      borderRadius: "8px",
                      fontSize: "13px",
                      color: "#dc2626",
                      marginBottom: "16px"
                    },
                    children: error
                  }
                ),
                success && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      padding: "12px 16px",
                      backgroundColor: "#ecfdf5",
                      border: "1px solid #a7f3d0",
                      borderRadius: "8px",
                      fontSize: "13px",
                      color: "#059669",
                      marginBottom: "16px"
                    },
                    children: success
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      textAlign: "center",
                      paddingTop: "48px",
                      paddingBottom: "48px"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Briefcase,
                        {
                          size: 48,
                          strokeWidth: 1.5,
                          style: {
                            color: "#d1d5db",
                            margin: "0 auto 16px auto"
                          }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "h3",
                        {
                          style: {
                            fontSize: "14px",
                            fontWeight: "600",
                            margin: "0 0 8px 0",
                            color: "#1d1d1f"
                          },
                          children: "No jobs analyzed yet"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "p",
                        {
                          style: {
                            fontSize: "13px",
                            color: "#6e6e73",
                            margin: "0 0 8px 0",
                            lineHeight: "1.5"
                          },
                          children: 'Navigate to a LinkedIn job page and click "Analyze Current LinkedIn Job Page" above'
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "p",
                        {
                          style: {
                            fontSize: "12px",
                            color: "#9ca3af",
                            margin: 0,
                            lineHeight: "1.4"
                          },
                          children: "The extension will extract job requirements and keywords to generate custom resumes"
                        }
                      )
                    ]
                  }
                )
              ] })
            ]
          }
        )
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
          @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
          }
        ` }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            height: "100%",
            overflow: "hidden"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  padding: "20px 20px 16px 20px",
                  borderBottom: "1px solid rgba(0, 0, 0, 0.08)"
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "4px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h2",
                    {
                      style: {
                        fontSize: "20px",
                        fontWeight: "700",
                        margin: 0,
                        color: "#1d1d1f"
                      },
                      children: "Your Jobs"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        fontSize: "12px",
                        color: "#6e6e73"
                      },
                      children: [
                        jobs.length,
                        " analyzed"
                      ]
                    }
                  )
                ] })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, padding: "20px", overflow: "auto" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: handleAnalyzeCurrentPage,
                  disabled: analyzing,
                  style: {
                    width: "100%",
                    padding: "14px 20px",
                    background: analyzing ? "#9ca3af" : "#0077B5",
                    color: "white",
                    border: "none",
                    borderRadius: "8px",
                    fontSize: "14px",
                    fontWeight: "600",
                    cursor: analyzing ? "not-allowed" : "pointer",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    gap: "10px",
                    transition: "background 0.2s, transform 0.1s",
                    marginBottom: "16px"
                  },
                  onMouseEnter: (e) => {
                    if (!analyzing) {
                      e.currentTarget.style.background = "#006399";
                      e.currentTarget.style.transform = "translateY(-1px)";
                    }
                  },
                  onMouseLeave: (e) => {
                    if (!analyzing) {
                      e.currentTarget.style.background = "#0077B5";
                      e.currentTarget.style.transform = "translateY(0)";
                    }
                  },
                  children: analyzing ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { size: 18, strokeWidth: 2, style: { animation: "spin 1s linear infinite" } }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Analyzing Job..." })
                  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Scan, { size: 18, strokeWidth: 2 }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Analyze Current LinkedIn Job Page" })
                  ] })
                }
              ),
              error && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    padding: "12px 16px",
                    backgroundColor: "#fef2f2",
                    border: "1px solid #fecaca",
                    borderRadius: "8px",
                    fontSize: "13px",
                    color: "#dc2626",
                    marginBottom: "16px"
                  },
                  children: error
                }
              ),
              success && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    padding: "12px 16px",
                    backgroundColor: "#ecfdf5",
                    border: "1px solid #a7f3d0",
                    borderRadius: "8px",
                    fontSize: "13px",
                    color: "#059669",
                    marginBottom: "16px"
                  },
                  children: success
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: jobs.map((job) => {
                const existingResume = resumes.find((r2) => r2.jobDescriptionId === job.id);
                const isSelected = selectedJob?.id === job.id;
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  JobCard$2,
                  {
                    job,
                    existingResume,
                    isSelected,
                    generating,
                    onSelect: () => {
                      setSelectedJob(job);
                      if (existingResume) {
                        setGeneratedResume(existingResume);
                      } else {
                        setGeneratedResume(null);
                      }
                    },
                    onDelete: (e) => {
                      e.stopPropagation();
                      handleDeleteJob(job.id);
                    },
                    onGenerateResume: (e) => {
                      e.stopPropagation();
                      handleGenerateResume(job);
                    },
                    getATSScoreStyle,
                    formatDate
                  },
                  job.id
                );
              }) }),
              selectedJob && generatedResume && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    marginTop: "16px",
                    paddingTop: "16px",
                    borderTop: "1px solid rgba(0, 0, 0, 0.08)"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        backgroundColor: "white",
                        border: "1px solid rgba(0, 0, 0, 0.08)",
                        borderRadius: "8px",
                        padding: "16px"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            style: {
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "space-between",
                              marginBottom: "16px"
                            },
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "h3",
                                {
                                  style: {
                                    fontSize: "16px",
                                    fontWeight: "700",
                                    margin: 0,
                                    color: "#1d1d1f"
                                  },
                                  children: "Generated Resume"
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                "div",
                                {
                                  style: {
                                    fontSize: "13px",
                                    padding: "6px 12px",
                                    borderRadius: "8px",
                                    fontWeight: "600",
                                    ...getATSScoreStyle(generatedResume.atsOptimization.overallATSScore)
                                  },
                                  children: [
                                    "ATS Score: ",
                                    generatedResume.atsOptimization.overallATSScore,
                                    "/100"
                                  ]
                                }
                              )
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            style: {
                              display: "grid",
                              gridTemplateColumns: "1fr 1fr 1fr",
                              gap: "12px",
                              marginBottom: "16px"
                            },
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center" }, children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "12px", color: "#6e6e73", marginBottom: "4px" }, children: "Keyword Match" }),
                                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "20px", fontWeight: "700", color: "#1d1d1f" }, children: [
                                  generatedResume.atsOptimization.keywordMatchRate,
                                  "%"
                                ] })
                              ] }),
                              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center" }, children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "12px", color: "#6e6e73", marginBottom: "4px" }, children: "Format" }),
                                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "20px", fontWeight: "700", color: "#1d1d1f" }, children: [
                                  generatedResume.atsOptimization.formatCompliance.score,
                                  "%"
                                ] })
                              ] }),
                              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center" }, children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "12px", color: "#6e6e73", marginBottom: "4px" }, children: "Content" }),
                                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "20px", fontWeight: "700", color: "#1d1d1f" }, children: [
                                  generatedResume.atsOptimization.contentQuality.score,
                                  "%"
                                ] })
                              ] })
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "10px" }, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            "button",
                            {
                              onClick: () => handleDownloadPDF(),
                              style: {
                                width: "100%",
                                padding: "12px 16px",
                                background: "#0077B5",
                                color: "white",
                                border: "none",
                                borderRadius: "8px",
                                fontSize: "14px",
                                fontWeight: "600",
                                cursor: "pointer",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                gap: "10px",
                                transition: "background 0.2s, transform 0.1s"
                              },
                              onMouseEnter: (e) => {
                                e.currentTarget.style.background = "#006399";
                                e.currentTarget.style.transform = "translateY(-1px)";
                              },
                              onMouseLeave: (e) => {
                                e.currentTarget.style.background = "#0077B5";
                                e.currentTarget.style.transform = "translateY(0)";
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { size: 16, strokeWidth: 2 }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Download as PDF (for Easy Apply)" })
                              ]
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            "button",
                            {
                              onClick: () => handleDownloadDOCX(),
                              style: {
                                width: "100%",
                                padding: "12px 16px",
                                background: "#059669",
                                color: "white",
                                border: "none",
                                borderRadius: "8px",
                                fontSize: "14px",
                                fontWeight: "600",
                                cursor: "pointer",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                gap: "10px",
                                transition: "background 0.2s, transform 0.1s"
                              },
                              onMouseEnter: (e) => {
                                e.currentTarget.style.background = "#047857";
                                e.currentTarget.style.transform = "translateY(-1px)";
                              },
                              onMouseLeave: (e) => {
                                e.currentTarget.style.background = "#059669";
                                e.currentTarget.style.transform = "translateY(0)";
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { size: 16, strokeWidth: 2 }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Download as DOCX (for Easy Apply)" })
                              ]
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            "button",
                            {
                              onClick: () => handleCopyToClipboard(generatedResume),
                              style: {
                                width: "100%",
                                padding: "12px 16px",
                                background: "white",
                                color: "#1d1d1f",
                                border: "1px solid rgba(0, 0, 0, 0.12)",
                                borderRadius: "8px",
                                fontSize: "14px",
                                fontWeight: "600",
                                cursor: "pointer",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                gap: "10px",
                                transition: "background 0.2s, border-color 0.2s"
                              },
                              onMouseEnter: (e) => {
                                e.currentTarget.style.background = "#f9fafb";
                                e.currentTarget.style.borderColor = "rgba(0, 0, 0, 0.16)";
                              },
                              onMouseLeave: (e) => {
                                e.currentTarget.style.background = "white";
                                e.currentTarget.style.borderColor = "rgba(0, 0, 0, 0.12)";
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { size: 16, strokeWidth: 2 }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Copy to Clipboard" })
                              ]
                            }
                          )
                        ] }),
                        generatedResume.atsOptimization.recommendations.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            style: {
                              marginTop: "16px",
                              paddingTop: "16px",
                              borderTop: "1px solid rgba(0, 0, 0, 0.08)"
                            },
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "h4",
                                {
                                  style: {
                                    fontSize: "12px",
                                    fontWeight: "700",
                                    color: "#6e6e73",
                                    margin: "0 0 8px 0"
                                  },
                                  children: "Recommendations"
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { style: { margin: 0, padding: 0, listStyle: "none", display: "flex", flexDirection: "column", gap: "6px" }, children: generatedResume.atsOptimization.recommendations.slice(0, 3).map((rec, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                "li",
                                {
                                  style: {
                                    fontSize: "12px",
                                    color: "#6e6e73",
                                    display: "flex",
                                    alignItems: "flex-start",
                                    gap: "8px"
                                  },
                                  children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#0077B5", marginTop: "2px" }, children: "â€¢" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: rec })
                                  ]
                                },
                                i
                              )) })
                            ]
                          }
                        )
                      ]
                    }
                  )
                }
              )
            ] })
          ]
        }
      )
    ] });
  }
  function JobCard$2({
    job,
    existingResume,
    isSelected,
    generating,
    onSelect,
    onDelete,
    onGenerateResume,
    getATSScoreStyle,
    formatDate
  }) {
    const [isHovered, setIsHovered] = reactExports.useState(false);
    const [showKeywords, setShowKeywords] = reactExports.useState(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "16px",
          borderRadius: "12px",
          border: isSelected ? "1px solid #0077B5" : "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: isSelected ? "rgba(0, 119, 181, 0.03)" : "white",
          boxShadow: isHovered && !isSelected ? "0 4px 12px rgba(0, 0, 0, 0.08)" : "0 2px 4px rgba(0, 0, 0, 0.04)",
          cursor: "pointer",
          transition: "all 200ms cubic-bezier(0.4, 0.0, 0.2, 1)",
          transform: isHovered && !isSelected ? "translateY(-2px)" : "translateY(0)"
        },
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", justifyContent: "space-between", marginBottom: "8px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "h3",
                {
                  style: {
                    fontSize: "15px",
                    fontWeight: "600",
                    margin: "0 0 6px 0",
                    color: "#1d1d1f"
                  },
                  children: job.jobTitle
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: "8px",
                    fontSize: "13px",
                    color: "#6e6e73",
                    marginBottom: "8px"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { size: 12, strokeWidth: 2 }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: job.company }),
                    job.location && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { size: 12, strokeWidth: 2, style: { marginLeft: "4px" } }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: job.location })
                    ] })
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: onDelete,
                style: {
                  padding: "8px",
                  background: "transparent",
                  border: "none",
                  borderRadius: "6px",
                  color: "#9ca3af",
                  cursor: "pointer",
                  transition: "all 150ms"
                },
                title: "Delete job",
                onMouseEnter: (e) => {
                  e.currentTarget.style.color = "#dc2626";
                  e.currentTarget.style.backgroundColor = "#fef2f2";
                },
                onMouseLeave: (e) => {
                  e.currentTarget.style.color = "#9ca3af";
                  e.currentTarget.style.backgroundColor = "transparent";
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 16, strokeWidth: 2 })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              onClick: onSelect,
              style: {
                display: "flex",
                alignItems: "center",
                gap: "16px",
                fontSize: "12px",
                color: "#6e6e73",
                marginBottom: "12px"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 12, strokeWidth: 2 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                    job.extractedKeywords.length,
                    " keywords"
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Calendar, { size: 12, strokeWidth: 2 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: formatDate(job.analyzedAt) })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: (e) => {
                e.stopPropagation();
                setShowKeywords(!showKeywords);
              },
              style: {
                width: "100%",
                padding: "8px 12px",
                marginBottom: "12px",
                backgroundColor: "transparent",
                border: "1px solid #0077B5",
                borderRadius: "6px",
                fontSize: "12px",
                fontWeight: "600",
                color: "#0077B5",
                cursor: "pointer",
                transition: "all 150ms",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "6px"
              },
              onMouseEnter: (e) => {
                e.currentTarget.style.backgroundColor = "rgba(0, 119, 181, 0.05)";
              },
              onMouseLeave: (e) => {
                e.currentTarget.style.backgroundColor = "transparent";
              },
              children: [
                showKeywords ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { size: 14 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { size: 14 }),
                showKeywords ? "Hide Keywords" : "View All Keywords"
              ]
            }
          ),
          showKeywords && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: "12px", paddingBottom: "12px", borderBottom: "1px solid rgba(0, 0, 0, 0.08)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px" }, children: (() => {
            const sortedKeywords = job.extractedKeywords.sort((a, b) => b.score - a.score);
            const scores = sortedKeywords.map((k) => k.score || 0);
            const minScore = Math.min(...scores);
            const maxScore = Math.max(...scores);
            const getColorForScore = (score) => {
              if (maxScore === minScore) {
                return { bg: "#34C75915", border: "#34C759" };
              }
              const normalized = (score - minScore) / (maxScore - minScore);
              const hue = normalized * 120;
              return {
                bg: `hsl(${hue}, 70%, 95%)`,
                border: `hsl(${hue}, 70%, 45%)`
              };
            };
            return sortedKeywords.map((keyword) => {
              const score = keyword.score || 0;
              const colors = getColorForScore(score);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    padding: "6px 10px",
                    backgroundColor: colors.bg,
                    borderLeft: `3px solid ${colors.border}`,
                    borderRadius: "6px",
                    fontSize: "11px",
                    fontWeight: "600",
                    color: "#1d1d1f",
                    display: "flex",
                    alignItems: "center",
                    gap: "4px"
                  },
                  title: `Score: ${Math.round(score)} (${keyword.required ? "Required" : "Preferred"})`,
                  children: [
                    keyword.phrase,
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "9px", color: "#6e6e73" }, children: Math.round(score) })
                  ]
                },
                keyword.phrase
              );
            });
          })() }) }),
          existingResume ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                paddingTop: "12px",
                borderTop: "1px solid rgba(0, 0, 0, 0.08)"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 16, strokeWidth: 2, style: { color: "#059669" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "13px", color: "#059669", fontWeight: "600" }, children: "Resume Generated" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      fontSize: "12px",
                      padding: "4px 8px",
                      borderRadius: "6px",
                      fontWeight: "600",
                      ...getATSScoreStyle(existingResume.atsOptimization.overallATSScore)
                    },
                    children: [
                      "ATS: ",
                      existingResume.atsOptimization.overallATSScore
                    ]
                  }
                )
              ] })
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: onGenerateResume,
              disabled: generating,
              style: {
                width: "100%",
                marginTop: "12px",
                paddingTop: "12px",
                borderTop: "1px solid rgba(0, 0, 0, 0.08)",
                background: "rgba(0, 119, 181, 0.05)",
                border: "none",
                borderRadius: "6px",
                padding: "10px 16px",
                fontSize: "13px",
                fontWeight: "600",
                color: generating ? "#9ca3af" : "#0077B5",
                cursor: generating ? "not-allowed" : "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "8px",
                transition: "all 150ms"
              },
              onMouseEnter: (e) => {
                if (!generating) {
                  e.currentTarget.style.backgroundColor = "rgba(0, 119, 181, 0.1)";
                }
              },
              onMouseLeave: (e) => {
                if (!generating) {
                  e.currentTarget.style.backgroundColor = "rgba(0, 119, 181, 0.05)";
                }
              },
              children: generating ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { size: 16, strokeWidth: 2, style: { animation: "spin 1s linear infinite" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Generating Resume..." })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { size: 16, strokeWidth: 2 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Generate Resume" })
              ] })
            }
          )
        ]
      }
    );
  }
  content;
  function ProfileBuilderTab({ panelWidth = 400 }) {
    const [profile, setProfile] = reactExports.useState(null);
    const [stats, setStats] = reactExports.useState(null);
    const [activeSection, setActiveSection] = reactExports.useState("overview");
    const [isLoading, setIsLoading] = reactExports.useState(true);
    reactExports.useEffect(() => {
      loadProfile();
    }, []);
    const loadProfile = async () => {
      setIsLoading(true);
      try {
        const [profileData, statsData] = await Promise.all([
          getProfessionalProfile(),
          getProfileStats()
        ]);
        setProfile(profileData);
        setStats(statsData);
      } catch (error) {
        console.error("[Uproot] Error loading profile:", error);
      } finally {
        setIsLoading(false);
      }
    };
    const saveProfile = async (updatedProfile) => {
      try {
        await saveProfessionalProfile(updatedProfile);
        setProfile(updatedProfile);
        const statsData = await getProfileStats();
        setStats(statsData);
      } catch (error) {
        console.error("[Uproot] Error saving profile:", error);
      }
    };
    const isCompact = panelWidth < 400;
    if (isLoading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            flexDirection: "column",
            gap: "12px",
            color: "#6e6e73"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 32, className: "animate-pulse", strokeWidth: 2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "14px", fontWeight: "500" }, children: "Loading profile..." })
          ]
        }
      );
    }
    if (!profile) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyProfileState, { onCreateProfile: loadProfile });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "hidden",
          backgroundColor: "#FFFFFF"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: isCompact ? "16px" : "20px",
                borderBottom: "1px solid rgba(0, 0, 0, 0.08)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "12px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 20, color: "#0077B5" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h2",
                    {
                      style: {
                        fontSize: isCompact ? "18px" : "20px",
                        fontWeight: "700",
                        margin: 0,
                        color: "#1d1d1f"
                      },
                      children: "Professional Profile"
                    }
                  )
                ] }),
                stats && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "12px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", marginBottom: "4px" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "12px", color: "#6e6e73" }, children: "Profile Completeness" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: "12px", fontWeight: "600", color: "#0077B5" }, children: [
                      stats.profileCompleteness,
                      "%"
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        height: "6px",
                        backgroundColor: "rgba(0, 0, 0, 0.05)",
                        borderRadius: "3px",
                        overflow: "hidden"
                      },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          style: {
                            height: "100%",
                            width: `${stats.profileCompleteness}%`,
                            backgroundColor: "#0077B5",
                            transition: "width 300ms ease"
                          }
                        }
                      )
                    }
                  )
                ] }),
                stats && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      display: "grid",
                      gridTemplateColumns: "repeat(4, 1fr)",
                      gap: "8px"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(StatBadge, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: 12 }), value: stats.totalJobs, label: "Jobs" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(StatBadge, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(GraduationCap, { size: 12 }), value: stats.totalProjects, label: "Projects" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(StatBadge, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Code, { size: 12 }), value: stats.totalSkills, label: "Skills" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(StatBadge, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Award, { size: 12 }), value: stats.totalCertifications, label: "Certs" })
                    ]
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                borderBottom: "1px solid rgba(0, 0, 0, 0.08)",
                backgroundColor: "#FAFAFA",
                overflowX: "auto"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SectionTab,
                  {
                    label: "Overview",
                    isActive: activeSection === "overview",
                    onClick: () => setActiveSection("overview")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SectionTab,
                  {
                    label: "Experience",
                    isActive: activeSection === "experience",
                    onClick: () => setActiveSection("experience"),
                    count: stats?.totalJobs
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SectionTab,
                  {
                    label: "Skills",
                    isActive: activeSection === "skills",
                    onClick: () => setActiveSection("skills"),
                    count: stats?.totalSkills
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SectionTab,
                  {
                    label: "Education",
                    isActive: activeSection === "education",
                    onClick: () => setActiveSection("education"),
                    count: profile.education.length
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SectionTab,
                  {
                    label: "Projects",
                    isActive: activeSection === "projects",
                    onClick: () => setActiveSection("projects"),
                    count: stats?.totalProjects
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, overflowY: "auto", backgroundColor: "#FAFAFA" }, children: [
            activeSection === "overview" && /* @__PURE__ */ jsxRuntimeExports.jsx(OverviewSection, { profile, onUpdate: saveProfile, panelWidth }),
            activeSection === "experience" && /* @__PURE__ */ jsxRuntimeExports.jsx(ExperienceSection, { profile, onUpdate: saveProfile, panelWidth }),
            activeSection === "skills" && /* @__PURE__ */ jsxRuntimeExports.jsx(SkillsSection, { profile, onUpdate: saveProfile, panelWidth }),
            activeSection === "education" && /* @__PURE__ */ jsxRuntimeExports.jsx(EducationSection, { profile, onUpdate: saveProfile, panelWidth }),
            activeSection === "projects" && /* @__PURE__ */ jsxRuntimeExports.jsx(ProjectsSection, { profile, onUpdate: saveProfile, panelWidth })
          ] })
        ]
      }
    );
  }
  function StatBadge({
    icon,
    value,
    label
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "6px 8px",
          backgroundColor: "rgba(0, 0, 0, 0.02)",
          borderRadius: "6px",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          gap: "2px"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#0077B5" }, children: icon }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "14px", fontWeight: "700", color: "#1d1d1f" }, children: value }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "9px", color: "#6e6e73", textTransform: "uppercase" }, children: label })
        ]
      }
    );
  }
  function SectionTab({
    label,
    isActive,
    onClick,
    count
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick,
        style: {
          flex: 1,
          padding: "10px 12px",
          backgroundColor: isActive ? "#FFFFFF" : "transparent",
          borderBottom: isActive ? "2px solid #0077B5" : "2px solid transparent",
          border: "none",
          borderRadius: 0,
          cursor: "pointer",
          fontSize: "12px",
          fontWeight: isActive ? "600" : "500",
          color: isActive ? "#0077B5" : "#6e6e73",
          transition: "all 150ms",
          whiteSpace: "nowrap"
        },
        children: [
          label,
          count !== void 0 && count > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                marginLeft: "4px",
                padding: "1px 5px",
                backgroundColor: isActive ? "rgba(0, 119, 181, 0.1)" : "rgba(0, 0, 0, 0.05)",
                borderRadius: "8px",
                fontSize: "10px",
                fontWeight: "600"
              },
              children: count
            }
          )
        ]
      }
    );
  }
  function EmptyProfileState({ onCreateProfile }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          padding: "40px",
          textAlign: "center"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 64, color: "#0077B5", strokeWidth: 1.5 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "h2",
            {
              style: {
                fontSize: "24px",
                fontWeight: "700",
                margin: "24px 0 12px 0",
                color: "#1d1d1f"
              },
              children: "Build Your Professional Profile"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                fontSize: "14px",
                color: "#6e6e73",
                margin: "0 0 32px 0",
                maxWidth: "400px"
              },
              children: "Create a comprehensive career database. AI will use this to generate perfectly tailored, ATS-optimized resumes for every job you apply to."
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: onCreateProfile,
              style: {
                padding: "14px 32px",
                backgroundColor: "#0077B5",
                color: "white",
                border: "none",
                borderRadius: "12px",
                fontSize: "14px",
                fontWeight: "600",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                gap: "8px",
                transition: "all 150ms"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { size: 16 }),
                "Create Profile"
              ]
            }
          )
        ]
      }
    );
  }
  function OverviewSection({
    profile: _profile,
    onUpdate: _onUpdate,
    panelWidth: _panelWidth
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "#6e6e73", fontSize: "13px" }, children: "Overview section coming next..." }) });
  }
  function ExperienceSection({
    profile: _profile,
    onUpdate: _onUpdate,
    panelWidth: _panelWidth
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "#6e6e73", fontSize: "13px" }, children: "Experience section coming next..." }) });
  }
  function SkillsSection({
    profile: _profile,
    onUpdate: _onUpdate,
    panelWidth: _panelWidth
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "#6e6e73", fontSize: "13px" }, children: "Skills section coming next..." }) });
  }
  function EducationSection({
    profile: _profile,
    onUpdate: _onUpdate,
    panelWidth: _panelWidth
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "#6e6e73", fontSize: "13px" }, children: "Education section coming next..." }) });
  }
  function ProjectsSection({
    profile: _profile,
    onUpdate: _onUpdate,
    panelWidth: _panelWidth
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "#6e6e73", fontSize: "13px" }, children: "Projects section coming next..." }) });
  }
  content;
  function JobAnalyzerTab({ panelWidth = 400 }) {
    const [viewMode, setViewMode] = reactExports.useState("paste");
    const [jobText, setJobText] = reactExports.useState("");
    const [jobTitle, setJobTitle] = reactExports.useState("");
    const [company, setCompany] = reactExports.useState("");
    const [currentAnalysis, setCurrentAnalysis] = reactExports.useState(null);
    const [savedAnalyses, setSavedAnalyses] = reactExports.useState([]);
    const [profile, setProfile] = reactExports.useState(null);
    const isCompact = panelWidth < 400;
    reactExports.useEffect(() => {
      loadData();
    }, []);
    const loadData = async () => {
      const [analyses, profileData] = await Promise.all([
        getJobDescriptionAnalyses(),
        getProfessionalProfile()
      ]);
      setSavedAnalyses(analyses);
      setProfile(profileData);
    };
    const handleAnalyze = () => {
      if (!jobText.trim()) return;
      setViewMode("analyzing");
      setTimeout(() => {
        const keywords = extractKeywordsFromJobDescription(jobText);
        const { required, preferred } = categorizeJobRequirements(jobText);
        const analysis = {
          id: `job_${Date.now()}`,
          rawText: jobText,
          jobTitle: jobTitle || "Untitled Job",
          company: company || "Unknown Company",
          extractedKeywords: keywords,
          requiredSkills: required,
          preferredSkills: preferred,
          requiredExperience: extractExperience(jobText, true),
          preferredExperience: extractExperience(jobText, false),
          analyzedAt: Date.now()
        };
        if (profile) {
          analysis.matchAnalysis = calculateMatch(analysis, profile);
        }
        setCurrentAnalysis(analysis);
        setViewMode("results");
      }, 1500);
    };
    const handleSave = async () => {
      if (!currentAnalysis) return;
      await saveJobDescriptionAnalysis(currentAnalysis);
      await loadData();
    };
    const handleDelete = async (id) => {
      await deleteJobDescriptionAnalysis(id);
      await loadData();
    };
    const handleReset = () => {
      setJobText("");
      setJobTitle("");
      setCompany("");
      setCurrentAnalysis(null);
      setViewMode("paste");
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "hidden",
          backgroundColor: "#FFFFFF"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: isCompact ? "16px" : "20px",
                borderBottom: "1px solid rgba(0, 0, 0, 0.08)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Target, { size: 20, color: "#0077B5" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h2",
                    {
                      style: {
                        fontSize: isCompact ? "18px" : "20px",
                        fontWeight: "700",
                        margin: 0,
                        color: "#1d1d1f"
                      },
                      children: "Job Description Analyzer"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "13px", color: "#6e6e73", margin: 0 }, children: "Extract keywords, analyze ATS requirements, match against your profile" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, overflowY: "auto", backgroundColor: "#FAFAFA" }, children: [
            viewMode === "paste" && /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasteView,
              {
                jobText,
                jobTitle,
                company,
                onJobTextChange: setJobText,
                onJobTitleChange: setJobTitle,
                onCompanyChange: setCompany,
                onAnalyze: handleAnalyze,
                savedAnalyses,
                onSelectAnalysis: (analysis) => {
                  setCurrentAnalysis(analysis);
                  setJobText(analysis.rawText);
                  setJobTitle(analysis.jobTitle);
                  setCompany(analysis.company);
                  setViewMode("results");
                },
                onDeleteAnalysis: handleDelete,
                panelWidth
              }
            ),
            viewMode === "analyzing" && /* @__PURE__ */ jsxRuntimeExports.jsx(AnalyzingView, {}),
            viewMode === "results" && currentAnalysis && /* @__PURE__ */ jsxRuntimeExports.jsx(
              ResultsView,
              {
                analysis: currentAnalysis,
                hasProfile: profile !== null,
                onSave: handleSave,
                onReset: handleReset,
                panelWidth
              }
            )
          ] })
        ]
      }
    );
  }
  function PasteView({
    jobText,
    jobTitle,
    company,
    onJobTextChange,
    onJobTitleChange,
    onCompanyChange,
    onAnalyze,
    savedAnalyses,
    onSelectAnalysis,
    onDeleteAnalysis,
    panelWidth
  }) {
    const isCompact = panelWidth < 360;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: isCompact ? "12px" : "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "12px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "label",
          {
            style: {
              display: "block",
              fontSize: "12px",
              fontWeight: "600",
              marginBottom: "6px",
              color: "#1d1d1f"
            },
            children: "Job Title"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: jobTitle,
            onChange: (e) => onJobTitleChange(e.target.value),
            placeholder: "Senior Software Engineer",
            style: {
              width: "100%",
              padding: "10px 12px",
              border: "1px solid rgba(0, 0, 0, 0.1)",
              borderRadius: "8px",
              fontSize: "14px",
              fontFamily: "inherit"
            }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "12px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "label",
          {
            style: {
              display: "block",
              fontSize: "12px",
              fontWeight: "600",
              marginBottom: "6px",
              color: "#1d1d1f"
            },
            children: "Company"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: company,
            onChange: (e) => onCompanyChange(e.target.value),
            placeholder: "Google",
            style: {
              width: "100%",
              padding: "10px 12px",
              border: "1px solid rgba(0, 0, 0, 0.1)",
              borderRadius: "8px",
              fontSize: "14px",
              fontFamily: "inherit"
            }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "label",
          {
            style: {
              display: "block",
              fontSize: "12px",
              fontWeight: "600",
              marginBottom: "6px",
              color: "#1d1d1f"
            },
            children: "Job Description"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            value: jobText,
            onChange: (e) => onJobTextChange(e.target.value),
            placeholder: "Paste the full job description here...",
            style: {
              width: "100%",
              minHeight: "200px",
              padding: "12px",
              border: "1px solid rgba(0, 0, 0, 0.1)",
              borderRadius: "8px",
              fontSize: "13px",
              fontFamily: "inherit",
              resize: "vertical"
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "11px", color: "#6e6e73", marginTop: "4px" }, children: [
          jobText.length,
          " characters"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: onAnalyze,
          disabled: !jobText.trim(),
          style: {
            width: "100%",
            padding: "14px",
            backgroundColor: jobText.trim() ? "#0077B5" : "rgba(0, 0, 0, 0.1)",
            color: jobText.trim() ? "white" : "rgba(0, 0, 0, 0.3)",
            border: "none",
            borderRadius: "12px",
            fontSize: "14px",
            fontWeight: "600",
            cursor: jobText.trim() ? "pointer" : "not-allowed",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            gap: "8px",
            transition: "all 150ms"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 16 }),
            "Analyze with AI"
          ]
        }
      ),
      savedAnalyses.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: "24px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "h3",
          {
            style: {
              fontSize: "14px",
              fontWeight: "600",
              margin: "0 0 12px 0",
              color: "#1d1d1f"
            },
            children: [
              "Recent Analyses (",
              savedAnalyses.length,
              ")"
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: savedAnalyses.slice(0, 5).map((analysis) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          SavedAnalysisCard,
          {
            analysis,
            onSelect: () => onSelectAnalysis(analysis),
            onDelete: () => onDeleteAnalysis(analysis.id)
          },
          analysis.id
        )) })
      ] })
    ] });
  }
  function SavedAnalysisCard({
    analysis,
    onSelect,
    onDelete
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          backgroundColor: "#FFFFFF",
          borderRadius: "8px",
          padding: "12px",
          boxShadow: "0 1px 4px rgba(0, 0, 0, 0.08)",
          cursor: "pointer",
          transition: "all 150ms"
        },
        onClick: onSelect,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { size: 16, color: "#0077B5", style: { marginTop: "2px", flexShrink: 0 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "13px", fontWeight: "600", color: "#1d1d1f" }, children: analysis.jobTitle }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "11px", color: "#6e6e73" }, children: analysis.company })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: (e) => {
                e.stopPropagation();
                onDelete();
              },
              style: {
                padding: "4px",
                background: "none",
                border: "none",
                cursor: "pointer",
                color: "#6e6e73"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 14 })
            }
          )
        ] })
      }
    );
  }
  function AnalyzingView() {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          padding: "40px",
          textAlign: "center"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 48, color: "#0077B5", className: "animate-pulse" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "h3",
            {
              style: {
                fontSize: "18px",
                fontWeight: "700",
                margin: "20px 0 8px 0",
                color: "#1d1d1f"
              },
              children: "Analyzing Job Description..."
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "13px", color: "#6e6e73", margin: 0 }, children: "Extracting keywords, requirements, and ATS optimization tips" })
        ]
      }
    );
  }
  function ResultsView({
    analysis,
    hasProfile,
    onSave,
    onReset,
    panelWidth
  }) {
    const [activeTab, setActiveTab] = reactExports.useState("keywords");
    const isCompact = panelWidth < 360;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: isCompact ? "12px" : "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            backgroundColor: "#FFFFFF",
            borderRadius: "12px",
            padding: "16px",
            marginBottom: "16px",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: "12px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    width: "40px",
                    height: "40px",
                    borderRadius: "8px",
                    backgroundColor: "rgba(0, 119, 181, 0.1)",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    flexShrink: 0
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { size: 20, color: "#0077B5" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "h3",
                  {
                    style: {
                      fontSize: "16px",
                      fontWeight: "700",
                      margin: "0 0 4px 0",
                      color: "#1d1d1f"
                    },
                    children: analysis.jobTitle
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "13px", color: "#6e6e73", margin: 0 }, children: analysis.company })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  display: "grid",
                  gridTemplateColumns: "repeat(3, 1fr)",
                  gap: "8px",
                  marginTop: "12px"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    QuickStat,
                    {
                      label: "Keywords",
                      value: analysis.extractedKeywords.length,
                      color: "#0077B5"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    QuickStat,
                    {
                      label: "Required",
                      value: analysis.requiredSkills.length,
                      color: "#FF3B30"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    QuickStat,
                    {
                      label: "Preferred",
                      value: analysis.preferredSkills.length,
                      color: "#FF9500"
                    }
                  )
                ]
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "16px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TabButton,
          {
            label: "Keywords",
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Star, { size: 14 }),
            isActive: activeTab === "keywords",
            onClick: () => setActiveTab("keywords")
          }
        ),
        hasProfile && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TabButton,
          {
            label: "Match Analysis",
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Target, { size: 14 }),
            isActive: activeTab === "match",
            onClick: () => setActiveTab("match")
          }
        )
      ] }),
      activeTab === "keywords" && /* @__PURE__ */ jsxRuntimeExports.jsx(KeywordsView, { analysis }),
      activeTab === "match" && analysis.matchAnalysis && /* @__PURE__ */ jsxRuntimeExports.jsx(MatchAnalysisView, { matchAnalysis: analysis.matchAnalysis }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            gap: "8px",
            marginTop: "16px",
            position: "sticky",
            bottom: 0,
            paddingTop: "12px",
            backgroundColor: "#FAFAFA"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: onReset,
                style: {
                  flex: 1,
                  padding: "12px",
                  backgroundColor: "rgba(0, 0, 0, 0.05)",
                  border: "none",
                  borderRadius: "8px",
                  fontSize: "13px",
                  fontWeight: "600",
                  cursor: "pointer",
                  color: "#1d1d1f"
                },
                children: "New Analysis"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: onSave,
                style: {
                  flex: 1,
                  padding: "12px",
                  backgroundColor: "#0077B5",
                  color: "white",
                  border: "none",
                  borderRadius: "8px",
                  fontSize: "13px",
                  fontWeight: "600",
                  cursor: "pointer",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  gap: "6px"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Award, { size: 14 }),
                  "Save Analysis"
                ]
              }
            )
          ]
        }
      )
    ] });
  }
  function QuickStat({ label, value, color }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "8px",
          backgroundColor: "rgba(0, 0, 0, 0.02)",
          borderRadius: "6px",
          textAlign: "center"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "18px", fontWeight: "700", color }, children: value }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "10px", color: "#6e6e73" }, children: label })
        ]
      }
    );
  }
  function TabButton({
    label,
    icon,
    isActive,
    onClick
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick,
        style: {
          flex: 1,
          padding: "10px",
          backgroundColor: isActive ? "#0077B5" : "rgba(0, 0, 0, 0.05)",
          color: isActive ? "white" : "#6e6e73",
          border: "none",
          borderRadius: "8px",
          fontSize: "12px",
          fontWeight: "600",
          cursor: "pointer",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          gap: "6px",
          transition: "all 150ms"
        },
        children: [
          icon,
          label
        ]
      }
    );
  }
  function KeywordsView({ analysis }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        KeywordSection,
        {
          title: "Required Skills",
          keywords: analysis.extractedKeywords.filter((k) => k.required),
          color: "#FF3B30",
          emptyMessage: "No required skills identified"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        KeywordSection,
        {
          title: "Preferred Skills",
          keywords: analysis.extractedKeywords.filter((k) => !k.required),
          color: "#FF9500",
          emptyMessage: "No preferred skills identified"
        }
      )
    ] });
  }
  function KeywordSection({
    title,
    keywords,
    color,
    emptyMessage
  }) {
    const [showAll, setShowAll] = reactExports.useState(false);
    const INITIAL_DISPLAY_LIMIT = 20;
    const hasMore = keywords.length > INITIAL_DISPLAY_LIMIT;
    const displayedKeywords = showAll ? keywords : keywords.slice(0, INITIAL_DISPLAY_LIMIT);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "h4",
        {
          style: {
            fontSize: "13px",
            fontWeight: "600",
            margin: "0 0 8px 0",
            color: "#1d1d1f"
          },
          children: [
            title,
            " (",
            keywords.length,
            ")"
          ]
        }
      ),
      keywords.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "12px", color: "#6e6e73", fontStyle: "italic" }, children: emptyMessage }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px" }, children: displayedKeywords.map((keyword) => /* @__PURE__ */ jsxRuntimeExports.jsx(KeywordBadge, { keyword, color }, keyword.phrase)) }),
        hasMore && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setShowAll(!showAll),
            style: {
              marginTop: "8px",
              padding: "6px 12px",
              backgroundColor: "transparent",
              border: `1px solid ${color}`,
              borderRadius: "6px",
              fontSize: "11px",
              fontWeight: "600",
              color,
              cursor: "pointer",
              transition: "all 150ms"
            },
            children: showAll ? "Show Less" : `View All ${keywords.length} Keywords`
          }
        )
      ] })
    ] });
  }
  function KeywordBadge({ keyword, color }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "6px 10px",
          backgroundColor: `${color}15`,
          borderLeft: `3px solid ${color}`,
          borderRadius: "6px",
          fontSize: "11px",
          fontWeight: "600",
          color: "#1d1d1f",
          display: "flex",
          alignItems: "center",
          gap: "4px"
        },
        title: `Score: ${keyword.score}, Occurrences: ${keyword.occurrences}`,
        children: [
          keyword.phrase,
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "9px", color: "#6e6e73" }, children: Math.round(keyword.score) })
        ]
      }
    );
  }
  function MatchAnalysisView({ matchAnalysis }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            backgroundColor: "#FFFFFF",
            borderRadius: "12px",
            padding: "16px",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)",
            textAlign: "center"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "48px", fontWeight: "700", color: getScoreColor(matchAnalysis.overallScore) }, children: [
              matchAnalysis.overallScore,
              "%"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "13px", color: "#6e6e73" }, children: "Overall Match Score" })
          ]
        }
      ),
      matchAnalysis.recommendations.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            backgroundColor: "#FFFFFF",
            borderRadius: "12px",
            padding: "16px",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { style: { fontSize: "13px", fontWeight: "600", margin: "0 0 12px 0" }, children: "Recommendations" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: matchAnalysis.recommendations.map((rec, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "12px", color: "#6e6e73", lineHeight: "1.5" }, children: [
              "â€¢ ",
              rec
            ] }, i)) })
          ]
        }
      )
    ] });
  }
  function getScoreColor(score) {
    if (score >= 80) return "#34C759";
    if (score >= 60) return "#0077B5";
    if (score >= 40) return "#FF9500";
    return "#FF3B30";
  }
  function extractExperience(jobDescription, required) {
    const pattern = required ? /(\d+\+?\s+years?.*?experience)/gi : /preferred.*?(\d+\+?\s+years?.*?experience)/gi;
    const matches = jobDescription.match(pattern) || [];
    return matches.slice(0, 3);
  }
  function calculateMatch(analysis, profile) {
    const profileSkills = [
      ...profile.technicalSkills.filter((s) => s && s.name).map((s) => s.name.toLowerCase()),
      ...profile.softSkills.filter((s) => s && s.name).map((s) => s.name.toLowerCase()),
      ...profile.tools.filter((t) => t && t.name).map((t) => t.name.toLowerCase())
    ];
    const jobKeywords = analysis.extractedKeywords.map((k) => k.phrase.toLowerCase());
    const matched = jobKeywords.filter(
      (k) => profileSkills.some((s) => s.includes(k) || k.includes(s))
    );
    const matchPercentage = jobKeywords.length > 0 ? matched.length / jobKeywords.length * 100 : 0;
    return {
      overallScore: Math.round(matchPercentage),
      keywordMatch: {
        matched: analysis.extractedKeywords.filter(
          (k) => profileSkills.some((s) => s.includes(k.phrase.toLowerCase()) || k.phrase.toLowerCase().includes(s))
        ),
        missing: analysis.extractedKeywords.filter(
          (k) => !profileSkills.some((s) => s.includes(k.phrase.toLowerCase()) || k.phrase.toLowerCase().includes(s))
        ),
        matchPercentage
      },
      experienceMatch: {
        hasRequiredExperience: true,
        // Simplified
        hasPreferredExperience: true,
        score: 80
      },
      skillsMatch: {
        requiredSkillsMatched: analysis.requiredSkills.filter(
          (s) => profileSkills.some((ps) => ps.includes(s.toLowerCase()))
        ),
        requiredSkillsMissing: analysis.requiredSkills.filter(
          (s) => !profileSkills.some((ps) => ps.includes(s.toLowerCase()))
        ),
        preferredSkillsMatched: analysis.preferredSkills.filter(
          (s) => profileSkills.some((ps) => ps.includes(s.toLowerCase()))
        ),
        score: Math.round(matchPercentage)
      },
      recommendations: [
        matchPercentage < 60 ? "Add more relevant skills to your profile" : "Great skill match!",
        "Emphasize matching keywords in your resume",
        "Consider adding projects that demonstrate required skills"
      ],
      suggestedExperiences: [],
      suggestedSkills: []
    };
  }
  content;
  function ResumeGeneratorTab({ panelWidth = 400 }) {
    const [viewMode, setViewMode] = reactExports.useState("select-job");
    const [jobAnalyses, setJobAnalyses] = reactExports.useState([]);
    const [profile, setProfile] = reactExports.useState(null);
    const [selectedJob, setSelectedJob] = reactExports.useState(null);
    const [generatedResume, setGeneratedResume] = reactExports.useState(null);
    const [savedResumes, setSavedResumes] = reactExports.useState([]);
    const [atsScore, setAtsScore] = reactExports.useState(null);
    const isCompact = panelWidth < 400;
    reactExports.useEffect(() => {
      loadData();
    }, []);
    const loadData = async () => {
      const [jobs, profileData, resumes] = await Promise.all([
        getJobDescriptionAnalyses(),
        getProfessionalProfile(),
        getGeneratedResumes()
      ]);
      setJobAnalyses(jobs);
      setProfile(profileData);
      setSavedResumes(resumes);
    };
    const handleGenerateResume = async (job) => {
      if (!profile) {
        alert("Please create your professional profile first!");
        return;
      }
      setSelectedJob(job);
      setViewMode("generating");
      try {
        const resume = await generateResumeWithAI(job, profile);
        setGeneratedResume(resume);
        const score = calculateATSScore(
          resume.content.formattedText || "",
          job.extractedKeywords.map((k) => k.phrase),
          job.extractedKeywords.map((k) => k.phrase)
        );
        setAtsScore(score);
        setViewMode("preview");
      } catch (error) {
        console.error("[Uproot] Error generating resume:", error);
        alert("Failed to generate resume. Please try again.");
        setViewMode("select-job");
      }
    };
    const handleCopyToClipboard = () => {
      if (!generatedResume?.content.formattedText) return;
      navigator.clipboard.writeText(generatedResume.content.formattedText);
      alert("Resume copied to clipboard!");
    };
    const handleSaveResume = async () => {
      if (!generatedResume) return;
      await saveGeneratedResume(generatedResume);
      await loadData();
      alert("Resume saved!");
    };
    const handleReset = () => {
      setSelectedJob(null);
      setGeneratedResume(null);
      setAtsScore(null);
      setViewMode("select-job");
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "hidden",
          backgroundColor: "#FFFFFF"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: isCompact ? "16px" : "20px",
                borderBottom: "1px solid rgba(0, 0, 0, 0.08)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 20, color: "#0077B5" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h2",
                    {
                      style: {
                        fontSize: isCompact ? "18px" : "20px",
                        fontWeight: "700",
                        margin: 0,
                        color: "#1d1d1f"
                      },
                      children: "AI Resume Generator"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "13px", color: "#6e6e73", margin: 0 }, children: "Generate custom, ATS-optimized resumes for each job" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, overflowY: "auto", backgroundColor: "#FAFAFA" }, children: [
            viewMode === "select-job" && /* @__PURE__ */ jsxRuntimeExports.jsx(
              SelectJobView,
              {
                jobAnalyses,
                savedResumes,
                hasProfile: profile !== null,
                onSelectJob: handleGenerateResume,
                onLoadResume: (resume) => {
                  setGeneratedResume(resume);
                  setSelectedJob(
                    jobAnalyses.find((j) => j.id === resume.jobDescriptionId) || null
                  );
                  if (resume.atsOptimization) {
                    setAtsScore(resume.atsOptimization);
                  }
                  setViewMode("preview");
                },
                panelWidth
              }
            ),
            viewMode === "generating" && /* @__PURE__ */ jsxRuntimeExports.jsx(GeneratingView$1, { jobTitle: selectedJob?.jobTitle || "" }),
            viewMode === "preview" && generatedResume && atsScore && /* @__PURE__ */ jsxRuntimeExports.jsx(
              PreviewView$1,
              {
                resume: generatedResume,
                atsScore,
                onCopy: handleCopyToClipboard,
                onSave: handleSaveResume,
                onReset: handleReset,
                panelWidth
              }
            )
          ] })
        ]
      }
    );
  }
  function SelectJobView({
    jobAnalyses,
    savedResumes,
    hasProfile,
    onSelectJob,
    onLoadResume,
    panelWidth
  }) {
    const isCompact = panelWidth < 360;
    if (!hasProfile) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            padding: "40px",
            textAlign: "center",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            gap: "16px"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 48, color: "#FF9500" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "18px", fontWeight: "700", margin: 0, color: "#1d1d1f" }, children: "Create Your Profile First" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "13px", color: "#6e6e73", margin: 0, maxWidth: "300px" }, children: "Build your professional profile so AI can generate tailored resumes for each job." })
          ]
        }
      );
    }
    if (jobAnalyses.length === 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            padding: "40px",
            textAlign: "center",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            gap: "16px"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Target, { size: 48, color: "#0077B5" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "18px", fontWeight: "700", margin: 0, color: "#1d1d1f" }, children: "Analyze a Job First" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "13px", color: "#6e6e73", margin: 0, maxWidth: "300px" }, children: "Go to Job Analyzer and analyze a job description. Then come back here to generate a custom resume." })
          ]
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: isCompact ? "12px" : "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: savedResumes.length > 0 ? "24px" : 0 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "h3",
          {
            style: {
              fontSize: "14px",
              fontWeight: "600",
              margin: "0 0 12px 0",
              color: "#1d1d1f"
            },
            children: "Select Job to Generate Resume"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: jobAnalyses.map((job) => /* @__PURE__ */ jsxRuntimeExports.jsx(JobCard$1, { job, onSelect: () => onSelectJob(job) }, job.id)) })
      ] }),
      savedResumes.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "h3",
          {
            style: {
              fontSize: "14px",
              fontWeight: "600",
              margin: "0 0 12px 0",
              color: "#1d1d1f"
            },
            children: [
              "Previously Generated (",
              savedResumes.length,
              ")"
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: savedResumes.slice(0, 5).map((resume) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          SavedResumeCard,
          {
            resume,
            onLoad: () => onLoadResume(resume)
          },
          resume.id
        )) })
      ] })
    ] });
  }
  function JobCard$1({ job, onSelect }) {
    const [showKeywords, setShowKeywords] = reactExports.useState(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          backgroundColor: "#FFFFFF",
          borderRadius: "12px",
          padding: "16px",
          boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)",
          transition: "all 150ms"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              onClick: onSelect,
              style: {
                display: "flex",
                alignItems: "flex-start",
                gap: "12px",
                cursor: "pointer"
              },
              onMouseEnter: (e) => {
                e.currentTarget.style.opacity = "0.8";
              },
              onMouseLeave: (e) => {
                e.currentTarget.style.opacity = "1";
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      width: "40px",
                      height: "40px",
                      borderRadius: "8px",
                      backgroundColor: "rgba(0, 119, 181, 0.1)",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      flexShrink: 0
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 20, color: "#0077B5" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h4",
                    {
                      style: {
                        fontSize: "15px",
                        fontWeight: "600",
                        margin: "0 0 4px 0",
                        color: "#1d1d1f"
                      },
                      children: job.jobTitle
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "13px", color: "#6e6e73", margin: "0 0 8px 0" }, children: job.company }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", flexWrap: "wrap" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { label: `${job.extractedKeywords.length} keywords`, color: "#0077B5" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { label: `${job.requiredSkills.length} required`, color: "#FF3B30" })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, { size: 20, color: "#0077B5" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: (e) => {
                e.stopPropagation();
                setShowKeywords(!showKeywords);
              },
              style: {
                marginTop: "12px",
                width: "100%",
                padding: "8px 12px",
                backgroundColor: "transparent",
                border: "1px solid #0077B5",
                borderRadius: "6px",
                fontSize: "12px",
                fontWeight: "600",
                color: "#0077B5",
                cursor: "pointer",
                transition: "all 150ms",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "6px"
              },
              children: [
                showKeywords ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { size: 14 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { size: 14 }),
                showKeywords ? "Hide Keywords" : "View All Keywords"
              ]
            }
          ),
          showKeywords && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "12px", paddingTop: "12px", borderTop: "1px solid rgba(0, 0, 0, 0.08)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: "6px" }, children: job.extractedKeywords.sort((a, b) => b.score - a.score).map((keyword) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: "6px 10px",
                backgroundColor: keyword.required ? "#FF3B3015" : "#FF950015",
                borderLeft: `3px solid ${keyword.required ? "#FF3B30" : "#FF9500"}`,
                borderRadius: "6px",
                fontSize: "11px",
                fontWeight: "600",
                color: "#1d1d1f",
                display: "flex",
                alignItems: "center",
                gap: "4px"
              },
              title: `Weight: ${keyword.score}/100, Frequency: ${keyword.frequency}`,
              children: [
                keyword.phrase,
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "9px", color: "#6e6e73" }, children: Math.round(keyword.score) })
              ]
            },
            keyword.phrase
          )) }) })
        ]
      }
    );
  }
  function SavedResumeCard({
    resume,
    onLoad
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        onClick: onLoad,
        style: {
          backgroundColor: "#FFFFFF",
          borderRadius: "8px",
          padding: "12px",
          boxShadow: "0 1px 4px rgba(0, 0, 0, 0.08)",
          cursor: "pointer"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { size: 16, color: "#34C759", style: { marginTop: "2px", flexShrink: 0 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "13px", fontWeight: "600", color: "#1d1d1f" }, children: resume.jobTitle }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "11px", color: "#6e6e73" }, children: [
              resume.company,
              " â€¢ ",
              new Date(resume.generatedAt).toLocaleDateString()
            ] })
          ] }),
          resume.atsOptimization && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: "4px 8px",
                backgroundColor: `${getATSScoreLevel(resume.atsOptimization.overallATSScore).color}15`,
                borderRadius: "6px",
                fontSize: "11px",
                fontWeight: "600",
                color: getATSScoreLevel(resume.atsOptimization.overallATSScore).color
              },
              children: [
                resume.atsOptimization.overallATSScore,
                "%"
              ]
            }
          )
        ] })
      }
    );
  }
  function Badge({ label, color }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        style: {
          padding: "4px 8px",
          backgroundColor: `${color}15`,
          borderRadius: "6px",
          fontSize: "11px",
          fontWeight: "600",
          color
        },
        children: label
      }
    );
  }
  function GeneratingView$1({ jobTitle }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          padding: "40px",
          textAlign: "center"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 64, color: "#0077B5", className: "animate-pulse" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "h3",
            {
              style: {
                fontSize: "20px",
                fontWeight: "700",
                margin: "24px 0 8px 0",
                color: "#1d1d1f"
              },
              children: "Generating Your Resume..."
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: "14px", color: "#6e6e73", margin: "0 0 16px 0" }, children: [
            "For: ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: jobTitle })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "13px", color: "#6e6e73", lineHeight: "1.8" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "âœ¨ Analyzing job requirements..." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "ðŸŽ¯ Selecting relevant experiences..." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "ðŸ“ Writing custom summary..." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "ðŸ” Optimizing for ATS..." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "âš¡ Matching keywords..." })
          ] })
        ]
      }
    );
  }
  function PreviewView$1({
    resume,
    atsScore,
    onCopy,
    onSave,
    onReset,
    panelWidth
  }) {
    const [showRecommendations, setShowRecommendations] = reactExports.useState(true);
    const isCompact = panelWidth < 360;
    const scoreLevel = getATSScoreLevel(atsScore.overallATSScore);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: isCompact ? "12px" : "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            backgroundColor: "#FFFFFF",
            borderRadius: "12px",
            padding: "16px",
            marginBottom: "16px",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "12px", marginBottom: "12px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    width: "60px",
                    height: "60px",
                    borderRadius: "12px",
                    backgroundColor: `${scoreLevel.color}15`,
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    flexShrink: 0
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        fontSize: "24px",
                        fontWeight: "700",
                        color: scoreLevel.color
                      },
                      children: atsScore.overallATSScore
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "h3",
                  {
                    style: {
                      fontSize: "16px",
                      fontWeight: "700",
                      margin: "0 0 4px 0",
                      color: "#1d1d1f"
                    },
                    children: [
                      "ATS Score: ",
                      scoreLevel.label
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: "12px", color: "#6e6e73", margin: 0 }, children: [
                  "Keyword Match: ",
                  Math.round(atsScore.keywordMatchRate),
                  "% â€¢ Density:",
                  " ",
                  atsScore.keywordDensity.toFixed(1),
                  "%"
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  display: "grid",
                  gridTemplateColumns: "repeat(3, 1fr)",
                  gap: "8px"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Metric,
                    {
                      label: "Format",
                      value: atsScore.formatCompliance.score,
                      icon: atsScore.formatCompliance.score >= 80 ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 12 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CircleX, { size: 12 })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Metric,
                    {
                      label: "Content",
                      value: atsScore.contentQuality.score,
                      icon: atsScore.contentQuality.score >= 80 ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 12 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CircleX, { size: 12 })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Metric,
                    {
                      label: "Keywords",
                      value: Math.round(atsScore.keywordMatchRate),
                      icon: atsScore.keywordMatchRate >= 75 ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 12 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 12 })
                    }
                  )
                ]
              }
            )
          ]
        }
      ),
      atsScore.recommendations.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            backgroundColor: "#FFFFFF",
            borderRadius: "12px",
            padding: "16px",
            marginBottom: "16px",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => setShowRecommendations(!showRecommendations),
                style: {
                  width: "100%",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "space-between",
                  background: "none",
                  border: "none",
                  padding: 0,
                  cursor: "pointer",
                  marginBottom: showRecommendations ? "12px" : 0
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { style: { fontSize: "14px", fontWeight: "600", margin: 0, color: "#1d1d1f" }, children: [
                    "Recommendations (",
                    atsScore.recommendations.length,
                    ")"
                  ] }),
                  showRecommendations ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { size: 16, color: "#6e6e73" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { size: 16, color: "#6e6e73" })
                ]
              }
            ),
            showRecommendations && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: atsScore.recommendations.map((rec, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  fontSize: "12px",
                  color: "#6e6e73",
                  lineHeight: "1.5",
                  paddingLeft: "12px"
                },
                children: rec
              },
              i
            )) })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            backgroundColor: "#FFFFFF",
            borderRadius: "12px",
            padding: "16px",
            marginBottom: "16px",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "12px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { style: { fontSize: "14px", fontWeight: "600", margin: 0, color: "#1d1d1f" }, children: "Resume Preview" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: onCopy,
                  style: {
                    padding: "6px 12px",
                    backgroundColor: "rgba(0, 119, 181, 0.1)",
                    color: "#0077B5",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "12px",
                    fontWeight: "600",
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    gap: "4px"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 12 }),
                    "Copy"
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  padding: "12px",
                  backgroundColor: "#FAFAFA",
                  borderRadius: "8px",
                  fontSize: "12px",
                  fontFamily: "monospace",
                  whiteSpace: "pre-wrap",
                  maxHeight: "300px",
                  overflowY: "auto",
                  lineHeight: "1.6",
                  color: "#1d1d1f"
                },
                children: resume.content.formattedText || "Resume content will appear here..."
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: onReset,
            style: {
              flex: 1,
              padding: "14px",
              backgroundColor: "rgba(0, 0, 0, 0.05)",
              border: "none",
              borderRadius: "12px",
              fontSize: "13px",
              fontWeight: "600",
              cursor: "pointer",
              color: "#1d1d1f"
            },
            children: "New Resume"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: onSave,
            style: {
              flex: 1,
              padding: "14px",
              backgroundColor: "#0077B5",
              color: "white",
              border: "none",
              borderRadius: "12px",
              fontSize: "13px",
              fontWeight: "600",
              cursor: "pointer",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "6px"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Award, { size: 14 }),
              "Save Resume"
            ]
          }
        )
      ] })
    ] });
  }
  function Metric({
    label,
    value,
    icon
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: "8px",
          backgroundColor: "rgba(0, 0, 0, 0.02)",
          borderRadius: "6px",
          textAlign: "center"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "center", gap: "4px", marginBottom: "2px" }, children: [
            icon,
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "14px", fontWeight: "700", color: "#1d1d1f" }, children: value })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "9px", color: "#6e6e73", textTransform: "uppercase" }, children: label })
        ]
      }
    );
  }
  content;
  const TRANSFERABLE_SKILLS_MAP = {
    // Teaching â†’ Tech
    "teaching": ["communication", "presentation", "mentoring", "documentation", "training"],
    "classroom management": ["project management", "coordination", "organization", "time management"],
    "curriculum development": ["planning", "strategy", "content creation", "documentation"],
    // Sales â†’ Tech
    "sales": ["communication", "negotiation", "presentation", "client relations", "business development"],
    "account management": ["client relations", "project management", "stakeholder management"],
    "cold calling": ["outreach", "communication", "persistence", "networking"],
    // Management â†’ Tech
    "team leadership": ["leadership", "mentoring", "people management", "coaching"],
    "budget management": ["resource planning", "financial planning", "prioritization"],
    "strategic planning": ["strategy", "planning", "vision", "roadmap planning"],
    // Customer Service â†’ Tech
    "customer service": ["communication", "problem solving", "empathy", "support"],
    "technical support": ["troubleshooting", "problem solving", "documentation", "customer success"],
    "call center": ["communication", "efficiency", "problem solving", "multitasking"],
    // Military â†’ Tech
    "military": ["leadership", "discipline", "teamwork", "process adherence", "training"],
    "military leadership": ["leadership", "decision making", "crisis management", "team coordination"]
  };
  const SKILL_INFERENCE_MAP = {
    // Frontend frameworks â†’ languages
    "react": ["javascript", "html", "css", "jsx"],
    "vue": ["javascript", "html", "css"],
    "angular": ["typescript", "javascript", "html", "css"],
    "svelte": ["javascript", "html", "css"],
    // Backend frameworks â†’ languages
    "django": ["python"],
    "flask": ["python"],
    "fastapi": ["python"],
    "express": ["javascript", "node.js"],
    "spring": ["java"],
    "rails": ["ruby"],
    // Mobile frameworks â†’ languages
    "react native": ["javascript", "react"],
    "flutter": ["dart"],
    "swift ui": ["swift"],
    "jetpack compose": ["kotlin"],
    // Testing frameworks â†’ languages
    "jest": ["javascript"],
    "pytest": ["python"],
    "junit": ["java"],
    "rspec": ["ruby"],
    // Tools â†’ concepts
    "git": ["version control"],
    "docker": ["containerization", "devops"],
    "kubernetes": ["container orchestration", "devops", "docker"],
    "jenkins": ["ci/cd", "automation", "devops"],
    "terraform": ["infrastructure as code", "devops", "cloud"],
    // Cloud platforms â†’ skills
    "aws": ["cloud computing", "devops"],
    "azure": ["cloud computing", "devops"],
    "gcp": ["cloud computing", "devops"],
    // Databases â†’ concepts
    "postgresql": ["sql", "database", "relational database"],
    "mysql": ["sql", "database", "relational database"],
    "mongodb": ["nosql", "database"],
    "redis": ["caching", "nosql"]
  };
  function matchUserToJob(profile, requirements) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "matchUserToJob", {
      profileSkills: profile.skills.length,
      profileExperiences: profile.workExperience.length,
      requiredSkills: requirements.required.length,
      preferredSkills: requirements.preferred.length
    });
    try {
      log$1.info(LogCategory.SERVICE, "Starting semantic skill matching", {
        userName: profile.name,
        userTitle: profile.title,
        totalRequirements: requirements.required.length + requirements.preferred.length,
        seniority: profile.metadata.seniority,
        careerStage: profile.metadata.careerStage
      });
      const userSkills = collectUserSkills(profile);
      log$1.debug(LogCategory.SERVICE, "Collected user skills", {
        totalSkills: userSkills.size,
        explicitSkills: profile.skills.length,
        skills: Array.from(userSkills).slice(0, 20)
      });
      const requiredMatches = matchRequirements(
        requirements.required,
        profile,
        userSkills,
        true
      );
      const preferredMatches = matchRequirements(
        requirements.preferred,
        profile,
        userSkills,
        false
      );
      const allMatches = [...requiredMatches, ...preferredMatches];
      const directMatches = allMatches.filter((m) => m.matchType === "direct");
      const semanticMatches = allMatches.filter((m) => m.matchType === "semantic");
      const transferableMatches = allMatches.filter((m) => m.matchType === "transferable");
      const inferredMatches = allMatches.filter((m) => m.matchType === "inferred");
      log$1.info(LogCategory.SERVICE, "Matches categorized", {
        direct: directMatches.length,
        semantic: semanticMatches.length,
        transferable: transferableMatches.length,
        inferred: inferredMatches.length
      });
      const matchedRequirements = new Set(allMatches.map((m) => m.requirement.phrase.toLowerCase()));
      const missingRequired = requirements.required.filter(
        (req) => !matchedRequirements.has(req.phrase.toLowerCase())
      );
      const missingPreferred = requirements.preferred.filter(
        (req) => !matchedRequirements.has(req.phrase.toLowerCase())
      );
      const missing = [...missingRequired, ...missingPreferred];
      log$1.info(LogCategory.SERVICE, "Missing requirements identified", {
        missingRequired: missingRequired.length,
        missingPreferred: missingPreferred.length,
        criticalMissing: missingRequired.filter((r2) => r2.required).map((r2) => r2.phrase)
      });
      const matchScore = calculateMatchScore(
        requirements.required.length,
        requirements.preferred.length,
        requiredMatches.length,
        preferredMatches.length
      );
      log$1.info(LogCategory.SERVICE, "Match score calculated", {
        matchScore,
        requiredCoverage: (requiredMatches.length / requirements.required.length * 100).toFixed(1) + "%",
        preferredCoverage: requirements.preferred.length > 0 ? (preferredMatches.length / requirements.preferred.length * 100).toFixed(1) + "%" : "N/A"
      });
      const recommendations = generateRecommendations(
        profile,
        missing,
        allMatches,
        matchScore
      );
      log$1.info(LogCategory.SERVICE, "Recommendations generated", {
        total: recommendations.length,
        high: recommendations.filter((r2) => r2.priority === "high").length,
        medium: recommendations.filter((r2) => r2.priority === "medium").length,
        low: recommendations.filter((r2) => r2.priority === "low").length
      });
      const report = {
        matches: allMatches,
        missing,
        matchScore,
        recommendations,
        directMatches,
        semanticMatches,
        transferableMatches,
        inferredMatches
      };
      log$1.info(LogCategory.SERVICE, "Semantic skill matching completed", {
        matchScore,
        totalMatches: allMatches.length,
        missingCount: missing.length,
        recommendationCount: recommendations.length
      });
      endTrace();
      return report;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Semantic skill matching failed", error);
      endTrace();
      throw error;
    }
  }
  function collectUserSkills(profile) {
    const skills = /* @__PURE__ */ new Set();
    profile.skills.forEach((skill) => {
      if (skill && skill.name) {
        skills.add(skill.name.toLowerCase());
      }
    });
    profile.workExperience.forEach((exp) => {
      exp.skills.forEach((skill) => skills.add(skill.toLowerCase()));
      exp.achievements.forEach((achievement) => {
        achievement.skills.forEach((skill) => skills.add(skill.toLowerCase()));
        achievement.keywords.forEach((keyword) => skills.add(keyword.toLowerCase()));
        achievement.transferableSkills.forEach((skill) => skills.add(skill.toLowerCase()));
      });
    });
    profile.projects.forEach((project) => {
      project.skills.forEach((skill) => skills.add(skill.toLowerCase()));
      project.achievements.forEach((achievement) => {
        achievement.skills.forEach((skill) => skills.add(skill.toLowerCase()));
        achievement.keywords.forEach((keyword) => skills.add(keyword.toLowerCase()));
      });
    });
    if (profile.volunteer) {
      profile.volunteer.forEach((vol) => {
        vol.skills.forEach((skill) => skills.add(skill.toLowerCase()));
        vol.achievements.forEach((achievement) => {
          achievement.skills.forEach((skill) => skills.add(skill.toLowerCase()));
        });
      });
    }
    profile.education.forEach((edu) => {
      if (edu.relevantCourses) {
        edu.relevantCourses.forEach((course) => skills.add(course.toLowerCase()));
      }
    });
    return skills;
  }
  function matchRequirements(requirements, profile, userSkills, isRequired) {
    const matches = [];
    for (const requirement of requirements) {
      const match = findMatchForRequirement(requirement, profile, userSkills);
      if (match) {
        matches.push(match);
        log$1.debug(LogCategory.SERVICE, `Match found for "${requirement.phrase}"`, {
          type: match.matchType,
          confidence: match.confidence,
          evidence: match.userEvidence.length,
          required: isRequired
        });
      } else {
        log$1.debug(LogCategory.SERVICE, `No match found for "${requirement.phrase}"`, {
          required: isRequired
        });
      }
    }
    return matches;
  }
  function findMatchForRequirement(requirement, profile, userSkills) {
    const directMatch = findDirectMatch(requirement, profile, userSkills);
    if (directMatch) return directMatch;
    const semanticMatch = findSemanticMatch(requirement, profile, userSkills);
    if (semanticMatch) return semanticMatch;
    const transferableMatch = findTransferableMatch(requirement, profile, userSkills);
    if (transferableMatch) return transferableMatch;
    const inferredMatch = findInferredMatch(requirement, profile, userSkills);
    if (inferredMatch) return inferredMatch;
    return null;
  }
  function findDirectMatch(requirement, profile, userSkills) {
    const reqLower = requirement.phrase.toLowerCase();
    if (userSkills.has(reqLower)) {
      const evidence = findEvidenceForSkill(requirement.phrase, profile);
      if (evidence.length > 0) {
        return {
          requirement,
          userEvidence: evidence,
          matchType: "direct",
          confidence: 1,
          explanation: `Direct match: User explicitly lists "${requirement.phrase}" as a skill with ${evidence.length} concrete examples`
        };
      }
    }
    const skillMatch = skillsDatabase.findSkill(reqLower);
    if (skillMatch) {
      for (const synonym of skillMatch.synonyms || []) {
        if (userSkills.has(synonym.toLowerCase())) {
          const evidence = findEvidenceForSkill(synonym, profile);
          if (evidence.length > 0) {
            return {
              requirement,
              userEvidence: evidence,
              matchType: "direct",
              confidence: 0.95,
              explanation: `Direct match via synonym: User has "${synonym}" which matches "${requirement.phrase}"`
            };
          }
        }
      }
    }
    if (requirement.synonyms) {
      for (const synonym of requirement.synonyms) {
        if (userSkills.has(synonym.toLowerCase())) {
          const evidence = findEvidenceForSkill(synonym, profile);
          if (evidence.length > 0) {
            return {
              requirement,
              userEvidence: evidence,
              matchType: "direct",
              confidence: 0.95,
              explanation: `Direct match via synonym: User has "${synonym}" which matches "${requirement.phrase}"`
            };
          }
        }
      }
    }
    return null;
  }
  function findSemanticMatch(requirement, profile, userSkills) {
    const reqLower = requirement.phrase.toLowerCase();
    const reqWords = tokenizeSkill(reqLower);
    const similarSkills = [];
    for (const userSkill of Array.from(userSkills)) {
      const userWords = tokenizeSkill(userSkill);
      const similarity = calculateWordSimilarity(reqWords, userWords);
      if (similarity >= 0.5) {
        similarSkills.push({ skill: userSkill, similarity });
      }
    }
    similarSkills.sort((a, b) => b.similarity - a.similarity);
    if (similarSkills.length > 0) {
      const bestMatch = similarSkills[0];
      const evidence = findEvidenceForSkill(bestMatch.skill, profile);
      if (evidence.length > 0) {
        const confidence = 0.7 + bestMatch.similarity * 0.2;
        return {
          requirement,
          userEvidence: evidence,
          matchType: "semantic",
          confidence,
          explanation: `Semantic match: User has "${bestMatch.skill}" which is related to "${requirement.phrase}" (${(bestMatch.similarity * 100).toFixed(0)}% similar)`
        };
      }
    }
    return null;
  }
  function findTransferableMatch(requirement, profile, userSkills) {
    const reqLower = requirement.phrase.toLowerCase();
    for (const [sourceSkill, targetSkills] of Object.entries(TRANSFERABLE_SKILLS_MAP)) {
      if (userSkills.has(sourceSkill)) {
        const isTransferable = targetSkills.some(
          (target) => target === reqLower || reqLower.includes(target) || target.includes(reqLower)
        );
        if (isTransferable) {
          const evidence = findEvidenceForSkill(sourceSkill, profile);
          if (evidence.length > 0) {
            return {
              requirement,
              userEvidence: evidence,
              matchType: "transferable",
              confidence: 0.6,
              explanation: `Transferable skill: User's "${sourceSkill}" experience demonstrates "${requirement.phrase}" (career changer strength)`
            };
          }
        }
      }
    }
    return null;
  }
  function findInferredMatch(requirement, profile, userSkills) {
    const reqLower = requirement.phrase.toLowerCase();
    for (const [parentSkill, impliedSkills] of Object.entries(SKILL_INFERENCE_MAP)) {
      if (userSkills.has(parentSkill)) {
        const isImplied = impliedSkills.some(
          (implied) => implied === reqLower || reqLower.includes(implied) || implied.includes(reqLower)
        );
        if (isImplied) {
          const evidence = findEvidenceForSkill(parentSkill, profile);
          if (evidence.length > 0) {
            return {
              requirement,
              userEvidence: evidence,
              matchType: "inferred",
              confidence: 0.7,
              explanation: `Inferred skill: Since user knows "${parentSkill}", they likely know "${requirement.phrase}"`
            };
          }
        }
      }
    }
    return null;
  }
  function findEvidenceForSkill(skillName, profile) {
    const evidence = [];
    const skillLower = skillName.toLowerCase();
    for (const exp of profile.workExperience) {
      const hasSkill = exp.skills.some((s) => s.toLowerCase() === skillLower);
      if (hasSkill) {
        for (const achievement of exp.achievements) {
          const isRelevant = achievement.skills.some((s) => s.toLowerCase() === skillLower) || achievement.keywords.some((k) => k.toLowerCase() === skillLower);
          if (isRelevant) {
            evidence.push(achievement);
          }
        }
      }
    }
    for (const project of profile.projects) {
      const hasSkill = project.skills.some((s) => s.toLowerCase() === skillLower);
      if (hasSkill) {
        for (const achievement of project.achievements) {
          const isRelevant = achievement.skills.some((s) => s.toLowerCase() === skillLower) || achievement.keywords.some((k) => k.toLowerCase() === skillLower);
          if (isRelevant) {
            evidence.push(achievement);
          }
        }
      }
    }
    if (profile.volunteer) {
      for (const vol of profile.volunteer) {
        const hasSkill = vol.skills.some((s) => s.toLowerCase() === skillLower);
        if (hasSkill) {
          for (const achievement of vol.achievements) {
            evidence.push(achievement);
          }
        }
      }
    }
    return evidence;
  }
  function tokenizeSkill(skill) {
    const words = skill.toLowerCase().replace(/[.\-_/]/g, " ").split(/\s+/).filter((word) => word.length > 2);
    return new Set(words);
  }
  function calculateWordSimilarity(words1, words2) {
    if (words1.size === 0 || words2.size === 0) return 0;
    let overlap = 0;
    for (const word of Array.from(words1)) {
      if (words2.has(word)) {
        overlap++;
      }
    }
    const union = words1.size + words2.size - overlap;
    return union > 0 ? overlap / union : 0;
  }
  function calculateMatchScore(totalRequired, totalPreferred, matchedRequired, matchedPreferred) {
    const requiredScore = totalRequired > 0 ? matchedRequired / totalRequired : 1;
    const requiredWeight = 0.7;
    const preferredScore = totalPreferred > 0 ? matchedPreferred / totalPreferred : 0.5;
    const preferredWeight = 0.3;
    const weightedScore = requiredScore * requiredWeight + preferredScore * preferredWeight;
    return Math.min(1, weightedScore);
  }
  function generateRecommendations(profile, missing, matches, matchScore) {
    const recommendations = [];
    const missingRequired = missing.filter((m) => m.required);
    for (const skill of missingRequired.slice(0, 3)) {
      recommendations.push({
        type: "add-skill",
        priority: "high",
        skill: skill.phrase,
        reason: `Critical missing skill: "${skill.phrase}" is a required qualification`,
        suggestion: `Consider gaining experience with "${skill.phrase}" through projects, courses, or professional work. This is a must-have for this role.`
      });
    }
    const missingPreferred = missing.filter((m) => !m.required);
    for (const skill of missingPreferred.slice(0, 2)) {
      recommendations.push({
        type: "add-skill",
        priority: "medium",
        skill: skill.phrase,
        reason: `Preferred skill missing: "${skill.phrase}" would strengthen your application`,
        suggestion: `Learning "${skill.phrase}" could make you a more competitive candidate. Consider adding this to your skill development plan.`
      });
    }
    const weakMatches = matches.filter((m) => m.confidence < 0.7);
    for (const match of weakMatches.slice(0, 2)) {
      recommendations.push({
        type: "reframe-experience",
        priority: "medium",
        skill: match.requirement.phrase,
        reason: `Weak match for "${match.requirement.phrase}" (${match.matchType} match)`,
        suggestion: `Emphasize your "${match.requirement.phrase}" experience more prominently in your resume. Add more specific examples.`
      });
    }
    if (matchScore < 0.6 && profile.metadata.careerStage !== "professional") {
      recommendations.push({
        type: "add-project",
        priority: "high",
        reason: "Overall match score is low",
        suggestion: "Consider building a project that demonstrates the missing required skills. This is especially valuable for career changers and students."
      });
    }
    const missingTechnicalSkills = missing.filter(
      (m) => m.category === "language" || m.category === "framework" || m.category === "cloud" || m.category === "devops" || m.category === "db" || m.category === "tool"
    );
    for (const skill of missingTechnicalSkills.slice(0, 1)) {
      recommendations.push({
        type: "get-certification",
        priority: "low",
        skill: skill.phrase,
        reason: `Technical certification could validate "${skill.phrase}" skills`,
        suggestion: `Consider pursuing a certification in "${skill.phrase}" to demonstrate competency and fill this gap.`
      });
    }
    const priorityOrder = { high: 0, medium: 1, low: 2 };
    recommendations.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
    return recommendations;
  }
  content;
  function extractFacts(bullet) {
    const lowerBullet = bullet.toLowerCase();
    const actionVerbs = extractActionVerbs(bullet);
    const objects = extractObjects(bullet);
    const technologies = extractTechnologies(bullet);
    const teamInvolvement = /\b(led|lead|managed|manages|directed|mentored|oversaw|supervised|coached|guided)\b.*\b(team|group|engineers?|developers?|people)\b/.test(
      lowerBullet
    ) || /\bteam\s+(of\s+)?\d+/.test(lowerBullet);
    const teamSizeMatch = lowerBullet.match(/\bteam\s+of\s+(\d+)/);
    const teamSize = teamSizeMatch ? parseInt(teamSizeMatch[1]) : void 0;
    const scope = extractScope(bullet);
    const employment = extractEmploymentType$1(bullet);
    const otherFacts = extractOtherFacts(bullet);
    const metrics = extractMetrics(bullet);
    return {
      actionVerbs,
      objects,
      technologies,
      metrics,
      teamInvolvement,
      teamSize,
      scope,
      employment,
      otherFacts
    };
  }
  function extractActionVerbs(bullet) {
    const commonActionVerbs = [
      "built",
      "developed",
      "created",
      "designed",
      "implemented",
      "led",
      "managed",
      "directed",
      "optimized",
      "improved",
      "increased",
      "reduced",
      "achieved",
      "delivered",
      "architected",
      "engineered",
      "produced",
      "deployed",
      "launched",
      "drove",
      "established",
      "transformed",
      "automated",
      "integrated",
      "mentored",
      "coached",
      "supervised",
      "oversaw",
      "collaborated",
      "contributed",
      "participated"
    ];
    const found = [];
    const lowerBullet = bullet.toLowerCase();
    for (const verb of commonActionVerbs) {
      if (new RegExp(`\\b${verb}\\b`).test(lowerBullet)) {
        found.push(verb);
      }
    }
    return found;
  }
  function extractObjects(bullet, _actionVerbs) {
    const objects = [];
    const patterns = [
      /(?:built|developed|created|designed)\s+(?:a|an|the)?\s*([^,\.]+?)(?:\s+(?:with|using|for|to)|\s*[,\.]|$)/i,
      /(?:architected|designed|implemented)\s+(?:a|an|the)?\s*([^,\.]+?)(?:\s+(?:with|using|for|to)|\s*[,\.]|$)/i,
      /(?:led|managed|directed|oversaw)\s+(?:the)?\s*([^,\.]+?)(?:\s+(?:with|using|for|to)|\s*[,\.]|$)/i
    ];
    for (const pattern of patterns) {
      const matches = bullet.match(pattern);
      if (matches && matches[1]) {
        const obj = matches[1].trim();
        if (obj && !objects.includes(obj)) {
          objects.push(obj);
        }
      }
    }
    return objects;
  }
  function extractTechnologies(bullet) {
    const technologies = [];
    const techKeywords = [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "python",
      "java",
      "golang",
      "node",
      "node.js",
      "express",
      "django",
      "flask",
      "fastapi",
      "sql",
      "mongodb",
      "postgresql",
      "mysql",
      "redis",
      "docker",
      "kubernetes",
      "aws",
      "gcp",
      "azure",
      "graphql",
      "rest",
      "api",
      "microservices",
      "ci/cd",
      "jenkins",
      "github",
      "gitlab",
      "git",
      "html",
      "css",
      "sass",
      "webpack",
      "jest",
      "testing",
      "nextjs",
      "next.js",
      "rails",
      "spring",
      "scala",
      "rust",
      "c++",
      "c#"
    ];
    const lowerBullet = bullet.toLowerCase();
    for (const tech of techKeywords) {
      const escapedTech = tech.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      if (new RegExp(`\\b${escapedTech}\\b`).test(lowerBullet)) {
        technologies.push(tech);
      }
    }
    return technologies;
  }
  function extractScope(bullet) {
    const lowerBullet = bullet.toLowerCase();
    if (/\bfeature\b/.test(lowerBullet)) return "feature";
    if (/\bproduct\b/.test(lowerBullet)) return "product";
    if (/\bplatform\b/.test(lowerBullet)) return "platform";
    if (/\bsystem\b|\binfrastructure\b|\barchitecture\b/.test(lowerBullet))
      return "system";
    if (/\bwebsite\b|\bweb app\b|\bapp\b/.test(lowerBullet)) return "application";
    if (/\bservice\b|\bapi\b/.test(lowerBullet)) return "service";
    if (/\bmodule\b|\bcomponent\b/.test(lowerBullet)) return "component";
    if (/\blibrary\b|\bframework\b/.test(lowerBullet)) return "library";
    return "undefined";
  }
  function extractEmploymentType$1(bullet) {
    const lowerBullet = bullet.toLowerCase();
    if (/\bintern\b|\binternship\b/.test(lowerBullet)) return "internship";
    if (/\bfull[\s-]?time\b|\bfull-time\b/.test(lowerBullet)) return "full-time";
    if (/\bcontract\b|\bcontractor\b/.test(lowerBullet)) return "contract";
    if (/\bpart[\s-]?time\b|\bpart-time\b/.test(lowerBullet)) return "part-time";
    return void 0;
  }
  function extractOtherFacts(bullet) {
    const facts = [];
    const properNounMatches = bullet.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b/g);
    if (properNounMatches) {
      facts.push(...properNounMatches);
    }
    if (/award|recognition|promoted|promotion/.test(bullet.toLowerCase())) {
      const match = bullet.match(/(?:won|received|got|earned|awarded)\s+(?:the\s+)?([^,\.]+)/i);
      if (match && match[1]) {
        facts.push(`Award: ${match[1]}`);
      }
    }
    return facts;
  }
  function extractMetrics(bullet) {
    const metrics = [];
    const metricPatterns = [
      /(\d+(?:[.,]\d{3})*(?:\.\d+)?)\s*([%â‚¬$Â£Â¥]|\s*(?:users?|customers?|employees?|developers?|engineers?|hours|days|weeks|months|years|revenue|profit|savings|reduction|increase|growth|improvement))/gi,
      /(\d+(?:[.,]\d{3})*(?:\.\d+)?)\s*([%])\s*(increase|decrease|growth|improvement|reduction)/gi
    ];
    for (const pattern of metricPatterns) {
      let match;
      while ((match = pattern.exec(bullet)) !== null) {
        const value = parseFloat(match[1].replace(/,/g, ""));
        const unit = match[2];
        const context = match[3];
        metrics.push({
          value,
          unit,
          context
        });
      }
    }
    return metrics;
  }
  content;
  async function generateCoverLetter$1(profile, jobPosting, config) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "generateCoverLetter", {
      profileName: profile.name,
      jobPostingLength: jobPosting.length
    });
    try {
      log$1.info(LogCategory.SERVICE, "Starting AI cover letter generation", {
        name: profile.name,
        targetLength: config?.targetLength || 300,
        temperature: config?.temperature || 0.4
      });
      log$1.debug(LogCategory.SERVICE, "Extracting job context");
      const jobContext = extractJobContext(jobPosting);
      log$1.info(LogCategory.SERVICE, "Job context extracted", {
        company: jobContext.company,
        role: jobContext.role,
        culture: jobContext.culture,
        keyRequirements: jobContext.keyRequirements.length
      });
      log$1.debug(LogCategory.SERVICE, "Detecting company culture");
      const tone = detectCompanyCulture(jobPosting, config?.tone);
      log$1.info(LogCategory.SERVICE, "Tone profile determined", {
        style: tone.style,
        formality: tone.formality,
        enthusiasm: tone.enthusiasm
      });
      log$1.debug(LogCategory.SERVICE, "Matching user to job requirements");
      const jobRequirements = {
        required: jobContext.keyRequirements.filter((k) => k.required),
        preferred: jobContext.keyRequirements.filter((k) => !k.required)
      };
      const matchReport = matchUserToJob(profile, jobRequirements);
      log$1.info(LogCategory.SERVICE, "User-job matching complete", {
        matchScore: matchReport.matchScore,
        matches: matchReport.matches.length
      });
      log$1.debug(LogCategory.SERVICE, "Selecting best achievement stories");
      const stories = selectBestStories(profile, matchReport, jobContext);
      log$1.info(LogCategory.SERVICE, "Stories selected", {
        primaryStory: stories.primary ? stories.primary.achievement.id : "none",
        secondaryStory: stories.secondary ? stories.secondary.achievement.id : "none"
      });
      log$1.debug(LogCategory.SERVICE, "Building cover letter narrative");
      const narrative = buildNarrative(profile, matchReport, stories, jobContext);
      log$1.info(LogCategory.SERVICE, "Narrative structure created", {
        hook: narrative.hook.substring(0, 50),
        theme: narrative.closingTheme
      });
      log$1.debug(LogCategory.SERVICE, "Generating sections with Claude API");
      const sections = await generateSectionsWithAI(narrative, jobContext, tone, config);
      log$1.info(LogCategory.SERVICE, "AI generation complete");
      log$1.debug(LogCategory.SERVICE, "Assembling full cover letter");
      const fullText = assembleCoverLetter(sections, profile, jobContext, config);
      const htmlFormatted = formatAsHTML(fullText);
      const wordCount = countWords(fullText);
      log$1.info(LogCategory.SERVICE, "Cover letter assembled", {
        wordCount,
        targetRange: "250-400"
      });
      log$1.debug(LogCategory.SERVICE, "Verifying no hallucination");
      const verification = verifyNoHallucinationInCoverLetter(
        fullText,
        profile,
        sections,
        jobContext
      );
      log$1.info(LogCategory.SERVICE, "Hallucination check complete", {
        noHallucination: verification.noHallucination,
        confidence: verification.confidence,
        addedFacts: verification.addedFacts.length
      });
      log$1.debug(LogCategory.SERVICE, "Calculating ATS score");
      const matchAnalysis = calculateCoverLetterATSScore(
        fullText,
        jobContext,
        matchReport
      );
      log$1.info(LogCategory.SERVICE, "ATS score calculated", {
        atsScore: matchAnalysis.atsScore,
        keywordCoverage: verification.keywordCoverage
      });
      const result2 = {
        fullText,
        htmlFormatted,
        sections,
        narrative,
        tone,
        wordCount,
        verification,
        matchAnalysis
      };
      log$1.info(LogCategory.SERVICE, "Cover letter generation complete", {
        wordCount,
        atsScore: matchAnalysis.atsScore,
        noHallucination: verification.noHallucination
      });
      endTrace();
      return result2;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Cover letter generation failed", error);
      endTrace();
      throw error;
    }
  }
  function extractJobContext(jobPosting) {
    let company = "Hiring Company";
    const companyPatterns = [
      /(?:at|@)\s+([A-Z][A-Za-z0-9\s&.,-]+?)(?:\s+is|,|\.|$)/,
      /([A-Z][A-Za-z0-9\s&.,-]+?)\s+is\s+(?:hiring|looking|seeking)/i,
      /Company:\s*([A-Z][A-Za-z0-9\s&.,-]+)/
    ];
    for (const pattern of companyPatterns) {
      const match = jobPosting.match(pattern);
      if (match && match[1]) {
        company = match[1].trim();
        break;
      }
    }
    let role = "Position";
    const rolePatterns = [
      /(?:Position|Role|Job Title|Title):\s*(.+)/i,
      /^([A-Z][A-Za-z\s-]+(?:Engineer|Developer|Manager|Designer|Analyst|Specialist))/m
    ];
    for (const pattern of rolePatterns) {
      const match = jobPosting.match(pattern);
      if (match && match[1]) {
        role = match[1].trim();
        break;
      }
    }
    let hiringManager;
    const managerPatterns = [
      /(?:Dear|Contact|Hiring Manager):\s*([A-Z][a-z]+\s+[A-Z][a-z]+)/,
      /(?:reach out to|contact)\s+([A-Z][a-z]+\s+[A-Z][a-z]+)/
    ];
    for (const pattern of managerPatterns) {
      const match = jobPosting.match(pattern);
      if (match && match[1]) {
        hiringManager = match[1].trim();
        break;
      }
    }
    const keyRequirements = extractKeywordsFromJobDescription(jobPosting);
    const culture = detectCultureLevel(jobPosting);
    return {
      company,
      role,
      hiringManager,
      keyRequirements,
      culture
    };
  }
  function detectCultureLevel(jobPosting) {
    const lowerPosting = jobPosting.toLowerCase();
    const formalKeywords = [
      "professional",
      "corporate",
      "established",
      "traditional",
      "conservative",
      "enterprise",
      "fortune",
      "institutional"
    ];
    const formalCount = formalKeywords.filter((kw) => lowerPosting.includes(kw)).length;
    const casualKeywords = [
      "startup",
      "fast-paced",
      "fun",
      "innovative",
      "disruptive",
      "cutting-edge",
      "dynamic",
      "flexible",
      "remote-first",
      "async"
    ];
    const casualCount = casualKeywords.filter((kw) => lowerPosting.includes(kw)).length;
    if (formalCount > casualCount && formalCount >= 2) {
      return "formal";
    } else if (casualCount > formalCount && casualCount >= 2) {
      return "casual";
    } else {
      return "business-casual";
    }
  }
  function detectCompanyCulture(jobPosting, toneOverride) {
    const culture = detectCultureLevel(jobPosting);
    let baseTone;
    switch (culture) {
      case "formal":
        baseTone = {
          style: "professional",
          enthusiasm: "reserved",
          formality: "formal",
          personalityLevel: 0.2
        };
        break;
      case "casual":
        baseTone = {
          style: "conversational",
          enthusiasm: "high",
          formality: "casual",
          personalityLevel: 0.8
        };
        break;
      default:
        baseTone = {
          style: "balanced",
          enthusiasm: "moderate",
          formality: "business-casual",
          personalityLevel: 0.5
        };
    }
    return {
      ...baseTone,
      ...toneOverride
    };
  }
  function selectBestStories(profile, matchReport, jobContext) {
    const allAchievements = [];
    profile.workExperience.forEach((exp) => {
      exp.achievements.forEach((achievement) => {
        allAchievements.push({
          achievement,
          source: "work",
          company: exp.company,
          title: exp.title
        });
      });
    });
    profile.projects.forEach((project) => {
      project.achievements.forEach((achievement) => {
        allAchievements.push({
          achievement,
          source: "project",
          company: project.name,
          title: "Project"
        });
      });
    });
    const scoredAchievements = allAchievements.map((item) => {
      const score = scoreAchievementRelevance(
        item.achievement,
        jobContext.keyRequirements
      );
      return {
        ...item,
        relevanceScore: score,
        starFramework: extractSTARFramework(item.achievement),
        keywords: item.achievement.keywords,
        estimatedWordCount: estimateWordCount(item.achievement)
      };
    });
    scoredAchievements.sort((a, b) => b.relevanceScore - a.relevanceScore);
    const primary = scoredAchievements.length > 0 ? scoredAchievements[0] : null;
    let secondary = null;
    if (scoredAchievements.length > 1 && primary) {
      for (const story of scoredAchievements.slice(1)) {
        const skillOverlap = calculateSkillOverlap(
          primary.achievement.skills,
          story.achievement.skills
        );
        if (skillOverlap < 0.6) {
          secondary = story;
          break;
        }
      }
    }
    return { primary, secondary };
  }
  function scoreAchievementRelevance(achievement, jobRequirements, _matchReport) {
    let score = 0;
    const achievementKeywords = new Set(
      [...achievement.skills, ...achievement.keywords].map((k) => k.toLowerCase())
    );
    const jobKeywords = new Set(
      jobRequirements.map((r2) => r2.phrase.toLowerCase())
    );
    let matchCount = 0;
    for (const keyword of achievementKeywords) {
      if (jobKeywords.has(keyword)) {
        matchCount++;
      }
    }
    const keywordScore = jobKeywords.size > 0 ? matchCount / jobKeywords.size : 0;
    score += keywordScore * 0.5;
    if (achievement.metrics && achievement.metrics.length > 0) {
      score += 0.2;
    }
    score += 0.1;
    const impactVerbs = ["led", "built", "architected", "launched", "transformed", "established"];
    const hasImpact = impactVerbs.some(
      (verb) => achievement.bullet.toLowerCase().includes(verb)
    );
    if (hasImpact) {
      score += 0.15;
    }
    return Math.min(1, score);
  }
  function extractSTARFramework(achievement) {
    const bullet = achievement.bullet;
    return {
      situation: extractSituation(bullet, achievement),
      task: extractTask(bullet, achievement),
      action: extractAction(bullet, achievement),
      result: extractResult(bullet, achievement)
    };
  }
  function extractSituation(bullet, achievement) {
    const contextMatch = bullet.match(/(?:At|In|During)\s+([^,]+)/);
    return contextMatch ? contextMatch[1] : `In ${achievement.action || "role"}`;
  }
  function extractTask(_bullet, achievement) {
    return achievement.object || "the objective";
  }
  function extractAction(_bullet, achievement) {
    return achievement.bullet;
  }
  function extractResult(_bullet, achievement) {
    if (achievement.result) {
      return achievement.result;
    }
    if (achievement.metrics && achievement.metrics.length > 0) {
      const metric = achievement.metrics[0];
      return `${metric.type} by ${metric.value}${metric.unit}`;
    }
    return "successful outcome";
  }
  function estimateWordCount(achievement) {
    return achievement.bullet.split(/\s+/).length;
  }
  function calculateSkillOverlap(skills1, skills2) {
    const set1 = new Set(skills1.map((s) => s.toLowerCase()));
    const set2 = new Set(skills2.map((s) => s.toLowerCase()));
    let overlap = 0;
    for (const skill of set1) {
      if (set2.has(skill)) {
        overlap++;
      }
    }
    return Math.max(set1.size, set2.size) > 0 ? overlap / Math.max(set1.size, set2.size) : 0;
  }
  function buildNarrative(profile, matchReport, stories, jobContext) {
    const hook = buildHook(profile, jobContext, matchReport);
    const valueProposition = buildValueProposition(profile, jobContext, matchReport);
    const connectionToRole = buildConnectionToRole(profile, jobContext);
    const closingTheme = buildClosingTheme(profile, jobContext);
    return {
      hook,
      valueProposition,
      primaryStory: stories.primary,
      secondaryStory: stories.secondary || void 0,
      connectionToRole,
      closingTheme
    };
  }
  function buildHook(_profile, _jobContext, _matchReport) {
    const topMatch = _matchReport.matches[0];
    const skill = topMatch ? topMatch.requirement.phrase : _jobContext.keyRequirements[0].phrase;
    return `${_profile.metadata.totalYearsExperience}+ years of ${skill} experience, passionate about ${_jobContext.company}'s mission`;
  }
  function buildValueProposition(_profile, _jobContext, _matchReport) {
    const strengths = _matchReport.matches.slice(0, 3).map((m) => m.requirement.phrase);
    return `Proven track record in ${strengths.join(", ")}`;
  }
  function buildConnectionToRole(_profile, _jobContext, _stories) {
    return `My experience aligns closely with ${_jobContext.role} requirements`;
  }
  function buildClosingTheme(_profile, _jobContext) {
    return `eager to contribute to ${_jobContext.company}'s continued success`;
  }
  async function generateSectionsWithAI(narrative, jobContext, tone, config) {
    const apiKey = process.env.VITE_ANTHROPIC_API_KEY;
    if (!apiKey) {
      throw new Error("VITE_ANTHROPIC_API_KEY environment variable not set");
    }
    const anthropic = new Anthropic({ apiKey });
    const opening = await generateOpening(anthropic, narrative, jobContext, tone, config);
    const paragraph1 = await generateBodyParagraph(
      anthropic,
      narrative.primaryStory,
      jobContext,
      tone,
      config
    );
    let paragraph2;
    if (narrative.secondaryStory) {
      paragraph2 = await generateBodyParagraph(
        anthropic,
        narrative.secondaryStory,
        jobContext,
        tone,
        config
      );
    }
    const closing = await generateClosing(anthropic, narrative, jobContext, tone, config);
    return {
      opening,
      body: {
        paragraph1,
        paragraph2
      },
      closing
    };
  }
  async function generateOpening(anthropic, narrative, jobContext, tone, config) {
    const prompt = `You are writing the opening paragraph of a cover letter.

STRICT RULES:
1. DO NOT invent experiences, achievements, or skills not provided
2. DO reference the company by name: "${jobContext.company}"
3. DO show genuine enthusiasm (not generic)
4. DO keep it 2-3 sentences max
5. DO use ${tone.style} tone
6. DO NOT add fake metrics or team sizes

USER INFO:
- Name: ${narrative.primaryStory.achievement.action}
- Years Experience: Not specified (DO NOT INVENT)

JOB INFO:
- Company: ${jobContext.company}
- Role: ${jobContext.role}
- Key requirement: ${jobContext.keyRequirements[0]?.phrase || "relevant skills"}

NARRATIVE:
Hook: "${narrative.hook}"
Value Proposition: "${narrative.valueProposition}"

Write ONLY the opening paragraph (2-3 sentences).
Format: "Dear [Name or Hiring Team],\\n\\n[Hook sentence]. [Value proposition]."

Begin:`;
    const message = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20241022",
      max_tokens: 200,
      temperature: config?.temperature || 0.4,
      messages: [
        {
          role: "user",
          content: prompt
        }
      ]
    });
    const responseText = message.content[0].type === "text" ? message.content[0].text : "";
    const lines = responseText.split("\n\n");
    const greeting = lines[0] || "Dear Hiring Manager,";
    const body = lines.slice(1).join(" ").trim();
    const sentences = body.split(/\.\s+/);
    const hook = sentences[0] + "." || body;
    const valueProposition = sentences.slice(1).join(". ").trim() || "";
    return {
      greeting,
      hook,
      valueProposition: valueProposition || narrative.valueProposition
    };
  }
  async function generateBodyParagraph(anthropic, story, jobContext, tone, config) {
    const prompt = `You are writing a body paragraph using the STAR method.

STRICT RULES:
1. ONLY use facts from the achievement provided below
2. DO NOT add fake metrics, team sizes, or accomplishments
3. DO quantify results if metrics are provided
4. DO emphasize the ACTION (60% of paragraph)
5. DO connect to job requirement: "${jobContext.keyRequirements[0]?.phrase || "role"}"
6. DO use ${tone.style} tone
7. DO keep it 100-150 words
8. DO write in narrative form (NOT bullet points)
9. DO NOT invent company names, technologies, or team details

ACHIEVEMENT (VERIFIED FACTS):
${JSON.stringify(story.achievement, null, 2)}

STAR BREAKDOWN:
Situation (10%): ${story.starFramework.situation}
Task (10%): ${story.starFramework.task}
Action (60%): ${story.starFramework.action} â† FOCUS HERE
Result (20%): ${story.starFramework.result}

Write the body paragraph focusing on what the user DID.
Example structure: "In [context], I [action verb] [object] [details]. [More action]. This resulted in [outcome]."

DO NOT start with "At [Company]" unless company is in the verified facts above.

Begin:`;
    const message = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20241022",
      max_tokens: 250,
      temperature: config?.temperature || 0.4,
      messages: [
        {
          role: "user",
          content: prompt
        }
      ]
    });
    const paragraph = message.content[0].type === "text" ? message.content[0].text.trim() : "";
    return paragraph;
  }
  async function generateClosing(anthropic, narrative, jobContext, tone, config) {
    const prompt = `You are writing the closing paragraph of a cover letter.

STRICT RULES:
1. DO reiterate interest in the role
2. DO include a call to action ("I'd love to discuss...")
3. DO keep it 2-3 sentences
4. DO use ${tone.style} tone
5. DO NOT be generic or overly formal
6. DO NOT invent availability or specific dates

CONTEXT:
Company: ${jobContext.company}
Role: ${jobContext.role}
Theme: ${narrative.closingTheme}

Write the closing paragraph (interest + call to action).
Format: "[Interest statement]. [Call to action]. [Sign-off]"

Begin:`;
    const message = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20241022",
      max_tokens: 200,
      temperature: config?.temperature || 0.4,
      messages: [
        {
          role: "user",
          content: prompt
        }
      ]
    });
    const responseText = message.content[0].type === "text" ? message.content[0].text : "";
    const sentences = responseText.split(/\.\s+/);
    const reiterateInterest = sentences[0] + "." || responseText;
    const callToAction = sentences[1] + "." || "I look forward to discussing this opportunity.";
    const signOff = sentences.length > 2 ? sentences.slice(2).join(". ").trim() : "Sincerely";
    return {
      reiterateInterest,
      callToAction,
      signOff: signOff || "Sincerely"
    };
  }
  function assembleCoverLetter(sections, profile, jobContext, config) {
    const lines = [];
    lines.push(profile.name);
    if (profile.email) lines.push(profile.email);
    if (profile.phone) lines.push(profile.phone);
    if (profile.location) lines.push(profile.location);
    lines.push("");
    const date = (/* @__PURE__ */ new Date()).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric"
    });
    lines.push(date);
    lines.push("");
    if (config?.includeHiringManager && jobContext.hiringManager) {
      lines.push(jobContext.hiringManager);
    }
    lines.push(jobContext.company);
    lines.push("");
    lines.push(sections.opening.greeting);
    lines.push("");
    lines.push(sections.opening.hook);
    if (sections.opening.valueProposition) {
      lines.push(sections.opening.valueProposition);
    }
    lines.push("");
    lines.push(sections.body.paragraph1);
    lines.push("");
    if (sections.body.paragraph2) {
      lines.push(sections.body.paragraph2);
      lines.push("");
    }
    lines.push(sections.closing.reiterateInterest);
    lines.push(sections.closing.callToAction);
    lines.push("");
    lines.push(sections.closing.signOff);
    lines.push(profile.name);
    return lines.join("\n");
  }
  function formatAsHTML(text) {
    const paragraphs = text.split("\n\n").filter((p) => p.trim());
    const htmlParts = paragraphs.map((p) => {
      const trimmed = p.trim().replace(/\n/g, "<br>");
      return `<p>${trimmed}</p>`;
    });
    return htmlParts.join("\n");
  }
  function countWords(text) {
    return text.trim().split(/\s+/).length;
  }
  function verifyNoHallucinationInCoverLetter(fullText, profile, sections, jobContext) {
    const addedFacts = [];
    let confidence = 1;
    const bodyTexts = [
      sections.body.paragraph1,
      sections.body.paragraph2 || ""
    ].filter((t) => t);
    for (const bodyText of bodyTexts) {
      const extractedFacts = extractFacts(bodyText);
      if (extractedFacts.teamInvolvement) {
        const hasTeamExp = profile.workExperience.some(
          (exp) => exp.achievements.some(
            (a) => a.bullet.toLowerCase().includes("led") || a.bullet.toLowerCase().includes("team") || a.bullet.toLowerCase().includes("managed")
          )
        );
        if (!hasTeamExp) {
          addedFacts.push("Added team leadership claim without evidence");
          confidence -= 0.25;
        }
      }
      if (extractedFacts.teamSize !== void 0) {
        const hasTeamSize = profile.workExperience.some(
          (exp) => exp.achievements.some((a) => /team\s+of\s+\d+/i.test(a.bullet))
        );
        if (!hasTeamSize) {
          addedFacts.push(`Added specific team size: ${extractedFacts.teamSize}`);
          confidence -= 0.25;
        }
      }
      if (extractedFacts.metrics.length > 0) {
        const allProfileMetrics = profile.workExperience.flatMap(
          (exp) => exp.achievements.flatMap((a) => a.metrics || [])
        );
        for (const metric of extractedFacts.metrics) {
          const hasMetric = allProfileMetrics.some(
            (m) => Math.abs(m.value - metric.value) < 0.1 && m.unit === metric.unit
          );
          if (!hasMetric) {
            addedFacts.push(`Added metric: ${metric.value}${metric.unit}`);
            confidence -= 0.2;
          }
        }
      }
    }
    const wordCount = countWords(fullText);
    const wordCountValid = wordCount >= 200 && wordCount <= 450;
    const spellingErrors = [];
    const sentimentScore = 0.7;
    const keywordsUsed = jobContext.keyRequirements.filter((kw) => fullText.toLowerCase().includes(kw.phrase.toLowerCase())).map((kw) => kw.phrase);
    const keywordCoverage = jobContext.keyRequirements.length > 0 ? keywordsUsed.length / jobContext.keyRequirements.length : 0;
    const allFactsFromProfile = profile.workExperience.flatMap(
      (exp) => exp.achievements.map((a) => a.bullet)
    );
    return {
      noHallucination: addedFacts.length === 0,
      allFactsFromProfile,
      addedFacts,
      confidence: Math.max(0, confidence),
      wordCount,
      wordCountValid,
      spellingErrors,
      sentimentScore,
      keywordsUsed,
      keywordCoverage
    };
  }
  function calculateCoverLetterATSScore(fullText, jobContext, _matchReport) {
    const lowerText = fullText.toLowerCase();
    const requirements = jobContext.keyRequirements;
    const requirementsAddressed = [];
    const requirementsMissed = [];
    for (const req of requirements) {
      if (lowerText.includes(req.phrase.toLowerCase())) {
        requirementsAddressed.push(req.phrase);
      } else {
        requirementsMissed.push(req.phrase);
      }
    }
    let score = 0;
    const keywordScore = requirements.length > 0 ? requirementsAddressed.length / requirements.length * 50 : 0;
    score += keywordScore;
    const wordCount = countWords(fullText);
    if (wordCount >= 250 && wordCount <= 400) {
      score += 15;
    } else if (wordCount >= 200 && wordCount < 250) {
      score += 10;
    } else if (wordCount > 400 && wordCount <= 450) {
      score += 10;
    } else {
      score += 5;
    }
    if (lowerText.includes("dear")) score += 5;
    if (lowerText.includes("sincerely") || lowerText.includes("best")) score += 5;
    if (lowerText.includes(jobContext.company.toLowerCase())) score += 5;
    if (lowerText.includes(jobContext.role.toLowerCase())) score += 5;
    if (requirementsAddressed.length >= 5) score += 8;
    if (/\d+%|\d+\s*(?:users|hours|days)/.test(fullText)) score += 7;
    return {
      requirementsAddressed,
      requirementsMissed,
      atsScore: Math.min(100, Math.round(score))
    };
  }
  content;
  const CACHE_STORAGE_KEY = "uproot_cover_letter_research_cache";
  async function researchCoverLetterTechniques(industry, companyName, useCache = true) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "researchCoverLetterTechniques", {
      industry,
      companyName,
      useCache
    });
    try {
      const cacheKey = generateCacheKey(industry, companyName);
      log$1.debug(LogCategory.SERVICE, "Generated cache key", { cacheKey });
      if (useCache) {
        const cachedResult = await getCachedResearch(cacheKey);
        if (cachedResult) {
          log$1.info(LogCategory.SERVICE, "Using cached research results", {
            cacheKey,
            age: Date.now() - cachedResult.researchedAt
          });
          endTrace();
          return cachedResult;
        }
      }
      log$1.info(LogCategory.SERVICE, "Cache miss - performing new research", { cacheKey });
      const research = await performDeepResearch(industry, companyName);
      await cacheResearch(cacheKey, research);
      log$1.info(LogCategory.SERVICE, "Research completed and cached", { cacheKey });
      endTrace();
      return research;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Cover letter research failed", error);
      endTrace();
      throw error;
    }
  }
  async function performDeepResearch(industry, companyName) {
    {
      throw new Error("VITE_ANTHROPIC_API_KEY environment variable not set");
    }
  }
  function generateCacheKey(industry, companyName) {
    const normalized = industry.toLowerCase().replace(/\s+/g, "_");
    if (companyName) {
      const companyNormalized = companyName.toLowerCase().replace(/\s+/g, "_");
      return `${normalized}__${companyNormalized}`;
    }
    return normalized;
  }
  async function getCachedResearch(cacheKey) {
    try {
      const cache = await loadCache();
      const result2 = cache[cacheKey];
      if (!result2) {
        log$1.debug(LogCategory.SERVICE, "Cache miss - no entry found", { cacheKey });
        return null;
      }
      if (Date.now() > result2.expiresAt) {
        log$1.debug(LogCategory.SERVICE, "Cache miss - entry expired", {
          cacheKey,
          expiresAt: result2.expiresAt
        });
        return null;
      }
      return result2;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Failed to load cache", error);
      return null;
    }
  }
  async function cacheResearch(cacheKey, research) {
    try {
      const cache = await loadCache();
      cache[cacheKey] = research;
      await saveCache(cache);
      log$1.debug(LogCategory.SERVICE, "Research cached successfully", { cacheKey });
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Failed to save cache", error);
    }
  }
  async function loadCache() {
    try {
      const result2 = await chrome.storage.local.get(CACHE_STORAGE_KEY);
      return result2[CACHE_STORAGE_KEY] || {};
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Failed to load cache from storage", error);
      return {};
    }
  }
  async function saveCache(cache) {
    try {
      await chrome.storage.local.set({ [CACHE_STORAGE_KEY]: cache });
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Failed to save cache to storage", error);
      throw error;
    }
  }
  content;
  async function generateCoverLetterWithResearch(profile, jobPosting, config, enableResearch = true) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "generateCoverLetterWithResearch", {
      profileName: profile.personalInfo.fullName,
      jobPostingLength: jobPosting.length,
      enableResearch
    });
    try {
      log$1.info(LogCategory.SERVICE, "Starting enhanced cover letter generation with research mode", {
        enableResearch
      });
      let research;
      if (enableResearch) {
        log$1.debug(LogCategory.SERVICE, "Detecting industry and company");
        const { industry, company } = detectIndustryAndCompany(jobPosting);
        log$1.info(LogCategory.SERVICE, "Detected industry and company", { industry, company });
        log$1.debug(LogCategory.SERVICE, "Performing deep research on cover letter techniques");
        research = await researchCoverLetterTechniques(industry, company);
        log$1.info(LogCategory.SERVICE, "Deep research completed", {
          trendsFound: research.industryTrends.length,
          tipsFound: research.atsOptimizationTips.length
        });
        log$1.debug(LogCategory.SERVICE, "Applying research findings to generation config");
        config = enhanceConfigWithResearch(config || {}, research);
      }
      log$1.debug(LogCategory.SERVICE, "Generating cover letter with enhanced config");
      const result2 = await generateCoverLetter$1(profile, jobPosting, config);
      const enhancedResult = {
        ...result2,
        research
      };
      log$1.info(LogCategory.SERVICE, "Enhanced cover letter generation complete", {
        wordCount: result2.wordCount,
        atsScore: result2.matchAnalysis?.atsScore,
        hadResearch: !!research
      });
      endTrace();
      return enhancedResult;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Enhanced cover letter generation failed", error);
      endTrace();
      throw error;
    }
  }
  function detectIndustryAndCompany(jobPosting) {
    const lowerPosting = jobPosting.toLowerCase();
    const industryPatterns = {
      technology: ["software", "tech", "engineer", "developer", "programming", "data science", "AI", "ML", "cloud"],
      healthcare: ["healthcare", "medical", "hospital", "clinical", "physician", "nurse", "patient"],
      finance: ["finance", "banking", "investment", "accounting", "financial", "trading", "analyst"],
      marketing: ["marketing", "advertising", "brand", "campaign", "digital marketing", "SEO", "content"],
      education: ["education", "teaching", "professor", "academic", "university", "school", "curriculum"],
      consulting: ["consulting", "consultant", "advisory", "strategy", "management consulting"],
      retail: ["retail", "sales", "store", "merchandise", "customer service", "ecommerce"],
      manufacturing: ["manufacturing", "production", "factory", "supply chain", "operations"],
      legal: ["legal", "law", "attorney", "paralegal", "litigation", "compliance"],
      nonprofit: ["nonprofit", "NGO", "charity", "foundation", "social impact", "community"]
    };
    let detectedIndustry = "general";
    let maxMatches = 0;
    for (const [industry, keywords] of Object.entries(industryPatterns)) {
      let matches = 0;
      for (const keyword of keywords) {
        if (lowerPosting.includes(keyword.toLowerCase())) {
          matches++;
        }
      }
      if (matches > maxMatches) {
        maxMatches = matches;
        detectedIndustry = industry;
      }
    }
    let company = "company";
    const companyPatterns = [
      /(?:at|@)\s+([A-Z][A-Za-z0-9\s&.,-]+?)(?:\s+is|,|\.|$)/,
      /([A-Z][A-Za-z0-9\s&.,-]+?)\s+is\s+(?:hiring|looking|seeking)/i,
      /Company:\s*([A-Z][A-Za-z0-9\s&.,-]+)/,
      /About\s+([A-Z][A-Za-z0-9\s&.,-]+)/i
    ];
    for (const pattern of companyPatterns) {
      const match = jobPosting.match(pattern);
      if (match && match[1]) {
        company = match[1].trim();
        break;
      }
    }
    return { industry: detectedIndustry, company };
  }
  function enhanceConfigWithResearch(config, research) {
    if (research.toneBestPractices.length > 0) {
      const toneText = research.toneBestPractices.join(" ").toLowerCase();
      if (toneText.includes("formal") || toneText.includes("professional") || toneText.includes("conservative")) {
        config.tone = {
          ...config.tone,
          style: "professional",
          formality: "formal",
          enthusiasm: "reserved",
          personalityLevel: 0.3
        };
      } else if (toneText.includes("casual") || toneText.includes("conversational") || toneText.includes("friendly")) {
        config.tone = {
          ...config.tone,
          style: "conversational",
          formality: "casual",
          enthusiasm: "high",
          personalityLevel: 0.7
        };
      } else {
        config.tone = {
          ...config.tone,
          style: "balanced",
          formality: "business-casual",
          enthusiasm: "moderate",
          personalityLevel: 0.5
        };
      }
    }
    if (research.exampleStructures.length > 0) {
      const structureText = research.exampleStructures.join(" ").toLowerCase();
      if (structureText.includes("concise") || structureText.includes("brief") || structureText.includes("short")) {
        config.targetLength = 250;
      } else if (structureText.includes("detailed") || structureText.includes("comprehensive")) {
        config.targetLength = 400;
      } else {
        config.targetLength = 300;
      }
    }
    config.researchContext = {
      industryTrends: research.industryTrends,
      atsOptimizationTips: research.atsOptimizationTips,
      commonMistakesToAvoid: research.commonMistakes,
      companySpecificAdvice: research.companySpecificAdvice
    };
    return config;
  }
  content;
  async function generateCoverLetter(jobData, selectedJob, profile, options) {
    const jobPosting = selectedJob.rawText || jobData.description;
    const params = {
      tone: options?.tone ? {
        style: mapLegacyTone(options.tone)
      } : void 0,
      targetLength: "medium"
    };
    const result2 = await generateCoverLetterWithResearch(
      profile,
      jobPosting,
      {
        ...params,
        targetLength: options?.targetWordCount
      },
      true
      // enable research mode
    );
    const coverLetter = {
      id: crypto.randomUUID(),
      jobTitle: jobData.jobTitle,
      company: jobData.company,
      generationMethod: "ai",
      version: 1,
      status: "draft",
      content: {
        contactInfo: {
          fullName: profile.personalInfo.fullName,
          email: profile.personalInfo.email,
          phone: profile.personalInfo.phone,
          location: profile.personalInfo.location,
          linkedinUrl: profile.personalInfo.linkedinUrl,
          portfolioUrl: profile.personalInfo.portfolioUrl
        },
        date: (/* @__PURE__ */ new Date()).toLocaleDateString("en-US", {
          year: "numeric",
          month: "long",
          day: "numeric"
        }),
        recipientInfo: {
          companyName: jobData.company
        },
        greeting: result2.sections.opening.greeting,
        opening: {
          id: "opening",
          type: "opening",
          text: result2.sections.opening.hook + " " + result2.sections.opening.valueProposition,
          keywords: []
        },
        body: [
          {
            id: "body1",
            type: "experience",
            text: result2.sections.body.paragraph1,
            keywords: []
          },
          ...result2.sections.body.paragraph2 ? [{
            id: "body2",
            type: "experience",
            text: result2.sections.body.paragraph2,
            keywords: []
          }] : []
        ],
        closing: {
          id: "closing",
          type: "closing",
          text: result2.sections.closing.reiterateInterest + " " + result2.sections.closing.callToAction,
          keywords: []
        },
        signOff: result2.sections.closing.signOff,
        signature: profile.personalInfo.fullName,
        fullText: result2.fullText,
        wordCount: result2.wordCount,
        paragraphCount: 4 + (result2.sections.body.paragraph2 ? 1 : 0)
      },
      qualityScore: {
        overallScore: 85,
        // Placeholder
        grade: "A",
        grammar: { score: 90, weight: 20, issues: [], passed: true },
        readability: { score: 85, weight: 15, issues: [], passed: true },
        tone: { score: 90, weight: 10, issues: [], passed: true },
        atsCompatibility: { score: result2.matchAnalysis.atsScore, weight: 15, issues: [], passed: true },
        contentQuality: { score: 85, weight: 20, issues: [], passed: true },
        structure: { score: 90, weight: 10, issues: [], passed: true },
        personalization: { score: 85, weight: 10, issues: [], passed: true },
        criticalIssues: [],
        warnings: result2.verification.addedFacts.map((f) => ({
          severity: "warning",
          category: "content",
          message: f
        })),
        suggestions: [],
        fleschKincaidGrade: 10,
        fleschReadingEase: 65,
        passiveVoicePercentage: 5,
        clichÃ©Count: 0,
        buzzwordCount: 1,
        isReadyToSend: result2.verification.noHallucination,
        estimatedSuccessProbability: result2.matchAnalysis.atsScore
      },
      atsOptimization: {
        overallATSScore: result2.matchAnalysis.atsScore,
        keywordDensity: 3.5,
        keywordMatchRate: result2.verification.keywordCoverage * 100,
        primaryKeywordsUsed: result2.verification.keywordsUsed.slice(0, 8),
        secondaryKeywordsUsed: result2.verification.keywordsUsed.slice(8),
        totalKeywords: result2.verification.keywordsUsed.length,
        keywordsUsed: result2.verification.keywordsUsed,
        keywordsMissing: result2.matchAnalysis.requirementsMissed,
        formatCompliance: {
          singleColumn: true,
          noHeadersFooters: true,
          standardFont: true,
          noGraphics: true,
          noTables: true,
          score: 100
        },
        lengthCompliance: {
          wordCount: result2.wordCount,
          optimal: result2.verification.wordCountValid,
          tooShort: result2.wordCount < 200,
          tooLong: result2.wordCount > 500,
          score: result2.verification.wordCountValid ? 100 : 70
        },
        personalizationScore: 85,
        companyNameMentioned: result2.fullText.includes(jobData.company),
        jobTitleMentioned: result2.fullText.includes(jobData.jobTitle),
        companyResearchEvident: true,
        recommendations: result2.matchAnalysis.requirementsMissed.map(
          (kw) => `Consider mentioning: ${kw}`
        )
      },
      customizationLevel: "standard",
      createdAt: Date.now(),
      updatedAt: Date.now(),
      lastEditedAt: Date.now()
    };
    const warnings = result2.verification.addedFacts;
    return { coverLetter, warnings };
  }
  function mapLegacyTone(tone) {
    const lowerTone = tone.toLowerCase();
    if (lowerTone.includes("professional") || lowerTone.includes("formal")) {
      return "professional";
    } else if (lowerTone.includes("conversational") || lowerTone.includes("casual")) {
      return "conversational";
    } else {
      return "balanced";
    }
  }
  content;
  const exportCoverLetter = async (_letter, _options) => ({ success: true, fileName: "cover-letter.pdf", error: void 0 });
  function CoverLetterTab({ panelWidth = 400 }) {
    const backgroundColor = "#FFFFFF";
    const textColor = "#1d1d1f";
    const accentColor = "#0077B5";
    const [viewMode, setViewMode] = reactExports.useState("select-job");
    const [jobAnalyses, setJobAnalyses] = reactExports.useState([]);
    const [profile, setProfile] = reactExports.useState(null);
    const [selectedJob, setSelectedJob] = reactExports.useState(null);
    const [selectedTone, setSelectedTone] = reactExports.useState("professional");
    const [generatedLetter, setGeneratedLetter] = reactExports.useState(null);
    const [warnings, setWarnings] = reactExports.useState([]);
    const isCompact = panelWidth < 400;
    reactExports.useEffect(() => {
      loadData();
    }, []);
    const loadData = async () => {
      const [analyses, prof] = await Promise.all([
        getJobDescriptionAnalyses(),
        getProfessionalProfile()
      ]);
      setJobAnalyses(analyses);
      setProfile(prof);
    };
    const handleJobSelect = (job) => {
      setSelectedJob(job);
      setViewMode("select-tone");
    };
    const handleToneSelect = async (tone) => {
      if (!profile || !selectedJob) return;
      setSelectedTone(tone);
      setViewMode("generating");
      setWarnings([]);
      try {
        const jobData = {
          jobTitle: selectedJob.jobTitle,
          company: selectedJob.company,
          location: selectedJob.location || "",
          description: selectedJob.description || "",
          url: selectedJob.jobUrl || "",
          jobId: selectedJob.id,
          postedDate: void 0,
          employmentType: void 0,
          seniorityLevel: void 0
        };
        const result2 = await generateCoverLetter(jobData, selectedJob, profile, {
          useAI: true,
          tone,
          targetWordCount: 280
        });
        setGeneratedLetter(result2.coverLetter);
        setWarnings(result2.warnings);
        setViewMode("preview");
      } catch (error) {
        console.error("[CoverLetterTab] Error generating cover letter:", error);
        alert("Failed to generate cover letter. Please try again.");
        setViewMode("select-tone");
      }
    };
    const handleCopyToClipboard = () => {
      if (!generatedLetter) return;
      navigator.clipboard.writeText(generatedLetter.content.fullText);
      alert("Cover letter copied to clipboard!");
    };
    const handleSave = () => {
      if (!generatedLetter) return;
      alert("Cover letter saved!");
    };
    const handleExport = async (format) => {
      if (!generatedLetter || !selectedJob) return;
      `CoverLetter_${selectedJob.company}_${selectedJob.jobTitle}`.replace(
        /[^a-zA-Z0-9_-]/g,
        "_"
      );
      const result2 = await exportCoverLetter();
      if (result2.success) {
        alert(`âœ“ Cover letter exported as ${result2.fileName}`);
      } else {
        alert(`âœ— Export failed: ${result2.error}`);
      }
    };
    const handleReset = () => {
      setSelectedJob(null);
      setSelectedTone("professional");
      setGeneratedLetter(null);
      setWarnings([]);
      setViewMode("select-job");
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "hidden"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                padding: isCompact ? "16px" : "20px",
                borderBottom: `1px solid ${backgroundColor}40`,
                backgroundColor: "transparent"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "12px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { size: 24, color: accentColor, strokeWidth: 2 }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h2",
                    {
                      style: {
                        fontSize: isCompact ? "18px" : "20px",
                        fontWeight: "700",
                        margin: "0 0 4px 0",
                        color: textColor
                      },
                      children: "Cover Letter Generator"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "p",
                    {
                      style: {
                        fontSize: "13px",
                        color: `${textColor}99`,
                        margin: 0
                      },
                      children: "AI-powered, ATS-optimized cover letters"
                    }
                  )
                ] })
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, overflow: "auto" }, children: [
            viewMode === "select-job" && /* @__PURE__ */ jsxRuntimeExports.jsx(
              JobSelectView,
              {
                jobAnalyses,
                profile,
                onSelect: handleJobSelect,
                panelWidth
              }
            ),
            viewMode === "select-tone" && selectedJob && /* @__PURE__ */ jsxRuntimeExports.jsx(
              ToneSelectView,
              {
                jobTitle: selectedJob.jobTitle,
                onSelect: handleToneSelect,
                onBack: () => setViewMode("select-job"),
                panelWidth
              }
            ),
            viewMode === "generating" && /* @__PURE__ */ jsxRuntimeExports.jsx(GeneratingView, { tone: selectedTone }),
            viewMode === "preview" && generatedLetter && /* @__PURE__ */ jsxRuntimeExports.jsx(
              PreviewView,
              {
                coverLetter: generatedLetter,
                warnings,
                onCopy: handleCopyToClipboard,
                onSave: handleSave,
                onExport: handleExport,
                onReset: handleReset,
                panelWidth
              }
            )
          ] })
        ]
      }
    );
  }
  function JobSelectView({
    jobAnalyses,
    profile,
    onSelect,
    panelWidth
  }) {
    const textColor = "#1d1d1f";
    const accentColor = "#0077B5";
    const isCompact = panelWidth < 360;
    if (!profile) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "40px 24px", textAlign: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 48, color: "#FF9500" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "18px", fontWeight: "600", margin: "16px 0 8px 0", color: textColor }, children: "Profile Required" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "14px", color: `${textColor}99` }, children: "Please create your professional profile first." })
      ] });
    }
    if (jobAnalyses.length === 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "40px 24px", textAlign: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 48, color: accentColor }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "18px", fontWeight: "600", margin: "16px 0 8px 0", color: textColor }, children: "No Jobs Analyzed" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "14px", color: `${textColor}99` }, children: "Analyze job descriptions first to generate cover letters." })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: isCompact ? "12px" : "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "14px", color: `${textColor}99`, marginBottom: "16px" }, children: "Select a job to generate a tailored cover letter:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: jobAnalyses.map((job) => /* @__PURE__ */ jsxRuntimeExports.jsx(JobCard, { job, onClick: () => onSelect(job) }, job.id)) })
    ] });
  }
  function JobCard({
    job,
    onClick
  }) {
    const backgroundColor = "#FFFFFF";
    const textColor = "#1d1d1f";
    const accentColor = "#0077B5";
    const [isHovered, setIsHovered] = reactExports.useState(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick,
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        style: {
          width: "100%",
          padding: "16px",
          backgroundColor: isHovered ? `${backgroundColor}60` : `${backgroundColor}e6`,
          backdropFilter: "blur(10px)",
          border: `1px solid ${backgroundColor}40`,
          borderRadius: "12px",
          cursor: "pointer",
          textAlign: "left",
          transition: "all 200ms cubic-bezier(0.4, 0, 0.2, 1)",
          transform: isHovered ? "translateY(-2px)" : "translateY(0)",
          boxShadow: isHovered ? "0 4px 12px rgba(0, 0, 0, 0.12)" : "0 2px 8px rgba(0, 0, 0, 0.08)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "h4",
            {
              style: {
                fontSize: "16px",
                fontWeight: "600",
                margin: "0 0 4px 0",
                color: textColor
              },
              children: job.jobTitle
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "p",
            {
              style: {
                fontSize: "14px",
                color: `${textColor}99`,
                margin: "0 0 8px 0"
              },
              children: [
                job.company,
                " â€¢ ",
                job.location || "Remote"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: "6px", flexWrap: "wrap" }, children: job.extractedKeywords.slice(0, 3).map((keyword, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                fontSize: "12px",
                color: accentColor,
                backgroundColor: `${accentColor}15`,
                padding: "4px 8px",
                borderRadius: "4px"
              },
              children: keyword.phrase
            },
            i
          )) })
        ]
      }
    );
  }
  function ToneSelectView({
    jobTitle,
    onSelect,
    onBack,
    panelWidth
  }) {
    const textColor = "#1d1d1f";
    const accentColor = "#0077B5";
    const isCompact = panelWidth < 360;
    const tones = [
      {
        tone: "professional",
        label: "Professional",
        description: "Formal, traditional business tone",
        emoji: "ðŸ‘”",
        bestFor: "Finance, Law, Corporate"
      },
      {
        tone: "enthusiastic",
        label: "Enthusiastic",
        description: "Energetic, passionate tone",
        emoji: "ðŸ”¥",
        bestFor: "Startups, Creative, Sales"
      },
      {
        tone: "confident",
        label: "Technical",
        description: "Detail-oriented, precise tone",
        emoji: "âš™ï¸",
        bestFor: "Engineering, Data, Research"
      },
      {
        tone: "conversational",
        label: "Conversational",
        description: "Friendly, approachable tone",
        emoji: "ðŸ’¬",
        bestFor: "Nonprofits, Education, HR"
      }
    ];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: isCompact ? "12px" : "16px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: onBack,
          style: {
            display: "flex",
            alignItems: "center",
            gap: "6px",
            padding: "8px",
            backgroundColor: "transparent",
            border: "none",
            color: accentColor,
            fontSize: "14px",
            fontWeight: "600",
            cursor: "pointer",
            marginBottom: "16px",
            transition: "all 200ms"
          },
          onMouseEnter: (e) => {
            e.currentTarget.style.transform = "translateX(-4px)";
          },
          onMouseLeave: (e) => {
            e.currentTarget.style.transform = "translateX(0)";
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeft, { size: 16 }),
            "Back to jobs"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "14px", color: `${textColor}99`, marginBottom: "4px" }, children: "Generating for:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "h3",
        {
          style: {
            fontSize: "16px",
            fontWeight: "600",
            color: textColor,
            marginBottom: "16px"
          },
          children: jobTitle
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "14px", color: `${textColor}99`, marginBottom: "16px" }, children: "Choose a tone for your cover letter:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "12px" }, children: tones.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(ToneCard, { ...item, onClick: () => onSelect(item.tone) }, item.tone)) })
    ] });
  }
  function ToneCard({
    tone: _tone,
    label,
    description,
    emoji,
    bestFor,
    onClick
  }) {
    const backgroundColor = "#FFFFFF";
    const textColor = "#1d1d1f";
    const accentColor = "#0077B5";
    const [isHovered, setIsHovered] = reactExports.useState(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick,
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        style: {
          width: "100%",
          padding: "16px",
          backgroundColor: isHovered ? `${backgroundColor}60` : `${backgroundColor}e6`,
          backdropFilter: "blur(10px)",
          border: `1px solid ${backgroundColor}40`,
          borderRadius: "12px",
          cursor: "pointer",
          textAlign: "left",
          transition: "all 200ms cubic-bezier(0.4, 0, 0.2, 1)",
          transform: isHovered ? "scale(1.02)" : "scale(1)",
          boxShadow: isHovered ? "0 4px 12px rgba(0, 0, 0, 0.12)" : "0 2px 8px rgba(0, 0, 0, 0.08)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: "12px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "32px" }, children: emoji }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "h4",
              {
                style: {
                  fontSize: "16px",
                  fontWeight: "600",
                  margin: "0 0 4px 0",
                  color: textColor
                },
                children: label
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "p",
              {
                style: {
                  fontSize: "13px",
                  color: `${textColor}99`,
                  margin: "0 0 8px 0"
                },
                children: description
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "span",
              {
                style: {
                  fontSize: "12px",
                  color: accentColor,
                  fontWeight: "500"
                },
                children: [
                  "Best for: ",
                  bestFor
                ]
              }
            )
          ] })
        ] })
      }
    );
  }
  function GeneratingView({ tone }) {
    const textColor = "#1d1d1f";
    const accentColor = "#0077B5";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          padding: "40px 24px",
          textAlign: "center"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            RefreshCw,
            {
              size: 48,
              color: accentColor,
              className: "animate-spin",
              style: { marginBottom: "16px" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "h3",
            {
              style: {
                fontSize: "20px",
                fontWeight: "700",
                margin: "0 0 8px 0",
                color: textColor
              },
              children: "Generating Your Cover Letter..."
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: "14px", color: `${textColor}99`, margin: "0 0 24px 0" }, children: [
            "Tone: ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: tone })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                fontSize: "13px",
                color: `${textColor}99`,
                lineHeight: "1.6"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { margin: "4px 0" }, children: "âœ¨ Analyzing job requirements" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { margin: "4px 0" }, children: "ðŸŽ¯ Matching your experience" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { margin: "4px 0" }, children: "ðŸ“ Crafting compelling content" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { margin: "4px 0" }, children: "ðŸ” Optimizing for ATS" })
              ]
            }
          )
        ]
      }
    );
  }
  function PreviewView({
    coverLetter,
    warnings,
    onCopy,
    onSave,
    onExport,
    onReset,
    panelWidth
  }) {
    const backgroundColor = "#FFFFFF";
    const textColor = "#1d1d1f";
    const accentColor = "#0077B5";
    const [showWarnings, setShowWarnings] = reactExports.useState(true);
    const isCompact = panelWidth < 360;
    const atsScore = coverLetter.atsOptimization.overallATSScore;
    const scoreColor = atsScore >= 80 ? "#4CAF50" : atsScore >= 65 ? "#2196F3" : atsScore >= 50 ? "#FF9500" : "#F44336";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: isCompact ? "12px" : "16px" }, children: [
      warnings.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            backgroundColor: "#FFF9E6",
            border: "1px solid #FFD600",
            borderRadius: "12px",
            padding: "16px",
            marginBottom: "16px"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => setShowWarnings(!showWarnings),
                style: {
                  width: "100%",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "space-between",
                  background: "none",
                  border: "none",
                  padding: 0,
                  cursor: "pointer",
                  marginBottom: showWarnings ? "12px" : 0
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 16, color: "#FF9500" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { style: { fontSize: "14px", fontWeight: "600", margin: 0, color: textColor }, children: [
                      "Warnings (",
                      warnings.length,
                      ")"
                    ] })
                  ] }),
                  showWarnings ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { size: 16, color: `${textColor}99` }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { size: 16, color: `${textColor}99` })
                ]
              }
            ),
            showWarnings && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: warnings.map((warning, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "12px", color: `${textColor}99`, lineHeight: "1.5" }, children: [
              "âš ï¸ ",
              warning
            ] }, i)) })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            backgroundColor: `${backgroundColor}e6`,
            backdropFilter: "blur(10px)",
            borderRadius: "12px",
            padding: "16px",
            marginBottom: "16px",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { style: { fontSize: "14px", fontWeight: "600", margin: "0 0 4px 0", color: textColor }, children: "ATS Score" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: "12px", color: `${textColor}99`, margin: 0 }, children: [
                coverLetter.content.wordCount,
                " words â€¢ ",
                coverLetter.qualityScore.tone.score > 70 ? "professional" : "conversational",
                " tone"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  fontSize: "32px",
                  fontWeight: "700",
                  color: scoreColor
                },
                children: atsScore
              }
            )
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            backgroundColor: `${backgroundColor}e6`,
            backdropFilter: "blur(10px)",
            borderRadius: "12px",
            padding: "16px",
            marginBottom: "16px",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.08)"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "h4",
              {
                style: {
                  fontSize: "14px",
                  fontWeight: "600",
                  margin: "0 0 12px 0",
                  color: textColor
                },
                children: "Cover Letter"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "pre",
              {
                style: {
                  fontFamily: '"Courier New", monospace',
                  fontSize: "12px",
                  lineHeight: "1.6",
                  color: textColor,
                  whiteSpace: "pre-wrap",
                  wordWrap: "break-word",
                  margin: 0
                },
                children: coverLetter.content.fullText
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "8px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => onExport("pdf"),
            style: {
              flex: 1,
              padding: "12px",
              backgroundColor: "transparent",
              color: accentColor,
              border: `1.5px solid ${accentColor}`,
              borderRadius: "10px",
              fontSize: "13px",
              fontWeight: "600",
              cursor: "pointer",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "6px",
              transition: "all 200ms"
            },
            onMouseEnter: (e) => {
              e.currentTarget.style.backgroundColor = `${accentColor}10`;
              e.currentTarget.style.transform = "translateY(-2px)";
            },
            onMouseLeave: (e) => {
              e.currentTarget.style.backgroundColor = "transparent";
              e.currentTarget.style.transform = "translateY(0)";
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { size: 14 }),
              "PDF"
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => onExport("docx"),
            style: {
              flex: 1,
              padding: "12px",
              backgroundColor: "transparent",
              color: accentColor,
              border: `1.5px solid ${accentColor}`,
              borderRadius: "10px",
              fontSize: "13px",
              fontWeight: "600",
              cursor: "pointer",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "6px",
              transition: "all 200ms"
            },
            onMouseEnter: (e) => {
              e.currentTarget.style.backgroundColor = `${accentColor}10`;
              e.currentTarget.style.transform = "translateY(-2px)";
            },
            onMouseLeave: (e) => {
              e.currentTarget.style.backgroundColor = "transparent";
              e.currentTarget.style.transform = "translateY(0)";
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { size: 14 }),
              "DOCX"
            ]
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: onCopy,
            style: {
              flex: 1,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "6px",
              padding: "12px",
              backgroundColor: accentColor,
              color: "#FFFFFF",
              border: "none",
              borderRadius: "8px",
              fontSize: "14px",
              fontWeight: "600",
              cursor: "pointer",
              transition: "all 200ms"
            },
            onMouseEnter: (e) => {
              e.currentTarget.style.transform = "scale(1.02)";
              e.currentTarget.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.15)";
            },
            onMouseLeave: (e) => {
              e.currentTarget.style.transform = "scale(1)";
              e.currentTarget.style.boxShadow = "none";
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 16 }),
              "Copy"
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: onSave,
            style: {
              flex: 1,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "6px",
              padding: "12px",
              backgroundColor: `${backgroundColor}40`,
              color: textColor,
              border: `1px solid ${backgroundColor}60`,
              borderRadius: "8px",
              fontSize: "14px",
              fontWeight: "600",
              cursor: "pointer",
              transition: "all 200ms"
            },
            onMouseEnter: (e) => {
              e.currentTarget.style.backgroundColor = `${backgroundColor}60`;
            },
            onMouseLeave: (e) => {
              e.currentTarget.style.backgroundColor = `${backgroundColor}40`;
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Save, { size: 16 }),
              "Save"
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: onReset,
            style: {
              padding: "12px",
              backgroundColor: `${backgroundColor}40`,
              color: textColor,
              border: `1px solid ${backgroundColor}60`,
              borderRadius: "8px",
              fontSize: "14px",
              fontWeight: "600",
              cursor: "pointer",
              transition: "all 200ms"
            },
            onMouseEnter: (e) => {
              e.currentTarget.style.backgroundColor = `${backgroundColor}60`;
            },
            onMouseLeave: (e) => {
              e.currentTarget.style.backgroundColor = `${backgroundColor}40`;
            },
            children: "New"
          }
        )
      ] })
    ] });
  }
  content;
  class ErrorBoundary extends reactExports.Component {
    constructor(props) {
      super(props);
      __publicField(this, "handleReset", () => {
        this.setState({
          hasError: false,
          error: null,
          errorInfo: null
        });
        if (this.props.onReset) {
          this.props.onReset();
        }
      });
      this.state = {
        hasError: false,
        error: null,
        errorInfo: null
      };
    }
    static getDerivedStateFromError(error) {
      return { hasError: true, error };
    }
    componentDidCatch(error, errorInfo) {
      console.error("[ErrorBoundary] Component error caught:", error);
      console.error("[ErrorBoundary] Component stack:", errorInfo.componentStack);
      this.setState({
        error,
        errorInfo
      });
    }
    render() {
      if (this.state.hasError) {
        const {
          fallbackTitle = "Something went wrong",
          fallbackMessage = "An error occurred while rendering this component."
        } = this.props;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "center",
              padding: "40px 20px",
              textAlign: "center",
              backgroundColor: "#FFFFFF",
              minHeight: "300px"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TriangleAlert,
                {
                  size: 48,
                  color: "#FF3B30",
                  strokeWidth: 2,
                  style: { marginBottom: "16px" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "h2",
                {
                  style: {
                    fontSize: "18px",
                    fontWeight: "600",
                    color: "#1d1d1f",
                    marginBottom: "8px",
                    margin: 0
                  },
                  children: fallbackTitle
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  style: {
                    fontSize: "14px",
                    color: "#6e6e73",
                    marginBottom: "24px",
                    maxWidth: "400px",
                    margin: "8px 0 24px 0",
                    lineHeight: "1.5"
                  },
                  children: fallbackMessage
                }
              ),
              false,
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: this.handleReset,
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: "8px",
                    padding: "10px 20px",
                    backgroundColor: "#0077B5",
                    color: "#FFFFFF",
                    border: "none",
                    borderRadius: "8px",
                    fontSize: "14px",
                    fontWeight: "600",
                    cursor: "pointer",
                    transition: "background-color 150ms"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.backgroundColor = "#005885";
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "#0077B5";
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 16 }),
                    "Try Again"
                  ]
                }
              )
            ]
          }
        );
      }
      return this.props.children;
    }
  }
  content;
  const FeedTabWithErrorBoundary = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    ErrorBoundary,
    {
      fallbackTitle: "Feed Error",
      fallbackMessage: "Something went wrong loading your feed. This could be due to corrupted data or a network issue.",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(FeedTab, { ...props })
    }
  );
  const TabContent = {
    feed: FeedTabWithErrorBoundary,
    profile: ProfileTab,
    company: CompanyTab,
    watchlist: WatchlistTab,
    resume: ResumeTab,
    jobs: JobsTab,
    "profile-builder": ProfileBuilderTab,
    "job-analyzer": JobAnalyzerTab,
    "resume-generator": ResumeGeneratorTab,
    "cover-letter": CoverLetterTab,
    onboarding: OnboardingTab,
    settings: SettingsTab
    // Other tabs will use placeholder for now
  };
  const TabPlaceholder = ({ title }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
    padding: "24px",
    textAlign: "center",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    height: "100%"
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: {
      fontSize: "18px",
      fontWeight: "600",
      margin: "0 0 8px 0",
      color: "#1d1d1f"
    }, children: title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: {
      fontSize: "14px",
      color: "#6e6e73",
      margin: 0
    }, children: "Coming soon..." })
  ] });
  function TabNavigation({ activeTab, onTabChange, panelWidth = 400 }) {
    const pageContext = usePageContext();
    const { getCountForTab } = useBadgeCounts();
    const [isFirstRun, setIsFirstRun] = React.useState(false);
    reactExports.useEffect(() => {
      log$1.info(LogCategory.UI, "TabNavigation mounted", {
        activeTab,
        panelWidth,
        pageContext: pageContext.type
      });
      return () => {
        log$1.debug(LogCategory.UI, "TabNavigation unmounting");
      };
    }, []);
    reactExports.useEffect(() => {
      async function checkOnboarding() {
        log$1.debug(LogCategory.UI, "Checking onboarding status in TabNavigation");
        const { isOnboardingComplete: isOnboardingComplete2 } = await Promise.resolve().then(() => storage);
        const completed = await isOnboardingComplete2();
        log$1.info(LogCategory.UI, "Onboarding status retrieved", { completed, isFirstRun: !completed });
        setIsFirstRun(!completed);
      }
      checkOnboarding();
    }, []);
    const visibleTabs = reactExports.useMemo(() => {
      const tabs = getVisibleTabs(pageContext.type, isFirstRun);
      console.log("[Uproot] Visible tabs:", {
        pageType: pageContext.type,
        isProfilePage: pageContext.isProfilePage,
        tabIds: tabs.map((t) => t.id)
      });
      return tabs;
    }, [pageContext.type, isFirstRun, pageContext.isProfilePage]);
    const tabsWithBadges = reactExports.useMemo(() => {
      return visibleTabs.map((tab) => ({
        ...tab,
        badgeCount: getCountForTab(tab.id)
      }));
    }, [visibleTabs, getCountForTab]);
    useKeyboardShortcuts({
      activeTab,
      visibleTabs: tabsWithBadges.map((t) => t.id),
      onTabChange,
      enabled: true
    });
    reactExports.useEffect(() => {
      const isActiveTabVisible = tabsWithBadges.some((tab) => tab.id === activeTab);
      if (!isActiveTabVisible && tabsWithBadges.length > 0) {
        log$1.action("Auto-switching to visible tab", {
          from: activeTab,
          to: tabsWithBadges[0].id,
          reason: "active-tab-hidden",
          component: "TabNavigation"
        });
        onTabChange(tabsWithBadges[0].id);
      }
    }, [activeTab, tabsWithBadges, onTabChange]);
    const isCompact = panelWidth < 400;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          width: "100%"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              role: "tabpanel",
              id: `panel-${activeTab}`,
              "aria-labelledby": `tab-${activeTab}`,
              style: {
                flex: 1,
                overflow: "auto",
                backgroundColor: "#FFFFFF"
              },
              children: TabContent[activeTab] ? React.createElement(TabContent[activeTab], { panelWidth }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TabPlaceholder, { title: activeTab.charAt(0).toUpperCase() + activeTab.slice(1) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              role: "tablist",
              "aria-label": "Main navigation",
              "aria-orientation": "horizontal",
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "space-around",
                gap: isCompact ? "2px" : tabsWithBadges.length >= 7 ? "2px" : "4px",
                padding: "8px",
                borderTop: "1px solid rgba(0, 0, 0, 0.08)",
                backgroundColor: "rgba(255, 255, 255, 0.9)",
                backdropFilter: "blur(10px)",
                WebkitBackdropFilter: "blur(10px)",
                minHeight: "60px",
                position: "relative"
              },
              children: tabsWithBadges.map((tab) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                TabButton$1,
                {
                  tab,
                  isActive: activeTab === tab.id,
                  onClick: () => {
                    const tabConfig = TAB_CONFIGS.find((tc) => tc.id === tab.id);
                    log$1.action("Tab clicked in TabNavigation", {
                      tabId: tab.id,
                      tabLabel: tabConfig?.label ?? tab.id,
                      fromTab: activeTab
                    });
                    onTabChange(tab.id);
                  },
                  badgeCount: tab.badgeCount,
                  compact: isCompact,
                  totalVisibleTabs: tabsWithBadges.length
                },
                tab.id
              ))
            }
          )
        ]
      }
    );
  }
  content;
  function FloatingPanel() {
    const [activeTab, setActiveTab] = reactExports.useState("feed");
    const [panelSize, setPanelSize] = reactExports.useState({ width: 400, height: 500 });
    const [isMinimized, setIsMinimized] = reactExports.useState(false);
    const [panelPosition, setPanelPosition] = reactExports.useState({ x: 100, y: 100 });
    const [shouldAnimate, setShouldAnimate] = reactExports.useState(false);
    const rndRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      log$1.info(LogCategory.UI, "FloatingPanel mounted", {
        activeTab,
        panelSize,
        panelPosition,
        isMinimized
      });
      return () => {
        log$1.debug(LogCategory.UI, "FloatingPanel unmounting");
      };
    }, []);
    reactExports.useEffect(() => {
      async function checkFirstRun() {
        try {
          log$1.debug(LogCategory.UI, "Checking onboarding status");
          const { isOnboardingComplete: isOnboardingComplete2 } = await Promise.resolve().then(() => storage);
          const completed = await isOnboardingComplete2();
          log$1.info(LogCategory.UI, "Onboarding status checked", { completed });
          if (!completed) {
            log$1.action("Setting active tab to onboarding", { reason: "first-run" });
            setActiveTab("onboarding");
          }
        } catch (error) {
          if (error?.message?.includes("Extension context invalidated")) {
            return;
          }
          log$1.error(LogCategory.UI, "Failed to check onboarding status", error);
        }
      }
      checkFirstRun();
    }, []);
    const handleClose = () => {
      log$1.action("Close button clicked", { component: "FloatingPanel" });
      const container = document.getElementById("linkedin-extension-root");
      if (container) {
        container.style.display = "none";
        log$1.debug(LogCategory.UI, "FloatingPanel hidden");
      }
    };
    const handleMinimize = () => {
      const willBeMinimized = !isMinimized;
      log$1.action("Minimize/Maximize button clicked", {
        component: "FloatingPanel",
        willBeMinimized,
        currentPosition: panelPosition
      });
      if (!willBeMinimized && rndRef.current) {
        const viewportHeight = window.innerHeight;
        const fullPanelHeight = panelSize.height;
        const currentY = panelPosition.y;
        const currentBottomY = currentY + 60;
        const targetY = currentBottomY - fullPanelHeight;
        const newY = Math.max(20, Math.min(targetY, viewportHeight - fullPanelHeight - 40));
        const shouldReposition = Math.abs(newY - currentY) > 5;
        if (shouldReposition) {
          log$1.action("Repositioning panel on maximize", {
            reason: targetY < 20 ? "would go above viewport" : targetY > viewportHeight - fullPanelHeight - 40 ? "would go below viewport" : "normal expansion",
            currentY,
            currentBottomY,
            targetY,
            newY,
            adjustment: newY - currentY
          });
          setShouldAnimate(true);
          setTimeout(() => {
            rndRef.current?.updatePosition({ x: panelPosition.x, y: newY });
            setPanelPosition({ x: panelPosition.x, y: newY });
            console.log("[Uproot] Repositioned on maximize:", { from: currentY, to: newY, reason: targetY < 20 ? "too high" : "too low" });
            setTimeout(() => setShouldAnimate(false), 600);
          }, 50);
        } else {
          log$1.debug(LogCategory.UI, "Skipping reposition - adjustment too small", {
            currentY,
            targetY,
            difference: Math.abs(newY - currentY)
          });
        }
      }
      setIsMinimized(willBeMinimized);
    };
    reactExports.useEffect(() => {
      if (!isMinimized || !rndRef.current) return;
      const checkPosition = () => {
        const viewportHeight = window.innerHeight;
        const panelHeight = 60;
        const currentY = panelPosition.y;
        const maxAllowedY = viewportHeight - panelHeight - 20;
        if (currentY > maxAllowedY) {
          const newY = Math.max(20, maxAllowedY);
          setShouldAnimate(true);
          rndRef.current?.updatePosition({ x: panelPosition.x, y: newY });
          setPanelPosition({ x: panelPosition.x, y: newY });
          console.log("[Uproot] Auto-repositioned minimized panel:", { from: currentY, to: newY });
          setTimeout(() => setShouldAnimate(false), 500);
        }
      };
      checkPosition();
      window.addEventListener("resize", checkPosition);
      return () => window.removeEventListener("resize", checkPosition);
    }, [isMinimized, panelPosition.y]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Rnd,
      {
        ref: rndRef,
        position: panelPosition,
        size: isMinimized ? { width: panelSize.width, height: 60 } : panelSize,
        minWidth: 350,
        minHeight: isMinimized ? 60 : 400,
        maxWidth: 800,
        maxHeight: 900,
        bounds: "window",
        dragHandleClassName: "uproot-drag-handle",
        enableResizing: isMinimized ? false : {
          top: true,
          right: true,
          bottom: true,
          left: true,
          topRight: true,
          bottomRight: true,
          bottomLeft: true,
          topLeft: true
        },
        onDrag: (_e, data) => {
          setPanelPosition({ x: data.x, y: data.y });
        },
        onDragStop: (_e, data) => {
          log$1.action("Panel dragged", {
            from: panelPosition,
            to: { x: data.x, y: data.y },
            component: "FloatingPanel"
          });
          if (isMinimized) {
            const viewportHeight = window.innerHeight;
            const panelHeight = 60;
            const bottomThreshold = viewportHeight - panelHeight - 20;
            if (data.y > bottomThreshold) {
              const newY = Math.max(20, bottomThreshold);
              setShouldAnimate(true);
              setTimeout(() => {
                rndRef.current?.updatePosition({ x: data.x, y: newY });
                setPanelPosition({ x: data.x, y: newY });
                console.log("[Uproot] Repositioned after drag to bottom:", { from: data.y, to: newY });
                setTimeout(() => setShouldAnimate(false), 500);
              }, 50);
              return;
            }
          }
          setPanelPosition({ x: data.x, y: data.y });
        },
        onResize: (_e, direction, ref, _delta, position) => {
          if (!isMinimized) {
            const newSize = {
              width: parseInt(ref.style.width),
              height: parseInt(ref.style.height)
            };
            const clampedPosition = {
              x: Math.max(0, Math.min(position.x, window.innerWidth - newSize.width)),
              y: Math.max(0, Math.min(position.y, window.innerHeight - newSize.height))
            };
            log$1.action("Panel resized", {
              from: panelSize,
              to: newSize,
              direction,
              component: "FloatingPanel"
            });
            setPanelSize(newSize);
            setPanelPosition(clampedPosition);
          }
        },
        style: {
          zIndex: 999999,
          // Bouncy spring animation - only when programmatically repositioning, not during drag
          transition: shouldAnimate ? "all 500ms cubic-bezier(0.68, -0.55, 0.265, 1.55)" : "none"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              width: "100%",
              height: isMinimized ? "60px" : "100%",
              backgroundColor: "rgba(255, 255, 255, 0.95)",
              borderRadius: "16px",
              boxShadow: "0 20px 60px rgba(0, 0, 0, 0.3)",
              border: "1px solid rgba(0, 0, 0, 0.1)",
              display: "flex",
              flexDirection: "column",
              overflow: "hidden",
              fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
              transition: "height 300ms cubic-bezier(0.4, 0.0, 0.2, 1)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: "uproot-drag-handle",
                  style: {
                    padding: "16px",
                    borderBottom: isMinimized ? "none" : "1px solid rgba(0, 0, 0, 0.08)",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "space-between",
                    cursor: "move",
                    backgroundColor: "rgba(255, 255, 255, 0.9)",
                    backdropFilter: "blur(10px)",
                    WebkitBackdropFilter: "blur(10px)",
                    position: "relative",
                    zIndex: 10
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "12px" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          style: {
                            width: "28px",
                            height: "28px",
                            borderRadius: "8px",
                            background: "linear-gradient(135deg, #0077B5 0%, #00A0DC 100%)",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            color: "white",
                            fontSize: "12px",
                            fontWeight: "bold"
                          },
                          children: "UP"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "h2",
                        {
                          style: {
                            fontSize: "14px",
                            fontWeight: "600",
                            margin: 0,
                            color: "#1d1d1f"
                          },
                          children: "Uproot"
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "4px" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          onClick: handleMinimize,
                          style: {
                            background: "none",
                            border: "none",
                            cursor: "pointer",
                            padding: "6px",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            borderRadius: "6px",
                            transition: "background-color 150ms"
                          },
                          onMouseEnter: (e) => {
                            e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.05)";
                          },
                          onMouseLeave: (e) => {
                            e.currentTarget.style.backgroundColor = "transparent";
                          },
                          title: isMinimized ? "Maximize" : "Minimize",
                          children: isMinimized ? /* @__PURE__ */ jsxRuntimeExports.jsx(Maximize2, { size: 14, color: "#6e6e73" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Minimize2, { size: 14, color: "#6e6e73" })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          onClick: handleClose,
                          style: {
                            background: "none",
                            border: "none",
                            cursor: "pointer",
                            padding: "6px",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            borderRadius: "6px",
                            transition: "background-color 150ms"
                          },
                          onMouseEnter: (e) => {
                            e.currentTarget.style.backgroundColor = "rgba(255, 59, 48, 0.1)";
                          },
                          onMouseLeave: (e) => {
                            e.currentTarget.style.backgroundColor = "transparent";
                          },
                          title: "Close",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 14, color: "#FF3B30" })
                        }
                      )
                    ] })
                  ]
                }
              ),
              !isMinimized && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    flex: 1,
                    display: "flex",
                    flexDirection: "column",
                    overflow: "hidden",
                    position: "relative",
                    zIndex: 1
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabNavigation,
                    {
                      activeTab,
                      onTabChange: (tab) => {
                        log$1.action("Tab changed", { from: activeTab, to: tab, component: "FloatingPanel" });
                        setActiveTab(tab);
                      },
                      panelWidth: panelSize.width
                    }
                  )
                }
              )
            ]
          }
        )
      }
    );
  }
  content;
  function getPanelStyles(panelSize, isMinimized) {
    return `
    @keyframes minimizePanel {
      0% {
        height: ${panelSize.height}px;
        opacity: 1;
      }
      100% {
        height: 0;
        opacity: 0;
      }
    }

    @keyframes maximizePanel {
      0% {
        height: 0;
        opacity: 0;
      }
      100% {
        height: ${panelSize.height}px;
        opacity: 1;
      }
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .minimal-panel-container {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .minimal-panel-header {
      background: linear-gradient(135deg, #0077B5 0%, #005582 100%);
      color: white;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: move !important;
      user-select: none !important;
      position: relative;
      z-index: 1;
    }

    .minimal-panel-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 600;
    }

    .minimal-panel-controls {
      display: flex;
      gap: 8px;
    }

    .minimal-panel-button {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 6px;
      padding: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }

    .minimal-panel-button:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .minimal-panel-content {
      flex: 1;
      overflow-y: auto;
      ${isMinimized ? "display: none;" : ""}
    }

    /* Resize handle styles - Override react-rnd defaults */
    .react-resizable-handle {
      position: absolute !important;
      z-index: 2147483648 !important;
      background-color: transparent !important;
      pointer-events: auto !important;
      touch-action: none !important;
    }

    /* Corner handles - 20x20px clickable areas */
    .react-resizable-handle-se {
      bottom: 0 !important;
      right: 0 !important;
      width: 20px !important;
      height: 20px !important;
      cursor: se-resize !important;
    }

    .react-resizable-handle-sw {
      bottom: 0 !important;
      left: 0 !important;
      width: 20px !important;
      height: 20px !important;
      cursor: sw-resize !important;
    }

    .react-resizable-handle-ne {
      top: 0 !important;
      right: 0 !important;
      width: 20px !important;
      height: 20px !important;
      cursor: ne-resize !important;
    }

    .react-resizable-handle-nw {
      top: 0 !important;
      left: 0 !important;
      width: 20px !important;
      height: 20px !important;
      cursor: nw-resize !important;
    }

    /* Edge handles - 12px wide strips for better clickability */
    .react-resizable-handle-e {
      right: 0 !important;
      top: 0 !important;
      bottom: 0 !important;
      width: 12px !important;
      cursor: e-resize !important;
    }

    .react-resizable-handle-w {
      left: 0 !important;
      top: 0 !important;
      bottom: 0 !important;
      width: 12px !important;
      cursor: w-resize !important;
    }

    .react-resizable-handle-n {
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      height: 12px !important;
      cursor: n-resize !important;
    }

    .react-resizable-handle-s {
      bottom: 0 !important;
      left: 0 !important;
      right: 0 !important;
      height: 12px !important;
      cursor: s-resize !important;
    }

    /* Visual indicators for corner handles */
    .react-resizable-handle-se::after,
    .react-resizable-handle-sw::after,
    .react-resizable-handle-ne::after,
    .react-resizable-handle-nw::after {
      content: '';
      position: absolute;
      width: 10px;
      height: 10px;
      border-style: solid;
      border-color: rgba(0, 119, 181, 0.4);
      border-width: 2px;
      filter: drop-shadow(0 0 2px rgba(0, 119, 181, 0.6));
    }

    .react-resizable-handle-se::after {
      bottom: 4px;
      right: 4px;
      border-top: none;
      border-left: none;
    }

    .react-resizable-handle-sw::after {
      bottom: 4px;
      left: 4px;
      border-top: none;
      border-right: none;
    }

    .react-resizable-handle-ne::after {
      top: 4px;
      right: 4px;
      border-bottom: none;
      border-left: none;
    }

    .react-resizable-handle-nw::after {
      top: 4px;
      left: 4px;
      border-bottom: none;
      border-right: none;
    }

    /* Shared styles for both Job Description and Questions sections */
    .generate-section-container {
      padding: 20px;
    }

    .generate-section-header {
      margin-bottom: 20px;
    }

    .generate-section-title-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .generate-section-title {
      fontSize: 16px;
      font-weight: 600;
      color: #1d1d1f;
      margin: 0;
    }

    .generate-section-description {
      font-size: 13px;
      color: #6e6e73;
      margin: 0;
      line-height: 1.5;
    }

    .generate-form-group {
      margin-bottom: 16px;
    }

    .generate-label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      color: #1d1d1f;
      margin-bottom: 8px;
    }

    .generate-textarea,
    .generate-input {
      width: 100%;
      padding: 12px;
      border: 1px solid #d2d2d7;
      border-radius: 8px;
      fontSize: 13px;
      font-family: inherit;
      box-sizing: border-box;
      transition: border-color 0.2s;
    }

    .generate-textarea:focus,
    .generate-input:focus {
      outline: none;
      border-color: #0077B5;
    }

    .generate-textarea {
      min-height: 120px;
      resize: vertical;
    }

    .generate-button-primary {
      width: 100%;
      padding: 12px 16px;
      background: linear-gradient(135deg, #0077B5 0%, #005582 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: opacity 0.2s;
    }

    .generate-button-primary:hover:not(:disabled) {
      opacity: 0.9;
    }

    .generate-button-primary:disabled {
      background: #d2d2d7;
      cursor: not-allowed;
    }

    .generate-answer-box {
      padding: 16px;
      background-color: #f5f5f7;
      border-radius: 8px;
      margin-bottom: 16px;
    }

    .generate-answer-title {
      font-size: 14px;
      font-weight: 600;
      color: #1d1d1f;
      margin: 0 0 12px 0;
    }

    .generate-answer-text {
      font-size: 13px;
      color: #1d1d1f;
      line-height: 1.6;
      margin: 0;
      white-space: pre-wrap;
    }

    .generate-button-group {
      display: flex;
      gap: 12px;
    }

    .generate-button-secondary {
      flex: 1;
      padding: 12px 16px;
      background: white;
      color: #0077B5;
      border: 1px solid #0077B5;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .generate-button-secondary:hover {
      background-color: #f5f5f7;
    }

    .generate-error-box {
      padding: 12px 16px;
      background-color: #fef2f2;
      border: 1px solid #fecaca;
      border-radius: 8px;
      margin-bottom: 16px;
    }

    .generate-error-text {
      font-size: 13px;
      color: #dc2626;
      margin: 0;
    }

    /* Fill Form Button */
    .fill-form-button {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: rgba(255, 255, 255, 0.95);
      color: #0077B5;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .fill-form-button:hover:not(:disabled) {
      background: white;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .fill-form-button:disabled {
      background: rgba(255, 255, 255, 0.5);
      color: rgba(0, 119, 181, 0.5);
      cursor: not-allowed;
    }

    .fill-form-text {
      display: inline-block;
    }

    .fill-form-spinner {
      width: 14px;
      height: 14px;
      border: 2px solid #0077B5;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
  `;
  }
  content;
  var FormFieldType = /* @__PURE__ */ ((FormFieldType2) => {
    FormFieldType2["FIRST_NAME"] = "firstName";
    FormFieldType2["LAST_NAME"] = "lastName";
    FormFieldType2["FULL_NAME"] = "fullName";
    FormFieldType2["EMAIL"] = "email";
    FormFieldType2["PHONE"] = "phone";
    FormFieldType2["LOCATION"] = "location";
    FormFieldType2["CITY"] = "city";
    FormFieldType2["STATE"] = "state";
    FormFieldType2["ZIP_CODE"] = "zipCode";
    FormFieldType2["COUNTRY"] = "country";
    FormFieldType2["BIRTHDAY"] = "birthday";
    FormFieldType2["LINKEDIN_URL"] = "linkedinUrl";
    FormFieldType2["GITHUB_URL"] = "githubUrl";
    FormFieldType2["PORTFOLIO_URL"] = "portfolioUrl";
    FormFieldType2["WEBSITE"] = "website";
    FormFieldType2["JOB_TITLE"] = "jobTitle";
    FormFieldType2["COMPANY"] = "company";
    FormFieldType2["YEARS_EXPERIENCE"] = "yearsExperience";
    FormFieldType2["SKILLS"] = "skills";
    FormFieldType2["RESUME_UPLOAD"] = "resumeUpload";
    FormFieldType2["COVER_LETTER_UPLOAD"] = "coverLetterUpload";
    FormFieldType2["COVER_LETTER_TEXT"] = "coverLetterText";
    FormFieldType2["WORK_AUTHORIZATION"] = "workAuthorization";
    FormFieldType2["VETERAN_STATUS"] = "veteranStatus";
    FormFieldType2["DISABILITY_STATUS"] = "disabilityStatus";
    FormFieldType2["GENDER"] = "gender";
    FormFieldType2["RACE_ETHNICITY"] = "raceEthnicity";
    FormFieldType2["QUESTION"] = "question";
    FormFieldType2["REFERRAL"] = "referral";
    FormFieldType2["UNKNOWN"] = "unknown";
    return FormFieldType2;
  })(FormFieldType || {});
  class FormDetector {
    constructor() {
      __publicField(this, "observers", []);
    }
    /**
     * Detect all fillable fields on current page
     */
    detectFields() {
      const fields = [];
      const atsSystem = this.detectAtsSystem();
      const inputs = document.querySelectorAll(
        'input:not([type="hidden"]):not([type="submit"]):not([type="button"]), textarea, select'
      );
      console.log(`[FormDetector] Found ${inputs.length} potential fields`);
      inputs.forEach((input) => {
        const detected = this.classifyField(input, atsSystem);
        if (detected.type !== "unknown" || detected.confidence > 0.3) {
          fields.push(detected);
        }
      });
      const isJobApplication = this.isJobApplicationPage(fields);
      const overallConfidence = this.calculateOverallConfidence(fields);
      return {
        fields,
        atsSystem,
        isJobApplication,
        confidence: overallConfidence,
        timestamp: Date.now(),
        url: window.location.href
      };
    }
    /**
     * Classify a single field using multi-heuristic approach
     */
    classifyField(element, atsSystem) {
      const name = element.getAttribute("name")?.toLowerCase() || "";
      const id = element.id?.toLowerCase() || "";
      const placeholder = element.placeholder?.toLowerCase() || "";
      const type = element.type?.toLowerCase() || "";
      const ariaLabel = element.getAttribute("aria-label")?.toLowerCase() || "";
      const autocomplete = element.getAttribute("autocomplete")?.toLowerCase() || "";
      const labelText = this.getFieldLabel(element);
      const label = labelText?.toLowerCase() || "";
      const hints = `${name} ${id} ${placeholder} ${label} ${ariaLabel} ${autocomplete} ${type}`.toLowerCase();
      const classification = this.matchFieldType(hints, name, id, type, atsSystem);
      return {
        element,
        type: classification.type,
        label: labelText,
        placeholder: element.placeholder || null,
        confidence: classification.confidence,
        atsSystem,
        debugInfo: {
          name,
          id,
          hints,
          matchedPattern: classification.matchedPattern
        }
      };
    }
    /**
     * Match field type using pattern matching
     */
    matchFieldType(hints, name, id, type, atsSystem) {
      const patterns = [
        // Names
        {
          type: "firstName",
          patterns: [
            /\bfirst[\s_-]?name\b/,
            /\bgiven[\s_-]?name\b/,
            /\bfname\b/,
            /\bforename\b/
          ],
          weight: 1
        },
        {
          type: "lastName",
          patterns: [
            /\blast[\s_-]?name\b/,
            /\bsurname\b/,
            /\bfamily[\s_-]?name\b/,
            /\blname\b/
          ],
          weight: 1
        },
        {
          type: "fullName",
          patterns: [
            /\bfull[\s_-]?name\b/,
            /\byour[\s_-]?name\b/,
            /\bname\b(?!.*first|.*last)/
          ],
          weight: 0.8
        },
        // Contact
        {
          type: "email",
          patterns: [/\bemail\b/, /\be-?mail\b/, /autocomplete.*email/],
          weight: 1
        },
        {
          type: "phone",
          patterns: [
            /\bphone\b/,
            /\bmobile\b/,
            /\btelephone\b/,
            /\btel\b/,
            /autocomplete.*tel/
          ],
          weight: 1
        },
        // Location
        {
          type: "location",
          patterns: [
            /\blocation\b/,
            /\baddress\b/,
            /\bwhere.*live\b/,
            /\bcurrent.*location\b/
          ],
          weight: 0.9
        },
        {
          type: "city",
          patterns: [/\bcity\b/, /\btown\b/, /autocomplete.*address-level2/],
          weight: 0.95
        },
        {
          type: "state",
          patterns: [
            /\bstate\b/,
            /\bprovince\b/,
            /\bregion\b/,
            /autocomplete.*address-level1/
          ],
          weight: 0.95
        },
        {
          type: "zipCode",
          patterns: [
            /\bzip\b/,
            /\bpostal\b/,
            /\bpostcode\b/,
            /autocomplete.*postal-code/
          ],
          weight: 0.95
        },
        {
          type: "country",
          patterns: [/\bcountry\b/, /autocomplete.*country/],
          weight: 0.95
        },
        // Personal Info
        {
          type: "birthday",
          patterns: [
            /\bbirthday\b/,
            /\bdate.*of.*birth\b/,
            /\bdob\b/,
            /\bbirth.*date\b/,
            /autocomplete.*bday/
          ],
          weight: 1
        },
        // URLs
        {
          type: "linkedinUrl",
          patterns: [
            /\blinkedin\b/,
            /\blinked.*in\b/,
            /\blinkedin.*profile\b/,
            /\blinkedin.*url\b/
          ],
          weight: 1
        },
        {
          type: "githubUrl",
          patterns: [/\bgithub\b/, /\bgithub.*profile\b/, /\bgithub.*url\b/],
          weight: 1
        },
        {
          type: "portfolioUrl",
          patterns: [
            /\bportfolio\b/,
            /\bpersonal.*website\b/,
            /\bpersonal.*site\b/
          ],
          weight: 0.9
        },
        {
          type: "website",
          patterns: [/\bwebsite\b/, /\burl\b/, /\bhomepage\b/],
          weight: 0.7
        },
        // Skills & Documents
        {
          type: "skills",
          patterns: [
            /\bskills?\b/,
            /\bproficienc/,
            /\btechnolog/,
            /\bexpertise\b/,
            /\bcompetenc/
          ],
          weight: 0.9
        },
        {
          type: "resumeUpload",
          patterns: [
            /\bresume\b/,
            /\bcv\b/,
            /\bcurriculum.*vitae\b/,
            /\bupload.*resume\b/
          ],
          weight: 1
        },
        {
          type: "coverLetterUpload",
          patterns: [/\bcover.*letter\b/, /\bupload.*cover\b/],
          weight: 1
        },
        {
          type: "coverLetterText",
          patterns: [
            /\bcover.*letter\b/,
            /\bwhy.*want.*to.*work\b/,
            /\bwhy.*interested\b/
          ],
          weight: 0.85
        },
        // EEO / Legal
        {
          type: "workAuthorization",
          patterns: [
            /\bwork.*authorization\b/,
            /\bauthorized.*to.*work\b/,
            /\bvisa.*status\b/,
            /\bwork.*permit\b/,
            /\bsponsorship\b/
          ],
          weight: 1
        },
        {
          type: "veteranStatus",
          patterns: [
            /\bveteran\b/,
            /\bmilitary.*service\b/,
            /\bveteran.*status\b/
          ],
          weight: 1
        },
        {
          type: "disabilityStatus",
          patterns: [
            /\bdisabilit/,
            /\bdisabled\b/,
            /\baccommodation/,
            /\bada\b/
          ],
          weight: 1
        },
        {
          type: "gender",
          patterns: [/\bgender\b/, /\bsex\b(?!.*offender)/],
          weight: 0.95
        },
        {
          type: "raceEthnicity",
          patterns: [
            /\brace\b/,
            /\bethnicity\b/,
            /\brace.*ethnicity\b/,
            /\bdemographic/
          ],
          weight: 0.95
        },
        // Questions
        {
          type: "question",
          patterns: [
            /\bwhy\b/,
            /\bdescribe\b/,
            /\btell.*us\b/,
            /\bexplain\b/,
            /\bhow.*would\b/,
            /\bwhat.*makes\b/,
            /\badditional.*information\b/
          ],
          weight: 0.7
        },
        // Referral
        {
          type: "referral",
          patterns: [
            /\breferral\b/,
            /\breferred.*by\b/,
            /\bhow.*did.*you.*hear\b/,
            /\bsource\b/
          ],
          weight: 0.9
        }
      ];
      let bestMatch = null;
      for (const { type: fieldType, patterns: regexes, weight } of patterns) {
        for (const regex of regexes) {
          if (regex.test(hints)) {
            let confidence = weight;
            if (regex.test(name) || regex.test(id)) {
              confidence = Math.min(1, confidence + 0.1);
            }
            if (atsSystem) {
              confidence = Math.min(1, confidence + 0.05);
            }
            if (type === "email" && fieldType === "email") {
              confidence = 1;
            }
            if (type === "tel" && fieldType === "phone") {
              confidence = 1;
            }
            if (type === "url" && (fieldType === "linkedinUrl" || fieldType === "githubUrl" || fieldType === "portfolioUrl" || fieldType === "website")) {
              confidence = Math.min(1, confidence + 0.15);
            }
            if (type === "file" && (fieldType === "resumeUpload" || fieldType === "coverLetterUpload")) {
              confidence = Math.min(1, confidence + 0.1);
            }
            if (!bestMatch || confidence > bestMatch.confidence) {
              bestMatch = {
                type: fieldType,
                confidence,
                matchedPattern: regex.source
              };
            }
          }
        }
      }
      if (bestMatch) {
        return bestMatch;
      }
      return {
        type: "unknown",
        confidence: 0,
        matchedPattern: "none"
      };
    }
    /**
     * Get label text for a field
     */
    getFieldLabel(element) {
      const ariaLabel = element.getAttribute("aria-label");
      if (ariaLabel) return ariaLabel;
      const labelledBy = element.getAttribute("aria-labelledby");
      if (labelledBy) {
        const labelElement = document.getElementById(labelledBy);
        if (labelElement) return labelElement.textContent?.trim() || null;
      }
      if (element.id) {
        const label = document.querySelector(`label[for="${element.id}"]`);
        if (label) return label.textContent?.trim() || null;
      }
      const parentLabel = element.closest("label");
      if (parentLabel) {
        const clone = parentLabel.cloneNode(true);
        const nestedInputs = clone.querySelectorAll("input, textarea, select");
        nestedInputs.forEach((input) => input.remove());
        return clone.textContent?.trim() || null;
      }
      const previousSibling = element.previousElementSibling;
      if (previousSibling?.tagName === "LABEL") {
        return previousSibling.textContent?.trim() || null;
      }
      return null;
    }
    /**
     * Detect which ATS system is being used
     */
    detectAtsSystem() {
      const url = window.location.hostname.toLowerCase();
      const html = document.documentElement.innerHTML.toLowerCase();
      if (url.includes("greenhouse.io")) return "greenhouse";
      if (url.includes("lever.co")) return "lever";
      if (url.includes("myworkdayjobs.com") || url.includes("myworkday")) return "workday";
      if (url.includes("indeed.com")) return "indeed";
      if (url.includes("taleo.net")) return "taleo";
      if (url.includes("icims.com")) return "icims";
      if (url.includes("ultipro.com") || url.includes("ulti.pro")) return "ultipro";
      if (url.includes("smartrecruiters.com")) return "smartrecruiters";
      if (url.includes("ashbyhq.com")) return "ashby";
      if (url.includes("jobvite.com")) return "jobvite";
      if (html.includes("greenhouse")) return "greenhouse";
      if (html.includes("lever-frame") || html.includes("lever.co")) return "lever";
      if (html.includes("workday")) return "workday";
      if (html.includes("taleo")) return "taleo";
      if (html.includes("icims")) return "icims";
      return null;
    }
    /**
     * Determine if current page is a job application
     */
    isJobApplicationPage(fields) {
      const url = window.location.href.toLowerCase();
      const jobUrlPatterns = [
        /apply/,
        /application/,
        /job.*form/,
        /careers/,
        /jobs/,
        /greenhouse\.io/,
        /lever\.co/,
        /workday/,
        /indeed\.com/
      ];
      if (jobUrlPatterns.some((pattern) => pattern.test(url))) {
        return true;
      }
      const commonJobFields = [
        "firstName",
        "lastName",
        "fullName",
        "email",
        "phone",
        "resumeUpload",
        "coverLetterUpload",
        "coverLetterText",
        "workAuthorization"
        /* WORK_AUTHORIZATION */
      ];
      const matchedFieldTypes = new Set(
        fields.filter((f) => f.confidence > 0.5).map((f) => f.type)
      );
      const commonFieldCount = commonJobFields.filter(
        (type) => matchedFieldTypes.has(type)
      ).length;
      return commonFieldCount >= 3;
    }
    /**
     * Calculate overall confidence that this is a job application
     */
    calculateOverallConfidence(fields) {
      if (fields.length === 0) return 0;
      const avgFieldConfidence = fields.reduce((sum, f) => sum + f.confidence, 0) / fields.length;
      const highConfidenceFields = fields.filter((f) => f.confidence > 0.8).length;
      const highConfidenceBonus = Math.min(0.2, highConfidenceFields * 0.02);
      const atsBonus = this.detectAtsSystem() ? 0.1 : 0;
      return Math.min(1, avgFieldConfidence + highConfidenceBonus + atsBonus);
    }
    /**
     * Start observing for dynamic form fields
     */
    startObserving(callback) {
      const observer = new MutationObserver((mutations) => {
        const hasNewInputs = mutations.some(
          (mutation) => Array.from(mutation.addedNodes).some(
            (node) => node.nodeType === Node.ELEMENT_NODE && node.matches("input, textarea, select")
          )
        );
        if (hasNewInputs) {
          console.log("[FormDetector] New form fields detected, re-scanning...");
          const result2 = this.detectFields();
          callback(result2);
        }
      });
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
      this.observers.push(observer);
      console.log("[FormDetector] Started observing for dynamic form changes");
    }
    /**
     * Stop observing
     */
    stopObserving() {
      this.observers.forEach((obs) => obs.disconnect());
      this.observers = [];
      console.log("[FormDetector] Stopped observing");
    }
    /**
     * Get debug summary of detection results
     */
    getDebugSummary(result2) {
      const lines = [
        "=".repeat(80),
        "FORM DETECTION RESULTS",
        "=".repeat(80),
        "",
        `URL: ${result2.url}`,
        `ATS System: ${result2.atsSystem || "Unknown"}`,
        `Is Job Application: ${result2.isJobApplication ? "YES" : "NO"}`,
        `Overall Confidence: ${(result2.confidence * 100).toFixed(1)}%`,
        `Fields Detected: ${result2.fields.length}`,
        "",
        "DETECTED FIELDS:",
        "-".repeat(80)
      ];
      const sortedFields = [...result2.fields].sort((a, b) => b.confidence - a.confidence);
      sortedFields.forEach((field, index2) => {
        const confidencePercent = (field.confidence * 100).toFixed(1);
        const typeStr = field.type.padEnd(20);
        const labelStr = (field.label || "(no label)").substring(0, 40).padEnd(40);
        lines.push(
          `${(index2 + 1).toString().padStart(3)}. [${confidencePercent}%] ${typeStr} | ${labelStr}`
        );
        if (field.debugInfo) {
          lines.push(`     Name: ${field.debugInfo.name || "(none)"}`);
          lines.push(`     ID: ${field.debugInfo.id || "(none)"}`);
          lines.push(`     Pattern: ${field.debugInfo.matchedPattern}`);
          lines.push("");
        }
      });
      lines.push("=".repeat(80));
      return lines.join("\n");
    }
  }
  content;
  class AutoFiller {
    constructor() {
      __publicField(this, "detector");
      __publicField(this, "profile", null);
      this.detector = new FormDetector();
    }
    /**
     * Auto-fill all detected fields on current page
     */
    async autoFill(options = {}) {
      const {
        visualFeedback = true,
        skipLowConfidence = true,
        confidenceThreshold = 0.5,
        fillDelay = 100,
        onFieldFilled,
        onComplete
      } = options;
      console.log("[AutoFiller] Starting auto-fill process...");
      this.profile = await getAutofillProfile();
      if (!this.profile || !this.profile.email) {
        console.warn("[AutoFiller] No autofill profile found. Please set up your profile in Account Settings.");
        return {
          success: false,
          filledCount: 0,
          totalFields: 0,
          skippedFields: 0,
          errors: [{ field: null, error: "No autofill profile found" }]
        };
      }
      const detectionResult = this.detector.detectFields();
      console.log(`[AutoFiller] Detected ${detectionResult.fields.length} fields`);
      const result2 = {
        success: true,
        filledCount: 0,
        totalFields: detectionResult.fields.length,
        skippedFields: 0,
        errors: []
      };
      for (const field of detectionResult.fields) {
        if (skipLowConfidence && field.confidence < confidenceThreshold) {
          result2.skippedFields++;
          console.log(`[AutoFiller] Skipping ${field.type} (confidence: ${(field.confidence * 100).toFixed(1)}%)`);
          continue;
        }
        const value = this.getValueForField(field);
        if (!value) {
          result2.skippedFields++;
          continue;
        }
        try {
          await this.fillField(field, value, visualFeedback);
          result2.filledCount++;
          console.log(`[AutoFiller] âœ… Filled ${field.type}: ${value.substring(0, 30)}...`);
          if (onFieldFilled) {
            onFieldFilled(field, value);
          }
          if (fillDelay > 0) {
            await new Promise((resolve) => setTimeout(resolve, fillDelay));
          }
        } catch (error) {
          result2.errors.push({
            field,
            error: error.message
          });
          console.error(`[AutoFiller] âŒ Failed to fill ${field.type}:`, error);
        }
      }
      console.log(`[AutoFiller] Complete: ${result2.filledCount}/${result2.totalFields} fields filled`);
      if (onComplete) {
        onComplete(result2.filledCount, result2.totalFields);
      }
      return result2;
    }
    /**
     * Get value for a specific field type
     */
    getValueForField(field) {
      if (!this.profile) return null;
      switch (field.type) {
        case FormFieldType.FIRST_NAME:
          return this.profile.firstName;
        case FormFieldType.LAST_NAME:
          return this.profile.lastName;
        case FormFieldType.FULL_NAME:
          return this.profile.fullName || `${this.profile.firstName} ${this.profile.lastName}`;
        case FormFieldType.EMAIL:
          return this.profile.email;
        case FormFieldType.PHONE:
          return this.profile.phone;
        case FormFieldType.LOCATION:
          return this.profile.location;
        case FormFieldType.CITY:
          return this.profile.address?.city || this.extractCity(this.profile.location);
        case FormFieldType.STATE:
          return this.profile.address?.state || this.extractState(this.profile.location);
        case FormFieldType.ZIP_CODE:
          return this.profile.address?.zipCode || "";
        case FormFieldType.COUNTRY:
          return this.profile.address?.country || "United States";
        case FormFieldType.BIRTHDAY:
          return this.profile.birthday || "";
        case FormFieldType.LINKEDIN_URL:
          return this.profile.linkedinUrl || "";
        case FormFieldType.GITHUB_URL:
          return this.profile.githubUrl || "";
        case FormFieldType.PORTFOLIO_URL:
          return this.profile.portfolioUrl || "";
        case FormFieldType.WEBSITE:
          return this.profile.websiteUrl || this.profile.portfolioUrl || "";
        case FormFieldType.JOB_TITLE:
          return this.profile.currentJobTitle || "";
        case FormFieldType.COMPANY:
          return this.profile.currentCompany || "";
        case FormFieldType.YEARS_EXPERIENCE:
          return this.profile.totalYearsExperience ? this.profile.totalYearsExperience.toString() : "";
        case FormFieldType.WORK_AUTHORIZATION:
          return this.mapWorkAuthorizationToValue(this.profile.workAuthorization);
        case FormFieldType.VETERAN_STATUS:
          return this.mapVeteranStatusToValue(this.profile.veteranStatus);
        case FormFieldType.GENDER:
          return this.mapGenderToValue(this.profile.gender);
        // Skip these field types - require special handling
        case FormFieldType.SKILLS:
        case FormFieldType.RESUME_UPLOAD:
        case FormFieldType.COVER_LETTER_UPLOAD:
        case FormFieldType.COVER_LETTER_TEXT:
        case FormFieldType.QUESTION:
        case FormFieldType.REFERRAL:
          return null;
        default:
          return null;
      }
    }
    /**
     * Fill a single field with value
     */
    async fillField(field, value, visualFeedback) {
      const element = field.element;
      if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
        element.value = value;
      } else if (element instanceof HTMLSelectElement) {
        const option = Array.from(element.options).find(
          (opt) => opt.value === value || opt.textContent?.toLowerCase() === value.toLowerCase()
        );
        if (option) {
          element.value = option.value;
        }
      }
      element.dispatchEvent(new Event("input", { bubbles: true }));
      element.dispatchEvent(new Event("change", { bubbles: true }));
      element.dispatchEvent(new Event("blur", { bubbles: true }));
      if (visualFeedback) {
        this.addVisualFeedback(element);
      }
    }
    /**
     * Add visual feedback (green highlight) to filled field
     */
    addVisualFeedback(element) {
      const originalBackground = element.style.backgroundColor;
      const originalTransition = element.style.transition;
      element.style.transition = "background-color 0.3s ease";
      element.style.backgroundColor = "#D4EDDA";
      const checkmark = document.createElement("span");
      checkmark.textContent = "âœ“";
      checkmark.style.cssText = `
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #28A745;
      font-weight: bold;
      font-size: 16px;
      pointer-events: none;
      z-index: 10;
    `;
      const parent = element.parentElement;
      if (parent && getComputedStyle(parent).position === "static") {
        parent.style.position = "relative";
      }
      if (parent) {
        parent.appendChild(checkmark);
      }
      setTimeout(() => {
        element.style.backgroundColor = originalBackground;
        element.style.transition = originalTransition;
        if (checkmark.parentElement) {
          checkmark.remove();
        }
      }, 2e3);
    }
    /**
     * Extract city from location string ("San Francisco, CA" -> "San Francisco")
     */
    extractCity(location2) {
      const parts = location2.split(",");
      return parts[0]?.trim() || "";
    }
    /**
     * Extract state from location string ("San Francisco, CA" -> "CA")
     */
    extractState(location2) {
      const parts = location2.split(",");
      return parts[1]?.trim() || "";
    }
    /**
     * Map work authorization enum to form value
     */
    mapWorkAuthorizationToValue(auth) {
      if (!auth || auth === "prefer_not_to_say") return "";
      const mapping = {
        us_citizen: ["yes", "citizen", "us citizen", "authorized"],
        green_card: ["yes", "permanent resident", "green card"],
        visa: ["yes", "visa", "work visa"],
        need_sponsorship: ["no", "need sponsorship", "require sponsorship"]
      };
      const values = mapping[auth];
      return values ? values[0] : "";
    }
    /**
     * Map veteran status enum to form value
     */
    mapVeteranStatusToValue(status) {
      if (!status || status === "prefer_not_to_say") return "";
      const mapping = {
        not_veteran: "no",
        veteran: "yes",
        disabled_veteran: "disabled veteran"
      };
      return mapping[status] || "";
    }
    /**
     * Map gender enum to form value
     */
    mapGenderToValue(gender) {
      if (!gender || gender === "prefer_not_to_say") return "";
      const mapping = {
        male: "male",
        female: "female",
        non_binary: "non-binary",
        self_describe: ""
      };
      return mapping[gender] || "";
    }
    /**
     * Show notification to user
     */
    showNotification(message, type = "info") {
      const notification = document.createElement("div");
      const colors = {
        success: { bg: "#D4EDDA", border: "#28A745", text: "#155724" },
        info: { bg: "#D1ECF1", border: "#17A2B8", text: "#0C5460" },
        warning: { bg: "#FFF3CD", border: "#FFC107", text: "#856404" },
        error: { bg: "#F8D7DA", border: "#DC3545", text: "#721C24" }
      };
      const color = colors[type];
      notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: ${color.bg};
      border: 2px solid ${color.border};
      border-radius: 8px;
      padding: 16px 20px;
      color: ${color.text};
      font-family: system-ui, -apple-system, sans-serif;
      font-size: 14px;
      font-weight: 500;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 2147483646;
      isolation: isolate;
      max-width: 400px;
      animation: slideIn 0.3s ease-out;
    `;
      notification.textContent = message;
      document.body.appendChild(notification);
      setTimeout(() => {
        notification.style.animation = "slideOut 0.3s ease-out";
        setTimeout(() => {
          notification.remove();
        }, 300);
      }, 3e3);
    }
    /**
     * Start observing for dynamic form changes
     */
    startObserving(callback) {
      this.detector.startObserving((result2) => {
        console.log(`[AutoFiller] Detected ${result2.fields.length} new fields`);
        callback();
      });
    }
    /**
     * Stop observing
     */
    stopObserving() {
      this.detector.stopObserving();
    }
  }
  content;
  function PanelHeader({ isMinimized, onMinimize, onClose }) {
    const [isFilling, setIsFilling] = reactExports.useState(false);
    const [fillStatus, setFillStatus] = reactExports.useState("idle");
    const [filledCount, setFilledCount] = reactExports.useState(0);
    const handleFillForm = async () => {
      setIsFilling(true);
      setFillStatus("idle");
      log$1.info(LogCategory.UI, "Fill Form button clicked", { component: "PanelHeader" });
      try {
        const detector = new FormDetector();
        const detectionResult = detector.detectFields();
        if (detectionResult.fields.length === 0) {
          alert("No fillable fields detected on this page");
          setIsFilling(false);
          log$1.warn(LogCategory.SERVICE, "No fillable fields detected");
          return;
        }
        log$1.info(LogCategory.SERVICE, "Starting autofill", { fieldCount: detectionResult.fields.length });
        const filler = new AutoFiller();
        const result2 = await filler.autoFill();
        setFilledCount(result2.filledCount);
        setFillStatus("success");
        log$1.info(LogCategory.SERVICE, "Form autofill completed", { filledCount: result2.filledCount });
        setTimeout(() => setFillStatus("idle"), 2e3);
      } catch (error) {
        console.error("Autofill failed:", error);
        log$1.error(LogCategory.SERVICE, "Autofill failed", error);
        setFillStatus("error");
        alert("Failed to fill form. Please check console for details.");
        setTimeout(() => setFillStatus("idle"), 2e3);
      } finally {
        setIsFilling(false);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "minimal-panel-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "minimal-panel-title", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 16, strokeWidth: 2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Uproot AI Assistant" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "minimal-panel-controls", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            className: "fill-form-button",
            onClick: handleFillForm,
            disabled: isFilling,
            title: "Auto-fill form fields",
            children: [
              isFilling ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fill-form-spinner" }) : fillStatus === "success" ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { size: 16 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "fill-form-text", children: fillStatus === "success" ? `Filled ${filledCount}` : "Fill Form" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "minimal-panel-button",
            onClick: onMinimize,
            title: isMinimized ? "Maximize" : "Minimize",
            children: isMinimized ? /* @__PURE__ */ jsxRuntimeExports.jsx(Maximize2, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Minimize2, { size: 16 })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "minimal-panel-button",
            onClick: onClose,
            title: "Close",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 16 })
          }
        )
      ] })
    ] });
  }
  content;
  function AutofillTabSwitcher({
    activeView,
    onViewChange,
    panelWidth
  }) {
    const isCompact = panelWidth < 450;
    const fontSize = isCompact ? "11px" : "14px";
    const padding = isCompact ? "8px 10px" : "10px 16px";
    const gap = isCompact ? "4px" : "8px";
    const iconSize = isCompact ? 14 : 16;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          padding: "12px 16px",
          borderBottom: "1px solid rgba(0, 0, 0, 0.08)",
          backgroundColor: "rgba(0, 119, 181, 0.03)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => onViewChange("job-description"),
              style: {
                flex: 1,
                padding,
                backgroundColor: activeView === "job-description" ? "#0077B5" : "transparent",
                color: activeView === "job-description" ? "#FFFFFF" : "#6e6e73",
                border: activeView === "job-description" ? "none" : "1px solid rgba(0, 0, 0, 0.12)",
                borderRadius: "8px",
                fontSize,
                fontWeight: "600",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "6px",
                transition: "all 150ms"
              },
              onMouseEnter: (e) => {
                if (activeView !== "job-description") {
                  e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.04)";
                }
              },
              onMouseLeave: (e) => {
                if (activeView !== "job-description") {
                  e.currentTarget.style.backgroundColor = "transparent";
                }
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { size: iconSize, strokeWidth: 2 }),
                "Job Description"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => onViewChange("questions"),
              style: {
                flex: 1,
                padding,
                backgroundColor: activeView === "questions" ? "#0077B5" : "transparent",
                color: activeView === "questions" ? "#FFFFFF" : "#6e6e73",
                border: activeView === "questions" ? "none" : "1px solid rgba(0, 0, 0, 0.12)",
                borderRadius: "8px",
                fontSize,
                fontWeight: "600",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "6px",
                transition: "all 150ms"
              },
              onMouseEnter: (e) => {
                if (activeView !== "questions") {
                  e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.04)";
                }
              },
              onMouseLeave: (e) => {
                if (activeView !== "questions") {
                  e.currentTarget.style.backgroundColor = "transparent";
                }
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSquare, { size: iconSize, strokeWidth: 2 }),
                "Questions"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => onViewChange("experience-bullets"),
              style: {
                flex: 1,
                padding,
                backgroundColor: activeView === "experience-bullets" ? "#0077B5" : "transparent",
                color: activeView === "experience-bullets" ? "#FFFFFF" : "#6e6e73",
                border: activeView === "experience-bullets" ? "none" : "1px solid rgba(0, 0, 0, 0.12)",
                borderRadius: "8px",
                fontSize,
                fontWeight: "600",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "6px",
                transition: "all 150ms"
              },
              onMouseEnter: (e) => {
                if (activeView !== "experience-bullets") {
                  e.currentTarget.style.backgroundColor = "rgba(0, 0, 0, 0.04)";
                }
              },
              onMouseLeave: (e) => {
                if (activeView !== "experience-bullets") {
                  e.currentTarget.style.backgroundColor = "transparent";
                }
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: iconSize, strokeWidth: 2 }),
                isCompact ? "Experience" : "Experience Bullets"
              ]
            }
          )
        ] })
      }
    );
  }
  content;
  function JobDescriptionSection({
    jobDescription,
    onJobDescriptionChange
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-section-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-section-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-section-title-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { size: 20, strokeWidth: 2, style: { color: "#0077B5" } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "generate-section-title", children: "Job Description" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "generate-section-description", children: "Paste the job description here. This will be analyzed to generate personalized answers based on your profile." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-form-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "generate-label", children: "Full Job Description" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            className: "generate-textarea",
            value: jobDescription,
            onChange: (e) => onJobDescriptionChange(e.target.value),
            placeholder: "Paste the complete job description here...",
            style: { minHeight: "350px" }
          }
        )
      ] }),
      jobDescription && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        padding: "12px 16px",
        backgroundColor: "#f0f9ff",
        border: "1px solid #bfdbfe",
        borderRadius: "8px",
        marginTop: "12px"
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: {
        fontSize: "13px",
        color: "#1e40af",
        margin: 0,
        lineHeight: "1.5"
      }, children: "âœ“ Job description saved. Switch to the Questions tab to generate personalized answers." }) })
    ] });
  }
  content;
  async function generateAnswerFromProfile(question, keywords, profile) {
    try {
      const apiKey = void 0;
      if (!apiKey) {
        throw new Error("VITE_ANTHROPIC_API_KEY not set");
      }
      const anthropic = new Anthropic({ apiKey, dangerouslyAllowBrowser: true });
      const yearsExp = calculateYearsOfExperience(profile);
      const topSkills = profile.technicalSkills.slice(0, 5).filter((s) => s && s.name).map((s) => s.name).join(", ");
      const latestJob = profile.jobs[0];
      const latestJobText = latestJob ? `${latestJob.title} at ${latestJob.company}` : "N/A";
      const prompt = `STRICT RULES:
1. DO NOT invent experiences, skills, or accomplishments not in the profile
2. ONLY use facts from the professional profile below
3. DO reference job keywords when relevant
4. DO keep answer to 3-4 sentences maximum
5. DO NOT add fake metrics, team sizes, or company details
6. DO write in first person ("I have...", "My experience...")

PROFESSIONAL PROFILE:
- Name: ${profile.personalInfo.fullName}
- Latest Job: ${latestJobText}
- Technical Skills: ${topSkills}
- Years of Experience: ${yearsExp}

JOB KEYWORDS:
${keywords.join(", ")}

QUESTION:
"${question}"

Write a concise, professional answer (3-4 sentences) using ONLY verified facts from the profile.

Begin:`;
      const message = await anthropic.messages.create({
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 250,
        temperature: 0.4,
        messages: [{ role: "user", content: prompt }]
      });
      const answer = message.content[0].type === "text" ? message.content[0].text.trim() : "";
      return answer;
    } catch (error) {
      console.error("Failed to generate answer with AI:", error);
      const topSkills = profile.technicalSkills.slice(0, 3).filter((s) => s && s.name).map((s) => s.name).join(", ");
      return `Based on my experience with ${topSkills} and the requirements mentioned (${keywords.slice(0, 3).join(", ")}), I believe I'm well-suited for this role.`;
    }
  }
  function calculateYearsOfExperience(profile) {
    if (!profile.jobs || profile.jobs.length === 0) return 0;
    let totalMonths = 0;
    for (const job of profile.jobs) {
      const start = new Date(job.startDate);
      const end = job.current ? /* @__PURE__ */ new Date() : new Date(job.endDate || /* @__PURE__ */ new Date());
      const months = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
      totalMonths += Math.max(0, months);
    }
    return Math.round(totalMonths / 12);
  }
  content;
  function QuestionsSection({ profile, jobDescription }) {
    const [question, setQuestion] = reactExports.useState("");
    const [isGenerating, setIsGenerating] = reactExports.useState(false);
    const [generatedAnswer, setGeneratedAnswer] = reactExports.useState("");
    const [error, setError] = reactExports.useState("");
    const [showCopied, setShowCopied] = reactExports.useState(false);
    const [autoCopied, setAutoCopied] = reactExports.useState(false);
    reactExports.useEffect(() => {
      const handlePasteEvent = (event) => {
        const customEvent = event;
        if (customEvent.detail?.question) {
          setQuestion(customEvent.detail.question);
          log$1.info(LogCategory.UI, "Question pasted from keyboard shortcut", {
            questionLength: customEvent.detail.question.length
          });
        }
      };
      window.addEventListener("uproot:pasteToGenerate", handlePasteEvent);
      return () => {
        window.removeEventListener("uproot:pasteToGenerate", handlePasteEvent);
      };
    }, []);
    const handleGenerateAnswer = async () => {
      if (!question.trim()) {
        setError("Please enter a question");
        return;
      }
      if (!jobDescription.trim()) {
        setError("Please paste a job description in the Job Description tab first");
        return;
      }
      setIsGenerating(true);
      setError("");
      setAutoCopied(false);
      try {
        log$1.info(LogCategory.UI, "Generating AI answer from profile data", {
          questionLength: question.length,
          jdLength: jobDescription.length,
          hasProfile: !!profile
        });
        const { extractKeywordsFromJobDescription: extractKeywordsFromJobDescription2 } = await Promise.resolve().then(() => keywordExtractor);
        const keywords = extractKeywordsFromJobDescription2(jobDescription);
        const keywordStrings = keywords.map((k) => k.keyword || k);
        const answer = await generateAnswerFromProfile(question, keywordStrings, profile);
        setGeneratedAnswer(answer);
        await navigator.clipboard.writeText(answer);
        setAutoCopied(true);
        log$1.info(LogCategory.UI, "AI answer generated from profile and auto-copied to clipboard");
      } catch (err) {
        log$1.error(LogCategory.UI, "Failed to generate answer", err);
        setError("Failed to generate answer. Please try again.");
      } finally {
        setIsGenerating(false);
      }
    };
    const handleCopyAnswer = () => {
      if (!generatedAnswer) return;
      navigator.clipboard.writeText(generatedAnswer).then(() => {
        log$1.action("Answer copied to clipboard (manual)");
        setShowCopied(true);
        setTimeout(() => setShowCopied(false), 2e3);
      });
    };
    const handleReset = () => {
      setQuestion("");
      setGeneratedAnswer("");
      setError("");
      setShowCopied(false);
      setAutoCopied(false);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-section-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-section-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-section-title-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSquare, { size: 20, strokeWidth: 2, style: { color: "#0077B5" } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "generate-section-title", children: "AI Answer Generator" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "generate-section-description", children: "Enter a question to get a personalized answer based on your profile and the job description" })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "generate-error-box", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "generate-error-text", children: error }) }),
      !jobDescription && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        padding: "12px 16px",
        backgroundColor: "#fef3c7",
        border: "1px solid #fbbf24",
        borderRadius: "8px",
        marginBottom: "16px"
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: {
        fontSize: "13px",
        color: "#92400e",
        margin: 0,
        lineHeight: "1.5"
      }, children: "âš ï¸ Please paste a job description in the Job Description tab first" }) }),
      !generatedAnswer && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "generate-label", children: "Your Question" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              className: "generate-input",
              type: "text",
              value: question,
              onChange: (e) => setQuestion(e.target.value),
              placeholder: "e.g., Why do you want to work here?"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            className: "generate-button-primary",
            onClick: handleGenerateAnswer,
            disabled: isGenerating || !jobDescription,
            children: [
              isGenerating && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    width: "16px",
                    height: "16px",
                    border: "2px solid white",
                    borderTopColor: "transparent",
                    borderRadius: "50%",
                    animation: "spin 1s linear infinite"
                  }
                }
              ),
              isGenerating ? "Generating..." : "Generate Answer"
            ]
          }
        )
      ] }),
      generatedAnswer && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        autoCopied && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          padding: "12px 16px",
          backgroundColor: "#d1f4e0",
          border: "1px solid #4ade80",
          borderRadius: "8px",
          marginBottom: "16px",
          display: "flex",
          alignItems: "center",
          gap: "8px"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 16, style: { color: "#16a34a" } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: {
            fontSize: "13px",
            color: "#16a34a",
            margin: 0,
            fontWeight: "600"
          }, children: "âœ“ Answer automatically copied to clipboard!" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-answer-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "generate-answer-title", children: "Generated Answer" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "generate-answer-text", children: generatedAnswer })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-button-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "generate-button-primary", onClick: handleCopyAnswer, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 16, style: { marginRight: "6px" } }),
            showCopied ? "Copied!" : "Copy Answer"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "generate-button-secondary", onClick: handleReset, children: "New Question" })
        ] })
      ] })
    ] });
  }
  content;
  async function generateExperienceBullets(jobDescription, profile, targetJobIndex) {
    return log$1.trackAsync(LogCategory.SERVICE, "generateExperienceBullets", async () => {
      console.log("[Uproot] Generating experience bullets for job description");
      log$1.debug(LogCategory.SERVICE, "Starting bullet generation", {
        targetJobIndex,
        totalJobs: profile.jobs.length,
        descriptionLength: jobDescription.length
      });
      try {
        const apiKey = void 0;
        if (!apiKey) {
          log$1.error(LogCategory.SERVICE, "VITE_ANTHROPIC_API_KEY not set, using fallback");
          return generateFallbackBullets(profile, targetJobIndex);
        }
        const anthropic = new Anthropic({
          apiKey,
          dangerouslyAllowBrowser: true
        });
        const jobsToProcess = selectJobsToProcess(profile.jobs, targetJobIndex);
        log$1.info(LogCategory.SERVICE, `Processing ${jobsToProcess.length} jobs`);
        const topSkills = extractTopSkillsFromJobDescription(jobDescription);
        log$1.debug(LogCategory.SERVICE, "Extracted top skills from job description", {
          skillCount: topSkills.length,
          skills: topSkills
        });
        const prompt = buildPrompt(jobDescription, profile, jobsToProcess, topSkills);
        log$1.debug(LogCategory.SERVICE, "Built prompt for Claude API", {
          promptLength: prompt.length
        });
        log$1.debug(LogCategory.SERVICE, "Calling Claude API for bullet generation");
        const message = await anthropic.messages.create({
          model: "claude-3-5-sonnet-20241022",
          max_tokens: 800,
          temperature: 0.4,
          messages: [
            {
              role: "user",
              content: prompt
            }
          ]
        });
        const responseText = message.content[0].type === "text" ? message.content[0].text.trim() : "";
        log$1.debug(LogCategory.SERVICE, "Received Claude API response", {
          responseLength: responseText.length
        });
        const generatedBullets = parseClaudeResponse(responseText, jobsToProcess);
        log$1.info(LogCategory.SERVICE, "Successfully generated experience bullets", {
          jobsProcessed: generatedBullets.length,
          totalBullets: generatedBullets.reduce((sum, j) => sum + j.bullets.length, 0)
        });
        return generatedBullets;
      } catch (error) {
        log$1.error(LogCategory.SERVICE, "Bullet generation failed, using fallback", error);
        console.error("[Uproot] Error generating bullets:", error);
        return generateFallbackBullets(profile);
      }
    });
  }
  function selectJobsToProcess(jobs, targetJobIndex) {
    return jobs.slice(0, 3);
  }
  function extractTopSkillsFromJobDescription(jobDescription) {
    const technicalKeywords = [
      // Languages
      "JavaScript",
      "TypeScript",
      "Python",
      "Java",
      "C\\+\\+",
      "C#",
      "Go",
      "Rust",
      "Ruby",
      "PHP",
      "Swift",
      "Kotlin",
      // Frontend
      "React",
      "Vue",
      "Angular",
      "Svelte",
      "Next\\.js",
      "Nuxt",
      "HTML",
      "CSS",
      "Tailwind",
      // Backend
      "Node\\.js",
      "Express",
      "Django",
      "Flask",
      "Spring",
      "Laravel",
      "Rails",
      // Databases
      "PostgreSQL",
      "MySQL",
      "MongoDB",
      "Redis",
      "Elasticsearch",
      "DynamoDB",
      "SQL",
      "NoSQL",
      // Cloud & DevOps
      "AWS",
      "Azure",
      "GCP",
      "Docker",
      "Kubernetes",
      "CI/CD",
      "Jenkins",
      "GitHub Actions",
      "Terraform",
      // Other
      "GraphQL",
      "REST",
      "API",
      "Microservices",
      "Agile",
      "Scrum",
      "Git",
      "Testing",
      "TDD"
    ];
    const skills = [];
    for (const keyword of technicalKeywords) {
      const regex = new RegExp(`\\b${keyword}\\b`, "i");
      if (regex.test(jobDescription)) {
        skills.push(keyword.replace(/\\\\/g, "").replace(/\\\./g, "."));
      }
    }
    return skills.slice(0, 7);
  }
  function buildPrompt(_jobDescription, _profile, jobs, topSkills) {
    const jobHistorySection = jobs.map((job, index2) => {
      const technologies = job.technologies.join(", ") || "Not specified";
      const dates = formatJobDates(job);
      const currentTense = job.current ? "(current job - use present tense)" : "(use past tense)";
      return `Job ${index2 + 1}: ${job.title} at ${job.company} ${currentTense}
- Dates: ${dates}
- Technologies/Skills: ${technologies}
- Current bullets: ${job.bullets.slice(0, 3).map((b) => b.text).join("\n  â€¢ ")}`;
    }).join("\n\n");
    return `STRICT RULES:
1. DO NOT invent achievements, metrics, or responsibilities not in the job history
2. ONLY use actual job titles, companies, and dates from the profile
3. DO reference skills/keywords from the job description when relevant
4. DO keep each bullet to 1-2 lines (120-150 characters max)
5. DO start with strong action verbs (Led, Developed, Implemented, Architected, etc.)
6. DO NOT add fake team sizes, project budgets, or percentage improvements
7. DO write in past tense for previous jobs, present tense for current job
8. DO use actual technologies/skills from their profile

JOB DESCRIPTION REQUIREMENTS:
Key skills/requirements: ${topSkills.length > 0 ? topSkills.join(", ") : "General software engineering skills"}

USER'S JOB HISTORY:
${jobHistorySection}

TASK:
Generate 3-5 professional bullet points for EACH job that:
- Highlight relevant experience matching the job requirements above
- Use actual technologies/skills from their profile
- Are ATS-optimized with keywords from the job description
- Are truthful and fact-based
- Start with strong action verbs
- Are concise (120-150 characters each)

Format as JSON array:
[
  {
    "jobTitle": "Job Title",
    "company": "Company Name",
    "bullets": [
      "First bullet point...",
      "Second bullet point...",
      "Third bullet point..."
    ]
  }
]

Begin:`;
  }
  function formatJobDates(job) {
    const start = job.startDate || "Unknown";
    const end = job.current ? "Present" : job.endDate || "Unknown";
    return `${start} - ${end}`;
  }
  function parseClaudeResponse(responseText, _jobs) {
    try {
      const jsonMatch = responseText.match(/\[[\s\S]*\]/);
      if (!jsonMatch) {
        log$1.warn(LogCategory.SERVICE, "No JSON array found in response");
        throw new Error("Invalid response format");
      }
      const parsed = JSON.parse(jsonMatch[0]);
      if (!Array.isArray(parsed) || parsed.length === 0) {
        throw new Error("Response is not a valid array");
      }
      return parsed.map((job) => ({
        ...job,
        bullets: job.bullets.map((bullet) => {
          if (bullet.length > 150) {
            log$1.debug(LogCategory.SERVICE, "Trimming bullet to 150 characters", {
              original: bullet.length
            });
            return bullet.substring(0, 147) + "...";
          }
          return bullet;
        })
      }));
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Failed to parse Claude response", error);
      throw error;
    }
  }
  function generateFallbackBullets(profile, targetJobIndex) {
    console.log("[Uproot] Using fallback bullet generation");
    const jobs = selectJobsToProcess(profile.jobs);
    return jobs.map((job) => {
      const technologies = job.technologies.slice(0, 3).join(", ") || "various technologies";
      const actionVerb = job.current ? "Develop" : "Developed";
      const bullets = job.bullets.length > 0 ? job.bullets.slice(0, 4).map((b) => b.text) : [
        `${actionVerb} software solutions using ${technologies}`,
        `Collaborated with cross-functional teams to deliver projects`,
        `Implemented best practices and code quality standards`
      ];
      return {
        jobTitle: job.title,
        company: job.company,
        bullets
      };
    });
  }
  content;
  function ExperienceBulletsSection({ profile, jobDescription }) {
    const [isGenerating, setIsGenerating] = reactExports.useState(false);
    const [generatedBullets, setGeneratedBullets] = reactExports.useState([]);
    const [error, setError] = reactExports.useState("");
    const [copiedIndex, setCopiedIndex] = reactExports.useState(null);
    const handleGenerate = async () => {
      if (!jobDescription.trim()) {
        setError("Please paste a job description first");
        return;
      }
      if (!profile.jobs || profile.jobs.length === 0) {
        setError("No job experience found in your profile");
        return;
      }
      setIsGenerating(true);
      setError("");
      try {
        const bullets = await generateExperienceBullets(jobDescription, profile);
        setGeneratedBullets(bullets);
        log$1.info(LogCategory.UI, "Experience bullets generated successfully", {
          jobsProcessed: bullets.length,
          totalBullets: bullets.reduce((sum, j) => sum + j.bullets.length, 0)
        });
        setTimeout(() => {
          const container = document.querySelector(".minimal-panel-content");
          if (container) {
            container.scrollTop = container.scrollHeight;
          }
        }, 100);
      } catch (err) {
        log$1.error(LogCategory.UI, "Failed to generate experience bullets", err);
        setError("Failed to generate bullets. Please check your API key and try again.");
      } finally {
        setIsGenerating(false);
      }
    };
    const handleCopyBullet = async (jobIndex, bulletIndex) => {
      const bullet = generatedBullets[jobIndex].bullets[bulletIndex];
      await navigator.clipboard.writeText(bullet);
      const key = `${jobIndex}-${bulletIndex}`;
      setCopiedIndex(key);
      log$1.action("Bullet copied to clipboard", { jobIndex, bulletIndex });
      setTimeout(() => setCopiedIndex(null), 2e3);
    };
    const handleCopyAllForJob = async (jobIndex) => {
      const job = generatedBullets[jobIndex];
      const formattedBullets = job.bullets.map((b) => `â€¢ ${b}`).join("\n");
      await navigator.clipboard.writeText(formattedBullets);
      const key = `job-${jobIndex}`;
      setCopiedIndex(key);
      log$1.action("All bullets copied for job", { jobIndex, bulletCount: job.bullets.length });
      setTimeout(() => setCopiedIndex(null), 2e3);
    };
    const handleReset = () => {
      setGeneratedBullets([]);
      setError("");
      setCopiedIndex(null);
    };
    const hasNoJobs = !profile.jobs || profile.jobs.length === 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-section-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-section-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "generate-section-title-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: 20, strokeWidth: 2, style: { color: "#0077B5" } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "generate-section-title", children: "Experience Bullet Generator" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "generate-section-description", children: "Generate tailored bullet points for your job experiences based on the job description" })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "generate-error-box", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "generate-error-text", children: error }) }),
      !jobDescription && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        padding: "12px 16px",
        backgroundColor: "#fef3c7",
        border: "1px solid #fbbf24",
        borderRadius: "8px",
        marginBottom: "16px"
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: {
        fontSize: "13px",
        color: "#92400e",
        margin: 0,
        lineHeight: "1.5"
      }, children: "âš ï¸ Please paste a job description in the Job Description tab first" }) }),
      hasNoJobs && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        padding: "12px 16px",
        backgroundColor: "#fef3c7",
        border: "1px solid #fbbf24",
        borderRadius: "8px",
        marginBottom: "16px"
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: {
        fontSize: "13px",
        color: "#92400e",
        margin: 0,
        lineHeight: "1.5"
      }, children: "âš ï¸ No job experience found in your profile" }) }),
      generatedBullets.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: "generate-button-primary",
          onClick: handleGenerate,
          disabled: isGenerating || !jobDescription || hasNoJobs,
          children: [
            isGenerating && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  width: "16px",
                  height: "16px",
                  border: "2px solid white",
                  borderTopColor: "transparent",
                  borderRadius: "50%",
                  animation: "spin 1s linear infinite"
                }
              }
            ),
            isGenerating ? "Generating..." : "Generate Bullets"
          ]
        }
      ),
      generatedBullets.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: "20px" }, children: generatedBullets.map((job, jobIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              padding: "16px",
              backgroundColor: "#f5f5f7",
              borderRadius: "8px",
              border: "1px solid rgba(0, 0, 0, 0.08)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { style: {
                fontSize: "16px",
                fontWeight: "600",
                color: "#1d1d1f",
                margin: "0 0 12px 0"
              }, children: [
                job.jobTitle,
                " at ",
                job.company
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { style: {
                margin: "0 0 12px 0",
                paddingLeft: "20px",
                listStyleType: "disc"
              }, children: job.bullets.map((bullet, bulletIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "li",
                {
                  style: {
                    fontSize: "14px",
                    color: "#1d1d1f",
                    lineHeight: "1.6",
                    marginBottom: "8px",
                    position: "relative"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                    display: "flex",
                    alignItems: "flex-start",
                    justifyContent: "space-between",
                    gap: "8px"
                  }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { flex: 1 }, children: bullet }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        onClick: () => handleCopyBullet(jobIndex, bulletIndex),
                        style: {
                          padding: "4px 8px",
                          backgroundColor: copiedIndex === `${jobIndex}-${bulletIndex}` ? "#4ade80" : "white",
                          color: copiedIndex === `${jobIndex}-${bulletIndex}` ? "white" : "#0077B5",
                          border: "1px solid",
                          borderColor: copiedIndex === `${jobIndex}-${bulletIndex}` ? "#4ade80" : "#d2d2d7",
                          borderRadius: "6px",
                          fontSize: "12px",
                          fontWeight: "600",
                          cursor: "pointer",
                          display: "flex",
                          alignItems: "center",
                          gap: "4px",
                          flexShrink: 0,
                          transition: "all 0.2s"
                        },
                        children: copiedIndex === `${jobIndex}-${bulletIndex}` ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 12 }),
                          "Copied"
                        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 12 }),
                          "Copy"
                        ] })
                      }
                    )
                  ] })
                },
                bulletIndex
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => handleCopyAllForJob(jobIndex),
                  style: {
                    width: "100%",
                    padding: "10px 16px",
                    backgroundColor: copiedIndex === `job-${jobIndex}` ? "#4ade80" : "#0077B5",
                    color: "white",
                    border: "none",
                    borderRadius: "6px",
                    fontSize: "13px",
                    fontWeight: "600",
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    gap: "6px",
                    transition: "all 0.2s"
                  },
                  onMouseEnter: (e) => {
                    if (copiedIndex !== `job-${jobIndex}`) {
                      e.currentTarget.style.opacity = "0.9";
                    }
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.opacity = "1";
                  },
                  children: copiedIndex === `job-${jobIndex}` ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 16 }),
                    "All Bullets Copied!"
                  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 16 }),
                    "Copy All Bullets"
                  ] })
                }
              )
            ]
          },
          jobIndex
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "generate-button-secondary",
            onClick: handleReset,
            style: {
              marginTop: "16px",
              width: "100%"
            },
            children: "Generate New Bullets"
          }
        )
      ] })
    ] });
  }
  content;
  function calculateMaximizePosition(panelPosition, panelSize, rndRef, setShouldAnimate, setPanelPosition) {
    if (!rndRef.current) return;
    const viewportHeight = window.innerHeight;
    const fullPanelHeight = panelSize.height;
    const currentY = panelPosition.y;
    const currentBottomY = currentY + 60;
    const targetY = currentBottomY - fullPanelHeight;
    const newY = Math.max(20, Math.min(targetY, viewportHeight - fullPanelHeight - 40));
    const shouldReposition = Math.abs(newY - currentY) > 5;
    if (shouldReposition) {
      log$1.action("Repositioning panel on maximize", {
        reason: targetY < 20 ? "would go above viewport" : targetY > viewportHeight - fullPanelHeight - 40 ? "would go below viewport" : "normal expansion",
        currentY,
        currentBottomY,
        targetY,
        newY,
        adjustment: newY - currentY
      });
      setShouldAnimate(true);
      setTimeout(() => {
        rndRef.current?.updatePosition({ x: panelPosition.x, y: newY });
        setPanelPosition({ x: panelPosition.x, y: newY });
        console.log("[Uproot] Repositioned on maximize:", { from: currentY, to: newY, reason: targetY < 20 ? "too high" : "too low" });
        setTimeout(() => setShouldAnimate(false), 500);
      }, 50);
    } else {
      log$1.debug(LogCategory.UI, "Skipping reposition - adjustment too small", {
        currentY,
        targetY,
        difference: Math.abs(newY - currentY)
      });
    }
  }
  function autoRepositionMinimized(panelPosition, rndRef, setShouldAnimate, setPanelPosition) {
    if (!rndRef.current) return;
    const viewportHeight = window.innerHeight;
    const panelHeight = 60;
    const currentY = panelPosition.y;
    const maxAllowedY = viewportHeight - panelHeight - 20;
    if (currentY > maxAllowedY) {
      const newY = Math.max(20, maxAllowedY);
      setShouldAnimate(true);
      rndRef.current?.updatePosition({ x: panelPosition.x, y: newY });
      setPanelPosition({ x: panelPosition.x, y: newY });
      log$1.debug(LogCategory.UI, "Auto-repositioned minimized panel", { from: currentY, to: newY });
      setTimeout(() => setShouldAnimate(false), 500);
    }
  }
  function handleDragStop(d, isMinimized, rndRef, setShouldAnimate, setPanelPosition) {
    log$1.debug(LogCategory.UI, "Panel dragged", { x: d.x, y: d.y });
    if (isMinimized) {
      const viewportHeight = window.innerHeight;
      const panelHeight = 60;
      const bottomThreshold = viewportHeight - panelHeight - 20;
      if (d.y > bottomThreshold) {
        const newY = Math.max(20, bottomThreshold);
        setShouldAnimate(true);
        setTimeout(() => {
          rndRef.current?.updatePosition({ x: d.x, y: newY });
          setPanelPosition({ x: d.x, y: newY });
          log$1.debug(LogCategory.UI, "Repositioned after drag to bottom", { from: d.y, to: newY });
          setTimeout(() => setShouldAnimate(false), 500);
        }, 50);
        return;
      }
    }
    setPanelPosition({ x: d.x, y: d.y });
  }
  content;
  function MinimalAutofillPanel() {
    const [panelSize, setPanelSize] = reactExports.useState({ width: 400, height: 500 });
    const [isMinimized, setIsMinimized] = reactExports.useState(false);
    const [panelPosition, setPanelPosition] = reactExports.useState({ x: 100, y: 100 });
    const [shouldAnimate, setShouldAnimate] = reactExports.useState(false);
    const [profile, setProfile] = reactExports.useState(null);
    const [activeView, setActiveView] = reactExports.useState("job-description");
    const [jobDescription, setJobDescription] = reactExports.useState("");
    const rndRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      log$1.info(LogCategory.UI, "MinimalAutofillPanel mounted");
      loadProfile();
      return () => {
        log$1.debug(LogCategory.UI, "MinimalAutofillPanel unmounting");
      };
    }, []);
    async function loadProfile() {
      try {
        const prof = await getProfessionalProfile();
        setProfile(prof);
        log$1.info(LogCategory.UI, "Profile loaded for minimal panel", {
          hasProfile: !!prof
        });
      } catch (error) {
        log$1.error(LogCategory.UI, "Failed to load profile", error);
      }
    }
    const handleClose = () => {
      log$1.action("Close button clicked", { component: "MinimalAutofillPanel" });
      const container = document.getElementById("uproot-autofill-root");
      if (container) {
        container.style.display = "none";
        log$1.debug(LogCategory.UI, "MinimalAutofillPanel hidden");
      }
    };
    const handleMinimize = () => {
      const willBeMinimized = !isMinimized;
      log$1.action("Minimize/Maximize button clicked", {
        component: "MinimalAutofillPanel",
        willBeMinimized,
        currentPosition: panelPosition
      });
      if (!willBeMinimized) {
        calculateMaximizePosition(
          panelPosition,
          panelSize,
          rndRef,
          setShouldAnimate,
          setPanelPosition
        );
      }
      setIsMinimized(willBeMinimized);
    };
    reactExports.useEffect(() => {
      if (!isMinimized || !rndRef.current) return;
      const checkPosition = () => {
        autoRepositionMinimized(
          panelPosition,
          rndRef,
          setShouldAnimate,
          setPanelPosition
        );
      };
      checkPosition();
      window.addEventListener("resize", checkPosition);
      return () => window.removeEventListener("resize", checkPosition);
    }, [isMinimized, panelPosition.y]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: getPanelStyles(panelSize, isMinimized) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Rnd,
        {
          ref: rndRef,
          default: {
            x: panelPosition.x,
            y: panelPosition.y,
            width: panelSize.width,
            height: panelSize.height
          },
          size: isMinimized ? { width: panelSize.width, height: 60 } : void 0,
          position: panelPosition,
          onDragStop: (_e, d) => {
            handleDragStop(d, isMinimized, rndRef, setShouldAnimate, setPanelPosition);
          },
          onResize: (_e, _direction, ref, _delta, position) => {
            if (!isMinimized) {
              const newSize = {
                width: parseInt(ref.style.width),
                height: parseInt(ref.style.height)
              };
              const clampedPosition = {
                x: Math.max(0, Math.min(position.x, window.innerWidth - newSize.width)),
                y: Math.max(0, Math.min(position.y, window.innerHeight - newSize.height))
              };
              setPanelSize(newSize);
              setPanelPosition(clampedPosition);
            }
          },
          onResizeStop: (_e, _direction, ref, _delta, position) => {
            setPanelSize({
              width: parseInt(ref.style.width),
              height: parseInt(ref.style.height)
            });
            setPanelPosition(position);
            log$1.debug(LogCategory.UI, "Panel resized", {
              width: ref.style.width,
              height: ref.style.height
            });
          },
          minWidth: 350,
          minHeight: isMinimized ? 60 : 400,
          maxWidth: 600,
          maxHeight: 800,
          bounds: "window",
          dragHandleClassName: "minimal-panel-header",
          cancel: ".react-resizable-handle",
          disableDragging: false,
          enableResizing: isMinimized ? false : {
            top: true,
            right: true,
            bottom: true,
            left: true,
            topRight: true,
            bottomRight: true,
            bottomLeft: true,
            topLeft: true
          },
          resizeHandleStyles: {
            top: { height: "8px", top: 0, left: 0, right: 0 },
            right: { width: "8px", right: 0, top: 0, bottom: 0 },
            bottom: { height: "8px", bottom: 0, left: 0, right: 0 },
            left: { width: "8px", left: 0, top: 0, bottom: 0 },
            topRight: { width: "20px", height: "20px", top: 0, right: 0 },
            bottomRight: { width: "20px", height: "20px", bottom: 0, right: 0 },
            bottomLeft: { width: "20px", height: "20px", bottom: 0, left: 0 },
            topLeft: { width: "20px", height: "20px", top: 0, left: 0 }
          },
          style: {
            zIndex: 2147483647,
            isolation: "isolate",
            pointerEvents: "auto",
            transition: shouldAnimate ? "all 500ms cubic-bezier(0.68, -0.55, 0.265, 1.55)" : "none"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "minimal-panel-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PanelHeader,
              {
                isMinimized,
                onMinimize: handleMinimize,
                onClose: handleClose
              }
            ),
            !isMinimized && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "minimal-panel-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                AutofillTabSwitcher,
                {
                  activeView,
                  onViewChange: setActiveView,
                  panelWidth: panelSize.width
                }
              ),
              profile ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                activeView === "job-description" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  JobDescriptionSection,
                  {
                    jobDescription,
                    onJobDescriptionChange: setJobDescription
                  }
                ),
                activeView === "questions" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  QuestionsSection,
                  {
                    profile,
                    jobDescription
                  }
                ),
                activeView === "experience-bullets" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ExperienceBulletsSection,
                  {
                    profile,
                    jobDescription
                  }
                )
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "20px", textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "#6e6e73", fontSize: "14px" }, children: "Loading profile..." }) })
            ] })
          ] })
        }
      )
    ] });
  }
  content;
  const JOB_SNAPSHOTS_KEY = "uproot_job_snapshots";
  const PERSON_SNAPSHOTS_KEY = "uproot_person_snapshots";
  const COMPANY_SNAPSHOTS_KEY = "uproot_company_snapshots";
  content;
  function calculateJobMatch(job, criteria) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "calculateJobMatch", {
      jobTitle: job.title,
      criteriaJobTitles: criteria.jobTitles.length
    });
    try {
      log$1.debug(LogCategory.SERVICE, "Starting job match calculation", {
        jobId: job.id,
        jobTitle: job.title,
        company: job.company,
        criteriaSet: {
          titles: criteria.jobTitles.length,
          experienceLevels: criteria.experienceLevel.length,
          workLocations: criteria.workLocation.length,
          locations: criteria.locations.length
        }
      });
      const matches = {
        title: false,
        experienceLevel: false,
        workLocation: false,
        location: false
      };
      const reasons = [];
      let score = 0;
      log$1.debug(LogCategory.SERVICE, "Checking title match");
      if (criteria.jobTitles.length > 0) {
        const titleLower = job.title.toLowerCase();
        const matchedTitle = criteria.jobTitles.find(
          (prefTitle) => titleLower.includes(prefTitle.toLowerCase()) || prefTitle.toLowerCase().includes(titleLower)
        );
        if (matchedTitle) {
          matches.title = true;
          score += 40;
          reasons.push(`Matches "${matchedTitle}"`);
          log$1.info(LogCategory.SERVICE, `Title matched: "${matchedTitle}"`, { points: 40 });
        } else {
          log$1.debug(LogCategory.SERVICE, "No title match found");
        }
      } else {
        score += 20;
        log$1.debug(LogCategory.SERVICE, "No title criteria set, partial credit", { points: 20 });
      }
      log$1.debug(LogCategory.SERVICE, "Checking experience level match");
      if (criteria.experienceLevel.length > 0 && job.experienceLevel) {
        if (criteria.experienceLevel.includes(job.experienceLevel)) {
          matches.experienceLevel = true;
          score += 25;
          reasons.push(`${job.experienceLevel} level`);
          log$1.info(LogCategory.SERVICE, `Experience level matched: ${job.experienceLevel}`, { points: 25 });
        } else {
          log$1.debug(LogCategory.SERVICE, "Experience level did not match", {
            jobLevel: job.experienceLevel,
            criteriaLevels: criteria.experienceLevel
          });
        }
      } else {
        score += 15;
        log$1.debug(LogCategory.SERVICE, "No experience level criteria, partial credit", { points: 15 });
      }
      log$1.debug(LogCategory.SERVICE, "Checking work location match");
      if (criteria.workLocation.length > 0 && job.workLocation) {
        if (criteria.workLocation.includes(job.workLocation)) {
          matches.workLocation = true;
          score += 20;
          reasons.push(`${job.workLocation} work`);
          log$1.info(LogCategory.SERVICE, `Work location matched: ${job.workLocation}`, { points: 20 });
        } else {
          log$1.debug(LogCategory.SERVICE, "Work location did not match", {
            jobLocation: job.workLocation,
            criteriaLocations: criteria.workLocation
          });
        }
      } else {
        score += 10;
        log$1.debug(LogCategory.SERVICE, "No work location criteria, partial credit", { points: 10 });
      }
      log$1.debug(LogCategory.SERVICE, "Checking geographic location match");
      if (criteria.locations.length > 0) {
        const locationLower = job.location.toLowerCase();
        const matchedLocation = criteria.locations.find(
          (prefLoc) => locationLower.includes(prefLoc.toLowerCase()) || prefLoc.toLowerCase().includes(locationLower)
        );
        if (matchedLocation) {
          matches.location = true;
          score += 15;
          reasons.push(`Located in ${matchedLocation}`);
          log$1.info(LogCategory.SERVICE, `Location matched: ${matchedLocation}`, { points: 15 });
        } else {
          log$1.debug(LogCategory.SERVICE, "No location match found", { jobLocation: job.location });
        }
      } else {
        score += 10;
        log$1.debug(LogCategory.SERVICE, "No location criteria, partial credit", { points: 10 });
      }
      if (job.isEasyApply) {
        score = Math.min(100, score + 5);
        reasons.push("Easy Apply available");
        log$1.debug(LogCategory.SERVICE, "Easy Apply bonus applied", { points: 5 });
      }
      const hoursSincePosted = (Date.now() - job.postedTimestamp) / (1e3 * 60 * 60);
      if (hoursSincePosted < 24) {
        score = Math.min(100, score + 3);
        reasons.push("Posted recently");
        log$1.debug(LogCategory.SERVICE, "Recent posting bonus applied", {
          points: 3,
          hoursAgo: hoursSincePosted.toFixed(1)
        });
      }
      const result2 = {
        score: Math.round(score),
        matches,
        reasons
      };
      log$1.info(LogCategory.SERVICE, "Job match calculation completed", {
        jobTitle: job.title,
        finalScore: result2.score,
        matchedCriteria: Object.entries(matches).filter(([_, v]) => v).map(([k]) => k),
        reasonsCount: reasons.length
      });
      endTrace(result2);
      return result2;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Job match calculation failed", error, {
        jobId: job.id,
        jobTitle: job.title
      });
      endTrace();
      throw error;
    }
  }
  function filterMatchingJobs(jobs, criteria, minScore = 50) {
    const endTrace = log$1.trace(LogCategory.SERVICE, "filterMatchingJobs", {
      totalJobs: jobs.length,
      minScore
    });
    try {
      log$1.debug(LogCategory.SERVICE, "Filtering jobs by match score", {
        jobsToEvaluate: jobs.length,
        minScoreThreshold: minScore
      });
      const evaluated = jobs.map((job) => ({
        job,
        match: calculateJobMatch(job, criteria)
      }));
      log$1.info(LogCategory.SERVICE, "All jobs evaluated", {
        totalEvaluated: evaluated.length,
        scoreDistribution: {
          excellent: evaluated.filter((e) => e.match.score >= 80).length,
          good: evaluated.filter((e) => e.match.score >= 65 && e.match.score < 80).length,
          fair: evaluated.filter((e) => e.match.score >= 50 && e.match.score < 65).length,
          poor: evaluated.filter((e) => e.match.score < 50).length
        }
      });
      const filtered = evaluated.filter(({ match }) => match.score >= minScore);
      log$1.info(LogCategory.SERVICE, `Filtered to ${filtered.length} jobs meeting threshold`);
      const sorted = filtered.sort((a, b) => b.match.score - a.match.score);
      log$1.info(LogCategory.SERVICE, "Job filtering completed", {
        totalInput: jobs.length,
        passedFilter: sorted.length,
        filteredOut: jobs.length - sorted.length,
        topScores: sorted.slice(0, 5).map((m) => ({ title: m.job.title, score: m.match.score }))
      });
      endTrace(sorted);
      return sorted;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Job filtering failed", error, {
        jobCount: jobs.length,
        minScore
      });
      endTrace();
      throw error;
    }
  }
  content;
  const HIRING_KEYWORDS = [
    "hiring",
    "we're hiring",
    "we are hiring",
    "looking for",
    "seeking",
    "intern",
    "internship",
    "open role",
    "open position",
    "join our team",
    "join us",
    "we're looking",
    "we are looking",
    "recruiting",
    "applications"
  ];
  async function isCompanyWatchlisted(companyName) {
    try {
      const result2 = await chrome.storage.local.get("uproot_watchlist_companies");
      const companies = result2.uproot_watchlist_companies || [];
      const normalizedName = companyName.toLowerCase().trim();
      return companies.some((c) => c.name.toLowerCase().trim() === normalizedName);
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Error checking if company is watchlisted", { error, companyName });
      return false;
    }
  }
  function containsHiringKeywords(text) {
    const lowerText = text.toLowerCase();
    return HIRING_KEYWORDS.some((keyword) => lowerText.includes(keyword));
  }
  async function detectPersonInsights(current, previous, person) {
    log$1.debug(LogCategory.SERVICE, "Detecting person insights", {
      personName: person.name,
      currentCompany: current.currentRole?.company,
      previousCompany: previous?.currentRole?.company
    });
    if (!current.currentRole) {
      return await detectHiringActivity(current, person);
    }
    if (!previous || !previous.currentRole) {
      return await detectHiringActivity(current, person);
    }
    if (current.currentRole.company !== previous.currentRole.company) {
      log$1.info(LogCategory.SERVICE, "Job change detected", {
        personName: person.name,
        from: previous.currentRole.company,
        to: current.currentRole.company
      });
      const isTargetCompany = await isCompanyWatchlisted(current.currentRole.company);
      const isSeniorRole = /senior|lead|manager|director|head|vp|chief/i.test(current.currentRole.title);
      if (isTargetCompany || isSeniorRole) {
        const feedItem = {
          id: `person_insight_${person.id}_${Date.now()}`,
          type: "person_update",
          timestamp: Date.now(),
          read: false,
          // Person details
          personName: current.name,
          personTitle: current.currentRole.title,
          personUrl: current.profileUrl,
          personImage: current.photoUrl,
          // Insight details
          insightType: "job_change",
          newCompany: current.currentRole.company,
          newRole: current.currentRole.title,
          isTargetCompany,
          // Metadata
          title: isTargetCompany ? `${current.name} joined ${current.currentRole.company}` : `${current.name} changed jobs`,
          description: `${current.name} is now ${current.currentRole.title} at ${current.currentRole.company}${isTargetCompany ? " (Watchlisted Company!)" : ""}`,
          updateText: `Started new position at ${current.currentRole.company}`,
          actionUrl: current.profileUrl,
          actionLabel: "View Profile"
        };
        log$1.info(LogCategory.SERVICE, "Created job change feed item", {
          personName: current.name,
          isTargetCompany,
          isSeniorRole
        });
        return feedItem;
      }
      log$1.debug(LogCategory.SERVICE, "Job change not opportunity-relevant, skipping feed item", {
        isTargetCompany,
        isSeniorRole,
        role: current.currentRole.title
      });
      return null;
    }
    if (current.currentRole.title !== previous.currentRole.title) {
      const isTargetCompany = await isCompanyWatchlisted(current.currentRole.company);
      const isSeniorRole = /senior|lead|manager|director|head|vp|chief/i.test(current.currentRole.title);
      if (isTargetCompany && isSeniorRole) {
        const feedItem = {
          id: `person_insight_${person.id}_${Date.now()}`,
          type: "person_update",
          timestamp: Date.now(),
          read: false,
          // Person details
          personName: current.name,
          personTitle: current.currentRole.title,
          personUrl: current.profileUrl,
          personImage: current.photoUrl,
          // Insight details
          insightType: "job_change",
          // Treat promotion as job_change for V1
          newCompany: current.currentRole.company,
          newRole: current.currentRole.title,
          isTargetCompany: true,
          // Metadata
          title: `${current.name} promoted at ${current.currentRole.company}`,
          description: `${current.name} is now ${current.currentRole.title} at ${current.currentRole.company} (Watchlisted Company!)`,
          updateText: `Promoted to ${current.currentRole.title}`,
          actionUrl: current.profileUrl,
          actionLabel: "View Profile"
        };
        log$1.info(LogCategory.SERVICE, "Created promotion feed item", {
          personName: current.name,
          newTitle: current.currentRole.title
        });
        return feedItem;
      }
      log$1.debug(LogCategory.SERVICE, "Promotion not opportunity-relevant, skipping feed item", {
        isTargetCompany,
        isSeniorRole
      });
      return null;
    }
    return await detectHiringActivity(current, person);
  }
  async function detectHiringActivity(profile, person) {
    if (!profile.recentActivity || profile.recentActivity.length === 0) {
      return null;
    }
    for (const activity of profile.recentActivity) {
      if (containsHiringKeywords(activity.preview)) {
        log$1.info(LogCategory.SERVICE, "Hiring-related activity detected", {
          personName: person.name,
          activityPreview: activity.preview.substring(0, 100)
        });
        const feedItem = {
          id: `person_insight_${person.id}_${Date.now()}`,
          type: "person_update",
          timestamp: Date.now(),
          read: false,
          // Person details
          personName: profile.name,
          personTitle: profile.currentRole?.title,
          personUrl: profile.profileUrl,
          personImage: profile.photoUrl,
          // Insight details
          insightType: "new_activity",
          updateText: activity.preview,
          // Metadata
          title: `${profile.name} posted about hiring`,
          description: activity.preview.substring(0, 200) + (activity.preview.length > 200 ? "..." : ""),
          actionUrl: activity.url || profile.profileUrl,
          actionLabel: "View Post"
        };
        log$1.info(LogCategory.SERVICE, "Created hiring activity feed item", {
          personName: profile.name
        });
        return feedItem;
      }
    }
    return null;
  }
  content;
  const DETECTION_WINDOW_DAYS = 7;
  const MIN_NEW_JOBS_THRESHOLD = 3;
  const HEAT_THRESHOLDS = {
    // 3-5 new jobs
    HOT: 6,
    // 6-9 new jobs
    VERY_HOT: 10
    // 10+ new jobs
  };
  const JUNIOR_KEYWORDS = [
    "intern",
    "internship",
    "co-op",
    "coop",
    "entry",
    "junior",
    "associate",
    "new grad",
    "graduate",
    "entry level",
    "entry-level"
  ];
  function detectHiringHeat(currentJobs, previousSnapshot, company) {
    log$1.debug(LogCategory.SERVICE, "Detecting hiring heat for company", {
      company: company.name,
      currentJobCount: currentJobs.length
    });
    const now = Date.now();
    const windowStart = now - DETECTION_WINDOW_DAYS * 24 * 60 * 60 * 1e3;
    const recentJobs = currentJobs.filter((job) => job.postedTimestamp >= windowStart);
    log$1.debug(LogCategory.SERVICE, "Recent jobs within window", {
      recentJobCount: recentJobs.length,
      windowDays: DETECTION_WINDOW_DAYS
    });
    if (recentJobs.length < MIN_NEW_JOBS_THRESHOLD) {
      log$1.debug(LogCategory.SERVICE, "Not enough recent jobs", {
        recentJobCount: recentJobs.length,
        threshold: MIN_NEW_JOBS_THRESHOLD
      });
      return null;
    }
    const previousJobIds = new Set(previousSnapshot?.jobs.map((j) => j.id) || []);
    const newJobs = recentJobs.filter((job) => !previousJobIds.has(job.id));
    log$1.debug(LogCategory.SERVICE, "New jobs detected", {
      newJobCount: newJobs.length,
      previousSnapshotSize: previousJobIds.size
    });
    if (newJobs.length < MIN_NEW_JOBS_THRESHOLD) {
      log$1.debug(LogCategory.SERVICE, "Not enough NEW jobs", {
        newJobCount: newJobs.length,
        threshold: MIN_NEW_JOBS_THRESHOLD
      });
      return null;
    }
    const heatLevel = newJobs.length >= HEAT_THRESHOLDS.VERY_HOT ? "very_hot" : newJobs.length >= HEAT_THRESHOLDS.HOT ? "hot" : "warming";
    const internshipJobs = newJobs.filter(
      (job) => JUNIOR_KEYWORDS.some((keyword) => job.title.toLowerCase().includes(keyword))
    );
    log$1.info(LogCategory.SERVICE, "Hiring heat detected", {
      company: company.name,
      newJobCount: newJobs.length,
      internshipCount: internshipJobs.length,
      heatLevel
    });
    const topJobs = [
      ...internshipJobs.slice(0, 3),
      ...newJobs.filter((j) => !internshipJobs.includes(j)).slice(0, 3 - internshipJobs.length)
    ];
    return {
      company,
      jobCount: newJobs.length,
      internshipCount: internshipJobs.length,
      heatLevel,
      topJobTitles: topJobs.map((j) => j.title),
      detectionWindow: DETECTION_WINDOW_DAYS,
      actionUrl: `${company.companyUrl}/jobs/`
    };
  }
  async function shouldCreateHiringHeatItem(company, detectionWindow) {
    log$1.debug(LogCategory.SERVICE, "Checking for existing hiring_heat items", {
      company: company.name,
      detectionWindow
    });
    try {
      const feedItems = await getFeedItems();
      const windowStart = Date.now() - detectionWindow * 24 * 60 * 60 * 1e3;
      const existingHeat = feedItems.find(
        (item) => item.type === "hiring_heat" && item.company === company.name && item.timestamp >= windowStart
      );
      if (existingHeat) {
        log$1.debug(LogCategory.SERVICE, "Found existing hiring_heat item, skipping", {
          company: company.name,
          existingItemId: existingHeat.id,
          existingItemAge: Date.now() - existingHeat.timestamp
        });
        return false;
      }
      log$1.debug(LogCategory.SERVICE, "No existing hiring_heat item found, OK to create", {
        company: company.name
      });
      return true;
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Error checking existing hiring_heat items", { error });
      return true;
    }
  }
  async function generateHiringHeatFeedItem(indicator) {
    const { company, jobCount, internshipCount, heatLevel, topJobTitles, detectionWindow, actionUrl } = indicator;
    log$1.debug(LogCategory.SERVICE, "Generating hiring_heat feed item", {
      company: company.name,
      jobCount,
      heatLevel
    });
    const shouldCreate = await shouldCreateHiringHeatItem(company, detectionWindow);
    if (!shouldCreate) {
      log$1.info(LogCategory.SERVICE, "Skipping duplicate hiring_heat item", {
        company: company.name
      });
      console.log(`[Uproot] Skipping duplicate hiring_heat for ${company.name}`);
      return;
    }
    const heatEmoji = {
      warming: "ðŸ”¥",
      hot: "ðŸ”¥ðŸ”¥",
      very_hot: "ðŸ”¥ðŸ”¥ðŸ”¥"
    }[heatLevel];
    const title = `${company.name} is ramping up hiring ${heatEmoji}`;
    const description = `${jobCount} new position${jobCount > 1 ? "s" : ""} posted in the last ${detectionWindow} days${internshipCount && internshipCount > 0 ? ` (${internshipCount} intern/junior)` : ""}.

Top roles: ${topJobTitles.slice(0, 3).join(", ")}`;
    const feedItem = {
      type: "hiring_heat",
      timestamp: Date.now(),
      read: false,
      company: company.name,
      companyLogo: company.companyLogo || void 0,
      jobCount,
      detectionWindow,
      heatLevel,
      topJobTitles: topJobTitles.slice(0, 3),
      internshipCount,
      title,
      description,
      actionUrl,
      actionLabel: "View Open Roles"
    };
    try {
      await addFeedItem(feedItem);
      log$1.change(LogCategory.SERVICE, "feedItems", "create", {
        type: "hiring_heat",
        company: company.name,
        jobCount,
        heatLevel
      });
      console.log(
        `[Uproot] Created hiring_heat feed item for ${company.name} (${jobCount} jobs, ${heatLevel})`
      );
    } catch (error) {
      log$1.error(LogCategory.SERVICE, "Error creating hiring_heat feed item", {
        company: company.name,
        error
      });
      console.error(`[Uproot] Error creating hiring_heat feed item:`, error);
      throw error;
    }
  }
  content;
  function convertPersonProfileToLinkedInProfile$1(profile) {
    return {
      id: profile.profileUrl,
      profileUrl: profile.profileUrl,
      name: profile.name,
      headline: profile.headline,
      location: profile.location,
      photoUrl: profile.photoUrl,
      avatarUrl: profile.photoUrl,
      currentRole: profile.currentRole,
      experience: profile.currentRole ? [{
        company: profile.currentRole.company,
        title: profile.currentRole.title,
        location: profile.location
      }] : [],
      education: [],
      certifications: [],
      skills: [],
      connections: 0,
      mutualConnections: [],
      recentPosts: [],
      userPosts: [],
      engagedPosts: [],
      recentActivity: (profile.recentActivity || []).map((activity) => ({
        preview: activity.preview,
        timestamp: new Date(activity.timestamp).toISOString(),
        type: activity.type,
        url: activity.url
      })),
      scrapedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  async function getJobSnapshots() {
    try {
      const result2 = await chrome.storage.local.get(JOB_SNAPSHOTS_KEY);
      const snapshots = result2[JOB_SNAPSHOTS_KEY] || [];
      return new Map(snapshots.map((s) => [s.companyId, s]));
    } catch (error) {
      console.error("[Uproot] Error getting job snapshots:", error);
      return /* @__PURE__ */ new Map();
    }
  }
  async function saveJobSnapshots(snapshots) {
    try {
      const snapshotsArray = Array.from(snapshots.values());
      await chrome.storage.local.set({ [JOB_SNAPSHOTS_KEY]: snapshotsArray });
      console.log(`[Uproot] Saved ${snapshotsArray.length} job snapshots`);
    } catch (error) {
      console.error("[Uproot] Error saving job snapshots:", error);
    }
  }
  async function getPersonSnapshots() {
    try {
      const result2 = await chrome.storage.local.get(PERSON_SNAPSHOTS_KEY);
      const snapshots = result2[PERSON_SNAPSHOTS_KEY] || [];
      return new Map(snapshots.map((s) => [s.personId, s]));
    } catch (error) {
      console.error("[Uproot] Error getting person snapshots:", error);
      return /* @__PURE__ */ new Map();
    }
  }
  async function savePersonSnapshots(snapshots) {
    try {
      const snapshotsArray = Array.from(snapshots.values());
      await chrome.storage.local.set({ [PERSON_SNAPSHOTS_KEY]: snapshotsArray });
      console.log(`[Uproot] Saved ${snapshotsArray.length} person snapshots`);
    } catch (error) {
      console.error("[Uproot] Error saving person snapshots:", error);
    }
  }
  async function getCompanySnapshots() {
    try {
      const result2 = await chrome.storage.local.get(COMPANY_SNAPSHOTS_KEY);
      const snapshots = result2[COMPANY_SNAPSHOTS_KEY] || [];
      return new Map(snapshots.map((s) => [s.companyId, s]));
    } catch (error) {
      console.error("[Uproot] Error getting company snapshots:", error);
      return /* @__PURE__ */ new Map();
    }
  }
  async function saveCompanySnapshots(snapshots) {
    try {
      const snapshotsArray = Array.from(snapshots.values());
      await chrome.storage.local.set({ [COMPANY_SNAPSHOTS_KEY]: snapshotsArray });
      console.log(`[Uproot] Saved ${snapshotsArray.length} company snapshots`);
    } catch (error) {
      console.error("[Uproot] Error saving company snapshots:", error);
    }
  }
  async function checkCompanyJobs(company, preferences) {
    return log$1.trackAsync(LogCategory.SERVICE, "checkCompanyJobs", async () => {
      console.log(`[Uproot] Checking jobs for ${company.name}...`);
      log$1.debug(LogCategory.SERVICE, "Starting job check for company", {
        companyId: company.id,
        companyName: company.name,
        jobAlertEnabled: company.jobAlertEnabled
      });
      try {
        log$1.debug(LogCategory.SERVICE, "Scraping company jobs from page");
        const currentJobs = scrapeCompanyJobs(company.companyUrl);
        if (currentJobs.length === 0) {
          console.log(`[Uproot] No jobs found for ${company.name}`);
          log$1.warn(LogCategory.SERVICE, "No jobs found for company", { companyName: company.name });
          return [];
        }
        log$1.info(LogCategory.SERVICE, `Scraped ${currentJobs.length} current jobs`);
        log$1.debug(LogCategory.SERVICE, "Retrieving previous job snapshot");
        const snapshots = await getJobSnapshots();
        const previousSnapshot = snapshots.get(company.id);
        log$1.debug(LogCategory.SERVICE, "Detecting new jobs");
        const newJobs = detectNewJobs(currentJobs, previousSnapshot);
        console.log(`[Uproot] Found ${newJobs.length} new jobs for ${company.name}`);
        log$1.info(LogCategory.SERVICE, `Detected ${newJobs.length} new jobs`, {
          companyName: company.name,
          totalJobs: currentJobs.length,
          newJobs: newJobs.length
        });
        log$1.debug(LogCategory.SERVICE, "Updating job snapshot");
        snapshots.set(company.id, {
          companyId: company.id,
          lastChecked: Date.now(),
          jobs: currentJobs
        });
        await saveJobSnapshots(snapshots);
        log$1.debug(LogCategory.SERVICE, "Filtering jobs by user preferences");
        const matchCriteria = {
          jobTitles: preferences.jobTitles,
          experienceLevel: preferences.experienceLevel,
          workLocation: preferences.workLocation,
          locations: preferences.locations,
          industries: preferences.industries
        };
        const matchingJobs = filterMatchingJobs(newJobs, matchCriteria, 50);
        console.log(`[Uproot] ${matchingJobs.length} jobs match user preferences`);
        log$1.info(LogCategory.SERVICE, "Jobs filtered by preferences", {
          newJobs: newJobs.length,
          matchingJobs: matchingJobs.length,
          minScore: 50
        });
        log$1.debug(LogCategory.SERVICE, "Generating feed items for matching jobs");
        for (const { job, match } of matchingJobs) {
          await generateJobAlertFeedItem(job, company, match.score, match.reasons);
        }
        log$1.info(LogCategory.SERVICE, `Created ${matchingJobs.length} job alert feed items`);
        try {
          log$1.debug(LogCategory.SERVICE, "Detecting hiring heat for company");
          const hiringHeat = detectHiringHeat(currentJobs, previousSnapshot, company);
          if (hiringHeat) {
            log$1.info(LogCategory.SERVICE, "Hiring heat detected, generating feed item");
            await generateHiringHeatFeedItem(hiringHeat);
          }
        } catch (error) {
          log$1.error(LogCategory.SERVICE, "Error detecting hiring heat", error, {
            companyName: company.name
          });
          console.error("[Uproot] Error detecting hiring heat:", error);
        }
        return matchingJobs.map((m) => m.job);
      } catch (error) {
        console.error(`[Uproot] Error checking jobs for ${company.name}:`, error);
        log$1.error(LogCategory.SERVICE, "Job check failed", error, {
          companyId: company.id,
          companyName: company.name
        });
        return [];
      }
    });
  }
  function detectNewJobs(currentJobs, previousSnapshot) {
    if (!previousSnapshot) {
      return currentJobs;
    }
    const previousJobIds = new Set(previousSnapshot.jobs.map((j) => j.id));
    return currentJobs.filter((job) => !previousJobIds.has(job.id));
  }
  async function generateJobAlertFeedItem(job, company, matchScore, _reasons) {
    try {
      const feedItem = {
        type: "job_alert",
        timestamp: Date.now(),
        read: false,
        title: "New Job Match",
        description: job.title,
        company: company.name,
        companyLogo: company.companyLogo ?? void 0,
        location: job.location,
        jobUrl: job.jobUrl,
        matchScore,
        actionUrl: job.jobUrl,
        actionLabel: job.isEasyApply ? "Easy Apply" : "View Job",
        jobTitle: job.title
      };
      await addFeedItem(feedItem);
      console.log(`[Uproot] Created feed item for job: ${job.title} at ${company.name} (${matchScore}% match)`);
    } catch (error) {
      console.error("[Uproot] Error generating job alert feed item:", error);
    }
  }
  async function checkPersonProfile(person) {
    return log$1.trackAsync(LogCategory.SERVICE, "checkPersonProfile", async () => {
      console.log(`[Uproot] Checking profile for ${person.name}...`);
      log$1.debug(LogCategory.SERVICE, "Starting profile check", {
        personId: person.id,
        personName: person.name
      });
      try {
        log$1.debug(LogCategory.SERVICE, "Scraping person profile from page");
        const currentProfile = scrapePersonProfile();
        if (!currentProfile) {
          console.log(`[Uproot] Could not scrape profile for ${person.name}`);
          log$1.warn(LogCategory.SERVICE, "Failed to scrape profile", { personName: person.name });
          return;
        }
        log$1.info(LogCategory.SERVICE, "Profile scraped successfully", {
          personName: currentProfile.name,
          currentRole: currentProfile.currentRole.title,
          currentCompany: currentProfile.currentRole.company
        });
        log$1.debug(LogCategory.SERVICE, "Retrieving previous profile snapshot");
        const snapshots = await getPersonSnapshots();
        const previousSnapshot = snapshots.get(person.id);
        const currentLinkedInProfile = convertPersonProfileToLinkedInProfile$1(currentProfile);
        const previousLinkedInProfile = previousSnapshot?.profile ? convertPersonProfileToLinkedInProfile$1(previousSnapshot.profile) : void 0;
        log$1.debug(LogCategory.SERVICE, "Detecting person insights");
        const insight = await detectPersonInsights(
          currentLinkedInProfile,
          previousLinkedInProfile,
          person
        );
        if (insight) {
          log$1.info(LogCategory.SERVICE, "Person insight detected, adding to feed", {
            personName: person.name,
            insightType: insight.insightType
          });
          await addFeedItem(insight);
        } else {
          log$1.debug(LogCategory.SERVICE, "No opportunity-relevant insights detected");
        }
        log$1.debug(LogCategory.SERVICE, "Updating profile snapshot");
        snapshots.set(person.id, {
          personId: person.id,
          lastChecked: Date.now(),
          profile: currentProfile
        });
        await savePersonSnapshots(snapshots);
        console.log(`[Uproot] Updated profile snapshot for ${person.name}`);
        log$1.info(LogCategory.SERVICE, "Profile check completed", { personName: person.name });
      } catch (error) {
        console.error(`[Uproot] Error checking profile for ${person.name}:`, error);
        log$1.error(LogCategory.SERVICE, "Profile check failed", error, {
          personId: person.id,
          personName: person.name
        });
      }
    });
  }
  async function checkCompanyUpdates(company) {
    return log$1.trackAsync(LogCategory.SERVICE, "checkCompanyUpdates", async () => {
      console.log(`[Uproot] Checking updates for ${company.name}...`);
      log$1.debug(LogCategory.SERVICE, "Starting company updates check", {
        companyId: company.id,
        companyName: company.name
      });
      try {
        log$1.debug(LogCategory.SERVICE, "Scraping company updates from page");
        const currentUpdates = scrapeCompanyUpdates(company.companyUrl);
        if (currentUpdates.length === 0) {
          console.log(`[Uproot] No updates found for ${company.name}`);
          log$1.warn(LogCategory.SERVICE, "No updates found for company", { companyName: company.name });
          return;
        }
        log$1.info(LogCategory.SERVICE, `Scraped ${currentUpdates.length} current updates`);
        log$1.debug(LogCategory.SERVICE, "Retrieving previous updates snapshot");
        const snapshots = await getCompanySnapshots();
        const previousSnapshot = snapshots.get(company.id);
        log$1.debug(LogCategory.SERVICE, "Detecting new updates");
        const newUpdates = detectNewUpdates(currentUpdates, previousSnapshot);
        console.log(`[Uproot] Found ${newUpdates.length} new updates for ${company.name}`);
        log$1.info(LogCategory.SERVICE, `Detected ${newUpdates.length} new updates`, {
          companyName: company.name,
          totalUpdates: currentUpdates.length
        });
        log$1.debug(LogCategory.SERVICE, "Generating feed items for new updates");
        for (const update of newUpdates) {
          await generateCompanyUpdateFeedItem(update, company);
        }
        log$1.info(LogCategory.SERVICE, `Created ${newUpdates.length} company update feed items`);
        log$1.debug(LogCategory.SERVICE, "Updating company updates snapshot");
        snapshots.set(company.id, {
          companyId: company.id,
          lastChecked: Date.now(),
          updates: currentUpdates
        });
        await saveCompanySnapshots(snapshots);
        log$1.info(LogCategory.SERVICE, "Company updates check completed", { companyName: company.name });
      } catch (error) {
        console.error(`[Uproot] Error checking updates for ${company.name}:`, error);
        log$1.error(LogCategory.SERVICE, "Company updates check failed", error, {
          companyId: company.id,
          companyName: company.name
        });
      }
    });
  }
  function detectNewUpdates(currentUpdates, previousSnapshot) {
    if (!previousSnapshot) {
      return currentUpdates.slice(0, 1);
    }
    const previousUpdateIds = new Set(previousSnapshot.updates.map((u) => u.id));
    return currentUpdates.filter((update) => !previousUpdateIds.has(update.id));
  }
  async function generateCompanyUpdateFeedItem(update, company) {
    try {
      await addFeedItem({
        type: "company_update",
        timestamp: update.timestamp,
        read: false,
        title: "Company Update",
        description: update.preview,
        company: company.name,
        companyLogo: company.companyLogo ?? void 0,
        actionUrl: update.url,
        actionLabel: "See Post"
      });
      console.log(`[Uproot] Created feed item for ${company.name} update`);
    } catch (error) {
      console.error("[Uproot] Error generating company update feed item:", error);
    }
  }
  async function monitorCurrentPage(watchlistCompanies, watchlistPeople, preferences) {
    return log$1.trackAsync(LogCategory.SERVICE, "monitorCurrentPage", async () => {
      const currentUrl = window.location.href;
      console.log("[Uproot] Monitoring current page:", currentUrl);
      log$1.debug(LogCategory.SERVICE, "Starting page monitoring", {
        url: currentUrl,
        watchlistCompanies: watchlistCompanies.length,
        watchlistPeople: watchlistPeople.length
      });
      const companyId = getCompanyIdFromUrl(currentUrl);
      if (companyId) {
        log$1.debug(LogCategory.SERVICE, "Company page detected, checking watchlist", { companyId });
        const company = watchlistCompanies.find(
          (c) => c.companyUrl.includes(companyId)
        );
        if (company) {
          console.log(`[Uproot] On watchlisted company page: ${company.name}`);
          log$1.info(LogCategory.SERVICE, "Watchlisted company page detected", {
            companyName: company.name,
            jobAlertsEnabled: company.jobAlertEnabled
          });
          if (company.jobAlertEnabled && currentUrl.includes("/jobs")) {
            log$1.info(LogCategory.SERVICE, "Company jobs page detected, checking for new jobs");
            await checkCompanyJobs(company, preferences);
          }
          if (currentUrl.includes("/posts")) {
            log$1.info(LogCategory.SERVICE, "Company posts page detected, checking for updates");
            await checkCompanyUpdates(company);
          }
        } else {
          log$1.debug(LogCategory.SERVICE, "Company page not in watchlist");
        }
      }
      const profileUsername = getProfileUsernameFromUrl(currentUrl);
      if (profileUsername) {
        log$1.debug(LogCategory.SERVICE, "Profile page detected, checking watchlist", { profileUsername });
        const person = watchlistPeople.find(
          (p) => p.profileUrl.includes(profileUsername)
        );
        if (person) {
          console.log(`[Uproot] On watchlisted person page: ${person.name}`);
          log$1.info(LogCategory.SERVICE, "Watchlisted person page detected", { personName: person.name });
          await checkPersonProfile(person);
        } else {
          log$1.debug(LogCategory.SERVICE, "Profile page not in watchlist");
        }
      }
      log$1.info(LogCategory.SERVICE, "Page monitoring cycle completed");
    });
  }
  content;
  function querySelectorDeep(selector) {
    let element = document.querySelector(selector);
    if (element) return element;
    function searchShadowDOMRecursive(root) {
      const found = root.querySelector(selector);
      if (found) return found;
      const allElements = root.querySelectorAll("*");
      for (const el of allElements) {
        if (el.shadowRoot) {
          const shadowResult = searchShadowDOMRecursive(el.shadowRoot);
          if (shadowResult) return shadowResult;
        }
      }
      return null;
    }
    return searchShadowDOMRecursive(document);
  }
  function querySelectorAllDeep(selector) {
    const results = [];
    results.push(...Array.from(document.querySelectorAll(selector)));
    function searchShadowDOMRecursive(root) {
      results.push(...Array.from(root.querySelectorAll(selector)));
      const allElements = root.querySelectorAll("*");
      for (const el of allElements) {
        if (el.shadowRoot) {
          searchShadowDOMRecursive(el.shadowRoot);
        }
      }
    }
    searchShadowDOMRecursive(document);
    return results;
  }
  function tryExtractFromIframes(selector) {
    const iframes = document.querySelectorAll("iframe");
    for (const iframe of iframes) {
      try {
        if (iframe.contentDocument) {
          let searchIframeShadowDOM = function(doc) {
            const allElements = doc.querySelectorAll("*");
            for (const el of allElements) {
              if (el.shadowRoot) {
                const shadowElement = el.shadowRoot.querySelector(selector);
                if (shadowElement) return shadowElement;
                const nestedResult = searchIframeShadowDOM(el.shadowRoot);
                if (nestedResult) return nestedResult;
              }
            }
            return null;
          };
          const element = iframe.contentDocument.querySelector(selector);
          if (element) {
            console.log("[Uproot] Found content in iframe (main DOM):", iframe.src || "about:blank");
            return element;
          }
          const shadowResult = searchIframeShadowDOM(iframe.contentDocument);
          if (shadowResult) {
            console.log("[Uproot] Found content in iframe Shadow DOM:", iframe.src || "about:blank");
            return shadowResult;
          }
        }
      } catch (error) {
        console.debug("[Uproot] Cannot access iframe (cross-origin):", iframe.src, error);
      }
    }
    return null;
  }
  function extractAllVisibleText() {
    const allText = [];
    const skipSelectors = [
      "nav",
      "header",
      "footer",
      "aside",
      "button",
      "a",
      "svg",
      "img",
      ".global-nav",
      '[class*="navigation"]',
      '[class*="nav-"]',
      '[class*="header"]',
      '[class*="footer"]',
      '[class*="sidebar"]',
      '[class*="msg-overlay"]',
      '[class*="messaging"]',
      ".search-global-typeahead",
      '[class*="typeahead"]',
      '[role="navigation"]',
      '[role="banner"]',
      '[role="contentinfo"]',
      ".artdeco-modal",
      '[class*="modal"]',
      '[class*="popup"]',
      // LinkedIn-specific UI elements
      '[class*="job-card"]',
      '[class*="jobs-search"]',
      '[class*="jobs-unified-top-card"]',
      '[class*="artdeco-button"]',
      '[class*="jobs-apply"]',
      '[class*="job-details-jobs"]',
      '[class*="scaffold-layout"]',
      '[class*="jobs-save-button"]',
      '[class*="premium"]',
      '[class*="notification"]',
      "time",
      "[datetime]",
      '[class*="date"]',
      '[class*="time-badge"]',
      // Company info and social actions (LinkedIn right sidebar elements)
      '[data-view-name*="company"]',
      '[data-view-name*="interest"]',
      '[data-view-name*="follow"]',
      '[data-view-name*="social"]',
      '[aria-label*="Follow"]',
      '[aria-label*="Save"]',
      '[aria-label*="Share"]',
      // Result count and filter UI
      '[class*="results"]',
      '[class*="search-results"]',
      '[class*="filter"]',
      '[class*="sort"]',
      '[class*="promoted"]',
      '[class*="verified"]',
      // Job listing cards (not the selected job detail)
      'ul[class*="jobs-search__results"]',
      'li[class*="jobs-search-results__"]'
    ];
    const uiTextPatterns = [
      /^\d+\s+(week|weeks|day|days|month|months|year|years)\s+ago$/i,
      /^(easy|quick)\s+apply$/i,
      /^(follow|save|share|report|dismiss)$/i,
      /^(viewed|reviewed)\s+by\s+\d+/i,
      /^\d+\s+applicants?$/i,
      /^(promoted|verified|school alumni)/i,
      /^(learn more|show more|see more|see all)/i,
      /^i'm interested$/i,
      /^\d+\s+results/i,
      /^greater philadelphia/i,
      // Location filters
      /^how promoted jobs are chosen/i
    ];
    function isLinkedInUIText(text) {
      const lower = text.toLowerCase().trim();
      return uiTextPatterns.some((pattern) => pattern.test(lower)) || lower.includes("followers") || lower.includes("employees") || lower.includes("on linkedin");
    }
    function extractTextFromNode(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent?.trim();
        if (text && text.length > 0 && !isLinkedInUIText(text)) {
          allText.push(text);
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node;
        const tagName = element.tagName?.toLowerCase();
        if (["script", "style", "noscript", "iframe"].includes(tagName)) {
          return;
        }
        const className = element.className ? String(element.className) : "";
        const shouldSkip = skipSelectors.some((selector) => {
          if (selector.startsWith(".")) {
            return className.includes(selector.substring(1));
          } else if (selector.startsWith("[")) {
            if (selector.includes("role=")) {
              const role = element.getAttribute("role");
              return role && selector.includes(role);
            }
            if (selector.includes("class*=")) {
              const match = selector.match(/class\*="([^"]+)"/);
              return match && className.includes(match[1]);
            }
          }
          try {
            return element.matches(selector);
          } catch {
            return false;
          }
        });
        if (shouldSkip) {
          return;
        }
        for (const child of Array.from(node.childNodes)) {
          extractTextFromNode(child);
        }
        if (element.shadowRoot) {
          extractTextFromNode(element.shadowRoot);
        }
      }
    }
    const jobContainers = [
      ".scaffold-layout__detail",
      // Primary: Right panel in search results (SELECTED JOB)
      ".jobs-search__job-details",
      // Job details panel
      ".jobs-search__right-rail",
      // Right rail
      "div.jobs-search__job-details--container",
      // Job details wrapper
      '[class*="job-view"]',
      '[data-view-name="job-details"]',
      // Data attribute for job details
      'article[class*="job-details"]',
      // Job details article
      '[class*="job-details"]'
    ];
    let foundJobContainer = false;
    for (const selector of jobContainers) {
      const container = document.querySelector(selector);
      if (container && container.textContent && container.textContent.trim().length > 200) {
        console.log(`[Uproot] âœ… Using job container: ${selector} (${container.textContent.length} chars)`);
        extractTextFromNode(container);
        foundJobContainer = true;
        break;
      }
    }
    if (!foundJobContainer) {
      console.warn("[Uproot] âš ï¸ No specific job container found, using main (may include all jobs on page)");
      const mainContent = document.querySelector("main");
      if (mainContent) {
        extractTextFromNode(mainContent);
      } else {
        console.warn("[Uproot] âš ï¸ Main element not found, using body");
        extractTextFromNode(document.body);
      }
    }
    const iframes = document.querySelectorAll("iframe");
    for (const iframe of iframes) {
      try {
        if (iframe.contentDocument?.body) {
          extractTextFromNode(iframe.contentDocument.body);
        }
      } catch (error) {
      }
    }
    return allText.join(" ");
  }
  function isJobPage() {
    const url = window.location.href;
    const pathname = window.location.pathname;
    return url.includes("/jobs/view/") || pathname.startsWith("/jobs/view/") || pathname.includes("/jobs/collections/") || pathname.startsWith("/jobs/") && (url.includes("currentJobId=") || url.includes("jobId="));
  }
  function getJobId() {
    const url = window.location.href;
    const viewMatch = url.match(/\/jobs\/view\/(\d+)/);
    if (viewMatch) return viewMatch[1];
    const currentJobIdMatch = url.match(/currentJobId=(\d+)/);
    if (currentJobIdMatch) return currentJobIdMatch[1];
    const jobIdMatch = url.match(/jobId=(\d+)/);
    if (jobIdMatch) return jobIdMatch[1];
    return null;
  }
  function scrapeJobData() {
    const endTrace = log$1.trace(LogCategory.SERVICE, "scrapeJobData", {
      url: window.location.href
    });
    try {
      const currentUrl = window.location.href;
      console.log("[Uproot] Scraping job data from page...");
      console.log(`[Uproot] Current URL: ${currentUrl}`);
      log$1.debug(LogCategory.SERVICE, "Starting LinkedIn job page scrape", {
        url: currentUrl,
        pathname: window.location.pathname,
        timestamp: Date.now()
      });
      if (!isJobPage()) {
        console.log("[Uproot] Not a job page, skipping scrape");
        log$1.warn(LogCategory.SERVICE, "Not a LinkedIn job page, skipping scrape");
        endTrace();
        return null;
      }
      log$1.debug(LogCategory.SERVICE, "Confirmed job page, extracting job ID");
      const jobId = getJobId();
      if (!jobId) {
        console.error("[Uproot] Could not extract job ID");
        log$1.error(LogCategory.SERVICE, "Failed to extract job ID from URL", new Error("No job ID found"));
        endTrace();
        return null;
      }
      console.log(`[Uproot] âœ… Extracted job ID: ${jobId}`);
      log$1.info(LogCategory.SERVICE, `Extracted job ID: ${jobId}`);
      console.log("[Uproot] Waiting 100ms for DOM to settle before extraction...");
      log$1.debug(LogCategory.SERVICE, "Extracting job title from DOM (fresh query)");
      const jobTitle = extractJobTitle();
      if (!jobTitle) {
        console.error("[Uproot] Could not extract job title");
        log$1.error(LogCategory.SERVICE, "Failed to extract job title", new Error("No job title found"));
        endTrace();
        return null;
      }
      console.log(`[Uproot] âœ… Extracted job title: "${jobTitle}"`);
      log$1.info(LogCategory.SERVICE, `Extracted job title: ${jobTitle}`);
      log$1.debug(LogCategory.SERVICE, "Extracting company name from DOM (fresh query)");
      const company = extractCompanyName();
      if (!company) {
        console.error("[Uproot] Could not extract company name");
        log$1.error(LogCategory.SERVICE, "Failed to extract company name", new Error("No company name found"));
        endTrace();
        return null;
      }
      console.log(`[Uproot] âœ… Extracted company: "${company}"`);
      log$1.info(LogCategory.SERVICE, `Extracted company: ${company}`);
      log$1.debug(LogCategory.SERVICE, "Extracting location from DOM");
      const location2 = extractLocation();
      if (location2) {
        console.log(`[Uproot] âœ… Extracted location: "${location2}"`);
        log$1.info(LogCategory.SERVICE, `Extracted location: ${location2}`);
      } else {
        console.log("[Uproot] âš ï¸ Location not found (optional field)");
        log$1.debug(LogCategory.SERVICE, "Location not found (this is optional)");
      }
      log$1.debug(LogCategory.SERVICE, "Extracting job description from DOM (fresh query)");
      const description = extractDescription();
      if (!description) {
        console.warn("[Uproot] Could not extract job description, continuing with partial data");
        log$1.warn(LogCategory.SERVICE, "Job description not found, returning partial data");
      } else {
        const preview = description.substring(0, 100).replace(/\s+/g, " ");
        console.log(`[Uproot] âœ… Extracted description (${description.length} chars): "${preview}..."`);
        log$1.info(LogCategory.SERVICE, "Extracted job description", {
          length: description.length,
          wordCount: description.split(/\s+/).length,
          preview
        });
      }
      log$1.debug(LogCategory.SERVICE, "Extracting additional metadata");
      const postedDate = extractPostedDate();
      const employmentType = extractEmploymentType();
      const seniorityLevel = extractSeniorityLevel();
      log$1.info(LogCategory.SERVICE, "Metadata extracted", {
        postedDate: postedDate || "N/A",
        employmentType: employmentType || "N/A",
        seniorityLevel: seniorityLevel || "N/A"
      });
      const jobData = {
        jobTitle,
        company,
        location: location2,
        description,
        url: currentUrl,
        // Use current URL, not window.location.href (could have changed)
        jobId,
        postedDate,
        employmentType,
        seniorityLevel
      };
      console.log("[Uproot] âœ… Successfully scraped job data:");
      console.log(`  - Job ID: ${jobData.jobId}`);
      console.log(`  - Title: ${jobData.jobTitle}`);
      console.log(`  - Company: ${jobData.company}`);
      console.log(`  - Location: ${jobData.location || "N/A"}`);
      console.log(`  - Description: ${jobData.description?.length || 0} chars`);
      console.log(`  - URL: ${jobData.url}`);
      log$1.info(LogCategory.SERVICE, "Job scraping completed successfully", {
        jobId,
        jobTitle,
        company,
        hasDescription: !!description,
        descriptionLength: description?.length || 0,
        url: currentUrl
      });
      endTrace();
      return jobData;
    } catch (error) {
      console.error("[Uproot] Error scraping job data:", error);
      log$1.error(LogCategory.SERVICE, "Job scraping failed", error, {
        url: window.location.href
      });
      endTrace();
      return null;
    }
  }
  function isValidJobTitle(title) {
    const skipPatterns = [
      /^(WHAT|WHY|WHO|HOW|WHERE|WHEN)\s/i,
      // Section headers
      /MAKES US DIFFERENT/i,
      /ABOUT (US|THE|THIS|THE JOB)/i,
      // "About the Job"
      /^About the Job$/i,
      // Exact match for "About the Job"
      /OUR (MISSION|VISION|VALUES|CULTURE|TEAM)/i,
      /BENEFITS AND/i,
      /SIGN IN|LOG IN|JOIN NOW/i,
      /Skip to main content/i,
      /notification/i,
      /My Network/i,
      /Messaging/i,
      /For Business/i,
      /Premium/i,
      /GET STARTED/i,
      /LEARN MORE/i,
      /APPLY NOW/i,
      /^\d+\s*(years?|months?|days?)/i,
      // Time periods
      /^\d+\s*applications?/i,
      // Application counts
      // UI noise patterns
      /^\d+\s+notifications?/i,
      // "0 notifications", "5 notifications"
      /notifications?\s+(total|unread)/i,
      // "notifications total"
      /viewed|posted|reviewed|active/i,
      // Status indicators
      /applicants?|connections?|benefits?/i,
      // UI labels
      /reactivate|cancel|upgrade/i,
      // Action buttons
      /\(verified\s+job\)/i,
      // Badge labels
      /^(on-site|remote|hybrid)$/i,
      // Standalone location types
      // LinkedIn UI noise patterns (Nov 2024)
      /people you can reach out to/i,
      // Networking suggestions â­
      /meet the (hiring )?team/i,
      // "Meet the team", "Meet the hiring team"
      /^(skills?|qualifications?)$/i,
      // Section headers
      /^(company|job) (highlights?|description)$/i,
      // Section headers
      /^see (more|less)$/i,
      // Expand/collapse buttons
      /^show (more|less|all)$/i,
      // Show more buttons
      /^save( this)?( job)?$/i,
      // Save job button
      /^share( this)?( job)?$/i,
      // Share job button
      /^report( this)?( job)?$/i,
      // Report job button
      /^(easy )?apply$/i,
      // Apply button
      /^(save|share|report|apply|dismiss)$/i,
      // Action buttons
      /^\d+\s+(applicants?|views?)$/i,
      // Stats like "50 applicants"
      /be among the first/i,
      // Application prompts
      /^(you|your) (network|connections?|profile)$/i
      // User-specific sections
    ];
    if (!title || title.length < 3 || title.length > 150) {
      return false;
    }
    if (skipPatterns.some((pattern) => pattern.test(title))) {
      return false;
    }
    return true;
  }
  function extractJobTitle() {
    console.log("[Uproot] Trying expandable-text-box parent container for job title...");
    const expandableBox = document.querySelector('[data-testid="expandable-text-box"]');
    if (expandableBox) {
      console.log("[Uproot] Found expandable-text-box, searching parent containers for job title...");
      let parent = expandableBox.parentElement;
      let depth = 0;
      while (parent && depth < 10) {
        const headings = parent.querySelectorAll("h1, h2");
        for (const heading of Array.from(headings)) {
          if (heading?.textContent?.trim()) {
            const title = heading.textContent.trim();
            if (isValidJobTitle(title)) {
              console.log(`[Uproot] âœ… Found job title in expandable-text-box parent (depth ${depth}): "${title}"`);
              return title;
            } else {
              console.log(`[Uproot] Skipping invalid title at depth ${depth}: "${title}"`);
            }
          }
        }
        parent = parent.parentElement;
        depth++;
      }
      console.log("[Uproot] Searched 10 parent levels, no valid job title found");
    }
    console.log("[Uproot] Trying ARIA label extraction for job title...");
    const jobDetailContainers = [
      ".scaffold-layout__detail",
      // Right panel in search results
      ".jobs-search__job-details",
      // Job details panel
      ".jobs-unified-top-card",
      // Top card in job view
      ".job-details-jobs-unified-top-card"
      // Legacy top card
    ];
    for (const containerSelector of jobDetailContainers) {
      const container = document.querySelector(containerSelector);
      if (container) {
        console.log(`[Uproot] Checking for dismiss button in ${containerSelector}...`);
        const dismissButton = container.querySelector('[aria-label*="Dismiss"][aria-label*="job" i]');
        if (dismissButton) {
          const ariaLabel = dismissButton.getAttribute("aria-label");
          if (ariaLabel) {
            const match = ariaLabel.match(/^Dismiss\s+(.+?)\s+job$/i);
            if (match && match[1]) {
              const jobTitle = match[1].trim();
              if (jobTitle.length > 3 && jobTitle.length < 150) {
                console.log(`[Uproot] âœ… Found job title using ARIA label in ${containerSelector}: "${jobTitle}"`);
                return jobTitle;
              }
            }
          }
        }
      }
    }
    console.log("[Uproot] Trying to extract job title from job card in list...");
    const urlMatch = window.location.href.match(/currentJobId=(\d+)/);
    if (urlMatch) {
      const jobId = urlMatch[1];
      console.log(`[Uproot] Extracted job ID from URL: ${jobId}`);
      const jobCardSelectors = [
        `[data-job-id="${jobId}"]`,
        `[data-occludable-job-id="${jobId}"]`,
        `li[data-occludable-entity-urn*="${jobId}"]`,
        `div[data-job-id="${jobId}"]`
      ];
      for (const selector of jobCardSelectors) {
        const jobCard = document.querySelector(selector);
        if (jobCard) {
          console.log(`[Uproot] âœ… Found job card using selector: ${selector}`);
          const titleSelectors = [
            ".job-card-list__title",
            "a.job-card-list__title",
            ".job-card-container__link",
            "h3",
            "strong",
            '[class*="title"]'
          ];
          for (const titleSelector of titleSelectors) {
            const titleElement = jobCard.querySelector(titleSelector);
            if (titleElement?.textContent?.trim()) {
              const title = titleElement.textContent.trim();
              if (isValidJobTitle(title)) {
                console.log(`[Uproot] âœ… Found job title in job card: "${title}"`);
                return title;
              }
            }
          }
        }
      }
    }
    console.log("[Uproot] No job card found, trying document.title...");
    if (document.title) {
      const titleMatch = document.title.match(/^(.+?)\s+[\|\-]\s+.+?\s+\|\s+LinkedIn$/);
      if (titleMatch && titleMatch[1]) {
        const title = titleMatch[1].trim();
        if (isValidJobTitle(title)) {
          console.log(`[Uproot] âœ… Found job title in document.title: "${title}"`);
          return title;
        }
      }
    }
    console.log("[Uproot] document.title didn't work, trying h1/h2 in job containers...");
    for (const containerSelector of jobDetailContainers) {
      const container = document.querySelector(containerSelector);
      if (container) {
        const headings = container.querySelectorAll("h1, h2");
        console.log(`[Uproot] Found ${headings.length} h1/h2 elements in ${containerSelector}`);
        for (const heading of Array.from(headings)) {
          if (heading?.textContent?.trim()) {
            const title = heading.textContent.trim();
            if (isValidJobTitle(title)) {
              console.log(`[Uproot] âœ… Found job title in ${containerSelector} h1/h2: "${title}"`);
              return title;
            } else {
              console.log(`[Uproot] Skipping invalid title in ${containerSelector}: "${title}"`);
            }
          }
        }
      }
    }
    console.log("[Uproot] âš ï¸ ARIA label extraction failed, falling back to legacy selectors...");
    const selectors = [
      // Direct job view - legacy stable selectors
      ".job-details-jobs-unified-top-card__job-title h1",
      ".t-24.job-details-jobs-unified-top-card__job-title",
      "h1.t-24",
      "h1.job-title",
      // Direct job view variants
      "h1.job-details-jobs-unified-top-card__job-title",
      "h2.job-details-jobs-unified-top-card__job-title",
      ".job-details-jobs-unified-top-card__job-title",
      ".jobs-unified-top-card__job-title",
      "h1.jobs-unified-top-card__job-title",
      ".jobs-details h1",
      // Search results / list view selectors
      ".artdeco-entity-lockup__title",
      ".artdeco-entity-lockup__title a",
      ".job-card-list__title",
      ".job-card-list__title--link",
      "a.job-card-list__title--link",
      "a.job-card-list__title",
      ".job-card-container__title",
      // Public layout selectors
      ".jobs-search-results__list-item h3",
      ".base-search-card__title",
      // Modern LinkedIn selectors (2024+)
      '[class*="jobs-unified-top-card"] h1',
      '[class*="job-details"] h1',
      '[class*="top-card"] [class*="job-title"]',
      'div[class*="top-card__title"]',
      "[data-job-id] h1",
      "[data-job-id] h2"
    ];
    for (const selector of selectors) {
      let element = document.querySelector(selector);
      if (!element) {
        element = querySelectorDeep(selector);
      }
      if (element?.textContent?.trim()) {
        const source = element !== document.querySelector(selector) ? " (Shadow DOM/iframe)" : "";
        console.log(`[Uproot] Found job title using selector: ${selector}${source}`);
        return element.textContent.trim();
      }
    }
    let topCard = document.querySelector(".jobs-unified-top-card, .job-details-jobs-unified-top-card");
    if (!topCard) {
      topCard = querySelectorDeep(".jobs-unified-top-card, .job-details-jobs-unified-top-card");
    }
    if (topCard) {
      let h1 = topCard.querySelector("h1, h2");
      if (!h1 && topCard.shadowRoot) {
        h1 = topCard.shadowRoot.querySelector("h1, h2");
      }
      if (h1?.textContent?.trim()) {
        console.log("[Uproot] Found job title using fallback h1/h2 in top card");
        return h1.textContent.trim();
      }
    }
    console.warn("[Uproot] All job title selectors failed, trying ULTIMATE FALLBACK...");
    try {
      const allText = extractAllVisibleText();
      const lines = allText.split("\n").map((l) => l.trim()).filter((l) => l.length > 5 && l.length < 100);
      const jobTitleKeywords = [
        "engineer",
        "developer",
        "manager",
        "analyst",
        "designer",
        "architect",
        "scientist",
        "specialist",
        "consultant",
        "coordinator",
        "director",
        "lead",
        "senior",
        "junior",
        "associate",
        "assistant",
        "intern",
        "administrator",
        "technician",
        "representative",
        "officer",
        "executive"
      ];
      for (let i = 0; i < Math.min(lines.length, 30); i++) {
        const line = lines[i];
        const lowerLine = line.toLowerCase();
        if (!isValidJobTitle(line)) {
          continue;
        }
        if (line === line.toUpperCase() && line.length > 3) {
          continue;
        }
        if ((line.match(/[â€¢|Â·]/g) || []).length > 1) {
          continue;
        }
        if (/^[A-Z]/.test(line)) {
          const hasJobKeyword = jobTitleKeywords.some((keyword) => lowerLine.includes(keyword));
          if (hasJobKeyword) {
            console.warn(`[Uproot] ULTIMATE FALLBACK: Using "${line}" as job title (matched keyword)`);
            return line;
          }
        }
      }
    } catch (error) {
      console.error("[Uproot] ULTIMATE FALLBACK failed:", error);
    }
    console.error(`[Uproot] âŒ No job title found. Selectors tried (${selectors.length}):`, selectors.join(", "));
    return "";
  }
  function extractCompanyName() {
    const selectors = [
      // ===== PROVEN SELECTORS (from real-world scrapers) =====
      // Direct job view - most reliable (used by multiple production scrapers)
      ".job-details-jobs-unified-top-card__company-name a",
      ".jobs-details-top-card__company-url",
      ".job-details-jobs-unified-top-card__company-name",
      "a.topcard__org-name-link",
      // ===== EXTENDED COVERAGE =====
      // Direct job view variants
      'a.app-aware-link[href*="/company/"]',
      ".jobs-unified-top-card__company-name",
      'a[data-tracking-control-name="public_jobs_topcard-org-name"]',
      ".topcard__org-name-link",
      ".job-details-jobs-unified-top-card__primary-description a",
      "a.jobs-unified-top-card__company-name",
      // Search results / list view selectors (logged-in scaffold layout)
      ".artdeco-entity-lockup__subtitle",
      '.artdeco-entity-lockup__subtitle div[dir="ltr"]',
      ".job-card-container__company-name",
      "a.job-card-container__company-name",
      // Public layout selectors
      ".base-search-card__subtitle",
      ".job-card-container__primary-description",
      // Modern LinkedIn selectors (2024+)
      '[class*="jobs-unified-top-card"] [class*="company"]',
      '[class*="job-details"] [class*="company"]',
      '[class*="top-card"] a[href*="/company/"]',
      '[data-job-id] [class*="company"]',
      'a[href*="/company/"]',
      // Flexible attribute selectors
      '[class*="company-name"]',
      '[class*="org-name"]'
    ];
    for (const selector of selectors) {
      let element = document.querySelector(selector);
      if (!element) {
        element = querySelectorDeep(selector);
      }
      if (!element) {
        element = tryExtractFromIframes(selector);
      }
      if (element?.textContent?.trim()) {
        const source = element !== document.querySelector(selector) ? " (Shadow DOM/iframe)" : "";
        console.log(`[Uproot] Found company name using selector: ${selector}${source}`);
        return element.textContent.trim();
      }
    }
    let topCard = document.querySelector(".jobs-unified-top-card, .job-details-jobs-unified-top-card");
    if (!topCard) {
      topCard = querySelectorDeep(".jobs-unified-top-card, .job-details-jobs-unified-top-card");
    }
    if (topCard) {
      let companyLink = topCard.querySelector('a[href*="/company/"]');
      if (!companyLink && topCard.shadowRoot) {
        companyLink = topCard.shadowRoot.querySelector('a[href*="/company/"]');
      }
      if (companyLink?.textContent?.trim()) {
        console.log("[Uproot] Found company name using fallback company link");
        return companyLink.textContent.trim();
      }
    }
    console.warn("[Uproot] All company selectors failed, trying ULTIMATE FALLBACK...");
    try {
      const allText = extractAllVisibleText();
      const lines = allText.split("\n").map((l) => l.trim()).filter((l) => l.length > 2 && l.length < 80);
      const companyIndicators = [
        "Inc",
        "LLC",
        "Corp",
        "Ltd",
        "Limited",
        "Company",
        "Co.",
        "Corporation",
        "Incorporated",
        "GmbH",
        "AG",
        "SA",
        "PLC"
      ];
      const skipPatterns = [
        /Skip to/i,
        /notification/i,
        /Messaging/i,
        /My Network/i,
        /For Business/i,
        /Premium/i,
        /^(WHAT|WHY|WHO|HOW|WHERE|WHEN)\s/i,
        /MAKES US DIFFERENT/i,
        /ABOUT (US|THE|THIS)/i,
        /OUR (MISSION|VISION|VALUES|CULTURE|TEAM)/i,
        /SIGN IN|LOG IN|JOIN NOW/i,
        /GET STARTED/i,
        /LEARN MORE/i,
        /APPLY NOW/i,
        /^\d+\s*(years?|months?|days?|employees?|applicants?)/i
      ];
      const jobTitleKeywords = [
        "engineer",
        "developer",
        "manager",
        "analyst",
        "designer",
        "architect",
        "scientist",
        "specialist",
        "consultant",
        "coordinator",
        "director",
        "lead",
        "senior",
        "junior",
        "associate",
        "assistant",
        "intern",
        "administrator",
        "technician",
        "representative",
        "officer",
        "executive"
      ];
      for (let i = 0; i < Math.min(lines.length, 40); i++) {
        const line = lines[i];
        const lowerLine = line.toLowerCase();
        if (skipPatterns.some((pattern) => pattern.test(line))) {
          continue;
        }
        if (line === line.toUpperCase() && line.length > 3) {
          continue;
        }
        if ((line.match(/[â€¢|Â·]/g) || []).length > 1) {
          continue;
        }
        const looksLikeJobTitle = jobTitleKeywords.some((keyword) => lowerLine.includes(keyword));
        if (looksLikeJobTitle) {
          continue;
        }
        const hasCompanyIndicator = companyIndicators.some(
          (indicator) => line.includes(indicator) || line.endsWith(indicator + ".") || line.endsWith(indicator)
        );
        if (hasCompanyIndicator && /^[A-Z]/.test(line) && !line.includes("â€¢")) {
          console.warn(`[Uproot] ULTIMATE FALLBACK: Using "${line}" as company name (has indicator)`);
          return line;
        }
        if (i < 15 && /^[A-Z]/.test(line)) {
          const wordCount = line.split(/\s+/).length;
          if (wordCount >= 1 && wordCount <= 5) {
            const marketingKeywords = [
              /^Your\s/i,
              /^Our\s/i,
              /^My\s/i,
              /^Their\s/i,
              /\.$/,
              /\!$/,
              /\?$/,
              // Ends with sentence punctuation
              /tomorrow/i,
              /priority/i,
              /mission/i,
              /vision/i,
              /future/i,
              /success/i,
              /difference/i,
              /journey/i
            ];
            const isMarketingText = marketingKeywords.some((pattern) => pattern.test(line));
            if (isMarketingText) {
              continue;
            }
            const locationKeywords = [
              "Remote",
              "Hybrid",
              "On-site",
              "United States",
              "California",
              "New York",
              "Texas",
              "Florida",
              "London",
              "Toronto",
              "Onsite"
            ];
            const isLocation = locationKeywords.some((loc) => line.includes(loc));
            if (isLocation) {
              continue;
            }
            console.warn(`[Uproot] ULTIMATE FALLBACK: Using "${line}" as company name (reasonable format, position ${i})`);
            return line;
          }
        }
      }
    } catch (error) {
      console.error("[Uproot] ULTIMATE FALLBACK failed:", error);
    }
    console.error(`[Uproot] âŒ No company name found. Selectors tried (${selectors.length}):`, selectors.join(", "));
    return "";
  }
  function extractLocation() {
    const selectors = [
      ".job-details-jobs-unified-top-card__bullet",
      ".jobs-unified-top-card__bullet",
      'span[class*="location"]',
      ".topcard__flavor--bullet"
    ];
    for (const selector of selectors) {
      let element = document.querySelector(selector);
      if (!element) {
        element = querySelectorDeep(selector);
      }
      if (!element) {
        element = tryExtractFromIframes(selector);
      }
      if (element?.textContent?.trim()) {
        return element.textContent.trim();
      }
    }
    return "";
  }
  function extractDescription() {
    console.log("[Uproot] Starting description extraction...");
    const stableSelectors = [
      // âœ¨ HIGHEST PRIORITY: LinkedIn's expandable text box (Nov 2024)
      '[data-testid="expandable-text-box"]',
      // Direct job description container
      // CRITICAL: Selected job detail panel (RIGHT SIDE of search results)
      // These target the SPECIFIC job being viewed, not the entire page
      ".scaffold-layout__detail",
      // Primary: Right panel in job search results
      ".jobs-search__job-details",
      // Job details container
      ".jobs-search__right-rail",
      // Right rail container
      "div.jobs-search__job-details--container",
      // Job details wrapper
      // Data attribute selectors (LinkedIn uses these for state management)
      "[data-job-id]",
      '[data-view-name="job-details"]',
      '[data-view-name*="job"]',
      '[data-view-name*="description"]',
      // ARIA-based selectors (WCAG compliance, stable)
      '[role="main"] article',
      // Article within main (more specific than just main)
      '[role="article"]',
      'article[class*="job"]',
      'main article[class*="job"]',
      // ID-based selectors (more stable than classes)
      "#job-details",
      "div#job-details"
      // LAST RESORT: Broader selectors (WARNING: May include job list + filters)
      // Commented out 'main' alone as it's too broad
      // 'main', // â† Removed: Extracts entire page including all jobs
    ];
    console.log("[Uproot] Trying data attributes and semantic selectors...");
    for (const selector of stableSelectors) {
      let element = document.querySelector(selector);
      if (!element) {
        element = querySelectorDeep(selector);
      }
      if (element?.textContent?.trim()) {
        let text = element.textContent.trim().replace(/\s+/g, " ").replace(/Show (more|less)/gi, "");
        if (text.length > 200) {
          console.log(`[Uproot] âœ… Found description using ARIA/semantic selector: ${selector} (${text.length} chars)`);
          return text;
        }
      }
    }
    console.log("[Uproot] ARIA selectors failed, trying legacy CSS classes...");
    const legacySelectors = [
      ".jobs-description__content .jobs-box__html-content",
      ".jobs-description-content__text",
      ".show-more-less-html__markup",
      ".jobs-description__content",
      ".job-details-jobs-unified-description__content",
      ".jobs-box__html-content",
      "article.jobs-description",
      'div[class*="job-description"]',
      'div[class*="description-content"]'
    ];
    for (const selector of legacySelectors) {
      let element = document.querySelector(selector);
      if (!element) {
        element = querySelectorDeep(selector);
      }
      if (!element) {
        element = tryExtractFromIframes(selector);
      }
      if (element?.textContent?.trim()) {
        let text = element.textContent.trim();
        text = text.replace(/\s+/g, " ");
        text = text.replace(/Show (more|less)/gi, "");
        if (text.length > 100) {
          const source = element !== document.querySelector(selector) ? " (Shadow DOM or iframe)" : "";
          console.log(`[Uproot] âœ… Found description using selector: ${selector}${source} (${text.length} chars)`);
          return text;
        }
      }
    }
    console.warn("[Uproot] Primary selectors failed, trying fallback: collect all description elements...");
    const allDescriptionElements = querySelectorAllDeep('div[class*="description"]');
    if (allDescriptionElements.length > 0) {
      console.log(`[Uproot] Found ${allDescriptionElements.length} description elements, combining text...`);
      const combinedText = allDescriptionElements.map((el) => el.textContent?.trim() || "").filter((text) => text.length > 50).join(" ").replace(/\s+/g, " ").replace(/Show (more|less)/gi, "");
      if (combinedText.length > 100) {
        console.log(`[Uproot] âœ… Fallback 1 succeeded: combined ${allDescriptionElements.length} elements (${combinedText.length} chars)`);
        return combinedText;
      }
    }
    console.warn("[Uproot] Fallback 1 failed, trying fallback 2: extract all visible text...");
    const allText = extractAllVisibleText();
    if (allText.length > 200) {
      console.log(`[Uproot] âš ï¸ Fallback 2 succeeded: extracted all visible text (${allText.length} chars)`);
      console.warn("[Uproot] WARNING: Using all page text as fallback - may include non-description content");
      const lines = allText.split(/[.!?]+/).filter((line) => {
        const l = line.toLowerCase();
        const uiNoisePatterns = [
          /notification|messaging|premium|upgrade/i,
          /viewed|posted|reviewed|applicants?/i,
          /reactivate|cancel|sign in|log in/i,
          /connection works here/i,
          /actively reviewing/i,
          /\d+\s+(benefits?|years?|months?)/i
        ];
        if (uiNoisePatterns.some((pattern) => pattern.test(line))) {
          return false;
        }
        return l.length > 30 && (l.includes("experience") || l.includes("skill") || l.includes("require") || l.includes("responsible") || l.includes("qualifications") || l.includes("you will") || l.includes("we are looking") || l.includes("duties") || l.includes("background") || l.includes("knowledge"));
      });
      if (lines.length > 0) {
        const filteredText = lines.join(". ").trim();
        console.log(`[Uproot] âœ… Filtered fallback text to ${filteredText.length} chars from ${lines.length} relevant sentences`);
        return filteredText;
      }
      console.log("[Uproot] âš ï¸ Returning unfiltered page text as last resort");
      return allText.substring(0, 5e3);
    }
    const allSelectors = [...stableSelectors, ...legacySelectors];
    console.error(`[Uproot] âŒ All extraction methods failed. Selectors tried (${allSelectors.length}):`, allSelectors.join(", "));
    return "";
  }
  function extractPostedDate() {
    const selectors = [
      ".jobs-unified-top-card__posted-date",
      'span[class*="posted"]',
      ".topcard__flavor--metadata"
    ];
    for (const selector of selectors) {
      let element = document.querySelector(selector);
      if (!element) {
        element = querySelectorDeep(selector);
      }
      if (!element) {
        element = tryExtractFromIframes(selector);
      }
      if (element?.textContent?.trim()) {
        return element.textContent.trim();
      }
    }
    return void 0;
  }
  function extractEmploymentType() {
    const selectors = [
      'li.jobs-unified-top-card__job-insight span[class*="employment"]',
      'span[class*="employment-type"]'
    ];
    for (const selector of selectors) {
      let element = document.querySelector(selector);
      if (!element) {
        element = querySelectorDeep(selector);
      }
      if (!element) {
        element = tryExtractFromIframes(selector);
      }
      if (element?.textContent?.trim()) {
        return element.textContent.trim();
      }
    }
    let insights = Array.from(document.querySelectorAll(".jobs-unified-top-card__job-insight"));
    if (insights.length === 0) {
      insights = querySelectorAllDeep(".jobs-unified-top-card__job-insight");
    }
    for (const insight of insights) {
      const text = insight.textContent?.trim() || "";
      if (text.includes("Full-time") || text.includes("Part-time") || text.includes("Contract") || text.includes("Temporary") || text.includes("Internship")) {
        return text;
      }
    }
    return void 0;
  }
  function extractSeniorityLevel() {
    const selectors = [
      'li.jobs-unified-top-card__job-insight span[class*="seniority"]',
      'span[class*="seniority-level"]'
    ];
    for (const selector of selectors) {
      let element = document.querySelector(selector);
      if (!element) {
        element = querySelectorDeep(selector);
      }
      if (!element) {
        element = tryExtractFromIframes(selector);
      }
      if (element?.textContent?.trim()) {
        return element.textContent.trim();
      }
    }
    let insights = Array.from(document.querySelectorAll(".jobs-unified-top-card__job-insight"));
    if (insights.length === 0) {
      insights = querySelectorAllDeep(".jobs-unified-top-card__job-insight");
    }
    for (const insight of insights) {
      const text = insight.textContent?.trim() || "";
      if (text.includes("Entry level") || text.includes("Mid-Senior level") || text.includes("Director") || text.includes("Executive") || text.includes("Internship")) {
        return text;
      }
    }
    return void 0;
  }
  function isSearchResultsPage() {
    const url = window.location.href;
    return url.includes("/jobs/search-results/") || url.includes("/jobs/") && url.includes("currentJobId=") && !url.includes("/jobs/view/");
  }
  function tryExpandDescription() {
    const descriptionContainers = [
      ".jobs-description",
      ".job-details-jobs-unified-description__content",
      ".jobs-description__content",
      ".show-more-less-html",
      "article.jobs-description"
    ];
    console.log("[Uproot] Attempting to find job description Show More button...");
    for (const containerSelector of descriptionContainers) {
      const container = document.querySelector(containerSelector);
      if (container) {
        const showMoreSelectors = [
          "button.show-more-less-html__button",
          "button.show-more-less-html__button--more",
          "button.jobs-description__footer-button",
          'button[aria-label="Show more"]',
          'button[aria-label="See more description"]'
        ];
        for (const buttonSelector of showMoreSelectors) {
          const button = container.querySelector(buttonSelector);
          if (button && !button.disabled && button.offsetParent !== null) {
            console.log(`[Uproot] âœ… Found job description Show More button: ${containerSelector} > ${buttonSelector}`);
            button.focus();
            button.click();
            return true;
          }
        }
      }
    }
    const specificButtons = [
      "button.show-more-less-html__button--more",
      'button.show-more-less-html__button[aria-expanded="false"]',
      ".jobs-description button.show-more-less-html__button"
    ];
    for (const selector of specificButtons) {
      try {
        const button = document.querySelector(selector);
        if (button && !button.disabled && button.offsetParent !== null) {
          console.log(`[Uproot] âœ… Found Show More button via specific selector: ${selector}`);
          button.focus();
          button.click();
          return true;
        }
      } catch (error) {
        console.debug(`[Uproot] Selector "${selector}" failed:`, error);
      }
    }
    console.log("[Uproot] â„¹ï¸ No job description Show More button found (description may already be expanded)");
    return false;
  }
  async function waitForJobDetails(timeout) {
    return log$1.trackAsync(LogCategory.SERVICE, "waitForJobDetails", async () => {
      const isSearchResults = isSearchResultsPage();
      const effectiveTimeout = isSearchResults ? 25e3 : 18e3;
      const minLength = isSearchResults ? 50 : 100;
      log$1.debug(LogCategory.SERVICE, "Waiting for job details to load", {
        timeout: effectiveTimeout,
        pageType: isSearchResults ? "search-results" : "direct-view",
        minLength
      });
      const startTime = Date.now();
      let attempts = 0;
      let expandAttempted = false;
      const descriptionSelectors = [
        // âœ¨ HIGHEST PRIORITY: LinkedIn's expandable text box (Nov 2024+)
        '[data-testid="expandable-text-box"]',
        // Direct job description container
        // âœ¨ CRITICAL: Job-specific containers (SELECTED JOB ONLY - highest priority)
        // These target the RIGHT PANEL in search results, not the entire page
        ".scaffold-layout__detail",
        // Primary: Right panel containing selected job
        ".jobs-search__job-details",
        // Job details container
        ".jobs-search__right-rail",
        // Right rail container
        "div.jobs-search__job-details--container",
        // Job details wrapper
        // Original selectors (work for /jobs/view/ pages)
        ".show-more-less-html__markup",
        ".jobs-description__content",
        ".job-details-jobs-unified-description__content",
        ".jobs-box__html-content",
        "#job-details",
        "article.jobs-description",
        ".jobs-description-content__text",
        'div[class*="job-description"]',
        'div[class*="description-content"]',
        // Search-results specific selectors
        ".jobs-search__job-details--main-content",
        ".jobs-details-top-card__job-description",
        ".jobs-description",
        ".job-view-layout-main-column",
        ".jobs-unified-top-card__job-description",
        "[data-job-id] .jobs-description",
        ".scaffold-layout__detail .jobs-description",
        ".jobs-details__main-content",
        // Modern LinkedIn selectors (2024+)
        '[class*="jobs-description"]',
        '[class*="job-details"] [class*="description"]',
        '[data-job-id] [class*="description"]',
        'div[class*="show-more-less-html"]',
        '[class*="job-view"] [class*="description"]',
        'article[class*="description"]'
      ];
      console.group("[Uproot] DOM Structure Analysis at Start");
      console.log("[Uproot] Current URL:", window.location.href);
      console.log("[Uproot] Page Type:", isSearchResults ? "search-results" : "direct-view");
      const allJobElements = document.querySelectorAll('[class*="job"], [class*="description"]');
      console.log(`[Uproot] Found ${allJobElements.length} job-related elements on page`);
      const sampleClasses = Array.from(allJobElements).slice(0, 10).map((el) => ({
        tag: el.tagName,
        className: el.className,
        hasText: (el.textContent?.trim().length || 0) > 0,
        textLength: el.textContent?.trim().length || 0
      }));
      console.log("[Uproot] Sample job elements (first 10):", sampleClasses);
      let shadowRoots = 0;
      const shadowHosts = [];
      document.querySelectorAll("*").forEach((el) => {
        if (el.shadowRoot) {
          shadowRoots++;
          shadowHosts.push({
            tag: el.tagName,
            className: el.className,
            mode: el.shadowRoot.mode || "unknown"
          });
        }
      });
      if (shadowRoots > 0) {
        console.log(`[Uproot] Detected ${shadowRoots} Shadow DOM roots - using RECURSIVE search`);
        console.log("[Uproot] Shadow DOM hosts:", shadowHosts);
        const closedRoots = shadowHosts.filter((h) => h.mode === "closed");
        if (closedRoots.length > 0) {
          console.error(`[Uproot] âš ï¸ WARNING: ${closedRoots.length} CLOSED Shadow DOM roots detected - content is inaccessible!`);
          console.error("[Uproot] Closed Shadow DOM hosts:", closedRoots);
        }
      } else {
        console.log("[Uproot] No Shadow DOM detected");
      }
      const iframes = document.querySelectorAll("iframe");
      if (iframes.length > 0) {
        let crossOriginCount = 0;
        let accessibleCount = 0;
        iframes.forEach((iframe) => {
          const src = iframe.src || "about:blank";
          const isCrossOrigin = src.startsWith("http") && !src.includes(window.location.hostname);
          if (isCrossOrigin) {
            crossOriginCount++;
          } else {
            accessibleCount++;
          }
        });
        console.log(`[Uproot] Detected ${iframes.length} iframes: ${accessibleCount} accessible, ${crossOriginCount} cross-origin (skipped)`);
        if (crossOriginCount > 0) {
          console.log(`[Uproot] â„¹ï¸ ${crossOriginCount} cross-origin iframes cannot be searched (browser security policy - this is normal)`);
        }
      } else {
        console.log("[Uproot] No iframes detected");
      }
      console.groupEnd();
      let lastMutationTime = Date.now();
      const observer = new MutationObserver(() => {
        lastMutationTime = Date.now();
      });
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
      try {
        while (Date.now() - startTime < effectiveTimeout) {
          attempts++;
          if (isSearchResults && !expandAttempted && Date.now() - startTime > 2e3) {
            expandAttempted = true;
            const expanded = tryExpandDescription();
            if (expanded) {
              log$1.debug(LogCategory.SERVICE, "Triggered Show More expansion for job description");
              console.log('[Uproot] âœ… Job description "Show More" button clicked, waiting for content to expand...');
              await new Promise((resolve) => setTimeout(resolve, 1500));
            } else {
              console.log('[Uproot] â„¹ï¸ No "Show More" button found (description may already be expanded)');
            }
          }
          let selectorResults = [];
          for (const selector of descriptionSelectors) {
            let description = document.querySelector(selector);
            let source = "main DOM";
            if (!description) {
              description = querySelectorDeep(selector);
              if (description) {
                source = "Shadow DOM (recursive)";
                console.log(`[Uproot] ðŸ” Found content in Shadow DOM with selector: ${selector}`);
              }
            }
            if (!description) {
              description = tryExtractFromIframes(selector);
              if (description) {
                source = "iframe (with Shadow DOM search)";
                console.log(`[Uproot] ðŸ” Found content in iframe with selector: ${selector}`);
              }
            }
            if (description) {
              const textLength = description.textContent?.trim().length || 0;
              if (textLength >= minLength) {
                const elapsed2 = Date.now() - startTime;
                observer.disconnect();
                console.log(`[Uproot] âœ… Selector "${selector}" found valid content with ${textLength} chars from ${source}`);
                log$1.info(LogCategory.SERVICE, "Job details loaded successfully", {
                  elapsed: `${elapsed2}ms`,
                  attempts,
                  matchedSelector: selector,
                  pageType: isSearchResults ? "search-results" : "direct-view",
                  contentLength: textLength,
                  source
                });
                console.log(`[Uproot] Job details loaded using selector: ${selector} (${elapsed2}ms, ${attempts} attempts, ${textLength} chars, source: ${source})`);
                return true;
              } else {
                selectorResults.push({
                  selector,
                  found: true,
                  textLength,
                  reason: `content too short (${textLength} < ${minLength}) from ${source}`
                });
              }
            } else {
              selectorResults.push({
                selector,
                found: false,
                textLength: 0,
                reason: "element not found in main DOM, Shadow DOM, or iframes"
              });
            }
          }
          if (attempts % 10 === 0) {
            console.group(`[Uproot] Selector Check Results (Attempt ${attempts})`);
            const foundButTooShort = selectorResults.filter((r2) => r2.found && r2.textLength < minLength);
            const notFound = selectorResults.filter((r2) => !r2.found);
            console.log(`Total selectors checked: ${selectorResults.length}`);
            console.log(`Elements found but too short: ${foundButTooShort.length}`);
            console.log(`Elements not found: ${notFound.length}`);
            if (foundButTooShort.length > 0) {
              console.log("Found but too short:", foundButTooShort.map((r2) => `${r2.selector} (${r2.textLength} chars)`));
            }
            console.groupEnd();
          }
          const timeSinceLastMutation = Date.now() - lastMutationTime;
          if (timeSinceLastMutation < 50) {
            await new Promise((resolve) => setTimeout(resolve, 50));
          } else {
            await new Promise((resolve) => setTimeout(resolve, 200));
          }
        }
        observer.disconnect();
        const elapsed = Date.now() - startTime;
        console.warn("[Uproot] âš ï¸ All selectors failed, trying FALLBACK: extract all visible text...");
        try {
          const allText = extractAllVisibleText();
          if (allText.length > 200) {
            console.log(`[Uproot] âœ… FALLBACK SUCCESS: Extracted ${allText.length} chars of visible text`);
            console.log(`[Uproot] Content preview: "${allText.substring(0, 150)}..."`);
            log$1.info(LogCategory.SERVICE, "Job details loaded using FALLBACK (all visible text)", {
              elapsed: `${elapsed}ms`,
              attempts,
              contentLength: allText.length,
              source: "fallback: extractAllVisibleText()"
            });
            return true;
          } else {
            console.error(`[Uproot] âŒ FALLBACK FAILED: Only ${allText.length} chars extracted (minimum 200 required)`);
          }
        } catch (fallbackError) {
          console.error("[Uproot] âŒ FALLBACK ERROR:", fallbackError);
        }
        console.group("[Uproot] âŒ Job Details Load Failed - Debugging Info");
        console.log("Page Type:", isSearchResults ? "search-results" : "direct-view");
        console.log("URL:", window.location.href);
        console.log("Attempts:", attempts);
        console.log("Elapsed:", `${elapsed}ms`);
        console.log("Timeout:", `${effectiveTimeout}ms`);
        console.log("Selectors Checked:", descriptionSelectors.length);
        console.log("Shadow DOM Roots:", shadowRoots);
        console.log("Iframes:", iframes.length);
        console.log("Job Elements Found:", allJobElements.length);
        console.log("Expand Attempted:", expandAttempted);
        console.log("Min Content Length Required:", minLength);
        console.log("All selectors checked:", descriptionSelectors);
        console.group("Final Selector Status (Main DOM)");
        descriptionSelectors.forEach((selector) => {
          const el = document.querySelector(selector);
          if (el) {
            const textLength = el.textContent?.trim().length || 0;
            console.log(`  âš ï¸ "${selector}": FOUND but ${textLength} chars (need ${minLength}+)`);
          } else {
            console.log(`  âŒ "${selector}": NOT FOUND`);
          }
        });
        console.groupEnd();
        console.group('ðŸ” ALL Elements with "description" or "job" in class/id');
        const potentialElements = document.querySelectorAll('[class*="description"], [id*="description"], [class*="job"], [id*="job"]');
        const uniqueSelectors = /* @__PURE__ */ new Set();
        potentialElements.forEach((el) => {
          const classes = Array.from(el.classList).filter((c) => c.includes("description") || c.includes("job"));
          const id = el.id && (el.id.includes("description") || el.id.includes("job")) ? el.id : null;
          if (classes.length > 0) {
            classes.forEach((c) => uniqueSelectors.add(`.${c}`));
          }
          if (id) {
            uniqueSelectors.add(`#${id}`);
          }
        });
        console.log(`Found ${potentialElements.length} potential elements with ${uniqueSelectors.size} unique selectors`);
        console.log("Unique selectors found on page:", Array.from(uniqueSelectors).slice(0, 20));
        const elementsWithText = Array.from(potentialElements).map((el) => ({
          tag: el.tagName,
          classes: Array.from(el.classList).slice(0, 3).join(" "),
          textLength: el.textContent?.trim().length || 0,
          selector: el.id ? `#${el.id}` : `.${Array.from(el.classList)[0] || "unknown"}`
        })).filter((e) => e.textLength > 100).sort((a, b) => b.textLength - a.textLength).slice(0, 10);
        console.log("Top 10 elements by text content:");
        console.table(elementsWithText);
        console.groupEnd();
        if (shadowRoots > 0) {
          console.group("ðŸ” Attempting to extract from Shadow DOM...");
          let shadowTextExtracted = "";
          document.querySelectorAll("*").forEach((el) => {
            if (el.shadowRoot) {
              const shadowText = el.shadowRoot.textContent?.trim() || "";
              if (shadowText.length > shadowTextExtracted.length) {
                shadowTextExtracted = shadowText;
                console.log(`Found ${shadowText.length} chars in Shadow DOM of ${el.tagName}.${el.className}`);
              }
            }
          });
          if (shadowTextExtracted.length > 0) {
            console.log(`âœ… Extracted ${shadowTextExtracted.length} chars from Shadow DOM`);
            console.log(`Preview: "${shadowTextExtracted.substring(0, 200)}..."`);
          } else {
            console.error("âŒ Could not extract any text from Shadow DOM roots");
          }
          console.groupEnd();
        }
        console.groupEnd();
        log$1.warn(LogCategory.SERVICE, "Job details failed to load within timeout", {
          timeout: effectiveTimeout,
          elapsed: `${elapsed}ms`,
          attempts,
          selectorsChecked: descriptionSelectors.length,
          pageType: isSearchResults ? "search-results" : "direct-view",
          expandAttempted,
          shadowRoots,
          iframesFound: iframes.length,
          jobElementsFound: allJobElements.length
        });
        console.error(`[Uproot] âŒ Job details not found after ${elapsed}ms (${attempts} attempts). Page type: ${isSearchResults ? "search-results" : "direct-view"}`);
        console.error("[Uproot] Possible causes:");
        console.error("  â€¢ LinkedIn changed their page structure (selectors need updating)");
        console.error("  â€¢ Content is in CLOSED Shadow DOM (browser security prevents access)");
        console.error("  â€¢ Content is in cross-origin iframe (browser security prevents access)");
        console.error('  â€¢ Job description requires manual expansion ("Show More" button not found)');
        console.error("  â€¢ Network is slow and content hasn't loaded yet");
        console.error("  â€¢ Page requires authentication or has rate limiting");
        console.error("");
        console.error("[Uproot] ðŸ” DEBUG: Try manually inspecting the page:");
        console.error("  1. Right-click job description â†’ Inspect");
        console.error("  2. Look for #shadow-root (open) or #shadow-root (closed)");
        console.error("  3. If closed, content is inaccessible to extensions");
        console.error("  4. Check Network tab for failed requests");
        return false;
      } catch (error) {
        observer.disconnect();
        throw error;
      }
    });
  }
  content;
  const ATS_SYSTEMS = [
    {
      name: "greenhouse",
      patterns: [
        /greenhouse\.io/i,
        /boards\.greenhouse\.io/i,
        /grnh\.se/i
      ],
      weight: 1
    },
    {
      name: "lever",
      patterns: [
        /lever\.co/i,
        /jobs\.lever\.co/i
      ],
      weight: 1
    },
    {
      name: "workday",
      patterns: [
        /myworkday\.com/i,
        /myworkdayjobs\.com/i,
        /wd\d+\.myworkday\.com/i
      ],
      weight: 1
    },
    {
      name: "indeed",
      patterns: [
        /indeed\.com\/viewjob/i,
        /indeed\.com\/cmp\//i,
        /indeed\.com\/jobs/i
      ],
      weight: 1
    },
    {
      name: "taleo",
      patterns: [
        /taleo\.net/i,
        /tbe\.taleo\.net/i
      ],
      weight: 1
    },
    {
      name: "icims",
      patterns: [
        /icims\.com/i,
        /careers\-.*\.icims\.com/i
      ],
      weight: 1
    },
    {
      name: "ultipro",
      patterns: [
        /ultipro\.com/i,
        /recruiting\.ultipro\.com/i
      ],
      weight: 1
    },
    {
      name: "smartrecruiters",
      patterns: [
        /smartrecruiters\.com/i,
        /jobs\.smartrecruiters\.com/i
      ],
      weight: 1
    },
    {
      name: "ashby",
      patterns: [
        /ashbyhq\.com/i,
        /jobs\.ashbyhq\.com/i
      ],
      weight: 1
    },
    {
      name: "jobvite",
      patterns: [
        /jobvite\.com/i,
        /jobs\.jobvite\.com/i
      ],
      weight: 1
    }
  ];
  function detectATSSystem(url, hostname) {
    for (const { name, patterns } of ATS_SYSTEMS) {
      for (const pattern of patterns) {
        if (pattern.test(url) || pattern.test(hostname)) {
          log$1.info(LogCategory.CONTENT_SCRIPT, "ATS system detected", {
            system: name,
            url,
            hostname
          });
          return name;
        }
      }
    }
    return null;
  }
  function isJobApplicationPage() {
    const url = window.location.href.toLowerCase();
    const hostname = window.location.hostname.toLowerCase();
    const pathname = window.location.pathname.toLowerCase();
    let confidence = 0;
    const atsSystem = detectATSSystem(url, hostname);
    if (atsSystem) {
      confidence += 0.5;
    }
    const jobUrlPatterns = [
      /\/jobs?\//i,
      /\/careers?\//i,
      /\/apply/i,
      /\/application/i,
      /\/position/i,
      /\/opportunities/i,
      /\/openings?/i,
      /\/job-?post/i,
      /\/employment/i
    ];
    for (const pattern of jobUrlPatterns) {
      if (pattern.test(url) || pattern.test(pathname)) {
        confidence += 0.2;
        break;
      }
    }
    if (typeof document !== "undefined" && document.readyState === "complete") {
      const forms = document.querySelectorAll("form");
      const inputs = document.querySelectorAll('input[type="text"], input[type="email"], input[type="file"]');
      const textareas = document.querySelectorAll("textarea");
      if (forms.length > 0 && (inputs.length >= 3 || textareas.length >= 1)) {
        confidence += 0.2;
      }
      const applicationFieldPatterns = [
        /name/i,
        /email/i,
        /phone/i,
        /resume/i,
        /cover.*letter/i,
        /linkedin/i,
        /portfolio/i
      ];
      let matchedFields = 0;
      inputs.forEach((input) => {
        const name = input.getAttribute("name") || "";
        const id = input.id || "";
        const placeholder = input.placeholder || "";
        const combined = `${name} ${id} ${placeholder}`.toLowerCase();
        for (const pattern of applicationFieldPatterns) {
          if (pattern.test(combined)) {
            matchedFields++;
            break;
          }
        }
      });
      if (matchedFields >= 3) {
        confidence += 0.1;
      }
    }
    confidence = Math.min(1, confidence);
    log$1.info(LogCategory.CONTENT_SCRIPT, "Job application detection", {
      isApplication: confidence >= 0.5,
      confidence,
      url,
      hostname
    });
    return {
      isApplication: confidence >= 0.5,
      confidence
    };
  }
  function detectPageContext() {
    const url = window.location.href;
    const hostname = window.location.hostname;
    const pathname = window.location.pathname;
    const isLinkedIn = hostname.includes("linkedin.com");
    let context;
    let atsSystem = null;
    let confidence = 0;
    if (isLinkedIn) {
      context = "linkedin";
      confidence = 1;
      log$1.info(LogCategory.CONTENT_SCRIPT, "Page context: LinkedIn", {
        url,
        hostname,
        pathname
      });
    } else {
      atsSystem = detectATSSystem(url, hostname);
      const { isApplication, confidence: appConfidence } = isJobApplicationPage();
      if (isApplication) {
        context = "job-application";
        confidence = appConfidence;
        log$1.info(LogCategory.CONTENT_SCRIPT, "Page context: Job Application", {
          url,
          hostname,
          pathname,
          atsSystem,
          confidence
        });
      } else {
        context = "other";
        confidence = 0;
        log$1.info(LogCategory.CONTENT_SCRIPT, "Page context: Other", {
          url,
          hostname,
          pathname
        });
      }
    }
    return {
      context,
      url,
      hostname,
      pathname,
      isLinkedIn,
      isJobApplication: context === "job-application",
      atsSystem,
      confidence
    };
  }
  function getPanelType(pageInfo) {
    if (pageInfo.isLinkedIn) {
      return "full";
    }
    if (pageInfo.isJobApplication && pageInfo.confidence >= 0.5) {
      return "minimal";
    }
    return "none";
  }
  content;
  const SCRAPE_DELAY_MIN = 2e3;
  const SCRAPE_DELAY_MAX = 5e3;
  const CACHE_TTL = 7 * 24 * 60 * 60 * 1e3;
  const STORAGE_KEY = "networkGraph";
  const CACHE_KEY = "profile_scrape_cache";
  async function loadNetworkGraph() {
    const graph = new NetworkGraph();
    try {
      const result2 = await chrome.storage.local.get([STORAGE_KEY]);
      if (result2[STORAGE_KEY]) {
        graph.import(result2[STORAGE_KEY]);
        log$1.info(LogCategory.NETWORK, `Loaded network graph with ${graph.getAllNodes().length} nodes`);
      }
    } catch (error) {
      log$1.error(LogCategory.NETWORK, "Failed to load network graph", error);
    }
    return graph;
  }
  async function saveNetworkGraph(graph) {
    try {
      const data = graph.export();
      await chrome.storage.local.set({ [STORAGE_KEY]: data });
      log$1.info(LogCategory.NETWORK, `Saved network graph with ${data.nodes.length} nodes, ${data.edges.length} edges`);
    } catch (error) {
      log$1.error(LogCategory.NETWORK, "Failed to save network graph", error);
      throw error;
    }
  }
  async function wasRecentlyScraped(profileUrl) {
    try {
      const result2 = await chrome.storage.local.get([CACHE_KEY]);
      const cache = result2[CACHE_KEY] || [];
      const cached = cache.find((c) => c.profileUrl === profileUrl);
      if (cached && Date.now() < cached.expiresAt) {
        log$1.debug(LogCategory.NETWORK, `Profile ${profileUrl} was recently scraped, skipping`);
        return true;
      }
      return false;
    } catch (error) {
      log$1.error(LogCategory.NETWORK, "Failed to check scrape cache", error);
      return false;
    }
  }
  async function markProfileScraped(profileUrl) {
    try {
      const result2 = await chrome.storage.local.get([CACHE_KEY]);
      const cache = result2[CACHE_KEY] || [];
      const filtered = cache.filter((c) => c.profileUrl !== profileUrl);
      const now = Date.now();
      filtered.push({
        profileUrl,
        lastScraped: now,
        expiresAt: now + CACHE_TTL
      });
      const trimmed = filtered.slice(-500);
      await chrome.storage.local.set({ [CACHE_KEY]: trimmed });
    } catch (error) {
      log$1.error(LogCategory.NETWORK, "Failed to mark profile scraped", error);
    }
  }
  function convertPersonProfileToLinkedInProfile(profile) {
    return {
      id: profile.profileUrl,
      profileUrl: profile.profileUrl,
      name: profile.name,
      headline: profile.headline,
      location: profile.location,
      photoUrl: profile.photoUrl,
      avatarUrl: profile.photoUrl,
      currentRole: profile.currentRole,
      experience: profile.currentRole ? [{
        company: profile.currentRole.company,
        title: profile.currentRole.title,
        location: profile.location
      }] : [],
      education: [],
      certifications: [],
      skills: [],
      connections: 0,
      mutualConnections: [],
      recentPosts: [],
      userPosts: [],
      engagedPosts: [],
      recentActivity: (profile.recentActivity || []).map((activity) => ({
        preview: activity.preview,
        timestamp: new Date(activity.timestamp).toISOString(),
        type: activity.type,
        url: activity.url
      })),
      scrapedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  function convertToLinkedInProfile(profile) {
    return profile;
  }
  function convertToNetworkNode(profile, currentUserId) {
    const id = profile.profileUrl || profile.name;
    const degree = id === currentUserId ? 0 : 2;
    const linkedInProfile = convertToLinkedInProfile(profile);
    return {
      id,
      profile: linkedInProfile,
      status: "not_contacted",
      degree,
      matchScore: 0
      // Will be calculated when finding paths
    };
  }
  function calculateEdgeWeight(profile1, profile2) {
    let weight = 1;
    if (profile1.currentRole?.company && profile2.currentRole?.company) {
      if (profile1.currentRole.company === profile2.currentRole.company) {
        weight -= 0.2;
      }
    }
    const schools1 = profile1.education?.map((e) => e.school) || [];
    const schools2 = profile2.education?.map((e) => e.school) || [];
    if (schools1.some((s) => schools2.includes(s))) {
      weight -= 0.15;
    }
    return Math.max(0.1, Math.min(1, weight));
  }
  async function addMutualConnectionsToGraph(graph, _currentUserNode, targetNode, currentUserId, targetProfile) {
    try {
      log$1.info(LogCategory.NETWORK, "Attempting to scrape mutual connections...");
      const mutualConnections = scrapeMutualConnections();
      if (mutualConnections.length === 0) {
        log$1.info(LogCategory.NETWORK, "No mutual connections found on page");
        return;
      }
      log$1.info(LogCategory.NETWORK, `Found ${mutualConnections.length} mutual connections, adding to graph...`);
      const currentUserProfile = await getCurrentUser$1();
      if (!currentUserProfile) {
        log$1.warn(LogCategory.NETWORK, "Cannot calculate edge weights without current user profile");
        return;
      }
      const currentUserPersonProfile = {
        id: currentUserProfile.id || "",
        profileUrl: currentUserProfile.id || "",
        name: currentUserProfile.name || "",
        headline: currentUserProfile.headline || "",
        currentRole: {
          title: currentUserProfile.experience?.[0]?.title || "",
          company: currentUserProfile.experience?.[0]?.company || ""
        },
        location: currentUserProfile.location || "",
        photoUrl: currentUserProfile.avatarUrl,
        education: [],
        certifications: [],
        experience: currentUserProfile.experience?.map((exp) => ({
          company: exp.company || "",
          title: exp.title || "",
          duration: exp.duration,
          location: exp.location
        })) || [],
        skills: currentUserProfile.skills?.map(
          (skill) => typeof skill === "string" ? {
            name: skill,
            endorsementCount: 0,
            endorsedBy: []
          } : skill
        ) || [],
        mutualConnections: [],
        recentPosts: [],
        userPosts: [],
        engagedPosts: [],
        recentActivity: [],
        scrapedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      for (const mutualProfile of mutualConnections) {
        try {
          const mutualLinkedInProfile = convertPersonProfileToLinkedInProfile(mutualProfile);
          const mutualNode = convertToNetworkNode(mutualLinkedInProfile, mutualProfile.profileUrl);
          if (!graph.getNode(mutualNode.id)) {
            graph.addNode(mutualNode);
            log$1.info(LogCategory.NETWORK, `Added mutual connection to graph: ${mutualNode.id} (${mutualProfile.name})`);
          }
          const weightUserToMutual = calculateEdgeWeight(currentUserPersonProfile, mutualLinkedInProfile);
          graph.addEdge({
            from: currentUserId,
            to: mutualNode.id,
            weight: weightUserToMutual,
            relationshipType: "mutual"
          });
          graph.addEdge({
            from: mutualNode.id,
            to: currentUserId,
            weight: weightUserToMutual,
            relationshipType: "mutual"
          });
          const weightMutualToTarget = calculateEdgeWeight(mutualLinkedInProfile, targetProfile);
          graph.addEdge({
            from: mutualNode.id,
            to: targetNode.id,
            weight: weightMutualToTarget,
            relationshipType: "mutual"
          });
          graph.addEdge({
            from: targetNode.id,
            to: mutualNode.id,
            weight: weightMutualToTarget,
            relationshipType: "mutual"
          });
          log$1.info(
            LogCategory.NETWORK,
            `Created path: ${currentUserId} â†” ${mutualNode.id} â†” ${targetNode.id}`
          );
        } catch (err) {
          log$1.warn(LogCategory.NETWORK, `Failed to add mutual connection: ${mutualProfile.name}`, err);
        }
      }
      log$1.info(
        LogCategory.NETWORK,
        `Successfully added ${mutualConnections.length} mutual connections to graph`
      );
    } catch (error) {
      log$1.error(LogCategory.NETWORK, "Error adding mutual connections to graph", error);
    }
  }
  async function addProfileToGraph(profileUrl, currentUserId) {
    try {
      if (await wasRecentlyScraped(profileUrl)) {
        return { success: true, message: "Profile already in cache" };
      }
      const delay = SCRAPE_DELAY_MIN + Math.random() * (SCRAPE_DELAY_MAX - SCRAPE_DELAY_MIN);
      await new Promise((resolve) => setTimeout(resolve, delay));
      log$1.info(LogCategory.NETWORK, `Scraping profile: ${profileUrl}`);
      const profileData = scrapePersonProfile();
      if (!profileData) {
        log$1.warn(LogCategory.NETWORK, `Failed to scrape profile: ${profileUrl}`);
        return { success: false, message: "Failed to scrape profile data" };
      }
      const linkedInProfile = convertPersonProfileToLinkedInProfile(profileData);
      const graph = await loadNetworkGraph();
      const node = convertToNetworkNode(linkedInProfile, currentUserId);
      graph.addNode(node);
      log$1.info(LogCategory.NETWORK, `Added node to graph: ${node.id}`);
      if (currentUserId) {
        let currentUserNode = graph.getNode(currentUserId);
        if (!currentUserNode) {
          log$1.info(LogCategory.NETWORK, `Current user node not found, creating minimal node: ${currentUserId}`);
          const currentUserProfile = await getCurrentUser$1();
          if (currentUserProfile) {
            const personProfile = {
              id: currentUserProfile.id || "",
              profileUrl: currentUserProfile.id || "",
              name: currentUserProfile.name || "LinkedIn User",
              headline: currentUserProfile.headline || "",
              currentRole: {
                title: currentUserProfile.experience?.[0]?.title || "",
                company: currentUserProfile.experience?.[0]?.company || ""
              },
              location: currentUserProfile.location || "",
              photoUrl: currentUserProfile.avatarUrl,
              education: [],
              certifications: [],
              experience: currentUserProfile.experience?.map((exp) => ({
                company: exp.company || "",
                title: exp.title || "",
                duration: exp.duration,
                location: exp.location
              })) || [],
              skills: currentUserProfile.skills?.map(
                (skill) => typeof skill === "string" ? {
                  name: skill,
                  endorsementCount: 0,
                  endorsedBy: []
                } : skill
              ) || [],
              mutualConnections: [],
              recentPosts: [],
              userPosts: [],
              engagedPosts: [],
              recentActivity: [],
              scrapedAt: (/* @__PURE__ */ new Date()).toISOString()
            };
            const currentUserNetworkNode = convertToNetworkNode(personProfile, currentUserId);
            graph.addNode(currentUserNetworkNode);
            currentUserNode = currentUserNetworkNode;
            log$1.info(LogCategory.NETWORK, `Added current user to graph from cache: ${currentUserId}`);
          } else {
            log$1.warn(LogCategory.NETWORK, "Could not get current user profile (cache miss and detection failed)");
          }
        }
        if (currentUserNode) {
          const weight = calculateEdgeWeight(currentUserNode.profile, linkedInProfile);
          graph.addEdge({
            from: currentUserId,
            to: node.id,
            weight,
            relationshipType: "mutual"
          });
          log$1.info(LogCategory.NETWORK, `Added edge: ${currentUserId} -> ${node.id} (weight: ${weight})`);
          graph.addEdge({
            from: node.id,
            to: currentUserId,
            weight,
            relationshipType: "mutual"
          });
          log$1.info(LogCategory.NETWORK, `Added reverse edge: ${node.id} -> ${currentUserId} (weight: ${weight})`);
          await addMutualConnectionsToGraph(graph, currentUserNode, node, currentUserId, linkedInProfile);
        }
      }
      await saveNetworkGraph(graph);
      await markProfileScraped(profileUrl);
      return {
        success: true,
        message: `Added ${profileData.name} to network (${graph.getAllNodes().length} total profiles)`
      };
    } catch (error) {
      log$1.error(LogCategory.NETWORK, "Failed to add profile to graph", error);
      return { success: false, message: error.message };
    }
  }
  content;
  function waitForElement(selector, timeout = 5e3) {
    return new Promise((resolve, reject) => {
      if (document.querySelector(selector)) {
        return resolve(document.querySelector(selector));
      }
      const observer = new MutationObserver(() => {
        if (document.querySelector(selector)) {
          observer.disconnect();
          resolve(document.querySelector(selector));
        }
      });
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
      setTimeout(() => {
        observer.disconnect();
        reject(new Error(`Element ${selector} not found within ${timeout}ms`));
      }, timeout);
    });
  }
  function querySelectorAllFallback(parent, selectors) {
    for (const selector of selectors) {
      try {
        const elements = parent.querySelectorAll(selector);
        if (elements.length > 0) {
          return Array.from(elements);
        }
      } catch (error) {
        console.warn(`[Helpers] Invalid selector: ${selector}`, error);
      }
    }
    return [];
  }
  content;
  class RateLimiter {
    /**
     * Create a new rate limiter
     *
     * @param maxRequestsPerHour - Maximum requests allowed per hour (default: 100)
     * @param minDelayMs - Minimum delay between requests in ms (default: 5000)
     * @param maxDelayMs - Maximum delay between requests in ms (default: 15000)
     */
    constructor(maxRequestsPerHour = 100, minDelayMs = 5e3, maxDelayMs = 15e3) {
      __publicField(this, "queue", []);
      __publicField(this, "processing", false);
      __publicField(this, "requestCount", 0);
      __publicField(this, "hourStartTime", Date.now());
      this.maxRequestsPerHour = maxRequestsPerHour;
      this.minDelayMs = minDelayMs;
      this.maxDelayMs = maxDelayMs;
      console.log(
        `[RateLimiter] Initialized: ${maxRequestsPerHour} req/hr, ${minDelayMs}-${maxDelayMs}ms delays`
      );
    }
    /**
     * Enqueue a function to be executed with rate limiting
     *
     * @param fn - Async function to execute
     * @returns Promise that resolves with function result
     * @throws Error if queue is full or function execution fails
     *
     * @example
     * ```typescript
     * const profile = await rateLimiter.enqueue(() => scrapeProfile(url));
     * ```
     */
    async enqueue(fn) {
      if (this.queue.length >= 1e3) {
        throw new Error("[RateLimiter] Queue full (1000 requests). Too many pending requests.");
      }
      return new Promise((resolve, reject) => {
        this.queue.push(async () => {
          try {
            const result2 = await fn();
            resolve(result2);
          } catch (error) {
            reject(error);
          }
        });
        if (!this.processing) {
          this.processQueue();
        }
      });
    }
    /**
     * Process queued functions one at a time
     * Handles hourly quota, delays, and error recovery
     */
    async processQueue() {
      this.processing = true;
      console.log(`[RateLimiter] Starting queue processing (${this.queue.length} pending)`);
      while (this.queue.length > 0) {
        const hourElapsed = Date.now() - this.hourStartTime;
        if (hourElapsed > 36e5) {
          console.log(
            `[RateLimiter] Hour elapsed. Resetting counter (was ${this.requestCount} requests)`
          );
          this.requestCount = 0;
          this.hourStartTime = Date.now();
        }
        if (this.requestCount >= this.maxRequestsPerHour) {
          const waitTime = 36e5 - hourElapsed;
          const waitTimeMin = Math.ceil(waitTime / 6e4);
          console.warn(
            `[RateLimiter] Rate limit reached (${this.requestCount}/${this.maxRequestsPerHour}). Waiting ${waitTimeMin} minutes until next hour.`
          );
          await this.sleep(waitTime);
          this.requestCount = 0;
          this.hourStartTime = Date.now();
          console.log("[RateLimiter] Rate limit reset. Resuming queue processing.");
        }
        const fn = this.queue.shift();
        if (fn) {
          try {
            await fn();
            this.requestCount++;
            console.log(
              `[RateLimiter] Request ${this.requestCount}/${this.maxRequestsPerHour} complete. Queue: ${this.queue.length} remaining.`
            );
            if (this.queue.length > 0) {
              const delay = this.randomDelay();
              const delaySec = (delay / 1e3).toFixed(1);
              console.log(`[RateLimiter] Waiting ${delaySec}s before next request...`);
              await this.sleep(delay);
            }
          } catch (error) {
            console.error("[RateLimiter] Request failed (continuing queue):", error);
          }
        }
      }
      console.log("[RateLimiter] Queue empty. Stopping processing.");
      this.processing = false;
    }
    /**
     * Generate random delay between min and max
     * Mimics human browsing patterns
     */
    randomDelay() {
      return Math.floor(Math.random() * (this.maxDelayMs - this.minDelayMs) + this.minDelayMs);
    }
    /**
     * Sleep for specified milliseconds
     */
    sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    /**
     * Get current queue statistics
     * Useful for debugging and monitoring
     */
    getStats() {
      const timeUntilReset = Math.max(0, 36e5 - (Date.now() - this.hourStartTime));
      return {
        queueLength: this.queue.length,
        requestCount: this.requestCount,
        maxRequests: this.maxRequestsPerHour,
        timeUntilReset,
        processing: this.processing
      };
    }
  }
  const rateLimiter = new RateLimiter();
  content;
  const PROGRESS_KEY = "connection_scrape_progress";
  let isPaused = false;
  let isStopped = false;
  function pauseScraping() {
    console.log("[ConnectionScraper] Pausing scrape operation...");
    isPaused = true;
  }
  function resumeScraping() {
    console.log("[ConnectionScraper] Resuming scrape operation...");
    isPaused = false;
  }
  function resetState() {
    isPaused = false;
    isStopped = false;
  }
  function checkPaused() {
    return isPaused;
  }
  function checkStopped() {
    return isStopped;
  }
  async function loadProgress() {
    try {
      const result2 = await chrome.storage.local.get(PROGRESS_KEY);
      return result2[PROGRESS_KEY] || null;
    } catch (error) {
      console.error("[ConnectionScraper] Failed to load progress:", error);
      return null;
    }
  }
  async function updateProgress(progress) {
    try {
      await chrome.storage.local.set({ [PROGRESS_KEY]: progress });
      console.log(`[ConnectionScraper] Progress saved: ${progress.totalScraped} connections`);
    } catch (error) {
      console.error("[ConnectionScraper] Failed to save progress:", error);
    }
  }
  async function clearProgress() {
    try {
      await chrome.storage.local.remove(PROGRESS_KEY);
      console.log("[ConnectionScraper] Progress cleared");
    } catch (error) {
      console.error("[ConnectionScraper] Failed to clear progress:", error);
    }
  }
  content;
  const NAME_SELECTORS = [
    ".mn-connection-card__name",
    ".artdeco-entity-lockup__title",
    "[data-test-entity-lockup-title]",
    '.reusable-search__result-container a[href*="/in/"]',
    'a[data-control-name="connection_profile"]'
  ];
  const HEADLINE_SELECTORS = [
    ".mn-connection-card__occupation",
    ".artdeco-entity-lockup__subtitle",
    "[data-test-entity-lockup-subtitle]",
    ".entity-result__primary-subtitle"
  ];
  const PROFILE_URL_SELECTORS = [
    'a.mn-connection-card__link[href*="/in/"]',
    'a[data-control-name="connection_profile"][href*="/in/"]',
    'a.artdeco-entity-lockup__title[href*="/in/"]',
    'a[href*="/in/"]'
  ];
  const AVATAR_SELECTORS = [
    ".mn-connection-card__picture img",
    ".artdeco-entity-lockup__image img",
    ".presence-entity__image",
    'img[data-ghost-classes*="person"]'
  ];
  const COMPANY_SELECTORS = [
    ".mn-connection-card__company-name",
    ".entity-result__primary-subtitle t-black",
    ".artdeco-entity-lockup__caption"
  ];
  const TOTAL_COUNT_SELECTORS = [
    ".mn-connections__header h1",
    ".pvs-header__title-text",
    "[data-test-connections-count]",
    "h1.text-heading-xlarge"
  ];
  function extractConnection(cardElement) {
    try {
      const profileLinkElement = querySelectorAllFallback(
        cardElement,
        PROFILE_URL_SELECTORS
      )[0];
      if (!profileLinkElement?.href) {
        return null;
      }
      const profileUrl = profileLinkElement.href;
      const profileIdMatch = profileUrl.match(/\/in\/([^\/\?]+)/);
      const profileId = profileIdMatch ? profileIdMatch[1] : profileUrl;
      const nameElement = querySelectorAllFallback(cardElement, NAME_SELECTORS)[0];
      const name = nameElement?.textContent?.trim();
      if (!name) {
        return null;
      }
      const headlineElement = querySelectorAllFallback(cardElement, HEADLINE_SELECTORS)[0];
      const headline = headlineElement?.textContent?.trim();
      const companyElement = querySelectorAllFallback(cardElement, COMPANY_SELECTORS)[0];
      const companyName = companyElement?.textContent?.trim();
      const avatarElement = querySelectorAllFallback(
        cardElement,
        AVATAR_SELECTORS
      )[0];
      const avatarUrl = avatarElement?.src && !avatarElement.src.includes("data:image") ? avatarElement.src : void 0;
      const node = {
        id: profileId,
        degree: 1,
        profile: {
          id: profileId,
          publicId: profileId,
          name,
          headline,
          avatarUrl,
          scrapedAt: (/* @__PURE__ */ new Date()).toISOString(),
          experience: companyName ? [{ company: companyName, title: headline || "" }] : [],
          skills: [],
          education: [],
          mutualConnections: [],
          recentPosts: [],
          certifications: [],
          userPosts: [],
          engagedPosts: [],
          recentActivity: []
        },
        matchScore: 0,
        status: "connected"
      };
      return node;
    } catch (error) {
      console.error("[ConnectionScraper] Failed to extract connection:", error);
      return null;
    }
  }
  async function connectionExists(profileId, existingBatch) {
    if (existingBatch.some((node) => node.id === profileId)) {
      return true;
    }
    try {
      const existing = await networkDB.nodes.get(profileId);
      return !!existing;
    } catch (error) {
      console.error("[ConnectionScraper] Error checking if connection exists:", error);
      return false;
    }
  }
  function getTotalConnectionCount() {
    try {
      const headerElement = querySelectorAllFallback(
        document,
        TOTAL_COUNT_SELECTORS
      )[0];
      if (!headerElement) {
        return null;
      }
      const text = headerElement.textContent?.trim() || "";
      const match = text.match(/(\d+[\d,]*)/);
      if (match) {
        const count = parseInt(match[1].replace(/,/g, ""), 10);
        console.log(`[ConnectionScraper] Total connections: ${count}`);
        return count;
      }
      return null;
    } catch (error) {
      console.error("[ConnectionScraper] Error extracting connection count:", error);
      return null;
    }
  }
  content;
  const MAX_SCROLLS = 200;
  const NO_CHANGE_THRESHOLD = 5;
  const MIN_DELAY_MS = 3e3;
  const MAX_DELAY_MS = 5e3;
  const CONNECTION_LIST_SELECTORS$1 = [
    ".mn-connection-card",
    ".artdeco-list__item",
    '[data-test-component="connections-list-item"]',
    ".reusable-search__result-container"
  ];
  async function scrollToLoadAllConnections(maxScrolls = MAX_SCROLLS, onProgress, existingProgress) {
    let scrollCount = 0;
    let noChangeCount = 0;
    let previousCount = 0;
    console.log("[ConnectionScraper] Starting infinite scroll...");
    while (scrollCount < maxScrolls && noChangeCount < NO_CHANGE_THRESHOLD) {
      if (checkStopped()) {
        console.log("[ConnectionScraper] Scraping stopped by user");
        break;
      }
      while (checkPaused()) {
        console.log("[ConnectionScraper] Scraping paused, waiting for resume...");
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
      window.scrollTo(0, document.body.scrollHeight);
      scrollCount++;
      const delay = Math.random() * (MAX_DELAY_MS - MIN_DELAY_MS) + MIN_DELAY_MS;
      console.log(
        `[ConnectionScraper] Scroll ${scrollCount}/${maxScrolls}, waiting ${Math.round(delay)}ms...`
      );
      await new Promise((resolve) => setTimeout(resolve, delay));
      const currentConnections = querySelectorAllFallback(
        document,
        CONNECTION_LIST_SELECTORS$1
      );
      const currentCount = currentConnections.length;
      console.log(
        `[ConnectionScraper] Found ${currentCount} connection cards (${currentCount - previousCount} new)`
      );
      if (onProgress && existingProgress) {
        onProgress({
          scraped: currentCount,
          total: existingProgress.totalConnections,
          status: "running",
          lastSaved: existingProgress.totalScraped
        });
      }
      if (currentCount === previousCount) {
        noChangeCount++;
        console.log(
          `[ConnectionScraper] No new connections (${noChangeCount}/${NO_CHANGE_THRESHOLD})`
        );
      } else {
        noChangeCount = 0;
      }
      previousCount = currentCount;
    }
    if (scrollCount >= maxScrolls) {
      console.warn(`[ConnectionScraper] Reached max scrolls (${maxScrolls})`);
    }
    if (noChangeCount >= NO_CHANGE_THRESHOLD) {
      console.log("[ConnectionScraper] All connections loaded (no new content)");
    }
    const finalConnections = querySelectorAllFallback(document, CONNECTION_LIST_SELECTORS$1);
    console.log(`[ConnectionScraper] Scroll complete: ${finalConnections.length} total cards`);
    return finalConnections;
  }
  content;
  const BATCH_SIZE = 50;
  const CONNECTION_LIST_SELECTORS = [
    ".mn-connection-card",
    ".artdeco-list__item",
    '[data-test-component="connections-list-item"]',
    ".reusable-search__result-container"
  ];
  async function saveBatch(connections) {
    if (connections.length === 0) {
      return;
    }
    try {
      await bulkAddNodes(connections);
      console.log(`[ConnectionScraper] Saved batch of ${connections.length} connections to IndexedDB`);
    } catch (error) {
      console.error("[ConnectionScraper] Failed to save batch:", error);
      throw error;
    }
  }
  async function scrapeConnections(options) {
    try {
      resetState();
      let progress;
      if (options?.resume) {
        const existingProgress = await loadProgress();
        if (existingProgress && existingProgress.status !== "complete") {
          console.log(
            `[ConnectionScraper] Resuming from ${existingProgress.totalScraped} connections`
          );
          progress = {
            ...existingProgress,
            status: "running"
          };
        } else {
          console.log("[ConnectionScraper] No progress to resume, starting fresh");
          progress = createFreshProgress();
        }
      } else {
        progress = createFreshProgress();
        await clearProgress();
      }
      console.log("[ConnectionScraper] Waiting for connections list...");
      await waitForElement(CONNECTION_LIST_SELECTORS[0], 15e3);
      progress.totalConnections = getTotalConnectionCount();
      console.log("[ConnectionScraper] Scrolling to load all connections...");
      const connectionElements = await scrollToLoadAllConnections(
        200,
        options?.onProgress,
        progress
      );
      if (checkStopped()) {
        progress.status = "paused";
        await updateProgress(progress);
        console.log("[ConnectionScraper] Scraping stopped, progress saved");
        return [];
      }
      const allConnections = [];
      let currentBatch = [];
      let newConnectionsCount = 0;
      console.log(`[ConnectionScraper] Extracting data from ${connectionElements.length} cards...`);
      for (let i = 0; i < connectionElements.length; i++) {
        const cardElement = connectionElements[i];
        try {
          const connection = extractConnection(cardElement);
          if (connection) {
            const exists = await connectionExists(connection.id, allConnections);
            if (!exists) {
              currentBatch.push(connection);
              allConnections.push(connection);
              newConnectionsCount++;
              if (currentBatch.length >= BATCH_SIZE) {
                await saveBatch(currentBatch);
                progress.totalScraped += currentBatch.length;
                progress.lastScrapedId = currentBatch[currentBatch.length - 1].id;
                progress.lastSaveAt = (/* @__PURE__ */ new Date()).toISOString();
                await updateProgress(progress);
                if (options?.onProgress) {
                  options.onProgress({
                    scraped: i + 1,
                    total: progress.totalConnections,
                    status: "running",
                    lastSaved: progress.totalScraped
                  });
                }
                console.log(
                  `[ConnectionScraper] Batch saved: ${progress.totalScraped} total connections`
                );
                currentBatch = [];
              }
            } else {
              console.log(`[ConnectionScraper] Duplicate connection skipped: ${connection.id}`);
            }
          }
        } catch (error) {
          console.error(`[ConnectionScraper] Error processing connection ${i}:`, error);
        }
      }
      if (currentBatch.length > 0) {
        await saveBatch(currentBatch);
        progress.totalScraped += currentBatch.length;
        progress.lastScrapedId = currentBatch[currentBatch.length - 1].id;
        progress.lastSaveAt = (/* @__PURE__ */ new Date()).toISOString();
        await updateProgress(progress);
        console.log(`[ConnectionScraper] Final batch saved: ${currentBatch.length} connections`);
      }
      progress.status = "complete";
      await updateProgress(progress);
      if (options?.onProgress) {
        options.onProgress({
          scraped: allConnections.length,
          total: progress.totalConnections,
          status: "complete",
          lastSaved: progress.totalScraped
        });
      }
      console.log(
        `[ConnectionScraper] Scraping complete: ${allConnections.length} connections (${newConnectionsCount} new)`
      );
      return allConnections;
    } catch (error) {
      console.error("[ConnectionScraper] Fatal error during scraping:", error);
      try {
        const errorProgress = await loadProgress();
        if (errorProgress) {
          errorProgress.status = "error";
          await updateProgress(errorProgress);
        }
      } catch (e) {
        console.error("[ConnectionScraper] Failed to save error state:", error);
      }
      throw error;
    }
  }
  async function scrapeConnectionsWithRetry(options, maxRetries = 3) {
    let lastError = null;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`[ConnectionScraper] Attempt ${attempt}/${maxRetries}`);
        return await scrapeConnections(options);
      } catch (error) {
        lastError = error;
        console.error(`[ConnectionScraper] Attempt ${attempt} failed:`, error);
        if (attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1e3;
          console.log(`[ConnectionScraper] Retrying in ${delay}ms...`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    }
    console.error(
      `[ConnectionScraper] All ${maxRetries} attempts failed, throwing last error`
    );
    throw lastError;
  }
  async function scrapeConnectionsSafe(options, maxRetries = 3) {
    return rateLimiter.enqueue(() => scrapeConnectionsWithRetry(options, maxRetries));
  }
  function createFreshProgress() {
    return {
      totalScraped: 0,
      lastScrapedId: null,
      startedAt: (/* @__PURE__ */ new Date()).toISOString(),
      lastSaveAt: (/* @__PURE__ */ new Date()).toISOString(),
      status: "running",
      totalConnections: null
    };
  }
  content;
  const definition = defineContentScript({
    matches: ["<all_urls>"],
    main() {
      log$1.info(LogCategory.CONTENT_SCRIPT, "Content script loaded", {
        url: window.location.href,
        pathname: window.location.pathname,
        isLinkedIn: window.location.hostname.includes("linkedin.com"),
        readyState: document.readyState
      });
      if (document.readyState === "loading") {
        log$1.debug(LogCategory.CONTENT_SCRIPT, "Waiting for DOMContentLoaded event");
        document.addEventListener("DOMContentLoaded", init);
      } else {
        log$1.debug(LogCategory.CONTENT_SCRIPT, "Document already loaded, initializing immediately");
        init();
      }
      function detectLinkedInPage() {
        const path = window.location.pathname;
        let pageType = "unknown";
        if (path.includes("/feed")) pageType = "feed";
        else if (path.includes("/jobs")) pageType = "jobs";
        else if (path.includes("/in/")) pageType = "profile";
        else if (path.includes("/company/")) pageType = "company";
        else if (path.includes("/search")) pageType = "search";
        else if (path.includes("/messaging")) pageType = "messaging";
        else if (path.includes("/mynetwork")) pageType = "mynetwork";
        log$1.info(LogCategory.CONTENT_SCRIPT, "LinkedIn page detected", {
          pageType,
          path,
          url: window.location.href
        });
        return pageType;
      }
      function init() {
        log$1.debug(LogCategory.CONTENT_SCRIPT, "Initializing content script");
        const pageInfo = detectPageContext();
        const panelType = getPanelType(pageInfo);
        log$1.info(LogCategory.CONTENT_SCRIPT, "Page context detected", {
          context: pageInfo.context,
          panelType,
          atsSystem: pageInfo.atsSystem,
          confidence: pageInfo.confidence
        });
        setTimeout(async () => {
          log$1.debug(LogCategory.CONTENT_SCRIPT, "Starting post-load initialization", { panelType });
          if (panelType !== "none") {
            injectPanel(panelType);
          } else {
            log$1.info(LogCategory.CONTENT_SCRIPT, "No panel needed for this page");
          }
          if (pageInfo.isLinkedIn) {
            const linkedInPageType = detectLinkedInPage();
            log$1.debug(LogCategory.CONTENT_SCRIPT, "LinkedIn page type", { linkedInPageType });
            startMonitoring();
            const currentUrl = window.location.href;
            if (currentUrl.includes("linkedin.com/in/") && !currentUrl.includes("/edit/")) {
              try {
                log$1.info(LogCategory.NETWORK, "LinkedIn profile detected on page load, adding to network graph");
                const currentUserProfile = getCurrentLinkedInUser();
                const currentUserId = currentUserProfile?.profileUrl;
                const result2 = await addProfileToGraph(currentUrl, currentUserId);
                if (result2.success) {
                  log$1.info(LogCategory.NETWORK, result2.message);
                } else {
                  log$1.warn(LogCategory.NETWORK, `Failed to add profile: ${result2.message}`);
                }
              } catch (error) {
                log$1.error(LogCategory.NETWORK, "Error building network graph on page load", error);
              }
            }
          }
        }, 1e3);
        observeUrlChanges();
      }
      async function startMonitoring() {
        const stopTimer = log$1.startTimer(LogCategory.CONTENT_SCRIPT, "watchlist monitoring");
        try {
          log$1.info(LogCategory.CONTENT_SCRIPT, "Starting watchlist monitoring");
          const [companies, people, onboardingState] = await Promise.all([
            getCompanyWatchlist(),
            getWatchlist(),
            getOnboardingState()
          ]);
          log$1.debug(LogCategory.CONTENT_SCRIPT, "Watchlist data loaded", {
            companyCount: companies.length,
            peopleCount: people.length,
            hasPreferences: !!onboardingState.preferences
          });
          if (!onboardingState.preferences) {
            log$1.info(LogCategory.CONTENT_SCRIPT, "No preferences set, skipping monitoring");
            stopTimer();
            return;
          }
          log$1.info(LogCategory.CONTENT_SCRIPT, "Starting page monitoring with watchlist", {
            companies: companies.length,
            people: people.length,
            preferences: onboardingState.preferences
          });
          await monitorCurrentPage(companies, people, onboardingState.preferences);
          log$1.info(LogCategory.CONTENT_SCRIPT, "Page monitoring completed successfully");
          stopTimer();
        } catch (error) {
          if (error?.message?.includes("Extension context invalidated")) {
            stopTimer();
            return;
          }
          log$1.error(LogCategory.CONTENT_SCRIPT, "Watchlist monitoring failed", error);
          stopTimer();
        }
      }
      function observeUrlChanges() {
        let lastUrl = window.location.href;
        log$1.info(LogCategory.CONTENT_SCRIPT, "Starting URL change observer", {
          initialUrl: lastUrl
        });
        const observer = new MutationObserver((mutations) => {
          const currentUrl = window.location.href;
          if (currentUrl !== lastUrl) {
            log$1.info(LogCategory.CONTENT_SCRIPT, "URL changed detected", {
              from: lastUrl,
              to: currentUrl
            });
            lastUrl = currentUrl;
            detectLinkedInPage();
            log$1.debug(LogCategory.CONTENT_SCRIPT, "Waiting for page to settle before monitoring");
            setTimeout(async () => {
              startMonitoring();
              if (currentUrl.includes("linkedin.com/in/") && !currentUrl.includes("/edit/")) {
                try {
                  log$1.info(LogCategory.NETWORK, "LinkedIn profile detected, adding to network graph");
                  const currentUserProfile = getCurrentLinkedInUser();
                  const currentUserId = currentUserProfile?.profileUrl;
                  const result2 = await addProfileToGraph(currentUrl, currentUserId);
                  if (result2.success) {
                    log$1.info(LogCategory.NETWORK, result2.message);
                  } else {
                    log$1.warn(LogCategory.NETWORK, `Failed to add profile: ${result2.message}`);
                  }
                } catch (error) {
                  log$1.error(LogCategory.NETWORK, "Error building network graph", error);
                }
              }
            }, 2e3);
          } else {
            log$1.debug(LogCategory.CONTENT_SCRIPT, "DOM mutations detected", {
              count: mutations.length,
              types: mutations.map((m) => m.type).filter((v, i, a) => a.indexOf(v) === i)
              // unique types
            });
          }
        });
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });
        log$1.info(LogCategory.CONTENT_SCRIPT, "URL observer started successfully");
      }
      function injectPanel(panelType) {
        log$1.debug(LogCategory.CONTENT_SCRIPT, "Attempting to inject panel", { panelType });
        const containerId = panelType === "full" ? "linkedin-extension-root" : "uproot-autofill-root";
        if (document.getElementById(containerId)) {
          log$1.info(LogCategory.CONTENT_SCRIPT, "Panel already exists, skipping injection", { panelType });
          return;
        }
        try {
          log$1.debug(LogCategory.CONTENT_SCRIPT, "Creating panel container element", { panelType });
          const container = document.createElement("div");
          container.id = containerId;
          container.style.cssText = "position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 2147483647; isolation: isolate;";
          document.body.appendChild(container);
          log$1.debug(LogCategory.CONTENT_SCRIPT, "Panel container added to DOM", { containerId });
          const panelWrapper = document.createElement("div");
          panelWrapper.style.cssText = "pointer-events: auto;";
          container.appendChild(panelWrapper);
          const root = ReactDOM.createRoot(panelWrapper);
          if (panelType === "full") {
            log$1.debug(LogCategory.CONTENT_SCRIPT, "Rendering FloatingPanel (LinkedIn)");
            root.render(
              /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingPanel, {}) })
            );
          } else {
            log$1.debug(LogCategory.CONTENT_SCRIPT, "Rendering MinimalAutofillPanel (job application)");
            root.render(
              /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MinimalAutofillPanel, {}) })
            );
          }
          log$1.info(LogCategory.CONTENT_SCRIPT, "Panel injected successfully", {
            panelType,
            containerId,
            zIndex: container.style.zIndex
          });
        } catch (error) {
          log$1.error(LogCategory.CONTENT_SCRIPT, "Panel injection failed", error, { panelType });
        }
      }
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
        log$1.debug(LogCategory.CONTENT_SCRIPT, "Message received from background/popup", {
          type: message.type,
          hasSender: !!sender,
          senderId: sender?.id
        });
        try {
          if (message.type === "TOGGLE_PANEL") {
            log$1.info(LogCategory.CONTENT_SCRIPT, "Processing TOGGLE_PANEL message");
            const pageInfo = detectPageContext();
            const panelType = getPanelType(pageInfo);
            const containerId = panelType === "full" ? "linkedin-extension-root" : "uproot-autofill-root";
            const container = document.getElementById(containerId);
            if (container) {
              const isHidden = container.style.display === "none";
              container.style.display = isHidden ? "" : "none";
              const action = isHidden ? "shown" : "hidden";
              log$1.info(LogCategory.CONTENT_SCRIPT, "Panel toggled", {
                action,
                panelType,
                wasHidden: isHidden,
                newDisplay: container.style.display
              });
              sendResponse({ success: true, action });
            } else if (panelType !== "none") {
              log$1.info(LogCategory.CONTENT_SCRIPT, "Container not found, injecting new panel", { panelType });
              injectPanel(panelType);
              sendResponse({ success: true, action: "injected" });
            } else {
              log$1.info(LogCategory.CONTENT_SCRIPT, "No panel needed for this page");
              sendResponse({ success: false, error: "Extension not available on this page" });
            }
            return true;
          }
          if (message.type === "ANALYZE_CURRENT_JOB") {
            log$1.info(LogCategory.CONTENT_SCRIPT, "Processing ANALYZE_CURRENT_JOB message");
            if (!isJobPage()) {
              log$1.info(LogCategory.CONTENT_SCRIPT, "Not on a job page, cannot analyze", {
                currentPath: window.location.pathname
              });
              sendResponse({ success: false, error: "Not on a LinkedIn job page" });
              return true;
            }
            log$1.debug(LogCategory.CONTENT_SCRIPT, "On job page, waiting for details to load");
            const detailsPromise = Promise.race([
              waitForJobDetails(),
              new Promise(
                (resolve) => setTimeout(() => resolve(false), 27e3)
                // 27s to ensure response before background timeout
              )
            ]);
            detailsPromise.then((success) => {
              if (!success) {
                log$1.warn(LogCategory.CONTENT_SCRIPT, "Job details failed to load within timeout");
                sendResponse({
                  success: false,
                  error: "Job details failed to load within timeout"
                });
                return;
              }
              log$1.debug(LogCategory.CONTENT_SCRIPT, "Job details loaded, starting scrape");
              const jobData = scrapeJobData();
              if (!jobData) {
                throw new Error("Could not extract job data");
              }
              log$1.info(LogCategory.CONTENT_SCRIPT, "Job data scraped successfully", {
                jobTitle: jobData.jobTitle,
                companyName: jobData.company,
                hasDescription: !!jobData.description,
                descriptionLength: jobData.description?.length || 0
              });
              sendResponse({ success: true, data: jobData });
            }).catch((error) => {
              log$1.error(LogCategory.CONTENT_SCRIPT, "Job scraping failed", error, {
                currentUrl: window.location.href
              });
              sendResponse({ success: false, error: error.message });
            });
            return true;
          }
          if (message.type === "SAVE_HIGHLIGHTED_QUESTION") {
            log$1.info(LogCategory.CONTENT_SCRIPT, "Processing SAVE_HIGHLIGHTED_QUESTION message");
            const selectedText = window.getSelection()?.toString().trim();
            if (!selectedText) {
              log$1.warn(LogCategory.CONTENT_SCRIPT, "No text highlighted to save");
              sendResponse({ success: false, error: "No text highlighted" });
              return true;
            }
            log$1.debug(LogCategory.CONTENT_SCRIPT, "Text highlighted", {
              length: selectedText.length,
              preview: selectedText.substring(0, 50)
            });
            Promise.resolve().then(() => autofillStorage).then(async ({ saveQuestion: saveQuestion2 }) => {
              try {
                const question = await saveQuestion2(selectedText);
                log$1.info(LogCategory.CONTENT_SCRIPT, "Question saved successfully", {
                  id: question.id,
                  questionPreview: selectedText.substring(0, 50)
                });
                const notification = document.createElement("div");
                notification.textContent = "âœ“ Question saved!";
                notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #28A745;
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                font-family: system-ui;
                font-size: 14px;
                font-weight: 600;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 2147483646;
                isolation: isolate;
                animation: slideIn 0.3s ease-out;
              `;
                document.body.appendChild(notification);
                setTimeout(() => {
                  notification.remove();
                }, 2e3);
                sendResponse({ success: true, question });
              } catch (error) {
                log$1.error(LogCategory.CONTENT_SCRIPT, "Failed to save question", error);
                sendResponse({ success: false, error: error.message });
              }
            });
            return true;
          }
          if (message.type === "PASTE_TO_GENERATE") {
            log$1.info(LogCategory.CONTENT_SCRIPT, "Processing PASTE_TO_GENERATE message");
            const selectedText = window.getSelection()?.toString().trim();
            if (!selectedText) {
              log$1.warn(LogCategory.CONTENT_SCRIPT, "No text highlighted to paste");
              sendResponse({ success: false, error: "No text highlighted" });
              return true;
            }
            log$1.debug(LogCategory.CONTENT_SCRIPT, "Text highlighted for paste to Generate", {
              length: selectedText.length,
              preview: selectedText.substring(0, 50)
            });
            const event = new CustomEvent("uproot:pasteToGenerate", {
              detail: { question: selectedText }
            });
            window.dispatchEvent(event);
            log$1.info(LogCategory.CONTENT_SCRIPT, "Paste to Generate event dispatched", {
              questionLength: selectedText.length
            });
            sendResponse({ success: true });
            return true;
          }
          if (message.type === "GET_CURRENT_USER") {
            log$1.info(LogCategory.CONTENT_SCRIPT, "Processing GET_CURRENT_USER message");
            try {
              const userProfile = getCurrentLinkedInUser();
              if (!userProfile) {
                log$1.warn(LogCategory.CONTENT_SCRIPT, "Could not detect current LinkedIn user", {
                  url: window.location.href,
                  isLinkedIn: window.location.hostname.includes("linkedin.com")
                });
                sendResponse({
                  success: false,
                  error: "Could not detect current LinkedIn user. Make sure you are logged in to LinkedIn."
                });
                return true;
              }
              log$1.info(LogCategory.CONTENT_SCRIPT, "Current user detected successfully", {
                name: userProfile.name,
                hasPhotoUrl: !!userProfile.photoUrl,
                hasHeadline: !!userProfile.headline
              });
              sendResponse({ success: true, data: userProfile });
            } catch (error) {
              log$1.error(LogCategory.CONTENT_SCRIPT, "Failed to get current user", error);
              sendResponse({
                success: false,
                error: error.message || "Unknown error occurred while detecting current user"
              });
            }
            return true;
          }
          if (message.type === "EXECUTE_CONNECTION_SCRAPE") {
            log$1.info(LogCategory.CONTENT_SCRIPT, "Processing EXECUTE_CONNECTION_SCRAPE message", {
              params: message.payload?.params,
              taskId: message.payload?.taskId
            });
            (async () => {
              try {
                const { params, taskId } = message.payload || {};
                const resume = params?.resume ?? true;
                log$1.debug(LogCategory.CONTENT_SCRIPT, "Starting connection scrape", {
                  taskId,
                  resume,
                  currentUrl: window.location.href
                });
                const connections = await scrapeConnectionsSafe({
                  resume,
                  onProgress: (update) => {
                    chrome.runtime.sendMessage({
                      type: "SCRAPER_PROGRESS",
                      payload: {
                        taskId,
                        taskType: "connection",
                        current: update.scraped,
                        total: update.total,
                        status: `Scraping connections... (${update.scraped}/${update.total || "?"})`,
                        lastUpdate: (/* @__PURE__ */ new Date()).toISOString()
                      }
                    }).catch((error) => {
                      log$1.warn(LogCategory.CONTENT_SCRIPT, "Failed to send progress update", {
                        error: error.message,
                        taskId
                      });
                    });
                    log$1.debug(LogCategory.CONTENT_SCRIPT, "Connection scrape progress", {
                      taskId,
                      scraped: update.scraped,
                      total: update.total,
                      status: update.status
                    });
                  }
                });
                log$1.info(LogCategory.CONTENT_SCRIPT, "Connection scrape completed successfully", {
                  taskId,
                  connectionsScraped: connections.length
                });
                chrome.runtime.sendMessage({
                  type: "SCRAPER_COMPLETED",
                  payload: {
                    taskId,
                    result: { connectionsScraped: connections.length }
                  }
                }).catch((error) => {
                  log$1.warn(LogCategory.CONTENT_SCRIPT, "Failed to send completion message", {
                    error: error.message,
                    taskId
                  });
                });
                sendResponse({
                  success: true,
                  data: { connectionsScraped: connections.length }
                });
              } catch (error) {
                log$1.error(LogCategory.CONTENT_SCRIPT, "Connection scrape failed", error, {
                  taskId: message.payload?.taskId
                });
                const errorMessage = error.message || "Unknown error during connection scrape";
                chrome.runtime.sendMessage({
                  type: "SCRAPER_FAILED",
                  payload: {
                    taskId: message.payload?.taskId,
                    error: errorMessage
                  }
                }).catch((msgError) => {
                  log$1.warn(LogCategory.CONTENT_SCRIPT, "Failed to send failure message", {
                    error: msgError.message,
                    taskId: message.payload?.taskId
                  });
                });
                sendResponse({
                  success: false,
                  error: errorMessage
                });
              }
            })();
            return true;
          }
          if (message.type === "PAUSE_CONNECTION_SCRAPE") {
            log$1.info(LogCategory.CONTENT_SCRIPT, "Processing PAUSE_CONNECTION_SCRAPE message");
            try {
              pauseScraping();
              log$1.info(LogCategory.CONTENT_SCRIPT, "Connection scraping paused");
              sendResponse({ success: true });
            } catch (error) {
              log$1.error(LogCategory.CONTENT_SCRIPT, "Failed to pause connection scraping", error);
              sendResponse({
                success: false,
                error: error.message
              });
            }
            return true;
          }
          if (message.type === "RESUME_CONNECTION_SCRAPE") {
            log$1.info(LogCategory.CONTENT_SCRIPT, "Processing RESUME_CONNECTION_SCRAPE message");
            try {
              resumeScraping();
              log$1.info(LogCategory.CONTENT_SCRIPT, "Connection scraping resumed");
              sendResponse({ success: true });
            } catch (error) {
              log$1.error(LogCategory.CONTENT_SCRIPT, "Failed to resume connection scraping", error);
              sendResponse({
                success: false,
                error: error.message
              });
            }
            return true;
          }
          log$1.debug(LogCategory.CONTENT_SCRIPT, "Unknown message type, ignoring", {
            type: message.type
          });
          return false;
        } catch (error) {
          log$1.error(LogCategory.CONTENT_SCRIPT, "Message handling failed", error, {
            messageType: message.type
          });
          sendResponse({ success: false, error: error.message });
          return true;
        }
      });
    }
  });
  content;
  var browserPolyfill$1 = { exports: {} };
  var browserPolyfill = browserPolyfill$1.exports;
  var hasRequiredBrowserPolyfill;
  function requireBrowserPolyfill() {
    if (hasRequiredBrowserPolyfill) return browserPolyfill$1.exports;
    hasRequiredBrowserPolyfill = 1;
    (function(module, exports$1) {
      (function(global2, factory) {
        {
          factory(module);
        }
      })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : browserPolyfill, function(module2) {
        if (!(globalThis.chrome && globalThis.chrome.runtime && globalThis.chrome.runtime.id)) {
          throw new Error("This script should only be loaded in a browser extension.");
        }
        if (!(globalThis.browser && globalThis.browser.runtime && globalThis.browser.runtime.id)) {
          const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
          const wrapAPIs = (extensionAPIs) => {
            const apiMetadata = {
              "alarms": {
                "clear": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "clearAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "bookmarks": {
                "create": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "get": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getChildren": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getRecent": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getSubTree": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getTree": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "move": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeTree": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "search": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "update": {
                  "minArgs": 2,
                  "maxArgs": 2
                }
              },
              "browserAction": {
                "disable": {
                  "minArgs": 0,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "enable": {
                  "minArgs": 0,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "getBadgeBackgroundColor": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getBadgeText": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getPopup": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getTitle": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "openPopup": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "setBadgeBackgroundColor": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setBadgeText": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setIcon": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "setPopup": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setTitle": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                }
              },
              "browsingData": {
                "remove": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "removeCache": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeCookies": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeDownloads": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeFormData": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeHistory": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeLocalStorage": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removePasswords": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removePluginData": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "settings": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "commands": {
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "contextMenus": {
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "update": {
                  "minArgs": 2,
                  "maxArgs": 2
                }
              },
              "cookies": {
                "get": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAll": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAllCookieStores": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "set": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "devtools": {
                "inspectedWindow": {
                  "eval": {
                    "minArgs": 1,
                    "maxArgs": 2,
                    "singleCallbackArg": false
                  }
                },
                "panels": {
                  "create": {
                    "minArgs": 3,
                    "maxArgs": 3,
                    "singleCallbackArg": true
                  },
                  "elements": {
                    "createSidebarPane": {
                      "minArgs": 1,
                      "maxArgs": 1
                    }
                  }
                }
              },
              "downloads": {
                "cancel": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "download": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "erase": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getFileIcon": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "open": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "pause": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeFile": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "resume": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "search": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "show": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                }
              },
              "extension": {
                "isAllowedFileSchemeAccess": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "isAllowedIncognitoAccess": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "history": {
                "addUrl": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "deleteAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "deleteRange": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "deleteUrl": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getVisits": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "search": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "i18n": {
                "detectLanguage": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAcceptLanguages": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "identity": {
                "launchWebAuthFlow": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "idle": {
                "queryState": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "management": {
                "get": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "getSelf": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "setEnabled": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "uninstallSelf": {
                  "minArgs": 0,
                  "maxArgs": 1
                }
              },
              "notifications": {
                "clear": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "create": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "getPermissionLevel": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "update": {
                  "minArgs": 2,
                  "maxArgs": 2
                }
              },
              "pageAction": {
                "getPopup": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getTitle": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "hide": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setIcon": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "setPopup": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setTitle": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "show": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                }
              },
              "permissions": {
                "contains": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "request": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "runtime": {
                "getBackgroundPage": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "getPlatformInfo": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "openOptionsPage": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "requestUpdateCheck": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "sendMessage": {
                  "minArgs": 1,
                  "maxArgs": 3
                },
                "sendNativeMessage": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "setUninstallURL": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "sessions": {
                "getDevices": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getRecentlyClosed": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "restore": {
                  "minArgs": 0,
                  "maxArgs": 1
                }
              },
              "storage": {
                "local": {
                  "clear": {
                    "minArgs": 0,
                    "maxArgs": 0
                  },
                  "get": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "getBytesInUse": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "remove": {
                    "minArgs": 1,
                    "maxArgs": 1
                  },
                  "set": {
                    "minArgs": 1,
                    "maxArgs": 1
                  }
                },
                "managed": {
                  "get": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "getBytesInUse": {
                    "minArgs": 0,
                    "maxArgs": 1
                  }
                },
                "sync": {
                  "clear": {
                    "minArgs": 0,
                    "maxArgs": 0
                  },
                  "get": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "getBytesInUse": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "remove": {
                    "minArgs": 1,
                    "maxArgs": 1
                  },
                  "set": {
                    "minArgs": 1,
                    "maxArgs": 1
                  }
                }
              },
              "tabs": {
                "captureVisibleTab": {
                  "minArgs": 0,
                  "maxArgs": 2
                },
                "create": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "detectLanguage": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "discard": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "duplicate": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "executeScript": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "get": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getCurrent": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "getZoom": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getZoomSettings": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "goBack": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "goForward": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "highlight": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "insertCSS": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "move": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "query": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "reload": {
                  "minArgs": 0,
                  "maxArgs": 2
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeCSS": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "sendMessage": {
                  "minArgs": 2,
                  "maxArgs": 3
                },
                "setZoom": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "setZoomSettings": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "update": {
                  "minArgs": 1,
                  "maxArgs": 2
                }
              },
              "topSites": {
                "get": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "webNavigation": {
                "getAllFrames": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getFrame": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "webRequest": {
                "handlerBehaviorChanged": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "windows": {
                "create": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "get": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getCurrent": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getLastFocused": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "update": {
                  "minArgs": 2,
                  "maxArgs": 2
                }
              }
            };
            if (Object.keys(apiMetadata).length === 0) {
              throw new Error("api-metadata.json has not been included in browser-polyfill");
            }
            class DefaultWeakMap extends WeakMap {
              constructor(createItem, items = void 0) {
                super(items);
                this.createItem = createItem;
              }
              get(key) {
                if (!this.has(key)) {
                  this.set(key, this.createItem(key));
                }
                return super.get(key);
              }
            }
            const isThenable = (value) => {
              return value && typeof value === "object" && typeof value.then === "function";
            };
            const makeCallback = (promise, metadata) => {
              return (...callbackArgs) => {
                if (extensionAPIs.runtime.lastError) {
                  promise.reject(new Error(extensionAPIs.runtime.lastError.message));
                } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
                  promise.resolve(callbackArgs[0]);
                } else {
                  promise.resolve(callbackArgs);
                }
              };
            };
            const pluralizeArguments = (numArgs) => numArgs == 1 ? "argument" : "arguments";
            const wrapAsyncFunction = (name, metadata) => {
              return function asyncFunctionWrapper(target, ...args) {
                if (args.length < metadata.minArgs) {
                  throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
                }
                if (args.length > metadata.maxArgs) {
                  throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
                }
                return new Promise((resolve, reject) => {
                  if (metadata.fallbackToNoCallback) {
                    try {
                      target[name](...args, makeCallback({
                        resolve,
                        reject
                      }, metadata));
                    } catch (cbError) {
                      console.warn(`${name} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `, cbError);
                      target[name](...args);
                      metadata.fallbackToNoCallback = false;
                      metadata.noCallback = true;
                      resolve();
                    }
                  } else if (metadata.noCallback) {
                    target[name](...args);
                    resolve();
                  } else {
                    target[name](...args, makeCallback({
                      resolve,
                      reject
                    }, metadata));
                  }
                });
              };
            };
            const wrapMethod = (target, method, wrapper) => {
              return new Proxy(method, {
                apply(targetMethod, thisObj, args) {
                  return wrapper.call(thisObj, target, ...args);
                }
              });
            };
            let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
            const wrapObject = (target, wrappers = {}, metadata = {}) => {
              let cache = /* @__PURE__ */ Object.create(null);
              let handlers = {
                has(proxyTarget2, prop) {
                  return prop in target || prop in cache;
                },
                get(proxyTarget2, prop, receiver) {
                  if (prop in cache) {
                    return cache[prop];
                  }
                  if (!(prop in target)) {
                    return void 0;
                  }
                  let value = target[prop];
                  if (typeof value === "function") {
                    if (typeof wrappers[prop] === "function") {
                      value = wrapMethod(target, target[prop], wrappers[prop]);
                    } else if (hasOwnProperty(metadata, prop)) {
                      let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                      value = wrapMethod(target, target[prop], wrapper);
                    } else {
                      value = value.bind(target);
                    }
                  } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
                    value = wrapObject(value, wrappers[prop], metadata[prop]);
                  } else if (hasOwnProperty(metadata, "*")) {
                    value = wrapObject(value, wrappers[prop], metadata["*"]);
                  } else {
                    Object.defineProperty(cache, prop, {
                      configurable: true,
                      enumerable: true,
                      get() {
                        return target[prop];
                      },
                      set(value2) {
                        target[prop] = value2;
                      }
                    });
                    return value;
                  }
                  cache[prop] = value;
                  return value;
                },
                set(proxyTarget2, prop, value, receiver) {
                  if (prop in cache) {
                    cache[prop] = value;
                  } else {
                    target[prop] = value;
                  }
                  return true;
                },
                defineProperty(proxyTarget2, prop, desc) {
                  return Reflect.defineProperty(cache, prop, desc);
                },
                deleteProperty(proxyTarget2, prop) {
                  return Reflect.deleteProperty(cache, prop);
                }
              };
              let proxyTarget = Object.create(target);
              return new Proxy(proxyTarget, handlers);
            };
            const wrapEvent = (wrapperMap) => ({
              addListener(target, listener, ...args) {
                target.addListener(wrapperMap.get(listener), ...args);
              },
              hasListener(target, listener) {
                return target.hasListener(wrapperMap.get(listener));
              },
              removeListener(target, listener) {
                target.removeListener(wrapperMap.get(listener));
              }
            });
            const onRequestFinishedWrappers = new DefaultWeakMap((listener) => {
              if (typeof listener !== "function") {
                return listener;
              }
              return function onRequestFinished(req) {
                const wrappedReq = wrapObject(req, {}, {
                  getContent: {
                    minArgs: 0,
                    maxArgs: 0
                  }
                });
                listener(wrappedReq);
              };
            });
            const onMessageWrappers = new DefaultWeakMap((listener) => {
              if (typeof listener !== "function") {
                return listener;
              }
              return function onMessage(message, sender, sendResponse) {
                let didCallSendResponse = false;
                let wrappedSendResponse;
                let sendResponsePromise = new Promise((resolve) => {
                  wrappedSendResponse = function(response) {
                    didCallSendResponse = true;
                    resolve(response);
                  };
                });
                let result2;
                try {
                  result2 = listener(message, sender, wrappedSendResponse);
                } catch (err) {
                  result2 = Promise.reject(err);
                }
                const isResultThenable = result2 !== true && isThenable(result2);
                if (result2 !== true && !isResultThenable && !didCallSendResponse) {
                  return false;
                }
                const sendPromisedResult = (promise) => {
                  promise.then((msg) => {
                    sendResponse(msg);
                  }, (error) => {
                    let message2;
                    if (error && (error instanceof Error || typeof error.message === "string")) {
                      message2 = error.message;
                    } else {
                      message2 = "An unexpected error occurred";
                    }
                    sendResponse({
                      __mozWebExtensionPolyfillReject__: true,
                      message: message2
                    });
                  }).catch((err) => {
                    console.error("Failed to send onMessage rejected reply", err);
                  });
                };
                if (isResultThenable) {
                  sendPromisedResult(result2);
                } else {
                  sendPromisedResult(sendResponsePromise);
                }
                return true;
              };
            });
            const wrappedSendMessageCallback = ({
              reject,
              resolve
            }, reply) => {
              if (extensionAPIs.runtime.lastError) {
                if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
                  resolve();
                } else {
                  reject(new Error(extensionAPIs.runtime.lastError.message));
                }
              } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
                reject(new Error(reply.message));
              } else {
                resolve(reply);
              }
            };
            const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
              if (args.length < metadata.minArgs) {
                throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
              }
              if (args.length > metadata.maxArgs) {
                throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
              }
              return new Promise((resolve, reject) => {
                const wrappedCb = wrappedSendMessageCallback.bind(null, {
                  resolve,
                  reject
                });
                args.push(wrappedCb);
                apiNamespaceObj.sendMessage(...args);
              });
            };
            const staticWrappers = {
              devtools: {
                network: {
                  onRequestFinished: wrapEvent(onRequestFinishedWrappers)
                }
              },
              runtime: {
                onMessage: wrapEvent(onMessageWrappers),
                onMessageExternal: wrapEvent(onMessageWrappers),
                sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                  minArgs: 1,
                  maxArgs: 3
                })
              },
              tabs: {
                sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                  minArgs: 2,
                  maxArgs: 3
                })
              }
            };
            const settingMetadata = {
              clear: {
                minArgs: 1,
                maxArgs: 1
              },
              get: {
                minArgs: 1,
                maxArgs: 1
              },
              set: {
                minArgs: 1,
                maxArgs: 1
              }
            };
            apiMetadata.privacy = {
              network: {
                "*": settingMetadata
              },
              services: {
                "*": settingMetadata
              },
              websites: {
                "*": settingMetadata
              }
            };
            return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
          };
          module2.exports = wrapAPIs(chrome);
        } else {
          module2.exports = globalThis.browser;
        }
      });
    })(browserPolyfill$1);
    return browserPolyfill$1.exports;
  }
  var browserPolyfillExports = requireBrowserPolyfill();
  const originalBrowser = /* @__PURE__ */ getDefaultExportFromCjs(browserPolyfillExports);
  const browser = originalBrowser;
  function print$1(method, ...args) {
    return;
  }
  const logger$1 = {
    debug: (...args) => print$1(console.debug, ...args),
    log: (...args) => print$1(console.log, ...args),
    warn: (...args) => print$1(console.warn, ...args),
    error: (...args) => print$1(console.error, ...args)
  };
  const _WxtLocationChangeEvent = class _WxtLocationChangeEvent extends Event {
    constructor(newUrl, oldUrl) {
      super(_WxtLocationChangeEvent.EVENT_NAME, {});
      this.newUrl = newUrl;
      this.oldUrl = oldUrl;
    }
  };
  __publicField(_WxtLocationChangeEvent, "EVENT_NAME", getUniqueEventName("wxt:locationchange"));
  let WxtLocationChangeEvent = _WxtLocationChangeEvent;
  function getUniqueEventName(eventName) {
    return `${browser?.runtime?.id}:${"content"}:${eventName}`;
  }
  function createLocationWatcher(ctx) {
    let interval;
    let oldUrl;
    return {
      /**
       * Ensure the location watcher is actively looking for URL changes. If it's already watching,
       * this is a noop.
       */
      run() {
        if (interval != null) return;
        oldUrl = new URL(location.href);
        interval = ctx.setInterval(() => {
          let newUrl = new URL(location.href);
          if (newUrl.href !== oldUrl.href) {
            window.dispatchEvent(new WxtLocationChangeEvent(newUrl, oldUrl));
            oldUrl = newUrl;
          }
        }, 1e3);
      }
    };
  }
  const _ContentScriptContext = class _ContentScriptContext {
    constructor(contentScriptName, options) {
      __publicField(this, "isTopFrame", window.self === window.top);
      __publicField(this, "abortController");
      __publicField(this, "locationWatcher", createLocationWatcher(this));
      __publicField(this, "receivedMessageIds", /* @__PURE__ */ new Set());
      this.contentScriptName = contentScriptName;
      this.options = options;
      this.abortController = new AbortController();
      if (this.isTopFrame) {
        this.listenForNewerScripts({ ignoreFirstEvent: true });
        this.stopOldScripts();
      } else {
        this.listenForNewerScripts();
      }
    }
    get signal() {
      return this.abortController.signal;
    }
    abort(reason) {
      return this.abortController.abort(reason);
    }
    get isInvalid() {
      if (browser.runtime.id == null) {
        this.notifyInvalidated();
      }
      return this.signal.aborted;
    }
    get isValid() {
      return !this.isInvalid;
    }
    /**
     * Add a listener that is called when the content script's context is invalidated.
     *
     * @returns A function to remove the listener.
     *
     * @example
     * browser.runtime.onMessage.addListener(cb);
     * const removeInvalidatedListener = ctx.onInvalidated(() => {
     *   browser.runtime.onMessage.removeListener(cb);
     * })
     * // ...
     * removeInvalidatedListener();
     */
    onInvalidated(cb) {
      this.signal.addEventListener("abort", cb);
      return () => this.signal.removeEventListener("abort", cb);
    }
    /**
     * Return a promise that never resolves. Useful if you have an async function that shouldn't run
     * after the context is expired.
     *
     * @example
     * const getValueFromStorage = async () => {
     *   if (ctx.isInvalid) return ctx.block();
     *
     *   // ...
     * }
     */
    block() {
      return new Promise(() => {
      });
    }
    /**
     * Wrapper around `window.setInterval` that automatically clears the interval when invalidated.
     */
    setInterval(handler, timeout) {
      const id = setInterval(() => {
        if (this.isValid) handler();
      }, timeout);
      this.onInvalidated(() => clearInterval(id));
      return id;
    }
    /**
     * Wrapper around `window.setTimeout` that automatically clears the interval when invalidated.
     */
    setTimeout(handler, timeout) {
      const id = setTimeout(() => {
        if (this.isValid) handler();
      }, timeout);
      this.onInvalidated(() => clearTimeout(id));
      return id;
    }
    /**
     * Wrapper around `window.requestAnimationFrame` that automatically cancels the request when
     * invalidated.
     */
    requestAnimationFrame(callback) {
      const id = requestAnimationFrame((...args) => {
        if (this.isValid) callback(...args);
      });
      this.onInvalidated(() => cancelAnimationFrame(id));
      return id;
    }
    /**
     * Wrapper around `window.requestIdleCallback` that automatically cancels the request when
     * invalidated.
     */
    requestIdleCallback(callback, options) {
      const id = requestIdleCallback((...args) => {
        if (!this.signal.aborted) callback(...args);
      }, options);
      this.onInvalidated(() => cancelIdleCallback(id));
      return id;
    }
    addEventListener(target, type, handler, options) {
      if (type === "wxt:locationchange") {
        if (this.isValid) this.locationWatcher.run();
      }
      target.addEventListener?.(
        type.startsWith("wxt:") ? getUniqueEventName(type) : type,
        handler,
        {
          ...options,
          signal: this.signal
        }
      );
    }
    /**
     * @internal
     * Abort the abort controller and execute all `onInvalidated` listeners.
     */
    notifyInvalidated() {
      this.abort("Content script context invalidated");
      logger$1.debug(
        `Content script "${this.contentScriptName}" context invalidated`
      );
    }
    stopOldScripts() {
      window.postMessage(
        {
          type: _ContentScriptContext.SCRIPT_STARTED_MESSAGE_TYPE,
          contentScriptName: this.contentScriptName,
          messageId: Math.random().toString(36).slice(2)
        },
        "*"
      );
    }
    verifyScriptStartedEvent(event) {
      const isScriptStartedEvent = event.data?.type === _ContentScriptContext.SCRIPT_STARTED_MESSAGE_TYPE;
      const isSameContentScript = event.data?.contentScriptName === this.contentScriptName;
      const isNotDuplicate = !this.receivedMessageIds.has(event.data?.messageId);
      return isScriptStartedEvent && isSameContentScript && isNotDuplicate;
    }
    listenForNewerScripts(options) {
      let isFirst = true;
      const cb = (event) => {
        if (this.verifyScriptStartedEvent(event)) {
          this.receivedMessageIds.add(event.data.messageId);
          const wasFirst = isFirst;
          isFirst = false;
          if (wasFirst && options?.ignoreFirstEvent) return;
          this.notifyInvalidated();
        }
      };
      addEventListener("message", cb);
      this.onInvalidated(() => removeEventListener("message", cb));
    }
  };
  __publicField(_ContentScriptContext, "SCRIPT_STARTED_MESSAGE_TYPE", getUniqueEventName(
    "wxt:content-script-started"
  ));
  let ContentScriptContext = _ContentScriptContext;
  const nullKey = Symbol("null");
  let keyCounter = 0;
  class ManyKeysMap extends Map {
    constructor() {
      super();
      this._objectHashes = /* @__PURE__ */ new WeakMap();
      this._symbolHashes = /* @__PURE__ */ new Map();
      this._publicKeys = /* @__PURE__ */ new Map();
      const [pairs] = arguments;
      if (pairs === null || pairs === void 0) {
        return;
      }
      if (typeof pairs[Symbol.iterator] !== "function") {
        throw new TypeError(typeof pairs + " is not iterable (cannot read property Symbol(Symbol.iterator))");
      }
      for (const [keys, value] of pairs) {
        this.set(keys, value);
      }
    }
    _getPublicKeys(keys, create2 = false) {
      if (!Array.isArray(keys)) {
        throw new TypeError("The keys parameter must be an array");
      }
      const privateKey = this._getPrivateKey(keys, create2);
      let publicKey;
      if (privateKey && this._publicKeys.has(privateKey)) {
        publicKey = this._publicKeys.get(privateKey);
      } else if (create2) {
        publicKey = [...keys];
        this._publicKeys.set(privateKey, publicKey);
      }
      return { privateKey, publicKey };
    }
    _getPrivateKey(keys, create2 = false) {
      const privateKeys = [];
      for (let key of keys) {
        if (key === null) {
          key = nullKey;
        }
        const hashes = typeof key === "object" || typeof key === "function" ? "_objectHashes" : typeof key === "symbol" ? "_symbolHashes" : false;
        if (!hashes) {
          privateKeys.push(key);
        } else if (this[hashes].has(key)) {
          privateKeys.push(this[hashes].get(key));
        } else if (create2) {
          const privateKey = `@@mkm-ref-${keyCounter++}@@`;
          this[hashes].set(key, privateKey);
          privateKeys.push(privateKey);
        } else {
          return false;
        }
      }
      return JSON.stringify(privateKeys);
    }
    set(keys, value) {
      const { publicKey } = this._getPublicKeys(keys, true);
      return super.set(publicKey, value);
    }
    get(keys) {
      const { publicKey } = this._getPublicKeys(keys);
      return super.get(publicKey);
    }
    has(keys) {
      const { publicKey } = this._getPublicKeys(keys);
      return super.has(publicKey);
    }
    delete(keys) {
      const { publicKey, privateKey } = this._getPublicKeys(keys);
      return Boolean(publicKey && super.delete(publicKey) && this._publicKeys.delete(privateKey));
    }
    clear() {
      super.clear();
      this._symbolHashes.clear();
      this._publicKeys.clear();
    }
    get [Symbol.toStringTag]() {
      return "ManyKeysMap";
    }
    get size() {
      return super.size;
    }
  }
  new ManyKeysMap();
  function initPlugins() {
  }
  function print(method, ...args) {
    return;
  }
  const logger = {
    debug: (...args) => print(console.debug, ...args),
    log: (...args) => print(console.log, ...args),
    warn: (...args) => print(console.warn, ...args),
    error: (...args) => print(console.error, ...args)
  };
  const result = (async () => {
    try {
      initPlugins();
      const { main, ...options } = definition;
      const ctx = new ContentScriptContext("content", options);
      return await main(ctx);
    } catch (err) {
      logger.error(
        `The content script "${"content"}" crashed on startup!`,
        err
      );
      throw err;
    }
  })();
  return result;
})();
content;
//# sourceMappingURL=content.js.map
