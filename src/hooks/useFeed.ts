/**
 * useFeed Hook
 * Manages feed items with persistent storage
 */

import { useState, useEffect, useCallback } from 'react';
import type { FeedItem, FeedStats } from '../types/feed';
import {
  getFeedItems,
  addFeedItem as storageAddFeedItem,
  toggleFeedItemRead,
  markAllFeedItemsAsRead,
  deleteFeedItem as storageDeleteFeedItem,
  getFeedStats,
  clearFeed as storageClearFeed,
  clearCompanySnapshots,
} from '../utils/storage';
import { FEED_STORAGE_KEY } from '../types/feed';

const initialStats: FeedStats = {
  totalItems: 0,
  unreadCount: 0,
  jobAlerts: 0,
  companyUpdates: 0,
  connectionUpdates: 0,
  warmPaths: 0,
};

export function useFeed() {
  const [feedItems, setFeedItems] = useState<FeedItem[]>([]);
  const [stats, setStats] = useState<FeedStats>(initialStats);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // NOTE: Deadline alerts are now generated by background alarm (every 6 hours)
  // This prevents performance issues from running deadline generation on every feed load
  // See: background.ts - 'deadline-alerts' alarm handler

  // Load feed items from storage
  const loadFeed = useCallback(async () => {
    try {
      console.log('[Uproot] Loading feed - starting...');
      setIsLoading(true);
      setError(null);

      // âœ… Deadline alerts now generated by background alarm (every 6 hours)
      // No longer generated on every load to improve performance

      // Load all feed items (including deadline alerts from background)
      const items = await getFeedItems();
      console.log('[Uproot] Loaded feed items from storage:', items.length, 'items');
      if (items.length > 0) {
        console.log('[Uproot] Feed items:', items.map(i => ({ id: i.id, type: i.type, title: i.title })));
      }
      const feedStats = await getFeedStats();
      setFeedItems(items);
      setStats(feedStats);
      console.log('[Uproot] Feed loaded successfully - items:', items.length, 'unread:', feedStats.unreadCount);
    } catch (err) {
      console.error('[Uproot] Error loading feed:', err);
      setError('Failed to load feed');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Load on mount
  useEffect(() => {
    loadFeed();
  }, [loadFeed]);

  // Listen for storage changes
  useEffect(() => {
    const handleStorageChange = (
      changes: { [key: string]: chrome.storage.StorageChange },
      areaName: string
    ) => {
      if (areaName === 'local' && changes[FEED_STORAGE_KEY]) {
        // Reload feed when storage changes
        loadFeed();
      }
    };

    chrome.storage.onChanged.addListener(handleStorageChange);

    return () => {
      chrome.storage.onChanged.removeListener(handleStorageChange);
    };
  }, [loadFeed]);

  // Add new feed item
  const addFeedItem = useCallback(async (item: Omit<FeedItem, 'id'>) => {
    try {
      const newItem = await storageAddFeedItem(item);
      await loadFeed(); // Reload to get updated stats
      return newItem;
    } catch (err) {
      console.error('[Uproot] Error adding feed item:', err);
      setError('Failed to add feed item');
      throw err;
    }
  }, [loadFeed]);

  // Toggle read status
  const toggleRead = useCallback(async (itemId: string) => {
    try {
      await toggleFeedItemRead(itemId);
      // Optimistically update local state
      setFeedItems((prevItems) =>
        prevItems.map((item) =>
          item.id === itemId ? { ...item, read: !item.read } : item
        )
      );
      // Update stats
      const feedStats = await getFeedStats();
      setStats(feedStats);
    } catch (err) {
      console.error('[Uproot] Error toggling read status:', err);
      setError('Failed to update read status');
      // Reload to restore correct state
      await loadFeed();
    }
  }, [loadFeed]);

  // Mark all as read
  const markAllAsRead = useCallback(async () => {
    try {
      await markAllFeedItemsAsRead();
      // Optimistically update local state
      setFeedItems((prevItems) =>
        prevItems.map((item) => ({ ...item, read: true }))
      );
      // Update stats
      setStats((prevStats) => ({ ...prevStats, unreadCount: 0 }));
    } catch (err) {
      console.error('[Uproot] Error marking all as read:', err);
      setError('Failed to mark all as read');
      // Reload to restore correct state
      await loadFeed();
    }
  }, [loadFeed]);

  // Delete feed item
  const deleteFeedItem = useCallback(async (itemId: string) => {
    try {
      await storageDeleteFeedItem(itemId);
      await loadFeed(); // Reload to get updated stats
    } catch (err) {
      console.error('[Uproot] Error deleting feed item:', err);
      setError('Failed to delete feed item');
      throw err;
    }
  }, [loadFeed]);

  // Clear all feed items
  const clearAllFeed = useCallback(async () => {
    try {
      console.log('[Uproot] Clearing feed - starting...');

      // Clear both feed items AND company snapshots
      // This forces fresh detection when visiting company pages again
      await Promise.all([
        storageClearFeed(),
        clearCompanySnapshots()
      ]);

      console.log('[Uproot] Feed and snapshots cleared from storage successfully');

      // Optimistically update local state
      setFeedItems([]);
      setStats(initialStats);
      console.log('[Uproot] Local state cleared - feedItems: 0, stats reset');

      // Verify the feed is actually empty in storage
      const verifyItems = await getFeedItems();
      console.log('[Uproot] Verification - items in storage after clear:', verifyItems.length);
      if (verifyItems.length > 0) {
        console.error('[Uproot] WARNING: Feed still has items after clearing!', verifyItems);
      }
    } catch (err) {
      console.error('[Uproot] Error clearing feed:', err);
      setError('Failed to clear feed');
      // Reload to restore correct state
      await loadFeed();
    }
  }, [loadFeed]);

  return {
    feedItems,
    stats,
    isLoading,
    error,
    addFeedItem,
    toggleRead,
    markAllAsRead,
    deleteFeedItem,
    clearAllFeed,
    reload: loadFeed,
  };
}
