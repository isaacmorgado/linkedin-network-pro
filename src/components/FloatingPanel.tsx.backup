/**
 * Main Floating Panel Component - WITH TAB NAVIGATION
 */

import React, { useState, useRef, useEffect } from 'react';
import { Rnd } from 'react-rnd';
import { X, Minimize2, Maximize2 } from 'lucide-react';
import { TabNavigation } from './navigation/TabNavigation';
import type { TabId } from '../types/navigation';
import { log, LogCategory } from '../utils/logger';

export function FloatingPanel() {
  const [activeTab, setActiveTab] = useState<TabId>('feed');
  const [panelSize, setPanelSize] = useState({ width: 400, height: 500 });
  const [isMinimized, setIsMinimized] = useState(false);
  const [panelPosition, setPanelPosition] = useState({ x: 100, y: 100 });
  const [shouldAnimate, setShouldAnimate] = useState(false);
  const rndRef = useRef<Rnd>(null);

  // Component mount/unmount logging
  useEffect(() => {
    log.info(LogCategory.UI, 'FloatingPanel mounted', {
      activeTab,
      panelSize,
      panelPosition,
      isMinimized
    });

    return () => {
      log.debug(LogCategory.UI, 'FloatingPanel unmounting');
    };
  }, []);

  // Check if first run and set to onboarding tab
  useEffect(() => {
    async function checkFirstRun() {
      log.debug(LogCategory.UI, 'Checking onboarding status');
      const { isOnboardingComplete } = await import('../utils/storage');
      const completed = await isOnboardingComplete();
      log.info(LogCategory.UI, 'Onboarding status checked', { completed });
      if (!completed) {
        log.action('Setting active tab to onboarding', { reason: 'first-run' });
        setActiveTab('onboarding');
      }
    }
    checkFirstRun();
  }, []);

  const handleClose = () => {
    log.action('Close button clicked', { component: 'FloatingPanel' });
    const container = document.getElementById('linkedin-extension-root');
    if (container) {
      container.style.display = 'none';
      log.debug(LogCategory.UI, 'FloatingPanel hidden');
    }
  };

  const handleMinimize = () => {
    const willBeMinimized = !isMinimized;
    log.action('Minimize/Maximize button clicked', {
      component: 'FloatingPanel',
      willBeMinimized,
      currentPosition: panelPosition
    });

    // If we're MAXIMIZING (currently minimized, about to expand)
    if (!willBeMinimized && rndRef.current) {
      const viewportHeight = window.innerHeight;
      const fullPanelHeight = panelSize.height;
      const currentY = panelPosition.y;

      // Check if full panel would go past the bottom (Windows taskbar)
      const wouldGoPastBottom = currentY + fullPanelHeight > viewportHeight - 40; // 40px for taskbar

      if (wouldGoPastBottom) {
        // Reposition so bottom of panel is 40px from bottom
        const newY = Math.max(20, viewportHeight - fullPanelHeight - 40);

        // Enable animation, reposition, then disable after animation completes
        setShouldAnimate(true);
        setTimeout(() => {
          rndRef.current?.updatePosition({ x: panelPosition.x, y: newY });
          setPanelPosition({ x: panelPosition.x, y: newY });
          console.log('[Uproot] Repositioned on maximize:', { from: currentY, to: newY });

          // Disable animation after it completes
          setTimeout(() => setShouldAnimate(false), 600);
        }, 50); // Small delay to let minimize animation start
      }
    }

    setIsMinimized(willBeMinimized);
  };

  // Auto-reposition when minimized and at bottom of viewport
  useEffect(() => {
    if (!isMinimized || !rndRef.current) return;

    const checkPosition = () => {
      const viewportHeight = window.innerHeight;
      const panelHeight = 60; // Minimized height
      const currentY = panelPosition.y;

      // If panel is below 80% of viewport height when minimized, animate it back up
      const maxAllowedY = viewportHeight - panelHeight - 20; // 20px padding from bottom

      if (currentY > maxAllowedY) {
        const newY = Math.max(20, maxAllowedY); // At least 20px from top

        // Enable animation, reposition, then disable
        setShouldAnimate(true);
        rndRef.current?.updatePosition({ x: panelPosition.x, y: newY });
        setPanelPosition({ x: panelPosition.x, y: newY });

        console.log('[Uproot] Auto-repositioned minimized panel:', { from: currentY, to: newY });

        // Disable animation after it completes
        setTimeout(() => setShouldAnimate(false), 500);
      }
    };

    // Check immediately when minimized
    checkPosition();

    // Also check on window resize
    window.addEventListener('resize', checkPosition);
    return () => window.removeEventListener('resize', checkPosition);
  }, [isMinimized, panelPosition.y]); // FIX: Include panelPosition.y in dependency array

  return (
    <>
      <style>{`
        .resize-handle {
          z-index: 2147483648 !important;
          position: absolute !important;
        }
        .resize-handle-top,
        .resize-handle-bottom {
          height: 20px !important;
        }
        .resize-handle-left,
        .resize-handle-right {
          width: 20px !important;
        }
        .resize-handle-topRight,
        .resize-handle-bottomRight,
        .resize-handle-bottomLeft,
        .resize-handle-topLeft {
          width: 20px !important;
          height: 20px !important;
        }
      `}</style>
      <Rnd
      ref={rndRef}
      default={{
        x: panelPosition.x,
        y: panelPosition.y,
        width: panelSize.width,
        height: panelSize.height,
      }}
      position={panelPosition}
      minWidth={350}
      minHeight={isMinimized ? 60 : 400}
      maxWidth={800}
      maxHeight={900}
      bounds="window"
      disableDragging={false}
      dragHandleClassName="panel-header"
      cancel="button, input, textarea, select"
      enableResizing={isMinimized ? false : {
        top: true,
        right: true,
        bottom: true,
        left: true,
        topRight: true,
        bottomRight: true,
        bottomLeft: true,
        topLeft: true,
      }}
      resizeHandleStyles={{
        top: { cursor: 'ns-resize', height: '20px', top: '-10px' },
        right: { cursor: 'ew-resize', width: '20px', right: '-10px' },
        bottom: { cursor: 'ns-resize', height: '20px', bottom: '-10px' },
        left: { cursor: 'ew-resize', width: '20px', left: '-10px' },
        topRight: { cursor: 'ne-resize', width: '20px', height: '20px', top: '-10px', right: '-10px' },
        bottomRight: { cursor: 'se-resize', width: '20px', height: '20px', bottom: '-10px', right: '-10px' },
        bottomLeft: { cursor: 'sw-resize', width: '20px', height: '20px', bottom: '-10px', left: '-10px' },
        topLeft: { cursor: 'nw-resize', width: '20px', height: '20px', top: '-10px', left: '-10px' },
      }}
      size={isMinimized ? { width: panelSize.width, height: 60 } : undefined}
      onDragStop={(_e, data) => {
        log.action('Panel dragged', {
          from: panelPosition,
          to: { x: data.x, y: data.y },
          component: 'FloatingPanel'
        });

        // Check if panel was dragged to bottom edge (within 20px) when minimized
        if (isMinimized) {
          const viewportHeight = window.innerHeight;
          const panelHeight = 60; // Minimized height
          const bottomThreshold = viewportHeight - panelHeight - 20;

          // If dragged to bottom edge, trigger animation to reposition
          if (data.y > bottomThreshold) {
            const newY = Math.max(20, bottomThreshold);
            setShouldAnimate(true);
            setTimeout(() => {
              rndRef.current?.updatePosition({ x: data.x, y: newY });
              setPanelPosition({ x: data.x, y: newY });
              console.log('[Uproot] Repositioned after drag to bottom:', { from: data.y, to: newY });
              setTimeout(() => setShouldAnimate(false), 500);
            }, 50);
            return;
          }
        }

        setPanelPosition({ x: data.x, y: data.y });
      }}
      onResize={(_e, direction, ref, _delta, position) => {
        if (!isMinimized) {
          const newSize = {
            width: parseInt(ref.style.width),
            height: parseInt(ref.style.height),
          };

          // FIX: Clamp position to prevent negative values
          const clampedPosition = {
            x: Math.max(0, Math.min(position.x, window.innerWidth - newSize.width)),
            y: Math.max(0, Math.min(position.y, window.innerHeight - newSize.height))
          };

          log.action('Panel resized', {
            from: panelSize,
            to: newSize,
            direction,
            component: 'FloatingPanel'
          });
          setPanelSize(newSize);
          // Update position when resizing from top or left edges
          setPanelPosition(clampedPosition);
        }
      }}
      style={{
        zIndex: 2147483647, // Max safe z-index value (2^31 - 1)
        isolation: 'isolate', // Create stacking context to prevent conflicts
        // Bouncy spring animation - only when programmatically repositioning, not during drag
        transition: shouldAnimate
          ? 'all 500ms cubic-bezier(0.68, -0.55, 0.265, 1.55)'
          : 'none',
      }}
      resizeHandleClasses={{
        top: 'resize-handle resize-handle-top',
        right: 'resize-handle resize-handle-right',
        bottom: 'resize-handle resize-handle-bottom',
        left: 'resize-handle resize-handle-left',
        topRight: 'resize-handle resize-handle-topRight',
        bottomRight: 'resize-handle resize-handle-bottomRight',
        bottomLeft: 'resize-handle resize-handle-bottomLeft',
        topLeft: 'resize-handle resize-handle-topLeft',
      }}
    >
      <div
        style={{
          width: '100%',
          height: isMinimized ? '60px' : '100%',
          backgroundColor: 'rgba(255, 255, 255, 0.95)',
          borderRadius: '16px',
          boxShadow: '0 20px 60px rgba(0, 0, 0, 0.3)',
          border: '1px solid rgba(0, 0, 0, 0.1)',
          display: 'flex',
          flexDirection: 'column',
          overflow: 'hidden',
          fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
          transition: 'height 300ms cubic-bezier(0.4, 0.0, 0.2, 1)',
        }}
      >
        {/* Header - Draggable */}
        <div
          className="panel-header"
          style={{
            padding: '16px',
            borderBottom: isMinimized ? 'none' : '1px solid rgba(0, 0, 0, 0.08)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            cursor: 'move',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            backdropFilter: 'blur(10px)',
            WebkitBackdropFilter: 'blur(10px)',
          }}
        >
          <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
            <div
              style={{
                width: '28px',
                height: '28px',
                borderRadius: '8px',
                background: 'linear-gradient(135deg, #0077B5 0%, #00A0DC 100%)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                color: 'white',
                fontSize: '12px',
                fontWeight: 'bold',
              }}
            >
              UP
            </div>
            <h2
              style={{
                fontSize: '14px',
                fontWeight: '600',
                margin: 0,
                color: '#1d1d1f',
              }}
            >
              Uproot
            </h2>
          </div>

          <div style={{ display: 'flex', gap: '4px' }}>
            <button
              onClick={handleMinimize}
              style={{
                background: 'none',
                border: 'none',
                cursor: 'pointer',
                padding: '6px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                borderRadius: '6px',
                transition: 'background-color 150ms',
              }}
              onMouseEnter={(e) => {
                e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.backgroundColor = 'transparent';
              }}
              title={isMinimized ? 'Maximize' : 'Minimize'}
            >
              {isMinimized ? (
                <Maximize2 size={14} color="#6e6e73" />
              ) : (
                <Minimize2 size={14} color="#6e6e73" />
              )}
            </button>

            <button
              onClick={handleClose}
              style={{
                background: 'none',
                border: 'none',
                cursor: 'pointer',
                padding: '6px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                borderRadius: '6px',
                transition: 'background-color 150ms',
              }}
              onMouseEnter={(e) => {
                e.currentTarget.style.backgroundColor = 'rgba(255, 59, 48, 0.1)';
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.backgroundColor = 'transparent';
              }}
              title="Close"
            >
              <X size={14} color="#FF3B30" />
            </button>
          </div>
        </div>

        {/* Tab Navigation & Content */}
        {!isMinimized && (
          <div
            style={{
              flex: 1,
              display: 'flex',
              flexDirection: 'column',
              overflow: 'hidden',
            }}
          >
            <TabNavigation
              activeTab={activeTab}
              onTabChange={(tab) => {
        log.action('Tab changed', { from: activeTab, to: tab, component: 'FloatingPanel' });
        setActiveTab(tab);
      }}
              panelWidth={panelSize.width}
            />
          </div>
        )}
      </div>
    </Rnd>
    </>
  );
}
